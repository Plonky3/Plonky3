<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","air","src","air.rs"],"content":"use core::ops::{Add, Mul, Sub};\r\n\r\nuse p3_field::{Algebra, ExtensionField, Field, PrimeCharacteristicRing};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\n\r\n/// An AIR (algebraic intermediate representation).\r\npub trait BaseAir\u003cF\u003e: Sync {\r\n    /// The number of columns (a.k.a. registers) in this AIR.\r\n    fn width(\u0026self) -\u003e usize;\r\n\r\n    fn preprocessed_trace(\u0026self) -\u003e Option\u003cRowMajorMatrix\u003cF\u003e\u003e {\r\n        None\r\n    }\r\n}\r\n\r\n///  An AIR with 0 or more public values.\r\npub trait BaseAirWithPublicValues\u003cF\u003e: BaseAir\u003cF\u003e {\r\n    fn num_public_values(\u0026self) -\u003e usize {\r\n        0\r\n    }\r\n}\r\n\r\n/// An AIR that works with a particular `AirBuilder`.\r\npub trait Air\u003cAB: AirBuilder\u003e: BaseAir\u003cAB::F\u003e {\r\n    fn eval(\u0026self, builder: \u0026mut AB);\r\n}\r\n\r\npub trait AirBuilder: Sized {\r\n    type F: Field;\r\n\r\n    type Expr: Algebra\u003cSelf::F\u003e + Algebra\u003cSelf::Var\u003e;\r\n\r\n    type Var: Into\u003cSelf::Expr\u003e\r\n        + Copy\r\n        + Send\r\n        + Sync\r\n        + Add\u003cSelf::F, Output = Self::Expr\u003e\r\n        + Add\u003cSelf::Var, Output = Self::Expr\u003e\r\n        + Add\u003cSelf::Expr, Output = Self::Expr\u003e\r\n        + Sub\u003cSelf::F, Output = Self::Expr\u003e\r\n        + Sub\u003cSelf::Var, Output = Self::Expr\u003e\r\n        + Sub\u003cSelf::Expr, Output = Self::Expr\u003e\r\n        + Mul\u003cSelf::F, Output = Self::Expr\u003e\r\n        + Mul\u003cSelf::Var, Output = Self::Expr\u003e\r\n        + Mul\u003cSelf::Expr, Output = Self::Expr\u003e;\r\n\r\n    type M: Matrix\u003cSelf::Var\u003e;\r\n\r\n    fn main(\u0026self) -\u003e Self::M;\r\n\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr;\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr;\r\n    fn is_transition(\u0026self) -\u003e Self::Expr {\r\n        self.is_transition_window(2)\r\n    }\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr;\r\n\r\n    /// Returns a sub-builder whose constraints are enforced only when `condition` is nonzero.\r\n    fn when\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, condition: I) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        FilteredAirBuilder {\r\n            inner: self,\r\n            condition: condition.into(),\r\n        }\r\n    }\r\n\r\n    /// Returns a sub-builder whose constraints are enforced only when `x != y`.\r\n    fn when_ne\u003cI1: Into\u003cSelf::Expr\u003e, I2: Into\u003cSelf::Expr\u003e\u003e(\r\n        \u0026mut self,\r\n        x: I1,\r\n        y: I2,\r\n    ) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        self.when(x.into() - y.into())\r\n    }\r\n\r\n    /// Returns a sub-builder whose constraints are enforced only on the first row.\r\n    fn when_first_row(\u0026mut self) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        self.when(self.is_first_row())\r\n    }\r\n\r\n    /// Returns a sub-builder whose constraints are enforced only on the last row.\r\n    fn when_last_row(\u0026mut self) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        self.when(self.is_last_row())\r\n    }\r\n\r\n    /// Returns a sub-builder whose constraints are enforced on all rows except the last.\r\n    fn when_transition(\u0026mut self) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        self.when(self.is_transition())\r\n    }\r\n\r\n    /// Returns a sub-builder whose constraints are enforced on all rows except the last `size - 1`.\r\n    fn when_transition_window(\u0026mut self, size: usize) -\u003e FilteredAirBuilder\u003c'_, Self\u003e {\r\n        self.when(self.is_transition_window(size))\r\n    }\r\n\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I);\r\n\r\n    fn assert_one\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        self.assert_zero(x.into() - Self::Expr::ONE);\r\n    }\r\n\r\n    fn assert_eq\u003cI1: Into\u003cSelf::Expr\u003e, I2: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I1, y: I2) {\r\n        self.assert_zero(x.into() - y.into());\r\n    }\r\n\r\n    /// Assert that `x` is a boolean, i.e. either 0 or 1.\r\n    fn assert_bool\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        let x = x.into();\r\n        self.assert_zero(x.clone() * (x - Self::Expr::ONE));\r\n    }\r\n\r\n    /// Assert that `x` is ternary, i.e. either 0, 1 or 2.\r\n    fn assert_tern\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        let x = x.into();\r\n        self.assert_zero(x.clone() * (x.clone() - Self::Expr::ONE) * (x - Self::Expr::TWO));\r\n    }\r\n}\r\n\r\npub trait AirBuilderWithPublicValues: AirBuilder {\r\n    type PublicVar: Into\u003cSelf::Expr\u003e + Copy;\r\n\r\n    fn public_values(\u0026self) -\u003e \u0026[Self::PublicVar];\r\n}\r\n\r\npub trait PairBuilder: AirBuilder {\r\n    fn preprocessed(\u0026self) -\u003e Self::M;\r\n}\r\n\r\npub trait ExtensionBuilder: AirBuilder {\r\n    type EF: ExtensionField\u003cSelf::F\u003e;\r\n\r\n    type ExprEF: Algebra\u003cSelf::Expr\u003e + Algebra\u003cSelf::EF\u003e;\r\n\r\n    type VarEF: Into\u003cSelf::ExprEF\u003e + Copy + Send + Sync;\r\n\r\n    fn assert_zero_ext\u003cI\u003e(\u0026mut self, x: I)\r\n    where\r\n        I: Into\u003cSelf::ExprEF\u003e;\r\n\r\n    fn assert_eq_ext\u003cI1, I2\u003e(\u0026mut self, x: I1, y: I2)\r\n    where\r\n        I1: Into\u003cSelf::ExprEF\u003e,\r\n        I2: Into\u003cSelf::ExprEF\u003e,\r\n    {\r\n        self.assert_zero_ext(x.into() - y.into());\r\n    }\r\n\r\n    fn assert_one_ext\u003cI\u003e(\u0026mut self, x: I)\r\n    where\r\n        I: Into\u003cSelf::ExprEF\u003e,\r\n    {\r\n        self.assert_eq_ext(x, Self::ExprEF::ONE)\r\n    }\r\n}\r\n\r\npub trait PermutationAirBuilder: ExtensionBuilder {\r\n    type MP: Matrix\u003cSelf::VarEF\u003e;\r\n\r\n    type RandomVar: Into\u003cSelf::ExprEF\u003e + Copy;\r\n\r\n    fn permutation(\u0026self) -\u003e Self::MP;\r\n\r\n    fn permutation_randomness(\u0026self) -\u003e \u0026[Self::RandomVar];\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct FilteredAirBuilder\u003c'a, AB: AirBuilder\u003e {\r\n    pub inner: \u0026'a mut AB,\r\n    condition: AB::Expr,\r\n}\r\n\r\nimpl\u003cAB: AirBuilder\u003e FilteredAirBuilder\u003c'_, AB\u003e {\r\n    pub fn condition(\u0026self) -\u003e AB::Expr {\r\n        self.condition.clone()\r\n    }\r\n}\r\n\r\nimpl\u003cAB: AirBuilder\u003e AirBuilder for FilteredAirBuilder\u003c'_, AB\u003e {\r\n    type F = AB::F;\r\n    type Expr = AB::Expr;\r\n    type Var = AB::Var;\r\n    type M = AB::M;\r\n\r\n    fn main(\u0026self) -\u003e Self::M {\r\n        self.inner.main()\r\n    }\r\n\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr {\r\n        self.inner.is_first_row()\r\n    }\r\n\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr {\r\n        self.inner.is_last_row()\r\n    }\r\n\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr {\r\n        self.inner.is_transition_window(size)\r\n    }\r\n\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        self.inner.assert_zero(self.condition() * x.into());\r\n    }\r\n}\r\n\r\nimpl\u003cAB: ExtensionBuilder\u003e ExtensionBuilder for FilteredAirBuilder\u003c'_, AB\u003e {\r\n    type EF = AB::EF;\r\n    type ExprEF = AB::ExprEF;\r\n    type VarEF = AB::VarEF;\r\n\r\n    fn assert_zero_ext\u003cI\u003e(\u0026mut self, x: I)\r\n    where\r\n        I: Into\u003cSelf::ExprEF\u003e,\r\n    {\r\n        self.inner.assert_zero_ext(x.into() * self.condition());\r\n    }\r\n}\r\n\r\nimpl\u003cAB: PermutationAirBuilder\u003e PermutationAirBuilder for FilteredAirBuilder\u003c'_, AB\u003e {\r\n    type MP = AB::MP;\r\n\r\n    type RandomVar = AB::RandomVar;\r\n\r\n    fn permutation(\u0026self) -\u003e Self::MP {\r\n        self.inner.permutation()\r\n    }\r\n\r\n    fn permutation_randomness(\u0026self) -\u003e \u0026[Self::RandomVar] {\r\n        self.inner.permutation_randomness()\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":55,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":60,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":63,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":78,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":82,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":83,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":87,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":88,"address":[],"length":0,"stats":{"Line":1801439850948198399}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":103,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":174,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":201,"address":[],"length":0,"stats":{"Line":9007199254740991999}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}}],"covered":16,"coverable":46},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","air","src","lib.rs"],"content":"//! APIs for AIRs, and generalizations like PAIRs.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod air;\r\npub mod utils;\r\nmod virtual_column;\r\n\r\npub use air::*;\r\npub use virtual_column::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","air","src","utils.rs"],"content":"//! A collection of utility functions helpful in defining AIR's.\r\n\r\nuse core::array;\r\n\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\n\r\nuse crate::AirBuilder;\r\n\r\n/// Pack a collection of bits into a number.\r\n///\r\n/// Given vec = [v0, v1, ..., v_n] returns v0 + 2v_1 + ... + 2^n v_n\r\n#[inline]\r\npub fn pack_bits_le\u003cR, Var, I\u003e(iter: I) -\u003e R\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n    Var: Into\u003cR\u003e + Clone,\r\n    I: DoubleEndedIterator\u003cItem = Var\u003e,\r\n{\r\n    iter.rev()\r\n        .map(Into::\u003cR\u003e::into)\r\n        .reduce(|acc, elem| acc.double() + elem)\r\n        .unwrap_or(R::ZERO)\r\n}\r\n\r\n/// Computes the arithmetic generalization of boolean `xor`.\r\n///\r\n/// For boolean inputs, `x ^ y = x + y - 2 xy`.\r\n#[inline(always)]\r\npub fn xor\u003cR: PrimeCharacteristicRing\u003e(x: R, y: R) -\u003e R {\r\n    x.clone() + y.clone() - x * y.double()\r\n}\r\n\r\n/// Computes the arithmetic generalization of a triple `xor`.\r\n///\r\n/// For boolean inputs `x ^ y ^ z = x + y + z - 2(xy + xz + yz) + 4xyz`.\r\n#[inline(always)]\r\npub fn xor3\u003cR: PrimeCharacteristicRing\u003e(x: R, y: R, z: R) -\u003e R {\r\n    // The cheapest way to implement this polynomial is to simply apply xor twice.\r\n    // This costs 2 adds, 2 subs, 2 muls and 2 doubles.\r\n    xor(x, xor(y, z))\r\n}\r\n\r\n/// Computes the arithmetic generalization of `andnot`.\r\n///\r\n/// For boolean inputs `(!x) \u0026 y = (1 - x)y`\r\n#[inline(always)]\r\npub fn andn\u003cR: PrimeCharacteristicRing\u003e(x: R, y: R) -\u003e R {\r\n    (R::ONE - x) * y\r\n}\r\n\r\n/// Compute `xor` on a list of boolean field elements.\r\n///\r\n/// Verifies at debug time that all inputs are boolean.\r\n#[inline(always)]\r\npub fn checked_xor\u003cF: Field, const N: usize\u003e(xs: [F; N]) -\u003e F {\r\n    xs.into_iter().fold(F::ZERO, |acc, x| {\r\n        debug_assert!(x.is_zero() || x.is_one());\r\n        xor(acc, x)\r\n    })\r\n}\r\n\r\n/// Compute `andnot` on a pair of boolean field elements.\r\n///\r\n/// Verifies at debug time that both inputs are boolean.\r\n#[inline(always)]\r\npub fn checked_andn\u003cF: Field\u003e(x: F, y: F) -\u003e F {\r\n    debug_assert!(x.is_zero() || x.is_one());\r\n    debug_assert!(y.is_zero() || y.is_one());\r\n    andn(x, y)\r\n}\r\n\r\n/// Convert a 32-bit integer into an array of 32 0 or 1 field elements.\r\n///\r\n/// The output array is in little-endian order.\r\n#[inline]\r\npub fn u32_to_bits_le\u003cR: PrimeCharacteristicRing\u003e(val: u32) -\u003e [R; 32] {\r\n    array::from_fn(|i| R::from_bool(val \u0026 (1 \u003c\u003c i) != 0))\r\n}\r\n\r\n/// Convert a 64-bit integer into an array of 64 0 or 1 field elements.\r\n///\r\n/// The output array is in little-endian order.\r\n#[inline]\r\npub fn u64_to_bits_le\u003cR: PrimeCharacteristicRing\u003e(val: u64) -\u003e [R; 64] {\r\n    array::from_fn(|i| R::from_bool(val \u0026 (1 \u003c\u003c i) != 0))\r\n}\r\n\r\n/// Convert a 64-bit integer into an array of four field elements representing the 16 bit limb decomposition.\r\n///\r\n/// The output array is in little-endian order.\r\n#[inline]\r\npub fn u64_to_16_bit_limbs\u003cR: PrimeCharacteristicRing\u003e(val: u64) -\u003e [R; 4] {\r\n    array::from_fn(|i| R::from_u16((val \u003e\u003e (16 * i)) as u16))\r\n}\r\n\r\n/// Verify that `a = b + c + d mod 2^32`\r\n///\r\n/// We assume that a, b, c, d are all given as `2, 16` bit limbs (e.g. `a = a[0] + 2^16 a[1]`) and\r\n/// each `16` bit limb has been range checked to ensure it contains a value in `[0, 2^16)`.\r\n///\r\n/// This function assumes we are working over a field with characteristic `P \u003e 3*2^16`.\r\n#[inline]\r\npub fn add3\u003cAB: AirBuilder\u003e(\r\n    builder: \u0026mut AB,\r\n    a: \u0026[AB::Var; 2],\r\n    b: \u0026[AB::Var; 2],\r\n    c: \u0026[AB::Expr; 2],\r\n    d: \u0026[AB::Expr; 2],\r\n) {\r\n    // Define:\r\n    //  acc    = a - b - c - d (mod P)\r\n    //  acc_16 = a[0] - b[0] - c[0] - d[0] (mod P)\r\n    //\r\n    // We perform 2 checks:\r\n    //\r\n    // (1) acc*(acc + 2^32)*(acc + 2*2^32) = 0.\r\n    // (2) acc_16*(acc_16 + 2^16)*(acc_16 + 2*2^16) = 0.\r\n    //\r\n    // We give a short proof for why this lets us conclude that a = b + c + d mod 2^32:\r\n    //\r\n    // As all 16 bit limbs have been range checked, we know that a, b, c, d lie in [0, 2^32) and hence\r\n    // a = b + c + d mod 2^32 if and only if, over the integers, a - b - c - d = 0, -2^32 or -2*2^32.\r\n    //\r\n    // Equation (1) verifies that a - b - c - d mod P = 0, -2^32 or -2*2^32.\r\n    //\r\n    // Field overflow cannot occur when computing acc_16 as our characteristic is larger than 3*2^16.\r\n    // Hence, equation (2) verifies that, over the integers, a[0] - b[0] - c[0] - d[0] = 0, -2^16 or -2*2^16.\r\n    // Either way we can immediately conclude that a - b - c - d = 0 mod 2^16.\r\n    //\r\n    // Now we can use the chinese remainder theorem to combine these results to conclude that\r\n    // a - b - c - d mod 2^16P = 0, -2^32 or -2*2^32.\r\n    //\r\n    // No overflow can occur mod 2^16 P as 2^16 P \u003e 3*2^32 and a, b, c, d \u003c 2^32. Hence we conclude that\r\n    // over the integers a - b - c - d = 0, -2^32 or -2*2^32 which implies a = b + c + d mod 2^32.\r\n\r\n    // By assumption P \u003e 3*2^16 so 1 \u003c\u003c 16 will be less than P. We use the checked version just to be safe.\r\n    // The compiler should optimize it away.\r\n    let two_16 =\r\n        \u003cAB::Expr as PrimeCharacteristicRing\u003e::PrimeSubfield::from_canonical_checked(1 \u003c\u003c 16)\r\n            .unwrap();\r\n    let two_32 = two_16.square();\r\n\r\n    let acc_16 = a[0] - b[0] - c[0].clone() - d[0].clone();\r\n    let acc_32 = a[1] - b[1] - c[1].clone() - d[1].clone();\r\n    let acc = acc_16.clone() + AB::Expr::from_prime_subfield(two_16) * acc_32;\r\n\r\n    builder.assert_zero(\r\n        acc.clone()\r\n            * (acc.clone() + AB::Expr::from_prime_subfield(two_32))\r\n            * (acc + AB::Expr::from_prime_subfield(two_32.double())),\r\n    );\r\n    builder.assert_zero(\r\n        acc_16.clone()\r\n            * (acc_16.clone() + AB::Expr::from_prime_subfield(two_16))\r\n            * (acc_16 + AB::Expr::from_prime_subfield(two_16.double())),\r\n    );\r\n}\r\n\r\n/// Verify that `a = b + c mod 2^32`\r\n///\r\n/// We assume that a, b, c are all given as `2, 16` bit limbs (e.g. `a = a[0] + 2^16 a[1]`) and\r\n/// each `16` bit limb has been range checked to ensure it contains a value in `[0, 2^16)`.\r\n///\r\n/// This function assumes we are working over a field with characteristic `P \u003e 2^17`.\r\n#[inline]\r\npub fn add2\u003cAB: AirBuilder\u003e(\r\n    builder: \u0026mut AB,\r\n    a: \u0026[AB::Var; 2],\r\n    b: \u0026[AB::Var; 2],\r\n    c: \u0026[AB::Expr; 2],\r\n) {\r\n    // Define:\r\n    //  acc    = a - b - c (mod P)\r\n    //  acc_16 = a[0] - b[0] - c[0] (mod P)\r\n    //\r\n    // We perform 2 checks:\r\n    //\r\n    // (1) acc*(acc + 2^32) = 0.\r\n    // (2) acc_16*(acc_16 + 2^16) = 0.\r\n    //\r\n    // We give a short proof for why this lets us conclude that a = b + c mod 2^32:\r\n    //\r\n    // As all 16 bit limbs have been range checked, we know that a, b, c lie in [0, 2^32) and hence\r\n    // a = b + c mod 2^32 if and only if, over the integers, a - b - c = 0 or -2^32.\r\n    //\r\n    // Equation (1) verifies that either a - b - c = 0 mod P or a - b - c = -2^32 mod P.\r\n    //\r\n    // Field overflow cannot occur when computing acc_16 as our characteristic is larger than 2^17.\r\n    // Hence, equation (2) verifies that, over the integers, a[0] - b[0] - c[0] = 0 or -2^16.\r\n    // Either way we can immediately conclude that a - b - c = 0 mod 2^16.\r\n    //\r\n    // Now we can use the chinese remainder theorem to combine these results to conclude that\r\n    // either a - b - c = 0 mod 2^16 P or a - b - c = -2^32 mod 2^16 P.\r\n    //\r\n    // No overflow can occur mod 2^16 P as 2^16 P \u003e 2^33 and a, b, c \u003c 2^32. Hence we conclude that\r\n    // over the integers a - b - c = 0 or a - b - c = -2^32 which is equivalent to a = b + c mod 2^32.\r\n\r\n    // By assumption P \u003e 2^17 so 1 \u003c\u003c 16 will be less than P. We use the checked version just to be safe.\r\n    // The compiler should optimize it away.\r\n    let two_16 =\r\n        \u003cAB::Expr as PrimeCharacteristicRing\u003e::PrimeSubfield::from_canonical_checked(1 \u003c\u003c 16)\r\n            .unwrap();\r\n    let two_32 = two_16.square();\r\n\r\n    let acc_16 = a[0] - b[0] - c[0].clone();\r\n    let acc_32 = a[1] - b[1] - c[1].clone();\r\n    let acc = acc_16.clone() + AB::Expr::from_prime_subfield(two_16) * acc_32;\r\n\r\n    builder.assert_zero(acc.clone() * (acc + AB::Expr::from_prime_subfield(two_32)));\r\n    builder.assert_zero(acc_16.clone() * (acc_16 + AB::Expr::from_prime_subfield(two_16)));\r\n}\r\n\r\n/// Verify that `a = (b ^ (c \u003c\u003c shift))`\r\n///\r\n/// We assume that a is given as `2 16` bit limbs and both b and c are unpacked into 32 individual bits.\r\n/// We assume that the bits of b have been range checked but not the inputs in c or a. Both of these are\r\n/// range checked as part of this function.\r\n#[inline]\r\npub fn xor_32_shift\u003cAB: AirBuilder\u003e(\r\n    builder: \u0026mut AB,\r\n    a: \u0026[AB::Var; 2],\r\n    b: \u0026[AB::Var; 32],\r\n    c: \u0026[AB::Var; 32],\r\n    shift: usize,\r\n) {\r\n    // First we range check all elements of c.\r\n    c.iter().for_each(|\u0026elem| builder.assert_bool(elem));\r\n\r\n    // Next we compute (b ^ (c \u003c\u003c shift)) and pack the result into two 16-bit integers.\r\n    let xor_shift_c_0_16 = b[..16]\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(i, elem)| xor((*elem).into(), c[(32 + i - shift) % 32].into()));\r\n    let sum_0_16: AB::Expr = pack_bits_le(xor_shift_c_0_16);\r\n\r\n    let xor_shift_c_16_32 = b[16..]\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(i, elem)| xor((*elem).into(), c[(32 + (i + 16) - shift) % 32].into()));\r\n    let sum_16_32: AB::Expr = pack_bits_le(xor_shift_c_16_32);\r\n\r\n    // As both b and c have been range checked to be boolean, all the (b ^ (c \u003c\u003c shift))\r\n    // are also boolean and so this final check additionally has the effect of range checking a[0], a[1].\r\n    builder.assert_eq(a[0], sum_0_16);\r\n    builder.assert_eq(a[1], sum_16_32);\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","air","src","virtual_column.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::ops::Mul;\r\n\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\n\r\n/// An affine function over columns in a PAIR.\r\n#[derive(Clone, Debug)]\r\npub struct VirtualPairCol\u003cF: Field\u003e {\r\n    column_weights: Vec\u003c(PairCol, F)\u003e,\r\n    constant: F,\r\n}\r\n\r\n/// A column in a PAIR, i.e. either a preprocessed column or a main trace column.\r\n#[derive(Clone, Copy, Debug)]\r\npub enum PairCol {\r\n    Preprocessed(usize),\r\n    Main(usize),\r\n}\r\n\r\nimpl PairCol {\r\n    pub const fn get\u003cT: Copy\u003e(\u0026self, preprocessed: \u0026[T], main: \u0026[T]) -\u003e T {\r\n        match self {\r\n            PairCol::Preprocessed(i) =\u003e preprocessed[*i],\r\n            PairCol::Main(i) =\u003e main[*i],\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e VirtualPairCol\u003cF\u003e {\r\n    pub const fn new(column_weights: Vec\u003c(PairCol, F)\u003e, constant: F) -\u003e Self {\r\n        Self {\r\n            column_weights,\r\n            constant,\r\n        }\r\n    }\r\n\r\n    pub fn new_preprocessed(column_weights: Vec\u003c(usize, F)\u003e, constant: F) -\u003e Self {\r\n        Self::new(\r\n            column_weights\r\n                .into_iter()\r\n                .map(|(i, w)| (PairCol::Preprocessed(i), w))\r\n                .collect(),\r\n            constant,\r\n        )\r\n    }\r\n\r\n    pub fn new_main(column_weights: Vec\u003c(usize, F)\u003e, constant: F) -\u003e Self {\r\n        Self::new(\r\n            column_weights\r\n                .into_iter()\r\n                .map(|(i, w)| (PairCol::Main(i), w))\r\n                .collect(),\r\n            constant,\r\n        )\r\n    }\r\n\r\n    pub const ONE: Self = Self::constant(F::ONE);\r\n\r\n    #[must_use]\r\n    pub const fn constant(x: F) -\u003e Self {\r\n        Self {\r\n            column_weights: vec![],\r\n            constant: x,\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn single(column: PairCol) -\u003e Self {\r\n        Self {\r\n            column_weights: vec![(column, F::ONE)],\r\n            constant: F::ZERO,\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn single_preprocessed(column: usize) -\u003e Self {\r\n        Self::single(PairCol::Preprocessed(column))\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn single_main(column: usize) -\u003e Self {\r\n        Self::single(PairCol::Main(column))\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn sum_main(columns: Vec\u003cusize\u003e) -\u003e Self {\r\n        let column_weights = columns.into_iter().map(|col| (col, F::ONE)).collect();\r\n        Self::new_main(column_weights, F::ZERO)\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn sum_preprocessed(columns: Vec\u003cusize\u003e) -\u003e Self {\r\n        let column_weights = columns.into_iter().map(|col| (col, F::ONE)).collect();\r\n        Self::new_preprocessed(column_weights, F::ZERO)\r\n    }\r\n\r\n    /// `a - b`, where `a` and `b` are columns in the preprocessed trace.\r\n    #[must_use]\r\n    pub fn diff_preprocessed(a_col: usize, b_col: usize) -\u003e Self {\r\n        Self::new_preprocessed(vec![(a_col, F::ONE), (b_col, F::NEG_ONE)], F::ZERO)\r\n    }\r\n\r\n    /// `a - b`, where `a` and `b` are columns in the main trace.\r\n    #[must_use]\r\n    pub fn diff_main(a_col: usize, b_col: usize) -\u003e Self {\r\n        Self::new_main(vec![(a_col, F::ONE), (b_col, F::NEG_ONE)], F::ZERO)\r\n    }\r\n\r\n    pub fn apply\u003cExpr, Var\u003e(\u0026self, preprocessed: \u0026[Var], main: \u0026[Var]) -\u003e Expr\r\n    where\r\n        F: Into\u003cExpr\u003e,\r\n        Expr: PrimeCharacteristicRing + Mul\u003cF, Output = Expr\u003e,\r\n        Var: Into\u003cExpr\u003e + Copy,\r\n    {\r\n        let mut result = self.constant.into();\r\n        for (column, weight) in self.column_weights.iter() {\r\n            result += column.get(preprocessed, main).into() * *weight;\r\n        }\r\n        result\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":39},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","benches","bench_field.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BatchSize, Criterion};\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_add_latency, benchmark_add_throughput, benchmark_inv, benchmark_iter_sum,\r\n    benchmark_mul_latency, benchmark_mul_throughput, benchmark_sub_latency,\r\n    benchmark_sub_throughput,\r\n};\r\n\r\ntype F = BabyBear;\r\n\r\nfn bench_field(c: \u0026mut Criterion) {\r\n    let name = \"BabyBear\";\r\n    const REPS: usize = 1000;\r\n    benchmark_inv::\u003cF\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 4, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 8, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 12, REPS\u003e(c, name);\r\n\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const L_REPS: usize = 10 * REPS;\r\n    benchmark_add_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_add_throughput::\u003cF, REPS\u003e(c, name);\r\n    benchmark_sub_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_sub_throughput::\u003cF, REPS\u003e(c, name);\r\n\r\n    c.bench_function(\"7th_root\", |b| {\r\n        b.iter_batched(\r\n            rand::random::\u003cF\u003e,\r\n            |x| x.exp_u64(1725656503),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\nfn bench_packedfield(c: \u0026mut Criterion) {\r\n    let name = type_name::\u003c\u003cF as Field\u003e::Packing\u003e().to_string();\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const REPS: usize = 100;\r\n    const L_REPS: usize = 10 * REPS;\r\n\r\n    benchmark_add_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_add_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_sub_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_sub_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_mul_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_mul_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n}\r\n\r\ncriterion_group!(baby_bear_arithmetic, bench_field, bench_packedfield);\r\ncriterion_main!(baby_bear_arithmetic);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","benches","extension.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_inv, benchmark_mul_latency, benchmark_mul_throughput, benchmark_square,\r\n};\r\n\r\ntype EF4 = BinomialExtensionField\u003cBabyBear, 4\u003e;\r\ntype EF5 = BinomialExtensionField\u003cBabyBear, 5\u003e;\r\n\r\n// Note that each round of throughput has 10 operations\r\n// So we should have 10 * more repetitions for latency tests.\r\nconst REPS: usize = 100;\r\nconst L_REPS: usize = 10 * REPS;\r\n\r\nfn bench_quartic_extension(c: \u0026mut Criterion) {\r\n    let name = \"BinomialExtensionField\u003cBabyBear, 4\u003e\";\r\n    benchmark_square::\u003cEF4\u003e(c, name);\r\n    benchmark_inv::\u003cEF4\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cEF4, REPS\u003e(c, name);\r\n    benchmark_mul_latency::\u003cEF4, L_REPS\u003e(c, name);\r\n}\r\n\r\nfn bench_qunitic_extension(c: \u0026mut Criterion) {\r\n    let name = \"BinomialExtensionField\u003cBabyBear, 5\u003e\";\r\n    benchmark_square::\u003cEF5\u003e(c, name);\r\n    benchmark_inv::\u003cEF5\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cEF5, REPS\u003e(c, name);\r\n    benchmark_mul_latency::\u003cEF5, L_REPS\u003e(c, name);\r\n}\r\n\r\ncriterion_group!(\r\n    bench_babybear_ef,\r\n    bench_quartic_extension,\r\n    bench_qunitic_extension\r\n);\r\ncriterion_main!(bench_babybear_ef);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","aarch64_neon","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","aarch64_neon","packing.rs"],"content":"use core::arch::aarch64::{int32x4_t, uint32x4_t};\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersNeon, PackedMontyField31Neon};\r\n\r\nuse crate::BabyBearParameters;\r\n\r\nconst WIDTH: usize = 4;\r\n\r\nimpl MontyParametersNeon for BabyBearParameters {\r\n    // SAFETY: This is a valid packed representation of P.\r\n    const PACKED_P: uint32x4_t = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x78000001; WIDTH]) };\r\n    // This MU is the same 0x88000001 as elsewhere, just interpreted as an `i32`.\r\n    // SAFETY: This is a valid packed representation of MU.\r\n    const PACKED_MU: int32x4_t = unsafe { transmute::\u003c[i32; WIDTH], _\u003e([-0x77ffffff; WIDTH]) };\r\n}\r\n\r\npub type PackedBabyBearNeon = PackedMontyField31Neon\u003cBabyBearParameters\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::BabyBear;\r\n\r\n    const SPECIAL_VALS: [BabyBear; WIDTH] =\r\n        BabyBear::new_array([0x00000000, 0x00000001, 0x00000002, 0x78000000]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedBabyBearNeon,\r\n        crate::PackedBabyBearNeon::ZERO,\r\n        p3_monty_31::PackedMontyField31Neon::\u003ccrate::BabyBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","aarch64_neon","poseidon2.rs"],"content":"//! Eventually this will hold a vectorized Neon implementation of Poseidon2 for PackedBabyBearNeon\r\n//! Currently this is essentially a placeholder to allow compilation and testing on Neon devices.\r\n//!\r\n//! Converting the AVX2/AVX512 code across to Neon is on the TODO list.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{BabyBear, PackedBabyBearNeon, Poseidon2BabyBear};\r\n\r\n    type F = BabyBear;\r\n    type Perm16 = Poseidon2BabyBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2BabyBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedBabyBearNeon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedBabyBearNeon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","baby_bear.rs"],"content":"use p3_field::exponentiation::exp_1725656503;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_monty_31::{\r\n    BarrettParameters, BinomialExtensionData, FieldParameters, MontyField31, MontyParameters,\r\n    PackedMontyParameters, RelativelyPrimePower, TwoAdicData,\r\n};\r\n\r\n/// The prime field `2^31 - 2^27 + 1`, a.k.a. the Baby Bear field.\r\npub type BabyBear = MontyField31\u003cBabyBearParameters\u003e;\r\n\r\n#[derive(Copy, Clone, Default, Debug, Eq, Hash, PartialEq)]\r\npub struct BabyBearParameters;\r\n\r\nimpl MontyParameters for BabyBearParameters {\r\n    /// The Baby Bear prime: 2^31 - 2^27 + 1.\r\n    /// This is the unique 31-bit prime with the highest possible 2 adicity (27).\r\n    const PRIME: u32 = 0x78000001;\r\n\r\n    const MONTY_BITS: u32 = 32;\r\n    const MONTY_MU: u32 = 0x88000001;\r\n}\r\n\r\nimpl PackedMontyParameters for BabyBearParameters {}\r\n\r\nimpl BarrettParameters for BabyBearParameters {}\r\n\r\nimpl FieldParameters for BabyBearParameters {\r\n    const MONTY_GEN: BabyBear = BabyBear::new(31);\r\n\r\n    fn try_inverse\u003cF: Field\u003e(p1: F) -\u003e Option\u003cF\u003e {\r\n        if p1.is_zero() {\r\n            return None;\r\n        }\r\n\r\n        // From Fermat's little theorem, in a prime field `F_p`, the inverse of `a` is `a^(p-2)`.\r\n        // Here p-2 = 2013265919 = 1110111111111111111111111111111_2.\r\n        // Uses 30 Squares + 7 Multiplications =\u003e 37 Operations total.\r\n\r\n        let p100000000 = p1.exp_power_of_2(8);\r\n        let p100000001 = p100000000 * p1;\r\n        let p10000000000000000 = p100000000.exp_power_of_2(8);\r\n        let p10000000100000001 = p10000000000000000 * p100000001;\r\n        let p10000000100000001000 = p10000000100000001.exp_power_of_2(3);\r\n        let p1000000010000000100000000 = p10000000100000001000.exp_power_of_2(5);\r\n        let p1000000010000000100000001 = p1000000010000000100000000 * p1;\r\n        let p1000010010000100100001001 = p1000000010000000100000001 * p10000000100000001000;\r\n        let p10000000100000001000000010 = p1000000010000000100000001.square();\r\n        let p11000010110000101100001011 = p10000000100000001000000010 * p1000010010000100100001001;\r\n        let p100000001000000010000000100 = p10000000100000001000000010.square();\r\n        let p111000011110000111100001111 =\r\n            p100000001000000010000000100 * p11000010110000101100001011;\r\n        let p1110000111100001111000011110000 = p111000011110000111100001111.exp_power_of_2(4);\r\n        let p1110111111111111111111111111111 =\r\n            p1110000111100001111000011110000 * p111000011110000111100001111;\r\n\r\n        Some(p1110111111111111111111111111111)\r\n    }\r\n}\r\n\r\nimpl RelativelyPrimePower\u003c7\u003e for BabyBearParameters {\r\n    /// In the field `BabyBear`, `a^{1/7}` is equal to a^{1725656503}.\r\n    ///\r\n    /// This follows from the calculation `7 * 1725656503 = 6*(2^31 - 2^27) + 1 = 1 mod (p - 1)`.\r\n    fn exp_root_d\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n        // We use a custom addition chain.\r\n        // This could possibly be further optimised.\r\n        exp_1725656503(val)\r\n    }\r\n}\r\n\r\nimpl TwoAdicData for BabyBearParameters {\r\n    const TWO_ADICITY: usize = 27;\r\n\r\n    type ArrayLike = \u0026'static [BabyBear];\r\n\r\n    const TWO_ADIC_GENERATORS: Self::ArrayLike = \u0026BabyBear::new_array([\r\n        0x1, 0x78000000, 0x67055c21, 0x5ee99486, 0xbb4c4e4, 0x2d4cc4da, 0x669d6090, 0x17b56c64,\r\n        0x67456167, 0x688442f9, 0x145e952d, 0x4fe61226, 0x4c734715, 0x11c33e2a, 0x62c3d2b1,\r\n        0x77cad399, 0x54c131f4, 0x4cabd6a6, 0x5cf5713f, 0x3e9430e8, 0xba067a3, 0x18adc27d,\r\n        0x21fd55bc, 0x4b859b3d, 0x3bd57996, 0x4483d85a, 0x3a26eef8, 0x1a427a41,\r\n    ]);\r\n\r\n    const ROOTS_8: Self::ArrayLike = \u0026BabyBear::new_array([0x1, 0x5ee99486, 0x67055c21, 0xc9ea3ba]);\r\n    const INV_ROOTS_8: Self::ArrayLike =\r\n        \u0026BabyBear::new_array([0x1, 0x6b615c47, 0x10faa3e0, 0x19166b7b]);\r\n\r\n    const ROOTS_16: Self::ArrayLike = \u0026BabyBear::new_array([\r\n        0x1, 0xbb4c4e4, 0x5ee99486, 0x4b49e08, 0x67055c21, 0x5376917a, 0xc9ea3ba, 0x563112a7,\r\n    ]);\r\n    const INV_ROOTS_16: Self::ArrayLike = \u0026BabyBear::new_array([\r\n        0x1, 0x21ceed5a, 0x6b615c47, 0x24896e87, 0x10faa3e0, 0x734b61f9, 0x19166b7b, 0x6c4b3b1d,\r\n    ]);\r\n}\r\n\r\nimpl BinomialExtensionData\u003c4\u003e for BabyBearParameters {\r\n    const W: BabyBear = BabyBear::new(11);\r\n    const DTH_ROOT: BabyBear = BabyBear::new(1728404513);\r\n    const EXT_GENERATOR: [BabyBear; 4] = BabyBear::new_array([8, 1, 0, 0]);\r\n    const EXT_TWO_ADICITY: usize = 29;\r\n\r\n    type ArrayLike = [[BabyBear; 4]; 2];\r\n    const TWO_ADIC_EXTENSION_GENERATORS: Self::ArrayLike =\r\n        BabyBear::new_2d_array([[0, 0, 1996171314, 0], [0, 0, 0, 124907976]]);\r\n}\r\n\r\nimpl BinomialExtensionData\u003c5\u003e for BabyBearParameters {\r\n    const W: BabyBear = BabyBear::new(2);\r\n    const DTH_ROOT: BabyBear = BabyBear::new(815036133);\r\n    const EXT_GENERATOR: [BabyBear; 5] = BabyBear::new_array([8, 1, 0, 0, 0]);\r\n    const EXT_TWO_ADICITY: usize = 27;\r\n\r\n    type ArrayLike = [[BabyBear; 5]; 0];\r\n    const TWO_ADIC_EXTENSION_GENERATORS: Self::ArrayLike = [];\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use core::array;\r\n\r\n    use p3_field::{InjectiveMonomial, PermutationMonomial, PrimeField64, TwoAdicField};\r\n    use p3_field_testing::{\r\n        test_field, test_field_dft, test_prime_field, test_prime_field_32, test_prime_field_64,\r\n        test_two_adic_field,\r\n    };\r\n\r\n    use super::*;\r\n\r\n    type F = BabyBear;\r\n\r\n    #[test]\r\n    fn test_baby_bear_two_adicity_generators() {\r\n        let base = BabyBear::from_u32(0x1a427a41);\r\n        for bits in 0..=BabyBear::TWO_ADICITY {\r\n            assert_eq!(\r\n                BabyBear::two_adic_generator(bits),\r\n                base.exp_power_of_2(BabyBear::TWO_ADICITY - bits)\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_to_babybear_array() {\r\n        let range_array: [u32; 32] = array::from_fn(|i| i as u32);\r\n        assert_eq!(\r\n            BabyBear::new_array(range_array),\r\n            range_array.map(F::from_u32)\r\n        )\r\n    }\r\n\r\n    #[test]\r\n    fn test_baby_bear() {\r\n        let f = F::from_u32(100);\r\n        assert_eq!(f.as_canonical_u64(), 100);\r\n\r\n        let f_1 = F::ONE;\r\n        let f_2 = F::TWO;\r\n        let f_p_minus_1 = F::NEG_ONE;\r\n        let f_p_minus_2 = F::NEG_ONE + F::NEG_ONE;\r\n        let m1 = F::from_u32(0x34167c58);\r\n        let m2 = F::from_u32(0x61f3207b);\r\n        let expected_prod = F::from_u32(0x1b5c8046);\r\n        assert_eq!(m1 * m2, expected_prod);\r\n\r\n        assert_eq!(m1.injective_exp_n().injective_exp_root_n(), m1);\r\n        assert_eq!(m2.injective_exp_n().injective_exp_root_n(), m2);\r\n        assert_eq!(F::TWO.injective_exp_n().injective_exp_root_n(), F::TWO);\r\n\r\n        let f_serialized = serde_json::to_string(\u0026f).unwrap();\r\n        let f_deserialized: F = serde_json::from_str(\u0026f_serialized).unwrap();\r\n        assert_eq!(f, f_deserialized);\r\n\r\n        let f_1_serialized = serde_json::to_string(\u0026f_1).unwrap();\r\n        let f_1_deserialized: F = serde_json::from_str(\u0026f_1_serialized).unwrap();\r\n        let f_1_serialized_again = serde_json::to_string(\u0026f_1_deserialized).unwrap();\r\n        let f_1_deserialized_again: F = serde_json::from_str(\u0026f_1_serialized_again).unwrap();\r\n        assert_eq!(f_1, f_1_deserialized);\r\n        assert_eq!(f_1, f_1_deserialized_again);\r\n\r\n        let f_2_serialized = serde_json::to_string(\u0026f_2).unwrap();\r\n        let f_2_deserialized: F = serde_json::from_str(\u0026f_2_serialized).unwrap();\r\n        assert_eq!(f_2, f_2_deserialized);\r\n\r\n        let f_p_minus_1_serialized = serde_json::to_string(\u0026f_p_minus_1).unwrap();\r\n        let f_p_minus_1_deserialized: F = serde_json::from_str(\u0026f_p_minus_1_serialized).unwrap();\r\n        assert_eq!(f_p_minus_1, f_p_minus_1_deserialized);\r\n\r\n        let f_p_minus_2_serialized = serde_json::to_string(\u0026f_p_minus_2).unwrap();\r\n        let f_p_minus_2_deserialized: F = serde_json::from_str(\u0026f_p_minus_2_serialized).unwrap();\r\n        assert_eq!(f_p_minus_2, f_p_minus_2_deserialized);\r\n\r\n        let m1_serialized = serde_json::to_string(\u0026m1).unwrap();\r\n        let m1_deserialized: F = serde_json::from_str(\u0026m1_serialized).unwrap();\r\n        assert_eq!(m1, m1_deserialized);\r\n\r\n        let m2_serialized = serde_json::to_string(\u0026m2).unwrap();\r\n        let m2_deserialized: F = serde_json::from_str(\u0026m2_serialized).unwrap();\r\n        assert_eq!(m2, m2_deserialized);\r\n    }\r\n\r\n    test_field!(crate::BabyBear);\r\n    test_two_adic_field!(crate::BabyBear);\r\n\r\n    test_field_dft!(radix2dit, crate::BabyBear, p3_dft::Radix2Dit\u003c_\u003e);\r\n    test_field_dft!(bowers, crate::BabyBear, p3_dft::Radix2Bowers);\r\n    test_field_dft!(parallel, crate::BabyBear, p3_dft::Radix2DitParallel::\u003c_\u003e);\r\n    test_field_dft!(\r\n        recur_dft,\r\n        crate::BabyBear,\r\n        p3_monty_31::dft::RecursiveDft\u003c_\u003e\r\n    );\r\n    test_prime_field!(crate::BabyBear);\r\n    test_prime_field_64!(crate::BabyBear);\r\n    test_prime_field_32!(crate::BabyBear);\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":7205759403792793759}},{"line":31,"address":[],"length":0,"stats":{"Line":7205759403792793759}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037928116}},{"line":39,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":40,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":41,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":42,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":43,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":44,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":45,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":46,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":47,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":48,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":49,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":50,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":51,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":52,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":53,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":54,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":56,"address":[],"length":0,"stats":{"Line":7133701809754865643}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":22,"coverable":22},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","extension.rs"],"content":"#[cfg(test)]\r\nmod test_quartic_extension {\r\n    use alloc::format;\r\n\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field::{PrimeCharacteristicRing, Serializable};\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::BabyBear;\r\n\r\n    type F = BabyBear;\r\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\r\n\r\n    test_field!(super::EF);\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n\r\n    #[test]\r\n    fn display() {\r\n        assert_eq!(format!(\"{}\", EF::ZERO), \"0\");\r\n        assert_eq!(format!(\"{}\", EF::ONE), \"1\");\r\n        assert_eq!(format!(\"{}\", EF::TWO), \"2\");\r\n\r\n        assert_eq!(\r\n            format!(\r\n                \"{}\",\r\n                EF::deserialize_slice(\u0026[F::TWO, F::ONE, F::ZERO, F::TWO])\r\n            ),\r\n            \"2 + X + 2 X^3\"\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_quintic_extension {\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::BabyBear;\r\n\r\n    type F = BabyBear;\r\n    type EF = BinomialExtensionField\u003cF, 5\u003e;\r\n\r\n    test_field!(super::EF);\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","lib.rs"],"content":"#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nextern crate alloc;\r\n\r\nmod baby_bear;\r\nmod extension;\r\nmod mds;\r\nmod poseidon2;\r\n\r\npub use baby_bear::*;\r\npub use mds::*;\r\npub use poseidon2::*;\r\n\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\nmod aarch64_neon;\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub use aarch64_neon::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\nmod x86_64_avx2;\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use x86_64_avx2::*;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\nmod x86_64_avx512;\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use x86_64_avx512::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","mds.rs"],"content":"//! MDS matrices over the BabyBear field, and permutations defined by them.\r\n//!\r\n//! NB: Not all sizes have fast implementations of their permutations.\r\n//! Supported sizes: 8, 12, 16, 24, 32, 64.\r\n//! Sizes 8 and 12 are from Plonky2, size 16 was found as part of concurrent\r\n//! work by Angus Gruen and Hamish Ivey-Law. Other sizes are from Ulrich Habck's\r\n//! database.\r\n\r\nuse p3_mds::util::first_row_to_first_col;\r\nuse p3_monty_31::{MDSUtils, MdsMatrixMontyField31};\r\n\r\n#[derive(Clone, Default)]\r\npub struct MDSBabyBearData;\r\n\r\nimpl MDSUtils for MDSBabyBearData {\r\n    const MATRIX_CIRC_MDS_8_COL: [i64; 8] = first_row_to_first_col(\u0026[7, 1, 3, 8, 8, 3, 4, 9]);\r\n    const MATRIX_CIRC_MDS_12_COL: [i64; 12] =\r\n        first_row_to_first_col(\u0026[1, 1, 2, 1, 8, 9, 10, 7, 5, 9, 4, 10]);\r\n    const MATRIX_CIRC_MDS_16_COL: [i64; 16] =\r\n        first_row_to_first_col(\u0026[1, 1, 51, 1, 11, 17, 2, 1, 101, 63, 15, 2, 67, 22, 13, 3]);\r\n    const MATRIX_CIRC_MDS_24_COL: [i64; 24] = first_row_to_first_col(\u0026[\r\n        0x2D0AAAAB, 0x64850517, 0x17F5551D, 0x04ECBEB5, 0x6D91A8D5, 0x60703026, 0x18D6F3CA,\r\n        0x729601A7, 0x77CDA9E2, 0x3C0F5038, 0x26D52A61, 0x0360405D, 0x68FC71C8, 0x2495A71D,\r\n        0x5D57AFC2, 0x1689DD98, 0x3C2C3DBE, 0x0C23DC41, 0x0524C7F2, 0x6BE4DF69, 0x0A6E572C,\r\n        0x5C7790FA, 0x17E118F6, 0x0878A07F,\r\n    ]);\r\n    const MATRIX_CIRC_MDS_32_COL: [i64; 32] = first_row_to_first_col(\u0026[\r\n        0x0BC00000, 0x2BED8F81, 0x337E0652, 0x4C4535D1, 0x4AF2DC32, 0x2DB4050F, 0x676A7CE3,\r\n        0x3A06B68E, 0x5E95C1B1, 0x2C5F54A0, 0x2332F13D, 0x58E757F1, 0x3AA6DCCE, 0x607EE630,\r\n        0x4ED57FF0, 0x6E08555B, 0x4C155556, 0x587FD0CE, 0x462F1551, 0x032A43CC, 0x5E2E43EA,\r\n        0x71609B02, 0x0ED97E45, 0x562CA7E9, 0x2CB70B1D, 0x4E941E23, 0x174A61C1, 0x117A9426,\r\n        0x73562137, 0x54596086, 0x487C560B, 0x68A4ACAB,\r\n    ]);\r\n    const MATRIX_CIRC_MDS_64_COL: [i64; 64] = first_row_to_first_col(\u0026[\r\n        0x39577778, 0x0072F4E1, 0x0B1B8404, 0x041E9C88, 0x32D22F9F, 0x4E4BF946, 0x20C7B6D7,\r\n        0x0587C267, 0x55877229, 0x4D186EC4, 0x4A19FD23, 0x1A64A20F, 0x2965CA4D, 0x16D98A5A,\r\n        0x471E544A, 0x193D5C8B, 0x6E66DF0C, 0x28BF1F16, 0x26DB0BC8, 0x5B06CDDB, 0x100DCCA2,\r\n        0x65C268AD, 0x199F09E7, 0x36BA04BE, 0x06C393F2, 0x51B06DFD, 0x6951B0C4, 0x6683A4C2,\r\n        0x3B53D11B, 0x26E5134C, 0x45A5F1C5, 0x6F4D2433, 0x3CE2D82E, 0x36309A7D, 0x3DD9B459,\r\n        0x68051E4C, 0x5C3AA720, 0x11640517, 0x0634D995, 0x1B0F6406, 0x72A18430, 0x26513CC5,\r\n        0x67C0B93C, 0x548AB4A3, 0x6395D20D, 0x3E5DBC41, 0x332AF630, 0x3C5DDCB3, 0x0AA95792,\r\n        0x66EB5492, 0x3F78DDDC, 0x5AC41627, 0x16CD5124, 0x3564DA96, 0x461867C9, 0x157B4E11,\r\n        0x1AA486C8, 0x0C5095A9, 0x3833C0C6, 0x008FEBA5, 0x52ECBE2E, 0x1D178A67, 0x58B3C04B,\r\n        0x6E95CB51,\r\n    ]);\r\n}\r\n\r\npub type MdsMatrixBabyBear = MdsMatrixMontyField31\u003cMDSBabyBearData\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n\r\n    use super::MdsMatrixBabyBear;\r\n    use crate::BabyBear;\r\n\r\n    #[test]\r\n    fn babybear8() {\r\n        let input: [BabyBear; 8] = BabyBear::new_array([\r\n            391474477, 1174409341, 666967492, 1852498830, 1801235316, 820595865, 585587525,\r\n            1348326858,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 8] = BabyBear::new_array([\r\n            1752937716, 1801468855, 1102954394, 284747746, 1636355768, 205443234, 1235359747,\r\n            1159982032,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn babybear12() {\r\n        let input: [BabyBear; 12] = BabyBear::new_array([\r\n            918423259, 673549090, 364157140, 9832898, 493922569, 1171855651, 246075034, 1542167926,\r\n            1787615541, 1696819900, 1884530130, 422386768,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 12] = BabyBear::new_array([\r\n            1631062293, 890348490, 1304705406, 1888740923, 845648570, 717048224, 1082440815,\r\n            914769887, 1872991191, 1366539339, 1805116914, 1998032485,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn babybear16() {\r\n        let input: [BabyBear; 16] = BabyBear::new_array([\r\n            1983708094, 1477844074, 1638775686, 98517138, 70746308, 968700066, 275567720,\r\n            1359144511, 960499489, 1215199187, 474302783, 79320256, 1923147803, 1197733438,\r\n            1638511323, 303948902,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 16] = BabyBear::new_array([\r\n            1497569692, 1038070871, 669165859, 456905446, 1116763366, 1267622262, 1985953057,\r\n            1060497461, 704264985, 306103349, 1271339089, 1551541970, 1796459417, 889229849,\r\n            1731972538, 439594789,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn babybear24() {\r\n        let input: [BabyBear; 24] = BabyBear::new_array([\r\n            1307148929, 1603957607, 1515498600, 1412393512, 785287979, 988718522, 1750345556,\r\n            853137995, 534387281, 930390055, 1600030977, 903985158, 1141020507, 636889442,\r\n            966037834, 1778991639, 1440427266, 1379431959, 853403277, 959593575, 733455867,\r\n            908584009, 817124993, 418826476,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 24] = BabyBear::new_array([\r\n            1537871777, 1626055274, 1705000179, 1426678258, 1688760658, 1347225494, 1291221794,\r\n            1224656589, 1791446853, 1978133881, 1820380039, 1366829700, 27479566, 409595531,\r\n            1223347944, 1752750033, 594548873, 1447473111, 1385412872, 1111945102, 1366585917,\r\n            138866947, 1326436332, 656898133,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn babybear32() {\r\n        let input: [BabyBear; 32] = BabyBear::new_array([\r\n            1346087634, 1511946000, 1883470964, 54906057, 233060279, 5304922, 1881494193,\r\n            743728289, 404047361, 1148556479, 144976634, 1726343008, 29659471, 1350407160,\r\n            1636652429, 385978955, 327649601, 1248138459, 1255358242, 84164877, 1005571393,\r\n            1713215328, 72913800, 1683904606, 904763213, 316800515, 656395998, 788184609,\r\n            1824512025, 1177399063, 1358745087, 444151496,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 32] = BabyBear::new_array([\r\n            1359576919, 1657405784, 1031581836, 212090105, 699048671, 877916349, 205627787,\r\n            1211567750, 210807569, 1696391051, 558468987, 161148427, 304343518, 76611896,\r\n            532792005, 1963649139, 1283500358, 250848292, 1109842541, 2007388683, 433801252,\r\n            1189712914, 626158024, 1436409738, 456315160, 1836818120, 1645024941, 925447491,\r\n            1599571860, 1055439714, 353537136, 379644130,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn babybear64() {\r\n        let input: [BabyBear; 64] = BabyBear::new_array([\r\n            1931358930, 1322576114, 1658000717, 134388215, 1517892791, 1486447670, 93570662,\r\n            898466034, 1576905917, 283824713, 1433559150, 1730678909, 155340881, 1978472263,\r\n            1980644590, 1814040165, 654743892, 849954227, 323176597, 146970735, 252703735,\r\n            1856579399, 162749290, 986745196, 352038183, 1239527508, 828473247, 1184743572,\r\n            1017249065, 36804843, 1378131210, 1286724687, 596095979, 1916924908, 528946791,\r\n            397247884, 23477278, 299412064, 415288430, 935825754, 1218003667, 1954592289,\r\n            1594612673, 664096455, 958392778, 497208288, 1544504580, 1829423324, 956111902,\r\n            458327015, 1736664598, 430977734, 599887171, 1100074154, 1197653896, 427838651,\r\n            466509871, 1236918100, 940670246, 1421951147, 255557957, 1374188100, 315300068,\r\n            623354170,\r\n        ]);\r\n\r\n        let mds_matrix_baby_bear: MdsMatrixBabyBear = Default::default();\r\n\r\n        let output = mds_matrix_baby_bear.permute(input);\r\n\r\n        let expected: [BabyBear; 64] = BabyBear::new_array([\r\n            442300274, 756862170, 167612495, 1103336044, 546496433, 1211822920, 329094196,\r\n            1334376959, 944085937, 977350947, 1445060130, 918469957, 800346119, 1957918170,\r\n            739098112, 1862817833, 1831589884, 1673860978, 698081523, 1128978338, 387929536,\r\n            1106772486, 1367460469, 1911237185, 362669171, 819949894, 1801786287, 1943505026,\r\n            586738185, 996076080, 1641277705, 1680239311, 1005815192, 63087470, 593010310,\r\n            364673774, 543368618, 1576179136, 47618763, 1990080335, 1608655220, 499504830,\r\n            861863262, 765074289, 139277832, 1139970138, 1510286607, 244269525, 43042067,\r\n            119733624, 1314663255, 893295811, 1444902994, 914930267, 1675139862, 1148717487,\r\n            1601328192, 534383401, 296215929, 1924587380, 1336639141, 34897994, 2005302060,\r\n            1780337352,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","poseidon2.rs"],"content":"//! Implementation of Poseidon2, see: https://eprint.iacr.org/2023/323\r\n//!\r\n//! For the diffusion matrix, 1 + Diag(V), we perform a search to find an optimized\r\n//! vector V composed of elements with efficient multiplication algorithms in AVX2/AVX512/NEON.\r\n//!\r\n//! This leads to using small values (e.g. 1, 2, 3, 4) where multiplication is implemented using addition\r\n//! and inverse powers of 2 where it is possible to avoid monty reductions.\r\n//! Additionally, for technical reasons, having the first entry be -2 is useful.\r\n//!\r\n//! Optimized Diagonal for BabyBear16:\r\n//! [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/2^27, -1/2^8, -1/16, -1/2^27].\r\n//! Optimized Diagonal for BabyBear24:\r\n//! [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27, -1/2^8, -1/4, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^27]\r\n//! See poseidon2\\src\\diffusion.rs for information on how to double check these matrices in Sage.\r\n\r\nuse p3_field::{Algebra, Field, PrimeCharacteristicRing, PrimeField32};\r\nuse p3_monty_31::{\r\n    GenericPoseidon2LinearLayersMonty31, InternalLayerBaseParameters, InternalLayerParameters,\r\n    MontyField31, Poseidon2ExternalLayerMonty31, Poseidon2InternalLayerMonty31,\r\n};\r\nuse p3_poseidon2::Poseidon2;\r\n\r\nuse crate::{BabyBear, BabyBearParameters};\r\n\r\npub type Poseidon2InternalLayerBabyBear\u003cconst WIDTH: usize\u003e =\r\n    Poseidon2InternalLayerMonty31\u003cBabyBearParameters, WIDTH, BabyBearInternalLayerParameters\u003e;\r\n\r\npub type Poseidon2ExternalLayerBabyBear\u003cconst WIDTH: usize\u003e =\r\n    Poseidon2ExternalLayerMonty31\u003cBabyBearParameters, WIDTH\u003e;\r\n\r\n/// Degree of the chosen permutation polynomial for BabyBear, used as the Poseidon2 S-Box.\r\n///\r\n/// As p - 1 = 15 * 2^{27} the neither 3 nor 5 satisfy gcd(p - 1, D) = 1.\r\n/// Instead we use the next smallest available value, namely 7.\r\nconst BABYBEAR_S_BOX_DEGREE: u64 = 7;\r\n\r\n/// An implementation of the Poseidon2 hash function specialised to run on the current architecture.\r\n///\r\n/// It acts on arrays of the form either `[BabyBear::Packing; WIDTH]` or `[BabyBear; WIDTH]`. For speed purposes,\r\n/// wherever possible, input arrays should of the form `[BabyBear::Packing; WIDTH]`.\r\npub type Poseidon2BabyBear\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    BabyBear,\r\n    Poseidon2ExternalLayerBabyBear\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerBabyBear\u003cWIDTH\u003e,\r\n    WIDTH,\r\n    BABYBEAR_S_BOX_DEGREE,\r\n\u003e;\r\n\r\n/// An implementation of the matrix multiplications in the internal and external layers of Poseidon2.\r\n///\r\n/// This can act on `[A; WIDTH]` for any ring implementing `Algebra\u003cBabyBear\u003e`.\r\n/// If you have either `[BabyBear::Packing; WIDTH]` or `[BabyBear; WIDTH]` it will be much faster\r\n/// to use `Poseidon2BabyBear\u003cWIDTH\u003e` instead of building a Poseidon2 permutation using this.\r\npub type GenericPoseidon2LinearLayersBabyBear =\r\n    GenericPoseidon2LinearLayersMonty31\u003cBabyBearParameters, BabyBearInternalLayerParameters\u003e;\r\n\r\n// In order to use BabyBear::new_array we need to convert our vector to a vector of u32's.\r\n// To do this we make use of the fact that BabyBear::ORDER_U32 - 1 = 15 * 2^27 so for 0 \u003c= n \u003c= 27:\r\n// -1/2^n = (BabyBear::ORDER_U32 - 1) \u003e\u003e n\r\n// 1/2^n = -(-1/2^n) = BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e n)\r\n\r\n/// The vector `[-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/2^27, -1/2^8, -1/16, -1/2^27]`\r\n/// saved as an array of BabyBear elements.\r\nconst INTERNAL_DIAG_MONTY_16: [BabyBear; 16] = BabyBear::new_array([\r\n    BabyBear::ORDER_U32 - 2,\r\n    1,\r\n    2,\r\n    (BabyBear::ORDER_U32 + 1) \u003e\u003e 1,\r\n    3,\r\n    4,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 1,\r\n    BabyBear::ORDER_U32 - 3,\r\n    BabyBear::ORDER_U32 - 4,\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 8),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 2),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 3),\r\n    BabyBear::ORDER_U32 - 15,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 8,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 4,\r\n    15,\r\n]);\r\n\r\n/// The vector [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27, -1/2^8, -1/4, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^27]\r\n/// saved as an array of BabyBear elements.\r\nconst INTERNAL_DIAG_MONTY_24: [BabyBear; 24] = BabyBear::new_array([\r\n    BabyBear::ORDER_U32 - 2,\r\n    1,\r\n    2,\r\n    (BabyBear::ORDER_U32 + 1) \u003e\u003e 1,\r\n    3,\r\n    4,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 1,\r\n    BabyBear::ORDER_U32 - 3,\r\n    BabyBear::ORDER_U32 - 4,\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 8),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 2),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 3),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 4),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 7),\r\n    BabyBear::ORDER_U32 - ((BabyBear::ORDER_U32 - 1) \u003e\u003e 9),\r\n    BabyBear::ORDER_U32 - 15,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 8,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 2,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 3,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 4,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 5,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 6,\r\n    (BabyBear::ORDER_U32 - 1) \u003e\u003e 7,\r\n    15,\r\n]);\r\n\r\n/// Contains data needed to define the internal layers of the Poseidon2 permutation.\r\n#[derive(Debug, Clone, Default)]\r\npub struct BabyBearInternalLayerParameters;\r\n\r\nimpl InternalLayerBaseParameters\u003cBabyBearParameters, 16\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [MontyField31\u003cBabyBearParameters\u003e; 15];\r\n\r\n    const INTERNAL_DIAG_MONTY: [BabyBear; 16] = INTERNAL_DIAG_MONTY_16;\r\n\r\n    /// Perform the internal matrix multiplication: s -\u003e (1 + Diag(V))s.\r\n    /// We ignore `state[0]` as it is handled separately.\r\n    fn internal_layer_mat_mul(\r\n        state: \u0026mut [MontyField31\u003cBabyBearParameters\u003e; 16],\r\n        sum: MontyField31\u003cBabyBearParameters\u003e,\r\n    ) {\r\n        // The diagonal matrix is defined by the vector:\r\n        // V = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/2^27, -1/2^8, -1/16, -1/2^27]\r\n        state[1] += sum;\r\n        state[2] = state[2].double() + sum;\r\n        state[3] = state[3].halve() + sum;\r\n        state[4] = sum + state[4].double() + state[4];\r\n        state[5] = sum + state[5].double().double();\r\n        state[6] = sum - state[6].halve();\r\n        state[7] = sum - (state[7].double() + state[7]);\r\n        state[8] = sum - state[8].double().double();\r\n        state[9] = state[9].mul_2exp_neg_n(8);\r\n        state[9] += sum;\r\n        state[10] = state[10].mul_2exp_neg_n(2);\r\n        state[10] += sum;\r\n        state[11] = state[11].mul_2exp_neg_n(3);\r\n        state[11] += sum;\r\n        state[12] = state[12].mul_2exp_neg_n(27);\r\n        state[12] += sum;\r\n        state[13] = state[13].mul_2exp_neg_n(8);\r\n        state[13] = sum - state[13];\r\n        state[14] = state[14].mul_2exp_neg_n(4);\r\n        state[14] = sum - state[14];\r\n        state[15] = state[15].mul_2exp_neg_n(27);\r\n        state[15] = sum - state[15];\r\n    }\r\n\r\n    fn generic_internal_linear_layer\u003cA: Algebra\u003cBabyBear\u003e\u003e(state: \u0026mut [A; 16]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use multiplication.\r\n        // This could probably be improved slightly by making use of the\r\n        // mul_2exp_u64 and div_2exp_u64 but this would involve porting div_2exp_u64 to PrimeCharacteristicRing.\r\n        state\r\n            .iter_mut()\r\n            .zip(INTERNAL_DIAG_MONTY_16)\r\n            .skip(3)\r\n            .for_each(|(val, diag_elem)| {\r\n                *val = full_sum.clone() + val.clone() * diag_elem;\r\n            });\r\n    }\r\n}\r\n\r\nimpl InternalLayerBaseParameters\u003cBabyBearParameters, 24\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [MontyField31\u003cBabyBearParameters\u003e; 23];\r\n\r\n    const INTERNAL_DIAG_MONTY: [BabyBear; 24] = INTERNAL_DIAG_MONTY_24;\r\n\r\n    /// Perform the internal matrix multiplication: s -\u003e (1 + Diag(V))s.\r\n    /// We ignore `state[0]` as it is handled separately.\r\n    fn internal_layer_mat_mul(\r\n        state: \u0026mut [MontyField31\u003cBabyBearParameters\u003e; 24],\r\n        sum: MontyField31\u003cBabyBearParameters\u003e,\r\n    ) {\r\n        // The diagonal matrix is defined by the vector:\r\n        // V = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27, -1/2^8, -1/4, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^27]\r\n        state[1] += sum;\r\n        state[2] = state[2].double() + sum;\r\n        state[3] = state[3].halve() + sum;\r\n        state[4] = sum + state[4].double() + state[4];\r\n        state[5] = sum + state[5].double().double();\r\n        state[6] = sum - state[6].halve();\r\n        state[7] = sum - (state[7].double() + state[7]);\r\n        state[8] = sum - state[8].double().double();\r\n        state[9] = state[9].mul_2exp_neg_n(8);\r\n        state[9] += sum;\r\n        state[10] = state[10].mul_2exp_neg_n(2);\r\n        state[10] += sum;\r\n        state[11] = state[11].mul_2exp_neg_n(3);\r\n        state[11] += sum;\r\n        state[12] = state[12].mul_2exp_neg_n(4);\r\n        state[12] += sum;\r\n        state[13] = state[13].mul_2exp_neg_n(7);\r\n        state[13] += sum;\r\n        state[14] = state[14].mul_2exp_neg_n(9);\r\n        state[14] += sum;\r\n        state[15] = state[15].mul_2exp_neg_n(27);\r\n        state[15] += sum;\r\n        state[16] = state[16].mul_2exp_neg_n(8);\r\n        state[16] = sum - state[16];\r\n        state[17] = state[17].mul_2exp_neg_n(2);\r\n        state[17] = sum - state[17];\r\n        state[18] = state[18].mul_2exp_neg_n(3);\r\n        state[18] = sum - state[18];\r\n        state[19] = state[19].mul_2exp_neg_n(4);\r\n        state[19] = sum - state[19];\r\n        state[20] = state[20].mul_2exp_neg_n(5);\r\n        state[20] = sum - state[20];\r\n        state[21] = state[21].mul_2exp_neg_n(6);\r\n        state[21] = sum - state[21];\r\n        state[22] = state[22].mul_2exp_neg_n(7);\r\n        state[22] = sum - state[22];\r\n        state[23] = state[23].mul_2exp_neg_n(27);\r\n        state[23] = sum - state[23];\r\n    }\r\n\r\n    fn generic_internal_linear_layer\u003cA: Algebra\u003cBabyBear\u003e\u003e(state: \u0026mut [A; 24]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use multiplication.\r\n        // This could probably be improved slightly by making use of the\r\n        // mul_2exp_u64 and div_2exp_u64 but this would involve porting div_2exp_u64 to PrimeCharacteristicRing.\r\n        state\r\n            .iter_mut()\r\n            .zip(INTERNAL_DIAG_MONTY_24)\r\n            .skip(3)\r\n            .for_each(|(val, diag_elem)| {\r\n                *val = full_sum.clone() + val.clone() * diag_elem;\r\n            });\r\n    }\r\n}\r\n\r\nimpl InternalLayerParameters\u003cBabyBearParameters, 16\u003e for BabyBearInternalLayerParameters {}\r\nimpl InternalLayerParameters\u003cBabyBearParameters, 24\u003e for BabyBearInternalLayerParameters {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::{Rng, SeedableRng};\r\n    use rand_xoshiro::Xoroshiro128Plus;\r\n\r\n    use super::*;\r\n\r\n    type F = BabyBear;\r\n\r\n    // We need to make some round constants. We use Xoroshiro128Plus for this as we can easily match this PRNG in sage.\r\n    // See: https://github.com/0xPolygonZero/hash-constants for the sage code used to create all these tests.\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(16)\r\n    /// vector([BB.random_element() for t in range(16)]).\r\n    #[test]\r\n    fn test_poseidon2_width_16_random() {\r\n        let mut input: [F; 16] = BabyBear::new_array([\r\n            894848333, 1437655012, 1200606629, 1690012884, 71131202, 1749206695, 1717947831,\r\n            120589055, 19776022, 42382981, 1831865506, 724844064, 171220207, 1299207443, 227047920,\r\n            1783754913,\r\n        ]);\r\n\r\n        let expected: [F; 16] = BabyBear::new_array([\r\n            1255099308, 941729227, 93609187, 112406640, 492658670, 1824768948, 812517469,\r\n            1055381989, 670973674, 1407235524, 891397172, 1003245378, 1381303998, 1564172645,\r\n            1399931635, 1005462965,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2BabyBear::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(24)\r\n    /// vector([BB.random_element() for t in range(24)]).\r\n    #[test]\r\n    fn test_poseidon2_width_24_random() {\r\n        let mut input: [F; 24] = BabyBear::new_array([\r\n            886409618, 1327899896, 1902407911, 591953491, 648428576, 1844789031, 1198336108,\r\n            355597330, 1799586834, 59617783, 790334801, 1968791836, 559272107, 31054313,\r\n            1042221543, 474748436, 135686258, 263665994, 1962340735, 1741539604, 449439011,\r\n            1131357108, 50869465, 1589724894,\r\n        ]);\r\n\r\n        let expected: [F; 24] = BabyBear::new_array([\r\n            249424342, 562262148, 757431114, 354243402, 57767055, 976981973, 1393169022,\r\n            1774550827, 1527742125, 1019514605, 1776327602, 266236737, 1412355182, 1070239213,\r\n            426390978, 1775539440, 1527732214, 1101406020, 1417710778, 1699632661, 413672313,\r\n            820348291, 1067197851, 1669055675,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2BabyBear::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test the generic internal layer against the optimized internal layer\r\n    /// for a random input of width 16.\r\n    #[test]\r\n    fn test_generic_internal_linear_layer_16() {\r\n        let mut rng = rand::thread_rng();\r\n        let mut input1: [F; 16] = rng.gen();\r\n        let mut input2 = input1;\r\n\r\n        let part_sum: F = input1[1..].iter().cloned().sum();\r\n        let full_sum = part_sum + input1[0];\r\n\r\n        input1[0] = part_sum - input1[0];\r\n\r\n        BabyBearInternalLayerParameters::internal_layer_mat_mul(\u0026mut input1, full_sum);\r\n        BabyBearInternalLayerParameters::generic_internal_linear_layer(\u0026mut input2);\r\n\r\n        assert_eq!(input1, input2);\r\n    }\r\n\r\n    /// Test the generic internal layer against the optimized internal layer\r\n    /// for a random input of width 24.\r\n    #[test]\r\n    fn test_generic_internal_linear_layer_24() {\r\n        let mut rng = rand::thread_rng();\r\n        let mut input1: [F; 24] = rng.gen();\r\n        let mut input2 = input1;\r\n\r\n        let part_sum: F = input1[1..].iter().cloned().sum();\r\n        let full_sum = part_sum + input1[0];\r\n\r\n        input1[0] = part_sum - input1[0];\r\n\r\n        BabyBearInternalLayerParameters::internal_layer_mat_mul(\u0026mut input1, full_sum);\r\n        BabyBearInternalLayerParameters::generic_internal_linear_layer(\u0026mut input2);\r\n\r\n        assert_eq!(input1, input2);\r\n    }\r\n}\r\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":129,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":130,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":131,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":132,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":133,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":134,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":135,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":136,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":137,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":138,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":139,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":140,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":141,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":142,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":143,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":144,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":145,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":146,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":147,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":148,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":149,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":150,"address":[],"length":0,"stats":{"Line":5908722711110106898}},{"line":153,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":154,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":158,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":159,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":160,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":165,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":167,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":169,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":170,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":182,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":188,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":189,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":190,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":191,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":192,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":193,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":194,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":195,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":196,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":197,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":198,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":199,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":200,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":201,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":202,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":203,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":204,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":205,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":206,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":207,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":208,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":209,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":210,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":211,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":212,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":213,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":214,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":215,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":216,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":217,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":218,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":219,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":220,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":221,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":222,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":223,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":224,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":225,"address":[],"length":0,"stats":{"Line":3098476543630904435}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":229,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":235,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":240,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":242,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":244,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":245,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":82,"coverable":82},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx2","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx2","packing.rs"],"content":"use core::arch::x86_64::__m256i;\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersAVX2, PackedMontyField31AVX2};\r\n\r\nuse crate::BabyBearParameters;\r\n\r\npub type PackedBabyBearAVX2 = PackedMontyField31AVX2\u003cBabyBearParameters\u003e;\r\n\r\nconst WIDTH: usize = 8;\r\n\r\nimpl MontyParametersAVX2 for BabyBearParameters {\r\n    const PACKED_P: __m256i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x78000001; WIDTH]) };\r\n    const PACKED_MU: __m256i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x88000001; WIDTH]) };\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::BabyBear;\r\n\r\n    const SPECIAL_VALS: [BabyBear; WIDTH] = BabyBear::new_array([\r\n        0x00000000, 0x00000001, 0x78000000, 0x77ffffff, 0x3c000000, 0x0ffffffe, 0x68000003,\r\n        0x70000002,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedBabyBearAVX2,\r\n        crate::PackedBabyBearAVX2::ZERO,\r\n        p3_monty_31::PackedMontyField31AVX2::\u003ccrate::BabyBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx2","poseidon2.rs"],"content":"use core::arch::x86_64::__m256i;\r\n\r\nuse p3_monty_31::{\r\n    mul_2exp_neg_8_avx2, mul_2exp_neg_n_avx2, mul_2exp_neg_two_adicity_avx2,\r\n    mul_neg_2exp_neg_8_avx2, mul_neg_2exp_neg_n_avx2, mul_neg_2exp_neg_two_adicity_avx2,\r\n    InternalLayerParametersAVX2,\r\n};\r\n\r\nuse crate::{BabyBearInternalLayerParameters, BabyBearParameters};\r\n\r\nimpl InternalLayerParametersAVX2\u003cBabyBearParameters, 16\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [__m256i; 15];\r\n\r\n    /// For the BabyBear field and width 16 we multiply by the diagonal matrix:\r\n    ///\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/2^27, -1/2^8, -1/16, -1/2^27].\r\n    /// The first 9 entries are handled elsewhere, this function handles all the positive/negative inverse powers of two.\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m256i; 15]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other numbers b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // input[8] -\u003e sum + input[8]/2**8\r\n        input[8] = mul_2exp_neg_8_avx2::\u003cBabyBearParameters, 19\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2**2\r\n        input[9] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 2, 25\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2**3\r\n        input[10] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 3, 24\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2**27\r\n        input[11] = mul_2exp_neg_two_adicity_avx2::\u003cBabyBearParameters, 27, 4\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum - input[12]/2**8\r\n        input[12] = mul_neg_2exp_neg_8_avx2::\u003cBabyBearParameters, 19\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum - input[13]/2**4\r\n        input[13] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 4, 23\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum - input[14]/2**27\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx2::\u003cBabyBearParameters, 27, 4\u003e(input[14]);\r\n    }\r\n}\r\n\r\nimpl InternalLayerParametersAVX2\u003cBabyBearParameters, 24\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [__m256i; 23];\r\n\r\n    /// For the BabyBear field and width 24 we multiply by the diagonal matrix:\r\n    ///\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27, -1/2^8, -1/4, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^27]\r\n    /// The first 9 entries are handled elsewhere, this function handles all the positive/negative inverse powers of two.\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum, the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m256i; 23]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // input[8] -\u003e sum + input[8]/2**8\r\n        input[8] = mul_2exp_neg_8_avx2::\u003cBabyBearParameters, 19\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2**2\r\n        input[9] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 2, 25\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2**3\r\n        input[10] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 3, 24\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2**4\r\n        input[11] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 4, 23\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum + input[12]/2**7\r\n        input[12] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 7, 20\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum + input[13]/2**9\r\n        input[13] = mul_2exp_neg_n_avx2::\u003cBabyBearParameters, 9, 18\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum + input[14]/2**27\r\n        input[14] = mul_2exp_neg_two_adicity_avx2::\u003cBabyBearParameters, 27, 4\u003e(input[14]);\r\n\r\n        // input[15] -\u003e sum - input[15]/2**8\r\n        input[15] = mul_neg_2exp_neg_8_avx2::\u003cBabyBearParameters, 19\u003e(input[15]);\r\n\r\n        // input[16] -\u003e sum - input[16]/2**2\r\n        input[16] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 2, 25\u003e(input[16]);\r\n\r\n        // input[17] -\u003e sum - input[17]/2**3\r\n        input[17] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 3, 24\u003e(input[17]);\r\n\r\n        // input[18] -\u003e sum - input[18]/2**4\r\n        input[18] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 4, 23\u003e(input[18]);\r\n\r\n        // input[19] -\u003e sum - input[19]/2**5\r\n        input[19] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 5, 22\u003e(input[19]);\r\n\r\n        // input[20] -\u003e sum - input[20]/2**6\r\n        input[20] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 6, 21\u003e(input[20]);\r\n\r\n        // input[21] -\u003e sum - input[21]/2**7\r\n        input[21] = mul_neg_2exp_neg_n_avx2::\u003cBabyBearParameters, 7, 20\u003e(input[21]);\r\n\r\n        // input[22] -\u003e sum - input[22]/2**27\r\n        input[22] = mul_neg_2exp_neg_two_adicity_avx2::\u003cBabyBearParameters, 27, 4\u003e(input[22]);\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{BabyBear, PackedBabyBearAVX2, Poseidon2BabyBear};\r\n\r\n    type F = BabyBear;\r\n    type Perm16 = Poseidon2BabyBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2BabyBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedBabyBearAVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedBabyBearAVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":28,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":31,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":34,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":37,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":40,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":43,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":46,"address":[],"length":0,"stats":{"Line":13402712491054596338}},{"line":61,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":67,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":70,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":73,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":76,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":79,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":82,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":85,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":88,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":91,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":94,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":97,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":100,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":103,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":106,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":109,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":24,"coverable":24},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx512","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx512","packing.rs"],"content":"use core::arch::x86_64::__m512i;\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersAVX512, PackedMontyField31AVX512};\r\n\r\nuse crate::BabyBearParameters;\r\n\r\npub type PackedBabyBearAVX512 = PackedMontyField31AVX512\u003cBabyBearParameters\u003e;\r\n\r\nconst WIDTH: usize = 16;\r\n\r\nimpl MontyParametersAVX512 for BabyBearParameters {\r\n    const PACKED_P: __m512i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x78000001; WIDTH]) };\r\n    const PACKED_MU: __m512i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x88000001; WIDTH]) };\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::BabyBear;\r\n\r\n    const SPECIAL_VALS: [BabyBear; WIDTH] = BabyBear::new_array([\r\n        0x00000000, 0x00000001, 0x78000000, 0x77ffffff, 0x3c000000, 0x0ffffffe, 0x68000003,\r\n        0x70000002, 0x00000000, 0x00000001, 0x78000000, 0x77ffffff, 0x3c000000, 0x0ffffffe,\r\n        0x68000003, 0x70000002,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedBabyBearAVX512,\r\n        crate::PackedBabyBearAVX512::ZERO,\r\n        p3_monty_31::PackedMontyField31AVX512::\u003ccrate::BabyBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","baby-bear","src","x86_64_avx512","poseidon2.rs"],"content":"use core::arch::x86_64::__m512i;\r\n\r\nuse p3_monty_31::{\r\n    mul_neg_2exp_neg_8_avx512, mul_neg_2exp_neg_n_avx512, mul_neg_2exp_neg_two_adicity_avx512,\r\n    InternalLayerParametersAVX512,\r\n};\r\n\r\nuse crate::{BabyBearInternalLayerParameters, BabyBearParameters};\r\n\r\nimpl InternalLayerParametersAVX512\u003cBabyBearParameters, 16\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [__m512i; 15];\r\n\r\n    /// For the BabyBear field and width 16 we multiply by the diagonal matrix:\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/2^27, -1/2^8, -1/16, -1/2^27].\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m512i; 15]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other numbers b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // This following 4 muls (from input[8] to input[11]) output the negative of what we want.\r\n        // This will be handled in add_sum.\r\n\r\n        // input[8] -\u003e sum + input[8]/2**8\r\n        input[8] = mul_neg_2exp_neg_8_avx512::\u003cBabyBearParameters, 19\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2**2\r\n        input[9] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 2, 25\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2**3\r\n        input[10] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 3, 24\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2**27\r\n        input[11] = mul_neg_2exp_neg_two_adicity_avx512::\u003cBabyBearParameters, 27, 4\u003e(input[11]);\r\n\r\n        // The remaining muls output the correct value again.\r\n\r\n        // input[12] -\u003e sum - input[12]/2**8\r\n        input[12] = mul_neg_2exp_neg_8_avx512::\u003cBabyBearParameters, 19\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum - input[13]/2**4\r\n        input[13] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 4, 23\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum - input[14]/2**27\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx512::\u003cBabyBearParameters, 27, 4\u003e(input[14]);\r\n    }\r\n\r\n    /// There are 4 positive inverse powers of two after the 4: 1/2^8, 1/4, 1/8, 1/2^27.\r\n    const NUM_POS: usize = 4;\r\n}\r\n\r\nimpl InternalLayerParametersAVX512\u003cBabyBearParameters, 24\u003e for BabyBearInternalLayerParameters {\r\n    type ArrayLike = [__m512i; 23];\r\n\r\n    /// For the BabyBear field and width 24 we multiply by the diagonal matrix:\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27, -1/2^8, -1/4, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^27]\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum, the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m512i; 23]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // This following 7 muls (from input[8] to input[14]) output the negative of what we want.\r\n        // This will be handled in add_sum.\r\n\r\n        // input[8] -\u003e sum + input[8]/2**8\r\n        input[8] = mul_neg_2exp_neg_8_avx512::\u003cBabyBearParameters, 19\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2**2\r\n        input[9] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 2, 25\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2**3\r\n        input[10] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 3, 24\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2**4\r\n        input[11] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 4, 23\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum + input[12]/2**7\r\n        input[12] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 7, 20\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum + input[13]/2**9\r\n        input[13] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 9, 18\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum + input[14]/2**27\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx512::\u003cBabyBearParameters, 27, 4\u003e(input[14]);\r\n\r\n        // The remaining muls output the correct value again.\r\n\r\n        // input[15] -\u003e sum - input[15]/2**8\r\n        input[15] = mul_neg_2exp_neg_8_avx512::\u003cBabyBearParameters, 19\u003e(input[15]);\r\n\r\n        // input[16] -\u003e sum - input[16]/2**2\r\n        input[16] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 2, 25\u003e(input[16]);\r\n\r\n        // input[17] -\u003e sum - input[17]/2**3\r\n        input[17] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 3, 24\u003e(input[17]);\r\n\r\n        // input[18] -\u003e sum - input[18]/2**4\r\n        input[18] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 4, 23\u003e(input[18]);\r\n\r\n        // input[19] -\u003e sum - input[19]/2**5\r\n        input[19] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 5, 22\u003e(input[19]);\r\n\r\n        // input[20] -\u003e sum - input[20]/2**6\r\n        input[20] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 6, 21\u003e(input[20]);\r\n\r\n        // input[21] -\u003e sum - input[21]/2**7\r\n        input[21] = mul_neg_2exp_neg_n_avx512::\u003cBabyBearParameters, 7, 20\u003e(input[21]);\r\n\r\n        // input[22] -\u003e sum - input[22]/2**27\r\n        input[22] = mul_neg_2exp_neg_two_adicity_avx512::\u003cBabyBearParameters, 27, 4\u003e(input[22]);\r\n    }\r\n\r\n    /// There are 7 positive inverse powers of two after the 4: 1/2^8, 1/4, 1/8, 1/16, 1/2^7, 1/2^9, 1/2^27,.\r\n    const NUM_POS: usize = 7;\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{BabyBear, PackedBabyBearAVX512, Poseidon2BabyBear};\r\n\r\n    type F = BabyBear;\r\n    type Perm16 = Poseidon2BabyBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2BabyBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedBabyBearAVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedBabyBearAVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3","src","lib.rs"],"content":"//! The blake3 hash function.\r\n\r\n#![no_std]\r\n\r\nuse p3_symmetric::CryptographicHasher;\r\n\r\n/// The blake3 hash function.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct Blake3;\r\n\r\nimpl CryptographicHasher\u003cu8, [u8; 32]\u003e for Blake3 {\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = u8\u003e,\r\n    {\r\n        const BUFLEN: usize = 512; // Tweakable parameter; determined by experiment\r\n        let mut hasher = blake3::Hasher::new();\r\n        p3_util::apply_to_chunks::\u003cBUFLEN, _, _\u003e(input, |buf| {\r\n            hasher.update(buf);\r\n        });\r\n        hasher.finalize().into()\r\n    }\r\n\r\n    fn hash_iter_slices\u003c'a, I\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = \u0026'a [u8]\u003e,\r\n    {\r\n        let mut hasher = blake3::Hasher::new();\r\n        for chunk in input.into_iter() {\r\n            hasher.update(chunk);\r\n        }\r\n        hasher.finalize().into()\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3-air","src","air.rs"],"content":"use alloc::vec::Vec;\r\nuse core::borrow::Borrow;\r\n\r\nuse itertools::izip;\r\nuse p3_air::utils::{add2, add3, pack_bits_le, xor, xor_32_shift};\r\nuse p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_field::{PrimeCharacteristicRing, PrimeField64};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse rand::random;\r\n\r\nuse crate::columns::{Blake3Cols, NUM_BLAKE3_COLS};\r\nuse crate::constants::{permute, BITS_PER_LIMB, IV};\r\nuse crate::{generate_trace_rows, Blake3State, FullRound, QuarterRound};\r\n\r\n/// Assumes the field size is at least 16 bits.\r\n#[derive(Debug)]\r\npub struct Blake3Air {}\r\n\r\nimpl Blake3Air {\r\n    pub fn generate_trace_rows\u003cF: PrimeField64\u003e(\r\n        \u0026self,\r\n        num_hashes: usize,\r\n        extra_capacity_bits: usize,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let inputs = (0..num_hashes).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        generate_trace_rows(inputs, extra_capacity_bits)\r\n    }\r\n\r\n    /// Verify that the quarter round function has been correctly computed.\r\n    ///\r\n    /// We assume that the values in a, b, c, d have all been range checked to be\r\n    /// either boolean (for b, d) or \u003c 2^16 (for a, c). This both range checks all x', x''\r\n    /// and auxiliary variables as well as checking the relevant constraints between\r\n    /// them to conclude that the outputs are correct given the inputs.\r\n    fn quarter_round_function\u003cAB: AirBuilder\u003e(\r\n        \u0026self,\r\n        builder: \u0026mut AB,\r\n        trace: \u0026QuarterRound\u003c\u003cAB as AirBuilder\u003e::Var, \u003cAB as AirBuilder\u003e::Expr\u003e,\r\n    ) {\r\n        // We need to pack some bits together to verify the additions.\r\n        // First we verify a' = a + b + m_{2i} mod 2^32\r\n        let b_0_16 = pack_bits_le(trace.b[..BITS_PER_LIMB].iter().copied());\r\n        let b_16_32 = pack_bits_le(trace.b[BITS_PER_LIMB..].iter().copied());\r\n\r\n        add3(\r\n            builder,\r\n            trace.a_prime,\r\n            trace.a,\r\n            \u0026[b_0_16, b_16_32],\r\n            trace.m_two_i,\r\n        );\r\n\r\n        // Next we verify that d' = (a' ^ d) \u003e\u003e 16 which is equivalently:  a' = d ^ (d' \u003c\u003c 16)\r\n        // This also range checks d' and a'.\r\n        xor_32_shift(builder, trace.a_prime, trace.d, trace.d_prime, 16);\r\n\r\n        // Next we verify c' = c + d' mod 2^32\r\n        let d_prime_0_16 = pack_bits_le(trace.d_prime[..BITS_PER_LIMB].iter().copied());\r\n        let d_prime_16_32 = pack_bits_le(trace.d_prime[BITS_PER_LIMB..].iter().copied());\r\n        add2(\r\n            builder,\r\n            trace.c_prime,\r\n            trace.c,\r\n            \u0026[d_prime_0_16, d_prime_16_32],\r\n        );\r\n\r\n        // Next we verify that b' = (c' ^ b) \u003e\u003e 12 which is equivalently: c' = b ^ (b' \u003c\u003c 12)\r\n        // This also range checks b' and c'.\r\n        xor_32_shift(builder, trace.c_prime, trace.b, trace.b_prime, 12);\r\n\r\n        // Next we verify a'' = a' + b' + m_{2i + 1} mod 2^32\r\n        let b_prime_0_16 = pack_bits_le(trace.b_prime[..BITS_PER_LIMB].iter().copied());\r\n        let b_prime_16_32 = pack_bits_le(trace.b_prime[BITS_PER_LIMB..].iter().copied());\r\n\r\n        add3(\r\n            builder,\r\n            trace.a_output,\r\n            trace.a_prime,\r\n            \u0026[b_prime_0_16, b_prime_16_32],\r\n            trace.m_two_i_plus_one,\r\n        );\r\n\r\n        // Next we verify that d'' = (a'' ^ d') \u003c\u003c 8 which is equivalently: a'' = d' ^ (d'' \u003c\u003c 8)\r\n        // This also range checks d'' and a''.\r\n\r\n        xor_32_shift(builder, trace.a_output, trace.d_prime, trace.d_output, 8);\r\n\r\n        // Next we verify c'' = c' + d'' mod 2^32\r\n        let d_output_0_16 = pack_bits_le(trace.d_output[..BITS_PER_LIMB].iter().copied());\r\n        let d_output_16_32 = pack_bits_le(trace.d_output[BITS_PER_LIMB..].iter().copied());\r\n        add2(\r\n            builder,\r\n            trace.c_output,\r\n            trace.c_prime,\r\n            \u0026[d_output_0_16, d_output_16_32],\r\n        );\r\n\r\n        // Finally we verify that b'' = (c'' ^ b') \u003c\u003c 7 which is equivalently: c'' = b' ^ (b'' \u003c\u003c 7)\r\n        // This also range checks b'' and c''.\r\n        xor_32_shift(builder, trace.c_output, trace.b_prime, trace.b_output, 7);\r\n\r\n        // Assuming all checks pass, a'', b'', c'', d'' are the correct values and have all been range checked.\r\n    }\r\n\r\n    /// Given data for a full round, produce the data corresponding to a\r\n    /// single application of the quarter round function on a column.\r\n    fn full_round_to_column_quarter_round\u003c'a, T: Copy, U\u003e(\r\n        \u0026self,\r\n        input: \u0026'a Blake3State\u003cT\u003e,\r\n        round_data: \u0026'a FullRound\u003cT\u003e,\r\n        m_vector: \u0026'a [[U; 2]; 16],\r\n        index: usize,\r\n    ) -\u003e QuarterRound\u003c'a, T, U\u003e {\r\n        QuarterRound {\r\n            a: \u0026input.row0[index],\r\n            b: \u0026input.row1[index],\r\n            c: \u0026input.row2[index],\r\n            d: \u0026input.row3[index],\r\n\r\n            m_two_i: \u0026m_vector[2 * index],\r\n\r\n            a_prime: \u0026round_data.state_prime.row0[index],\r\n            b_prime: \u0026round_data.state_prime.row1[index],\r\n            c_prime: \u0026round_data.state_prime.row2[index],\r\n            d_prime: \u0026round_data.state_prime.row3[index],\r\n\r\n            m_two_i_plus_one: \u0026m_vector[2 * index + 1],\r\n\r\n            a_output: \u0026round_data.state_middle.row0[index],\r\n            b_output: \u0026round_data.state_middle.row1[index],\r\n            c_output: \u0026round_data.state_middle.row2[index],\r\n            d_output: \u0026round_data.state_middle.row3[index],\r\n        }\r\n    }\r\n\r\n    /// Given data for a full round, produce the data corresponding to a\r\n    /// single application of the quarter round function on a diagonal.\r\n    fn full_round_to_diagonal_quarter_round\u003c'a, T: Copy, U\u003e(\r\n        \u0026self,\r\n        round_data: \u0026'a FullRound\u003cT\u003e,\r\n        m_vector: \u0026'a [[U; 2]; 16],\r\n        index: usize,\r\n    ) -\u003e QuarterRound\u003c'a, T, U\u003e {\r\n        QuarterRound {\r\n            a: \u0026round_data.state_middle.row0[index],\r\n            b: \u0026round_data.state_middle.row1[(index + 1) % 4],\r\n            c: \u0026round_data.state_middle.row2[(index + 2) % 4],\r\n            d: \u0026round_data.state_middle.row3[(index + 3) % 4],\r\n\r\n            m_two_i: \u0026m_vector[2 * index + 8],\r\n\r\n            a_prime: \u0026round_data.state_middle_prime.row0[index],\r\n            b_prime: \u0026round_data.state_middle_prime.row1[(index + 1) % 4],\r\n            c_prime: \u0026round_data.state_middle_prime.row2[(index + 2) % 4],\r\n            d_prime: \u0026round_data.state_middle_prime.row3[(index + 3) % 4],\r\n\r\n            m_two_i_plus_one: \u0026m_vector[2 * index + 9],\r\n\r\n            a_output: \u0026round_data.state_output.row0[index],\r\n            b_output: \u0026round_data.state_output.row1[(index + 1) % 4],\r\n            c_output: \u0026round_data.state_output.row2[(index + 2) % 4],\r\n            d_output: \u0026round_data.state_output.row3[(index + 3) % 4],\r\n        }\r\n    }\r\n\r\n    /// Verify a full round of the Blake-3 permutation.\r\n    fn verify_round\u003cAB: AirBuilder\u003e(\r\n        \u0026self,\r\n        builder: \u0026mut AB,\r\n        input: \u0026Blake3State\u003cAB::Var\u003e,\r\n        round_data: \u0026FullRound\u003cAB::Var\u003e,\r\n        m_vector: \u0026[[AB::Expr; 2]; 16],\r\n    ) {\r\n        // First we mix the columns.\r\n\r\n        // The first column quarter round function involves the states in position: 0, 4, 8, 12\r\n        // Along with the two m_vector elements in the 0 and 1 positions.\r\n        let trace_column_0 =\r\n            self.full_round_to_column_quarter_round(input, round_data, m_vector, 0);\r\n        self.quarter_round_function(builder, \u0026trace_column_0);\r\n\r\n        // The next column quarter round function involves the states in position: 1, 5, 9, 13\r\n        // Along with the two m_vector elements in the 2 and 3 positions.\r\n        let trace_column_1 =\r\n            self.full_round_to_column_quarter_round(input, round_data, m_vector, 1);\r\n        self.quarter_round_function(builder, \u0026trace_column_1);\r\n\r\n        // The next column quarter round function involves the states in position: 2, 6, 10, 14\r\n        // Along with the two m_vector elements in the 4 and 5 positions.\r\n        let trace_column_2 =\r\n            self.full_round_to_column_quarter_round(input, round_data, m_vector, 2);\r\n        self.quarter_round_function(builder, \u0026trace_column_2);\r\n\r\n        // The final column quarter round function involves the states in position: 3, 7, 11, 15\r\n        // Along with the two m_vector elements in the 6 and 7 positions.\r\n        let trace_column_3 =\r\n            self.full_round_to_column_quarter_round(input, round_data, m_vector, 3);\r\n        self.quarter_round_function(builder, \u0026trace_column_3);\r\n\r\n        // Second we mix the diagonals.\r\n\r\n        // The first diagonal quarter round function involves the states in position: 0, 5, 10, 15\r\n        // Along with the two m_vector elements in the 8 and 9 positions.\r\n        let trace_diagonal_0 = self.full_round_to_diagonal_quarter_round(round_data, m_vector, 0);\r\n        self.quarter_round_function(builder, \u0026trace_diagonal_0);\r\n\r\n        // The next diagonal quarter round function involves the states in position: 1, 6, 11, 12\r\n        // Along with the two m_vector elements in the 10 and 11 positions.\r\n        let trace_diagonal_1 = self.full_round_to_diagonal_quarter_round(round_data, m_vector, 1);\r\n        self.quarter_round_function(builder, \u0026trace_diagonal_1);\r\n\r\n        // The next diagonal quarter round function involves the states in position: 2, 7, 8, 13\r\n        // Along with the two m_vector elements in the 12 and 13 positions.\r\n        let trace_diagonal_2 = self.full_round_to_diagonal_quarter_round(round_data, m_vector, 2);\r\n        self.quarter_round_function(builder, \u0026trace_diagonal_2);\r\n\r\n        // The final diagonal quarter round function involves the states in position: 3, 4, 9, 14\r\n        // Along with the two m_vector elements in the 14 and 15 positions.\r\n        let trace_diagonal_3 = self.full_round_to_diagonal_quarter_round(round_data, m_vector, 3);\r\n        self.quarter_round_function(builder, \u0026trace_diagonal_3);\r\n    }\r\n}\r\n\r\nimpl\u003cF\u003e BaseAir\u003cF\u003e for Blake3Air {\r\n    fn width(\u0026self) -\u003e usize {\r\n        NUM_BLAKE3_COLS\r\n    }\r\n}\r\n\r\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for Blake3Air {\r\n    #[inline]\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        let main = builder.main();\r\n        let local = main.row_slice(0);\r\n        let local: \u0026Blake3Cols\u003cAB::Var\u003e = (*local).borrow();\r\n\r\n        let initial_row_3 = [\r\n            local.counter_low,\r\n            local.counter_hi,\r\n            local.block_len,\r\n            local.flags,\r\n        ];\r\n\r\n        // We start by checking that all the initialization inputs are boolean values.\r\n        local\r\n            .inputs\r\n            .iter()\r\n            .chain(local.chaining_values[0].iter())\r\n            .chain(local.chaining_values[1].iter())\r\n            .chain(initial_row_3.iter())\r\n            .for_each(|elem| elem.iter().for_each(|\u0026bool| builder.assert_bool(bool)));\r\n\r\n        // Next we ensure that the row0 and row2 for our initial state have been initialized correctly.\r\n\r\n        // row0 should contain the packing of the first 4 chaining_values.\r\n        local.chaining_values[0]\r\n            .iter()\r\n            .zip(local.initial_row0)\r\n            .for_each(|(bits, word)| {\r\n                let low_16 = pack_bits_le(bits[..BITS_PER_LIMB].iter().copied());\r\n                let hi_16 = pack_bits_le(bits[BITS_PER_LIMB..].iter().copied());\r\n                builder.assert_eq(low_16, word[0]);\r\n                builder.assert_eq(hi_16, word[1]);\r\n            });\r\n\r\n        // row2 should contain the first four constants in IV.\r\n        local\r\n            .initial_row2\r\n            .iter()\r\n            .zip(IV)\r\n            .for_each(|(row_elem, constant)| {\r\n                builder.assert_eq(row_elem[0], AB::Expr::from_u16(constant[0]));\r\n                builder.assert_eq(row_elem[1], AB::Expr::from_u16(constant[1]));\r\n            });\r\n\r\n        let mut m_values: [[AB::Expr; 2]; 16] = local.inputs.map(|bits| {\r\n            [\r\n                pack_bits_le(bits[..BITS_PER_LIMB].iter().copied()),\r\n                pack_bits_le(bits[BITS_PER_LIMB..].iter().copied()),\r\n            ]\r\n        });\r\n\r\n        let initial_state = Blake3State {\r\n            row0: local.initial_row0,\r\n            row1: local.chaining_values[1],\r\n            row2: local.initial_row2,\r\n            row3: initial_row_3,\r\n        };\r\n\r\n        // Now we can move to verifying that each of the seven rounds have been computed correctly.\r\n\r\n        // Round 1:\r\n        self.verify_round(builder, \u0026initial_state, \u0026local.full_rounds[0], \u0026m_values);\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 2:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[0].state_output,\r\n            \u0026local.full_rounds[1],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 3:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[1].state_output,\r\n            \u0026local.full_rounds[2],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 4:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[2].state_output,\r\n            \u0026local.full_rounds[3],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 5:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[3].state_output,\r\n            \u0026local.full_rounds[4],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 6:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[4].state_output,\r\n            \u0026local.full_rounds[5],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Permute the vector of m_values.\r\n        permute(\u0026mut m_values);\r\n\r\n        // Round 7:\r\n        self.verify_round(\r\n            builder,\r\n            \u0026local.full_rounds[5].state_output,\r\n            \u0026local.full_rounds[6],\r\n            \u0026m_values,\r\n        );\r\n\r\n        // Verify the final set of xor's.\r\n        // For the first 8 of these we xor state[i] and state[i + 8] (i = 0, .., 7)\r\n\r\n        // When i = 0, 1, 2, 3 both inputs are given as 16 bit integers. Hence we need to get the individual bits\r\n        // of one of them in order to test this.\r\n\r\n        local\r\n            .final_round_helpers\r\n            .iter()\r\n            .zip(local.full_rounds[6].state_output.row2)\r\n            .for_each(|(bits, word)| {\r\n                let low_16 = pack_bits_le(bits[..BITS_PER_LIMB].iter().copied());\r\n                let hi_16 = pack_bits_le(bits[BITS_PER_LIMB..].iter().copied());\r\n                builder.assert_eq(low_16, word[0]);\r\n                builder.assert_eq(hi_16, word[1]);\r\n            });\r\n        // Additionally, we need to ensure that both local.final_round_helpers and local.outputs[0] are boolean.\r\n\r\n        local\r\n            .final_round_helpers\r\n            .iter()\r\n            .chain(local.outputs[0].iter())\r\n            .for_each(|bits| bits.iter().for_each(|\u0026bit| builder.assert_bool(bit)));\r\n\r\n        // Finally we check the xor by xor'ing the output with final_round_helpers, packing the bits\r\n        // and comparing with the words in local.full_rounds[6].state_output.row0.\r\n\r\n        for (out_bits, left_words, right_bits) in izip!(\r\n            local.outputs[0],\r\n            local.full_rounds[6].state_output.row0,\r\n            local.final_round_helpers\r\n        ) {\r\n            // We can reuse xor_32_shift with a shift of 0.\r\n            // As a = b ^ c if and only if b = a ^ c we can perform our xor on the\r\n            // elements which we have the bits of and then check against a.\r\n            xor_32_shift(builder, \u0026left_words, \u0026out_bits, \u0026right_bits, 0)\r\n        }\r\n\r\n        // When i = 4, 5, 6, 7 we already have the bits of state[i] and state[i + 8] making this easy.\r\n        // This check also ensures that local.outputs[1] contains only boolean values.\r\n\r\n        for (out_bits, left_bits, right_bits) in izip!(\r\n            local.outputs[1],\r\n            local.full_rounds[6].state_output.row1,\r\n            local.full_rounds[6].state_output.row3\r\n        ) {\r\n            for (out_bit, left_bit, right_bit) in izip!(out_bits, left_bits, right_bits) {\r\n                builder.assert_eq(out_bit, xor(left_bit.into(), right_bit.into()));\r\n            }\r\n        }\r\n\r\n        // For the remaining 8, we xor state[i] and chaining_value[i - 8] (i = 8, .., 15)\r\n\r\n        // When i = 8, 9, 10, 11, we have the bits state[i] already as we used then in the\r\n        // i = 0, 1, 2, 3 case. Additionally we also have the bits of chaining_value[i - 8].\r\n        // Hence we can directly check that the output is correct.\r\n\r\n        for (out_bits, left_bits, right_bits) in izip!(\r\n            local.outputs[2],\r\n            local.chaining_values[0],\r\n            local.final_round_helpers\r\n        ) {\r\n            for (out_bit, left_bit, right_bit) in izip!(out_bits, left_bits, right_bits) {\r\n                builder.assert_eq(out_bit, xor(left_bit.into(), right_bit.into()));\r\n            }\r\n        }\r\n\r\n        // This is easy when i = 12, 13, 14, 15 as we already have the bits.\r\n        // This check also ensures that local.outputs[3] contains only boolean values.\r\n\r\n        for (out_bits, left_bits, right_bits) in izip!(\r\n            local.outputs[3],\r\n            local.chaining_values[1],\r\n            local.full_rounds[6].state_output.row3\r\n        ) {\r\n            for (out_bit, left_bit, right_bit) in izip!(out_bits, left_bits, right_bits) {\r\n                builder.assert_eq(out_bit, xor(left_bit.into(), right_bit.into()));\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":193},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3-air","src","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\r\nuse core::mem::size_of;\r\n\r\nuse crate::constants::U32_LIMBS;\r\n\r\n/// Columns for a Blake-3 AIR which computes one permutation per row.\r\n///\r\n/// This is a pretty wide trace but that should be fine.\r\n#[repr(C)]\r\npub struct Blake3Cols\u003cT\u003e {\r\n    // The inputs to the hash function.\r\n    pub inputs: [[T; 32]; 16],\r\n\r\n    // The chaining values are the first eight outputs of the previous compression.\r\n    pub chaining_values: [[[T; 32]; 4]; 2],\r\n\r\n    // A few auxiliary values use to flesh out the first state.\r\n    pub counter_low: [T; 32],\r\n    pub counter_hi: [T; 32],\r\n    pub block_len: [T; 32],\r\n    pub flags: [T; 32],\r\n\r\n    // It should be possible to remove these two but this makes a negligible difference to the overall width of the trace.\r\n    pub initial_row0: [[T; U32_LIMBS]; 4],\r\n    pub initial_row2: [[T; U32_LIMBS]; 4],\r\n\r\n    pub full_rounds: [FullRound\u003cT\u003e; 7],\r\n\r\n    pub final_round_helpers: [[T; 32]; 4],\r\n\r\n    pub outputs: [[[T; 32]; 4]; 4],\r\n}\r\n\r\n/// A state at a single instance of time.\r\n///\r\n/// Rows `0` and `2` are saved as `2` `16` bit limbs.\r\n/// Rows `1` and `3` are saved as `32` boolean values.\r\n#[repr(C)]\r\npub struct Blake3State\u003cT\u003e {\r\n    pub row0: [[T; U32_LIMBS]; 4],\r\n    pub row1: [[T; 32]; 4],\r\n    pub row2: [[T; U32_LIMBS]; 4],\r\n    pub row3: [[T; 32]; 4],\r\n}\r\n\r\n/// Full round columns.\r\n#[repr(C)]\r\npub struct FullRound\u003cT\u003e {\r\n    // A full round of the Blake3 hash consists of 2 sub rounds each containing 4 applications\r\n    // of the quarter round function.\r\n    //\r\n    // In the first sub round, the quarter round function is applied to each column of the matrix.\r\n    // In the second sub round, the quarter round function is applied to each left-right diagonal of the matrix.\r\n    //\r\n    // We use the output of the previous row to get the input to this row.\r\n    //\r\n    /// The outputs after applying the first half of the column quarter round functions.\r\n    pub state_prime: Blake3State\u003cT\u003e,\r\n\r\n    /// The outputs after the first sub round.\r\n    pub state_middle: Blake3State\u003cT\u003e,\r\n\r\n    /// The outputs after applying the first half of the diagonal quarter round functions.\r\n    pub state_middle_prime: Blake3State\u003cT\u003e,\r\n\r\n    /// This will also be the input to the next row.\r\n    pub state_output: Blake3State\u003cT\u003e,\r\n}\r\n\r\n/// Data needed to verify a single quarter round function.\r\n#[repr(C)]\r\npub(crate) struct QuarterRound\u003c'a, T, U\u003e {\r\n    // The inputs to the quarter round function.\r\n    pub a: \u0026'a [T; U32_LIMBS],\r\n    pub b: \u0026'a [T; 32],\r\n    pub c: \u0026'a [T; U32_LIMBS],\r\n    pub d: \u0026'a [T; 32],\r\n\r\n    pub m_two_i: \u0026'a [U; U32_LIMBS], // m_{2i}\r\n\r\n    // The state after the first half of the quarter round function.\r\n    pub a_prime: \u0026'a [T; U32_LIMBS],\r\n    pub b_prime: \u0026'a [T; 32],\r\n    pub c_prime: \u0026'a [T; U32_LIMBS],\r\n    pub d_prime: \u0026'a [T; 32],\r\n\r\n    pub m_two_i_plus_one: \u0026'a [U; U32_LIMBS], // m_{2i + 1}\r\n\r\n    // The output from the quarter round function.\r\n    pub a_output: \u0026'a [T; U32_LIMBS],\r\n    pub b_output: \u0026'a [T; 32],\r\n    pub c_output: \u0026'a [T; U32_LIMBS],\r\n    pub d_output: \u0026'a [T; 32],\r\n}\r\n\r\npub const NUM_BLAKE3_COLS: usize = size_of::\u003cBlake3Cols\u003cu8\u003e\u003e();\r\n\r\nimpl\u003cT\u003e Borrow\u003cBlake3Cols\u003cT\u003e\u003e for [T] {\r\n    fn borrow(\u0026self) -\u003e \u0026Blake3Cols\u003cT\u003e {\r\n        debug_assert_eq!(self.len(), NUM_BLAKE3_COLS);\r\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cBlake3Cols\u003cT\u003e\u003e() };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026shorts[0]\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e BorrowMut\u003cBlake3Cols\u003cT\u003e\u003e for [T] {\r\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut Blake3Cols\u003cT\u003e {\r\n        debug_assert_eq!(self.len(), NUM_BLAKE3_COLS);\r\n        let (prefix, shorts, suffix) = unsafe { self.align_to_mut::\u003cBlake3Cols\u003cT\u003e\u003e() };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026mut shorts[0]\r\n    }\r\n}\r\n","traces":[{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3-air","src","constants.rs"],"content":"pub const BITS_PER_LIMB: usize = 16;\r\npub const U32_LIMBS: usize = 32 / BITS_PER_LIMB;\r\n\r\n// The constants from the reference implementation.\r\n// Saved as pairs of 16 bit integers in [lo, hi] format.\r\npub(crate) const IV: [[u16; 2]; 8] = [\r\n    [0xE667, 0x6A09],\r\n    [0xAE85, 0xBB67],\r\n    [0xF372, 0x3C6E],\r\n    [0xF53A, 0xA54F],\r\n    [0x527F, 0x510E],\r\n    [0x688C, 0x9B05],\r\n    [0xD9AB, 0x1F83],\r\n    [0xCD19, 0x5BE0],\r\n];\r\n\r\n// The index map for the permutation used to permute the block words is:\r\n// `[2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8]`\r\n//\r\n// This permutation decomposes into 2 cycles of length 8:\r\n// `0 -\u003e 2 -\u003e 3 -\u003e 10 -\u003e 12 -\u003e 9 -\u003e 11 -\u003e 5 -\u003e 0`\r\n// `1 -\u003e 6 -\u003e 4 -\u003e 7 -\u003e 13 -\u003e 14 -\u003e 15 -\u003e 8 -\u003e 1`\r\n//\r\n// There might be a way to use this decomposition to slightly speed permute up.\r\n\r\n/// The index map for the permutation used to permute the block words.\r\nconst MSG_PERMUTATION: [usize; 16] = [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8];\r\n\r\n/// Apply the MSG_PERMUTATION to an array.\r\npub(crate) fn permute\u003cT: Clone\u003e(m: \u0026mut [T; 16]) {\r\n    let mut permuted = m.clone();\r\n    for i in 0..16 {\r\n        permuted[i] = m[MSG_PERMUTATION[i]].clone();\r\n    }\r\n    *m = permuted;\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3-air","src","generation.rs"],"content":"use alloc::vec::Vec;\r\nuse core::array;\r\n\r\nuse p3_air::utils::u32_to_bits_le;\r\nuse p3_field::{PrimeCharacteristicRing, PrimeField64};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse tracing::instrument;\r\n\r\nuse crate::columns::{Blake3Cols, NUM_BLAKE3_COLS};\r\nuse crate::constants::{permute, IV};\r\nuse crate::{Blake3State, FullRound};\r\n\r\n// TODO: Take generic iterable\r\n#[instrument(name = \"generate Blake3 trace\", skip_all)]\r\npub fn generate_trace_rows\u003cF: PrimeField64\u003e(\r\n    inputs: Vec\u003c[u32; 24]\u003e,\r\n    extra_capacity_bits: usize,\r\n) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    let num_rows = inputs.len();\r\n    assert!(\r\n        num_rows.is_power_of_two(),\r\n        \"Callers expected to pad inputs to VECTOR_LEN times a power of two\"\r\n    );\r\n\r\n    let trace_length = num_rows * NUM_BLAKE3_COLS;\r\n\r\n    // We allocate extra_capacity_bits now as this will be needed by the dft.\r\n    let mut long_trace = F::zero_vec(trace_length \u003c\u003c extra_capacity_bits);\r\n    long_trace.truncate(trace_length);\r\n\r\n    let mut trace = RowMajorMatrix::new(long_trace, NUM_BLAKE3_COLS);\r\n    let (prefix, rows, suffix) = unsafe { trace.values.align_to_mut::\u003cBlake3Cols\u003cF\u003e\u003e() };\r\n    assert!(prefix.is_empty(), \"Alignment should match\");\r\n    assert!(suffix.is_empty(), \"Alignment should match\");\r\n    assert_eq!(rows.len(), num_rows);\r\n\r\n    rows.par_iter_mut()\r\n        .zip(inputs)\r\n        .enumerate()\r\n        .for_each(|(counter, (row, input))| {\r\n            generate_trace_rows_for_perm(row, input, counter, num_rows);\r\n        });\r\n\r\n    trace\r\n}\r\n\r\n/// Each row is one full implementation of the Blake-3 hash.\r\nfn generate_trace_rows_for_perm\u003cF: PrimeField64\u003e(\r\n    row: \u0026mut Blake3Cols\u003cF\u003e,\r\n    input: [u32; 24],\r\n    counter: usize,\r\n    block_len: usize,\r\n) {\r\n    // We split the input into 2 parts.\r\n    // The first 16 elements we treat as the inputs or block_words\r\n    row.inputs = array::from_fn(|i| u32_to_bits_le(input[i]));\r\n\r\n    // the remaining 8 elements are interpreted as the chaining values.\r\n    row.chaining_values =\r\n        array::from_fn(|i| array::from_fn(|j| u32_to_bits_le(input[16 + 4 * i + j])));\r\n\r\n    row.counter_low = u32_to_bits_le(counter as u32);\r\n    row.counter_hi = u32_to_bits_le((counter \u003e\u003e 32) as u32);\r\n    row.block_len = u32_to_bits_le(block_len as u32);\r\n\r\n    // We set the flags initial value to just be 0.\r\n    row.flags = u32_to_bits_le(0);\r\n\r\n    row.initial_row0 = array::from_fn(|i| {\r\n        [\r\n            F::from_u16(input[16 + i] as u16),\r\n            F::from_u16((input[16 + i] \u003e\u003e 16) as u16),\r\n        ]\r\n    });\r\n\r\n    row.initial_row2 = array::from_fn(|i| [F::from_u16(IV[i][0]), F::from_u16(IV[i][1])]);\r\n\r\n    // We save the state and m_vec as u_32's we will quickly compute the hash using these whilst saving\r\n    // the appropriate data in the trace as we go.\r\n    let mut m_vec: [u32; 16] = array::from_fn(|i| input[i]);\r\n    let mut state = [\r\n        [input[16], input[16 + 1], input[16 + 2], input[16 + 3]],\r\n        [input[16 + 4], input[16 + 5], input[16 + 6], input[16 + 7]],\r\n        [\r\n            (IV[0][0] as u32) + ((IV[0][1] as u32) \u003c\u003c 16),\r\n            (IV[1][0] as u32) + ((IV[1][1] as u32) \u003c\u003c 16),\r\n            (IV[2][0] as u32) + ((IV[2][1] as u32) \u003c\u003c 16),\r\n            (IV[3][0] as u32) + ((IV[3][1] as u32) \u003c\u003c 16),\r\n        ],\r\n        [counter as u32, (counter \u003e\u003e 32) as u32, block_len as u32, 0],\r\n    ];\r\n\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[0], \u0026mut state, \u0026m_vec); // round 1\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[1], \u0026mut state, \u0026m_vec); // round 2\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[2], \u0026mut state, \u0026m_vec); // round 3\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[3], \u0026mut state, \u0026m_vec); // round 4\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[4], \u0026mut state, \u0026m_vec); // round 5\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[5], \u0026mut state, \u0026m_vec); // round 6\r\n    permute(\u0026mut m_vec);\r\n    generate_trace_row_for_round(\u0026mut row.full_rounds[6], \u0026mut state, \u0026m_vec); // round 7\r\n\r\n    // After performing all the rounds, all that is left to do is to populate the final xor data.\r\n\r\n    row.final_round_helpers = array::from_fn(|i| u32_to_bits_le(state[2][i]));\r\n\r\n    row.outputs[0] = array::from_fn(|i| u32_to_bits_le(state[0][i] ^ state[2][i]));\r\n    row.outputs[1] = array::from_fn(|i| u32_to_bits_le(state[1][i] ^ state[3][i]));\r\n    row.outputs[2] = array::from_fn(|i| u32_to_bits_le(state[2][i] ^ input[16 + i]));\r\n    row.outputs[3] = array::from_fn(|i| u32_to_bits_le(state[3][i] ^ input[20 + i]));\r\n}\r\n\r\nfn generate_trace_row_for_round\u003cF: PrimeField64\u003e(\r\n    round_data: \u0026mut FullRound\u003cF\u003e,\r\n    state: \u0026mut [[u32; 4]; 4],\r\n    m_vec: \u0026[u32; 16],\r\n) {\r\n    // We populate the round_data as we iterate through and compute the permutation following the reference implementation.\r\n\r\n    // We start by performing the first half of the four column quarter round functions.\r\n    (0..4).for_each(|i| {\r\n        (state[0][i], state[1][i], state[2][i], state[3][i]) = verifiable_half_round(\r\n            state[0][i],\r\n            state[1][i],\r\n            state[2][i],\r\n            state[3][i],\r\n            m_vec[2 * i],\r\n            false,\r\n        )\r\n    });\r\n\r\n    // After the first four operations we need to save a copy of the state into the trace.\r\n    save_state_to_trace(\u0026mut round_data.state_prime, state);\r\n\r\n    // Next we do the second half of the four column quarter round functions.\r\n    (0..4).for_each(|i| {\r\n        (state[0][i], state[1][i], state[2][i], state[3][i]) = verifiable_half_round(\r\n            state[0][i],\r\n            state[1][i],\r\n            state[2][i],\r\n            state[3][i],\r\n            m_vec[2 * i + 1],\r\n            true,\r\n        )\r\n    });\r\n\r\n    // Again we save another copy of the state.\r\n    save_state_to_trace(\u0026mut round_data.state_middle, state);\r\n\r\n    // We repeat with the diagonals quarter round function.\r\n\r\n    // Do the first half of the four diagonal quarter round functions.\r\n    (0..4).for_each(|i| {\r\n        (\r\n            state[0][i],\r\n            state[1][(i + 1) % 4],\r\n            state[2][(i + 2) % 4],\r\n            state[3][(i + 3) % 4],\r\n        ) = verifiable_half_round(\r\n            state[0][i],\r\n            state[1][(i + 1) % 4],\r\n            state[2][(i + 2) % 4],\r\n            state[3][(i + 3) % 4],\r\n            m_vec[8 + 2 * i],\r\n            false,\r\n        )\r\n    });\r\n\r\n    // Save a copy of the state to the trace.\r\n    save_state_to_trace(\u0026mut round_data.state_middle_prime, state);\r\n\r\n    // Do the second half of the four diagonal quarter round functions.\r\n    (0..4).for_each(|i| {\r\n        (\r\n            state[0][i],\r\n            state[1][(i + 1) % 4],\r\n            state[2][(i + 2) % 4],\r\n            state[3][(i + 3) % 4],\r\n        ) = verifiable_half_round(\r\n            state[0][i],\r\n            state[1][(i + 1) % 4],\r\n            state[2][(i + 2) % 4],\r\n            state[3][(i + 3) % 4],\r\n            m_vec[9 + 2 * i],\r\n            true,\r\n        )\r\n    });\r\n\r\n    // Save a copy of the state to the trace.\r\n    save_state_to_trace(\u0026mut round_data.state_output, state);\r\n}\r\n\r\n/// Perform half of a quarter round on the given elements.\r\n///\r\n/// The boolean flag, indicates if this is the first (false) or second (true) half round.\r\nfn verifiable_half_round(\r\n    mut a: u32,\r\n    mut b: u32,\r\n    mut c: u32,\r\n    mut d: u32,\r\n    m: u32,\r\n    flag: bool,\r\n) -\u003e (u32, u32, u32, u32) {\r\n    let (rot_1, rot_2) = if flag { (8, 7) } else { (16, 12) };\r\n\r\n    // The first summation:\r\n    a += b;\r\n    a += m;\r\n\r\n    // The first xor:\r\n    d = (d ^ a).rotate_right(rot_1);\r\n\r\n    // The second summation:\r\n    c += d;\r\n\r\n    // The second xor:\r\n    b = (b ^ c).rotate_right(rot_2);\r\n\r\n    (a, b, c, d)\r\n}\r\n\r\nfn save_state_to_trace\u003cR: PrimeCharacteristicRing\u003e(\r\n    trace: \u0026mut Blake3State\u003cR\u003e,\r\n    state: \u0026[[u32; 4]; 4],\r\n) {\r\n    trace.row0 = array::from_fn(|i| {\r\n        [\r\n            R::from_u16(state[0][i] as u16), // Store the bottom 16 bits packed.\r\n            R::from_u16((state[0][i] \u003e\u003e 16) as u16), // Store the top 16 bits packed.\r\n        ]\r\n    });\r\n    trace.row1 = array::from_fn(|i| u32_to_bits_le(state[1][i])); // Store all 32 bits unpacked.\r\n    trace.row2 = array::from_fn(|i| {\r\n        [\r\n            R::from_u16(state[2][i] as u16), // Store the bottom 16 bits packed.\r\n            R::from_u16((state[2][i] \u003e\u003e 16) as u16), // Store the top 16 bits packed.\r\n        ]\r\n    });\r\n    trace.row3 = array::from_fn(|i| u32_to_bits_le(state[3][i])); // Store all 32 bits unpacked.\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":118},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","blake3-air","src","lib.rs"],"content":"//! An AIR for the Blake-3 permutation. Assumes the field size is between 2^20 and 2^32.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod air;\r\nmod columns;\r\nmod constants;\r\nmod generation;\r\n\r\npub use air::*;\r\npub use columns::*;\r\npub use generation::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","bn254-fr","benches","bench_field.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse p3_bn254_fr::Bn254Fr;\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_add_latency, benchmark_add_throughput, benchmark_inv, benchmark_iter_sum,\r\n    benchmark_sub_latency, benchmark_sub_throughput,\r\n};\r\n\r\ntype F = Bn254Fr;\r\n\r\nfn bench_field(c: \u0026mut Criterion) {\r\n    let name = \"BN254Fr\";\r\n    const REPS: usize = 1000;\r\n    benchmark_inv::\u003cF\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 4, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 8, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 12, REPS\u003e(c, name);\r\n\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const L_REPS: usize = 10 * REPS;\r\n    benchmark_add_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_add_throughput::\u003cF, REPS\u003e(c, name);\r\n    benchmark_sub_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_sub_throughput::\u003cF, REPS\u003e(c, name);\r\n}\r\n\r\ncriterion_group!(bn254fr_arithmetic, bench_field);\r\ncriterion_main!(bn254fr_arithmetic);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","bn254-fr","src","lib.rs"],"content":"//! The scalar field of the BN254 curve, defined as `F_r` where `r = 21888242871839275222246405745257275088548364400416034343698204186575808495617`.\r\n\r\nmod poseidon2;\r\n\r\nuse core::fmt::{Debug, Display, Formatter};\r\nuse core::hash::{Hash, Hasher};\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\nuse core::{fmt, stringify};\r\n\r\nuse ff::{Field as FFField, PrimeField as FFPrimeField};\r\npub use halo2curves::bn256::Fr as FFBn254Fr;\r\nuse halo2curves::serde::SerdeObject;\r\nuse num_bigint::BigUint;\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{\r\n    quotient_map_small_int, Field, InjectiveMonomial, Packable, PrimeCharacteristicRing,\r\n    PrimeField, TwoAdicField,\r\n};\r\npub use poseidon2::Poseidon2Bn254;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::{Deserialize, Deserializer, Serialize};\r\n\r\n/// The BN254 curve scalar field prime, defined as `F_r` where `r = 21888242871839275222246405745257275088548364400416034343698204186575808495617`.\r\n#[derive(Copy, Clone, Default, Eq, PartialEq)]\r\npub struct Bn254Fr {\r\n    pub value: FFBn254Fr,\r\n}\r\n\r\nimpl Bn254Fr {\r\n    pub(crate) const fn new(value: FFBn254Fr) -\u003e Self {\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl Serialize for Bn254Fr {\r\n    /// Serializes to raw bytes, which are typically of the Montgomery representation of the field element.\r\n    // See https://github.com/privacy-scaling-explorations/halo2curves/blob/d34e9e46f7daacd194739455de3b356ca6c03206/derive/src/field/mod.rs#L493\r\n    fn serialize\u003cS: serde::Serializer\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e {\r\n        let bytes = self.value.to_raw_bytes();\r\n        serializer.serialize_bytes(\u0026bytes)\r\n    }\r\n}\r\n\r\nimpl\u003c'de\u003e Deserialize\u003c'de\u003e for Bn254Fr {\r\n    /// Deserializes from raw bytes, which are typically of the Montgomery representation of the field element.\r\n    /// Performs a check that the deserialized field element corresponds to a value less than the field modulus, and\r\n    /// returns error otherwise.\r\n    // See https://github.com/privacy-scaling-explorations/halo2curves/blob/d34e9e46f7daacd194739455de3b356ca6c03206/derive/src/field/mod.rs#L485\r\n    fn deserialize\u003cD: Deserializer\u003c'de\u003e\u003e(d: D) -\u003e Result\u003cSelf, D::Error\u003e {\r\n        let bytes: Vec\u003cu8\u003e = Deserialize::deserialize(d)?;\r\n\r\n        let value = FFBn254Fr::from_raw_bytes(\u0026bytes);\r\n\r\n        value\r\n            .map(Self::new)\r\n            .ok_or(serde::de::Error::custom(\"Invalid field element\"))\r\n    }\r\n}\r\n\r\nimpl Packable for Bn254Fr {}\r\n\r\nimpl Hash for Bn254Fr {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        for byte in self.value.to_repr().as_ref().iter() {\r\n            state.write_u8(*byte);\r\n        }\r\n    }\r\n}\r\n\r\nimpl Ord for Bn254Fr {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e core::cmp::Ordering {\r\n        self.value.cmp(\u0026other.value)\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Bn254Fr {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccore::cmp::Ordering\u003e {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\nimpl Display for Bn254Fr {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        \u003cFFBn254Fr as Debug\u003e::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl Debug for Bn254Fr {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Debug::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for Bn254Fr {\r\n    type PrimeSubfield = Self;\r\n\r\n    const ZERO: Self = Self::new(FFBn254Fr::ZERO);\r\n    const ONE: Self = Self::new(FFBn254Fr::ONE);\r\n    const TWO: Self = Self::new(FFBn254Fr::from_raw([2u64, 0, 0, 0]));\r\n\r\n    // r - 1 = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000000\r\n    const NEG_ONE: Self = Self::new(FFBn254Fr::from_raw([\r\n        0x43e1f593f0000000,\r\n        0x2833e84879b97091,\r\n        0xb85045b68181585d,\r\n        0x30644e72e131a029,\r\n    ]));\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f\r\n    }\r\n}\r\n\r\n/// Degree of the smallest permutation polynomial for BN254.\r\n///\r\n/// As p - 1 is divisible by 2 and 3 the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nimpl InjectiveMonomial\u003c5\u003e for Bn254Fr {}\r\n\r\n// TODO: Implement PermutationMonomial\u003c5\u003e for Bn254Fr.\r\n// Not a priority given how slow (and unused) this will be.\r\n\r\nimpl Field for Bn254Fr {\r\n    type Packing = Self;\r\n\r\n    // generator is 5\r\n    const GENERATOR: Self = Self::new(FFBn254Fr::from_raw([5u64, 0, 0, 0]));\r\n\r\n    fn is_zero(\u0026self) -\u003e bool {\r\n        self.value.is_zero().into()\r\n    }\r\n\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\r\n        let inverse = self.value.invert();\r\n\r\n        if inverse.is_some().into() {\r\n            Some(Self::new(inverse.unwrap()))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// r = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n    fn order() -\u003e BigUint {\r\n        BigUint::new(vec![\r\n            0xf0000001, 0x43e1f593, 0x79b97091, 0x2833e848, 0x8181585d, 0xb85045b6, 0xe131a029,\r\n            0x30644e72,\r\n        ])\r\n    }\r\n\r\n    fn multiplicative_group_factors() -\u003e Vec\u003c(BigUint, usize)\u003e {\r\n        vec![\r\n            (BigUint::from(2u8), 28),\r\n            (BigUint::from(3u8), 2),\r\n            (BigUint::from(13u8), 1),\r\n            (BigUint::from(29u8), 1),\r\n            (BigUint::from(983u16), 1),\r\n            (BigUint::from(11003u16), 1),\r\n            (BigUint::from(237073u32), 1),\r\n            (BigUint::from(405928799u32), 1),\r\n            (BigUint::from(1670836401704629u64), 1),\r\n            (BigUint::from(13818364434197438864469338081u128), 1),\r\n        ]\r\n    }\r\n}\r\n\r\nquotient_map_small_int!(Bn254Fr, u128, [u8, u16, u32, u64]);\r\nquotient_map_small_int!(Bn254Fr, i128, [i8, i16, i32, i64]);\r\n\r\nimpl QuotientMap\u003cu128\u003e for Bn254Fr {\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    fn from_int(int: u128) -\u003e Bn254Fr {\r\n        Self::new(FFBn254Fr::from_raw([int as u64, (int \u003e\u003e 64) as u64, 0, 0]))\r\n    }\r\n\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    fn from_canonical_checked(int: u128) -\u003e Option\u003cBn254Fr\u003e {\r\n        Some(Self::from_int(int))\r\n    }\r\n\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    unsafe fn from_canonical_unchecked(int: u128) -\u003e Bn254Fr {\r\n        Self::from_int(int)\r\n    }\r\n}\r\n\r\nimpl QuotientMap\u003ci128\u003e for Bn254Fr {\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    fn from_int(int: i128) -\u003e Bn254Fr {\r\n        // Nothing better than just branching based on the sign of int.\r\n        if int \u003e= 0 {\r\n            Self::from_int(int as u128)\r\n        } else {\r\n            -Self::from_int((-int) as u128)\r\n        }\r\n    }\r\n\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    fn from_canonical_checked(int: i128) -\u003e Option\u003cBn254Fr\u003e {\r\n        Some(Self::from_int(int))\r\n    }\r\n\r\n    /// Due to the size of the `BN254` prime, the input value is always canonical.\r\n    #[inline]\r\n    unsafe fn from_canonical_unchecked(int: i128) -\u003e Bn254Fr {\r\n        Self::from_int(int)\r\n    }\r\n}\r\n\r\nimpl PrimeField for Bn254Fr {\r\n    fn as_canonical_biguint(\u0026self) -\u003e BigUint {\r\n        let repr = self.value.to_repr();\r\n        let le_bytes = repr.as_ref();\r\n        BigUint::from_bytes_le(le_bytes)\r\n    }\r\n}\r\n\r\nimpl Add for Bn254Fr {\r\n    type Output = Self;\r\n\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        Self::new(self.value + rhs.value)\r\n    }\r\n}\r\n\r\nimpl AddAssign for Bn254Fr {\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        self.value += rhs.value;\r\n    }\r\n}\r\n\r\nimpl Sum for Bn254Fr {\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Sub for Bn254Fr {\r\n    type Output = Self;\r\n\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        Self::new(self.value.sub(rhs.value))\r\n    }\r\n}\r\n\r\nimpl SubAssign for Bn254Fr {\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        self.value -= rhs.value;\r\n    }\r\n}\r\n\r\nimpl Neg for Bn254Fr {\r\n    type Output = Self;\r\n\r\n    fn neg(self) -\u003e Self::Output {\r\n        self * Self::NEG_ONE\r\n    }\r\n}\r\n\r\nimpl Mul for Bn254Fr {\r\n    type Output = Self;\r\n\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        Self::new(self.value * rhs.value)\r\n    }\r\n}\r\n\r\nimpl MulAssign for Bn254Fr {\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        self.value *= rhs.value;\r\n    }\r\n}\r\n\r\nimpl Product for Bn254Fr {\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl Div for Bn254Fr {\r\n    type Output = Self;\r\n\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    fn div(self, rhs: Self) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cBn254Fr\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Bn254Fr {\r\n        Bn254Fr::new(FFBn254Fr::random(rng))\r\n    }\r\n}\r\n\r\nimpl TwoAdicField for Bn254Fr {\r\n    const TWO_ADICITY: usize = FFBn254Fr::S as usize;\r\n\r\n    fn two_adic_generator(bits: usize) -\u003e Self {\r\n        let mut omega = FFBn254Fr::ROOT_OF_UNITY;\r\n        for _ in bits..Self::TWO_ADICITY {\r\n            omega = omega.square();\r\n        }\r\n        Self::new(omega)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::{test_field, test_prime_field};\r\n\r\n    use super::*;\r\n\r\n    type F = Bn254Fr;\r\n\r\n    #[test]\r\n    fn test_bn254fr() {\r\n        let f = F::new(FFBn254Fr::from_u128(100));\r\n        assert_eq!(f.as_canonical_biguint(), BigUint::new(vec![100]));\r\n\r\n        let f = F::new(FFBn254Fr::from_str_vartime(\u0026F::order().to_str_radix(10)).unwrap());\r\n        assert!(f.is_zero());\r\n\r\n        // Generator check\r\n        let expected_multiplicative_group_generator = F::new(FFBn254Fr::from_u128(5));\r\n        assert_eq!(F::GENERATOR, expected_multiplicative_group_generator);\r\n        assert_eq!(F::GENERATOR.as_canonical_biguint(), BigUint::new(vec![5]));\r\n\r\n        let f_1 = F::ONE;\r\n        let f_2 = F::TWO;\r\n        let f_r_minus_1 = F::NEG_ONE;\r\n        let f_r_minus_2 = F::NEG_ONE + F::NEG_ONE;\r\n\r\n        let f_serialized = serde_json::to_string(\u0026f).unwrap();\r\n        let f_deserialized: F = serde_json::from_str(\u0026f_serialized).unwrap();\r\n        assert_eq!(f, f_deserialized);\r\n\r\n        let f_1_serialized = serde_json::to_string(\u0026f_1).unwrap();\r\n        let f_1_deserialized: F = serde_json::from_str(\u0026f_1_serialized).unwrap();\r\n        let f_1_serialized_again = serde_json::to_string(\u0026f_1_deserialized).unwrap();\r\n        let f_1_deserialized_again: F = serde_json::from_str(\u0026f_1_serialized_again).unwrap();\r\n        assert_eq!(f_1, f_1_deserialized);\r\n        assert_eq!(f_1, f_1_deserialized_again);\r\n\r\n        let f_2_serialized = serde_json::to_string(\u0026f_2).unwrap();\r\n        let f_2_deserialized: F = serde_json::from_str(\u0026f_2_serialized).unwrap();\r\n        assert_eq!(f_2, f_2_deserialized);\r\n\r\n        let f_r_minus_1_serialized = serde_json::to_string(\u0026f_r_minus_1).unwrap();\r\n        let f_r_minus_1_deserialized: F = serde_json::from_str(\u0026f_r_minus_1_serialized).unwrap();\r\n        assert_eq!(f_r_minus_1, f_r_minus_1_deserialized);\r\n\r\n        let f_r_minus_2_serialized = serde_json::to_string(\u0026f_r_minus_2).unwrap();\r\n        let f_r_minus_2_deserialized: F = serde_json::from_str(\u0026f_r_minus_2_serialized).unwrap();\r\n        assert_eq!(f_r_minus_2, f_r_minus_2_deserialized);\r\n    }\r\n\r\n    test_field!(crate::Bn254Fr);\r\n\r\n    test_prime_field!(crate::Bn254Fr);\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":10736581511651262467}},{"line":40,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":42,"address":[],"length":0,"stats":{"Line":432345564227567619}},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":52,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":15}},{"line":92,"address":[],"length":0,"stats":{"Line":15}},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":113,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":131,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":132,"address":[],"length":0,"stats":{"Line":16789419410837209088}},{"line":135,"address":[],"length":0,"stats":{"Line":17654110539292344323}},{"line":136,"address":[],"length":0,"stats":{"Line":17654110539292344323}},{"line":138,"address":[],"length":0,"stats":{"Line":17654110539292344323}},{"line":139,"address":[],"length":0,"stats":{"Line":17582052945254416387}},{"line":141,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":146,"address":[],"length":0,"stats":{"Line":144115188075855875}},{"line":147,"address":[],"length":0,"stats":{"Line":144115188075855875}},{"line":148,"address":[],"length":0,"stats":{"Line":144115188075855875}},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855875}},{"line":153,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":154,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":156,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":157,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":158,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":159,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":160,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":161,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":162,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":163,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":164,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":176,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":181,"address":[],"length":0,"stats":{"Line":504403158265495553}},{"line":182,"address":[],"length":0,"stats":{"Line":504403158265495553}},{"line":187,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":188,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":195,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":197,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":198,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":200,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":206,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":207,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":212,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":213,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":218,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":219,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":220,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":221,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":228,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":229,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":234,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":235,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":240,"address":[],"length":0,"stats":{"Line":4107282860161892352}},{"line":241,"address":[],"length":0,"stats":{"Line":16645304222761353216}},{"line":248,"address":[],"length":0,"stats":{"Line":432345564227567617}},{"line":249,"address":[],"length":0,"stats":{"Line":432345564227567617}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":263,"address":[],"length":0,"stats":{"Line":7638104968020361216}},{"line":270,"address":[],"length":0,"stats":{"Line":10016005571271983104}},{"line":271,"address":[],"length":0,"stats":{"Line":10016005571271983104}},{"line":276,"address":[],"length":0,"stats":{"Line":12105675798371893253}},{"line":277,"address":[],"length":0,"stats":{"Line":12105675798371893253}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":292,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":298,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":299,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":91},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","bn254-fr","src","poseidon2.rs"],"content":"//! Diffusion matrix for Bn254\r\n//!\r\n//! Reference: https://github.com/HorizenLabs/poseidon2/blob/main/plain_implementations/src/poseidon2/poseidon2_instance_bn256.rs\r\n\r\nuse std::sync::OnceLock;\r\n\r\nuse p3_field::PrimeCharacteristicRing;\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    internal_permute_state, matmul_internal, ExternalLayer, ExternalLayerConstants,\r\n    ExternalLayerConstructor, HLMDSMat4, InternalLayer, InternalLayerConstructor, Poseidon2,\r\n};\r\n\r\nuse crate::Bn254Fr;\r\n\r\n/// Degree of the chosen permutation polynomial for BN254, used as the Poseidon2 S-Box.\r\n///\r\n/// As p - 1 is divisible by 2 and 3 the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nconst BN254_S_BOX_DEGREE: u64 = 5;\r\n\r\n/// An implementation of the Poseidon2 hash function for the Bn254Fr field.\r\n///\r\n/// It acts on arrays of the form `[Bn254Fr; WIDTH]`.\r\npub type Poseidon2Bn254\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    Bn254Fr,\r\n    Poseidon2ExternalLayerBn254\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerBn254,\r\n    WIDTH,\r\n    BN254_S_BOX_DEGREE,\r\n\u003e;\r\n\r\n/// Currently we only support a single width for Poseidon2 BN254.\r\nconst BN254_WIDTH: usize = 3;\r\n\r\n#[inline]\r\nfn get_diffusion_matrix_3() -\u003e \u0026'static [Bn254Fr; 3] {\r\n    static MAT_DIAG3_M_1: OnceLock\u003c[Bn254Fr; 3]\u003e = OnceLock::new();\r\n    MAT_DIAG3_M_1.get_or_init(|| [Bn254Fr::ONE, Bn254Fr::ONE, Bn254Fr::TWO])\r\n}\r\n\r\n#[derive(Debug, Clone, Default)]\r\npub struct Poseidon2InternalLayerBn254 {\r\n    internal_constants: Vec\u003cBn254Fr\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cBn254Fr\u003e for Poseidon2InternalLayerBn254 {\r\n    fn new_from_constants(internal_constants: Vec\u003cBn254Fr\u003e) -\u003e Self {\r\n        Self { internal_constants }\r\n    }\r\n}\r\n\r\nimpl InternalLayer\u003cBn254Fr, BN254_WIDTH, BN254_S_BOX_DEGREE\u003e for Poseidon2InternalLayerBn254 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [Bn254Fr; BN254_WIDTH]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| matmul_internal(x, *get_diffusion_matrix_3()),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\npub type Poseidon2ExternalLayerBn254\u003cconst WIDTH: usize\u003e = ExternalLayerConstants\u003cBn254Fr, WIDTH\u003e;\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cBn254Fr, WIDTH\u003e\r\n    for Poseidon2ExternalLayerBn254\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cBn254Fr, WIDTH\u003e) -\u003e Self {\r\n        external_constants\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayer\u003cBn254Fr, WIDTH, BN254_S_BOX_DEGREE\u003e\r\n    for Poseidon2ExternalLayerBn254\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [Bn254Fr; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.get_initial_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026HLMDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [Bn254Fr; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.get_terminal_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026HLMDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use ff::PrimeField;\r\n    use p3_poseidon2::ExternalLayerConstants;\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n    use zkhash::ark_ff::{BigInteger, PrimeField as ark_PrimeField};\r\n    use zkhash::fields::bn256::FpBN256 as ark_FpBN256;\r\n    use zkhash::poseidon2::poseidon2::Poseidon2 as Poseidon2Ref;\r\n    use zkhash::poseidon2::poseidon2_instance_bn256::{POSEIDON2_BN256_PARAMS, RC3};\r\n\r\n    use super::*;\r\n    use crate::FFBn254Fr;\r\n\r\n    fn bn254_from_ark_ff(input: ark_FpBN256) -\u003e Bn254Fr {\r\n        let bytes = input.into_bigint().to_bytes_le();\r\n\r\n        let mut res = \u003cFFBn254Fr as PrimeField\u003e::Repr::default();\r\n\r\n        for (i, digit) in res.as_mut().iter_mut().enumerate() {\r\n            *digit = bytes[i];\r\n        }\r\n\r\n        let value = FFBn254Fr::from_repr(res);\r\n\r\n        if value.is_some().into() {\r\n            Bn254Fr {\r\n                value: value.unwrap(),\r\n            }\r\n        } else {\r\n            panic!(\"Invalid field element\")\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_poseidon2_bn254() {\r\n        const WIDTH: usize = 3;\r\n        const ROUNDS_F: usize = 8;\r\n        const ROUNDS_P: usize = 56;\r\n\r\n        type F = Bn254Fr;\r\n\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Poiseidon2 reference implementation from zkhash repo.\r\n        let poseidon2_ref = Poseidon2Ref::new(\u0026POSEIDON2_BN256_PARAMS);\r\n\r\n        // Copy over round constants from zkhash.\r\n        let mut round_constants: Vec\u003c[F; WIDTH]\u003e = RC3\r\n            .iter()\r\n            .map(|vec| {\r\n                vec.iter()\r\n                    .cloned()\r\n                    .map(bn254_from_ark_ff)\r\n                    .collect::\u003cVec\u003c_\u003e\u003e()\r\n                    .try_into()\r\n                    .unwrap()\r\n            })\r\n            .collect();\r\n\r\n        let internal_start = ROUNDS_F / 2;\r\n        let internal_end = (ROUNDS_F / 2) + ROUNDS_P;\r\n        let internal_round_constants = round_constants\r\n            .drain(internal_start..internal_end)\r\n            .map(|vec| vec[0])\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        let external_round_constants = ExternalLayerConstants::new(\r\n            round_constants[..(ROUNDS_F / 2)].to_vec(),\r\n            round_constants[(ROUNDS_F / 2)..].to_vec(),\r\n        );\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Poseidon2Bn254::new(external_round_constants, internal_round_constants);\r\n\r\n        // Generate random input and convert to both Goldilocks field formats.\r\n        let input_ark_ff = rng.gen::\u003c[ark_FpBN256; WIDTH]\u003e();\r\n        let input: [Bn254Fr; 3] = input_ark_ff\r\n            .iter()\r\n            .cloned()\r\n            .map(bn254_from_ark_ff)\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n\r\n        // Run reference implementation.\r\n        let output_ref = poseidon2_ref.permutation(\u0026input_ark_ff);\r\n\r\n        let expected: [F; WIDTH] = output_ref\r\n            .iter()\r\n            .cloned()\r\n            .map(bn254_from_ark_ff)\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n\r\n        // Run our implementation.\r\n        let mut output = input;\r\n        poseidon2.permute_mut(\u0026mut output);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":8142508126285856768}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":57,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":19,"coverable":20},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","duplex_challenger.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{Field, PrimeField64, Serializable};\r\nuse p3_symmetric::{CryptographicPermutation, Hash};\r\n\r\nuse crate::{CanObserve, CanSample, CanSampleBits, FieldChallenger};\r\n\r\n#[derive(Clone, Debug)]\r\npub struct DuplexChallenger\u003cF, P, const WIDTH: usize, const RATE: usize\u003e\r\nwhere\r\n    F: Clone,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    pub sponge_state: [F; WIDTH],\r\n    pub input_buffer: Vec\u003cF\u003e,\r\n    pub output_buffer: Vec\u003cF\u003e,\r\n    pub permutation: P,\r\n}\r\n\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Copy,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    pub fn new(permutation: P) -\u003e Self\r\n    where\r\n        F: Default,\r\n    {\r\n        Self {\r\n            sponge_state: [F::default(); WIDTH],\r\n            input_buffer: vec![],\r\n            output_buffer: vec![],\r\n            permutation,\r\n        }\r\n    }\r\n\r\n    fn duplexing(\u0026mut self) {\r\n        assert!(self.input_buffer.len() \u003c= RATE);\r\n\r\n        // Overwrite the first r elements with the inputs.\r\n        for (i, val) in self.input_buffer.drain(..).enumerate() {\r\n            self.sponge_state[i] = val;\r\n        }\r\n\r\n        // Apply the permutation.\r\n        self.permutation.permute_mut(\u0026mut self.sponge_state);\r\n\r\n        self.output_buffer.clear();\r\n        self.output_buffer.extend(\u0026self.sponge_state[..RATE]);\r\n    }\r\n}\r\n\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e FieldChallenger\u003cF\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n}\r\n\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cF\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Copy,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, value: F) {\r\n        // Any buffered output is now invalid.\r\n        self.output_buffer.clear();\r\n\r\n        self.input_buffer.push(value);\r\n\r\n        if self.input_buffer.len() == RATE {\r\n            self.duplexing();\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, P, const N: usize, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003c[F; N]\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Copy,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, values: [F; N]) {\r\n        for value in values {\r\n            self.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, P, const N: usize, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cHash\u003cF, F, N\u003e\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Copy,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, F, N\u003e) {\r\n        for value in values {\r\n            self.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\n// for TrivialPcs\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cVec\u003cVec\u003cF\u003e\u003e\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Copy,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, valuess: Vec\u003cVec\u003cF\u003e\u003e) {\r\n        for values in valuess {\r\n            for value in values {\r\n                self.observe(value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, P, const WIDTH: usize, const RATE: usize\u003e CanSample\u003cEF\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: Field,\r\n    EF: Serializable\u003cF\u003e,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn sample(\u0026mut self) -\u003e EF {\r\n        EF::deserialize_fn(|_| {\r\n            // If we have buffered inputs, we must perform a duplexing so that the challenge will\r\n            // reflect them. Or if we've run out of outputs, we must perform a duplexing to get more.\r\n            if !self.input_buffer.is_empty() || self.output_buffer.is_empty() {\r\n                self.duplexing();\r\n            }\r\n\r\n            self.output_buffer\r\n                .pop()\r\n                .expect(\"Output buffer should be non-empty\")\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e CanSampleBits\u003cusize\u003e\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e usize {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U64);\r\n        let rand_f: F = self.sample();\r\n        let rand_usize = rand_f.as_canonical_u64() as usize;\r\n        rand_usize \u0026 ((1 \u003c\u003c bits) - 1)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use core::iter;\r\n\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_goldilocks::Goldilocks;\r\n    use p3_symmetric::Permutation;\r\n\r\n    use super::*;\r\n    use crate::grinding_challenger::GrindingChallenger;\r\n\r\n    const WIDTH: usize = 24;\r\n    const RATE: usize = 16;\r\n\r\n    type G = Goldilocks;\r\n    type BB = BabyBear;\r\n\r\n    #[derive(Clone)]\r\n    struct TestPermutation {}\r\n\r\n    impl\u003cF: Clone\u003e Permutation\u003c[F; WIDTH]\u003e for TestPermutation {\r\n        fn permute_mut(\u0026self, input: \u0026mut [F; WIDTH]) {\r\n            input.reverse()\r\n        }\r\n    }\r\n\r\n    impl\u003cF: Clone\u003e CryptographicPermutation\u003c[F; WIDTH]\u003e for TestPermutation {}\r\n\r\n    #[test]\r\n    fn test_duplex_challenger() {\r\n        type Chal = DuplexChallenger\u003cG, TestPermutation, WIDTH, RATE\u003e;\r\n        let permutation = TestPermutation {};\r\n        let mut duplex_challenger = DuplexChallenger::new(permutation);\r\n\r\n        // Observe 12 elements.\r\n        (0..12).for_each(|element| duplex_challenger.observe(G::from_u8(element as u8)));\r\n\r\n        let state_after_duplexing: Vec\u003c_\u003e = iter::repeat(G::ZERO)\r\n            .take(12)\r\n            .chain((0..12).map(G::from_u8).rev())\r\n            .collect();\r\n\r\n        let expected_samples: Vec\u003cG\u003e = state_after_duplexing[..16].iter().copied().rev().collect();\r\n        let samples = \u003cChal as CanSample\u003cG\u003e\u003e::sample_vec(\u0026mut duplex_challenger, 16);\r\n        assert_eq!(samples, expected_samples);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_duplex_challenger_sample_bits_security() {\r\n        type GoldilocksChal = DuplexChallenger\u003cG, TestPermutation, WIDTH, RATE\u003e;\r\n        let permutation = TestPermutation {};\r\n        let mut duplex_challenger = GoldilocksChal::new(permutation);\r\n\r\n        for _ in 0..100 {\r\n            assert!(duplex_challenger.sample_bits(129) \u003c 4);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_duplex_challenger_sample_bits_security_small_field() {\r\n        type BabyBearChal = DuplexChallenger\u003cBB, TestPermutation, WIDTH, RATE\u003e;\r\n        let permutation = TestPermutation {};\r\n        let mut duplex_challenger = BabyBearChal::new(permutation);\r\n\r\n        for _ in 0..100 {\r\n            assert!(duplex_challenger.sample_bits(40) \u003c 1 \u003c\u003c 31);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_duplex_challenger_grind_security() {\r\n        type GoldilocksChal = DuplexChallenger\u003cG, TestPermutation, WIDTH, RATE\u003e;\r\n        let permutation = TestPermutation {};\r\n        let mut duplex_challenger = GoldilocksChal::new(permutation);\r\n\r\n        // This should cause sample_bits (and hence grind and check_witness) to\r\n        // panic. If bit sizes were not constrained correctly inside the\r\n        // challenger, (1 \u003c\u003c too_many_bits) would loop around, incorrectly\r\n        // grinding and accepting a 1-bit PoW.\r\n        let too_many_bits = usize::BITS as usize;\r\n\r\n        let witness = duplex_challenger.grind(too_many_bits);\r\n        assert!(duplex_challenger.check_witness(too_many_bits, witness));\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":31,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":32,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":33,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":38,"address":[],"length":0,"stats":{"Line":14339461213547659264}},{"line":39,"address":[],"length":0,"stats":{"Line":14339461213547659264}},{"line":42,"address":[],"length":0,"stats":{"Line":13330654897016668526}},{"line":43,"address":[],"length":0,"stats":{"Line":17942340915444056186}},{"line":47,"address":[],"length":0,"stats":{"Line":14339461213547659855}},{"line":49,"address":[],"length":0,"stats":{"Line":14339461213547659855}},{"line":50,"address":[],"length":0,"stats":{"Line":14339461213547659855}},{"line":68,"address":[],"length":0,"stats":{"Line":17942340915444056064}},{"line":70,"address":[],"length":0,"stats":{"Line":17942340915444056064}},{"line":72,"address":[],"length":0,"stats":{"Line":17942340915444056064}},{"line":74,"address":[],"length":0,"stats":{"Line":1801439850948198991}},{"line":75,"address":[],"length":0,"stats":{"Line":2305843009213694543}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":16573246628723425345}},{"line":100,"address":[],"length":0,"stats":{"Line":8502796096475496519}},{"line":101,"address":[],"length":0,"stats":{"Line":3458764513820540930}},{"line":113,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":114,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":115,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":4395513236313604547}},{"line":130,"address":[],"length":0,"stats":{"Line":12682136550675317209}},{"line":133,"address":[],"length":0,"stats":{"Line":9439544818968559676}},{"line":134,"address":[],"length":0,"stats":{"Line":12033618204333965278}},{"line":137,"address":[],"length":0,"stats":{"Line":8286623314361712606}},{"line":138,"address":[],"length":0,"stats":{"Line":8286623314361712606}},{"line":139,"address":[],"length":0,"stats":{"Line":8286623314361712606}},{"line":150,"address":[],"length":0,"stats":{"Line":4107282860161892418}},{"line":151,"address":[],"length":0,"stats":{"Line":4107282860161892418}},{"line":152,"address":[],"length":0,"stats":{"Line":4035225266123964475}},{"line":153,"address":[],"length":0,"stats":{"Line":3963167672086036539}},{"line":154,"address":[],"length":0,"stats":{"Line":3963167672086036539}},{"line":155,"address":[],"length":0,"stats":{"Line":3963167672086036539}}],"covered":35,"coverable":39},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","grinding_challenger.rs"],"content":"use p3_field::{Field, PrimeField, PrimeField32, PrimeField64};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_symmetric::CryptographicPermutation;\r\nuse tracing::instrument;\r\n\r\nuse crate::{CanObserve, CanSampleBits, DuplexChallenger, MultiField32Challenger};\r\n\r\npub trait GrindingChallenger:\r\n    CanObserve\u003cSelf::Witness\u003e + CanSampleBits\u003cusize\u003e + Sync + Clone\r\n{\r\n    type Witness: Field;\r\n\r\n    fn grind(\u0026mut self, bits: usize) -\u003e Self::Witness;\r\n\r\n    #[must_use]\r\n    fn check_witness(\u0026mut self, bits: usize, witness: Self::Witness) -\u003e bool {\r\n        self.observe(witness);\r\n        self.sample_bits(bits) == 0\r\n    }\r\n}\r\n\r\nimpl\u003cF, P, const WIDTH: usize, const RATE: usize\u003e GrindingChallenger\r\n    for DuplexChallenger\u003cF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    P: CryptographicPermutation\u003c[F; WIDTH]\u003e,\r\n{\r\n    type Witness = F;\r\n\r\n    #[instrument(name = \"grind for proof-of-work witness\", skip_all)]\r\n    fn grind(\u0026mut self, bits: usize) -\u003e Self::Witness {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U64);\r\n\r\n        let witness = (0..F::ORDER_U64)\r\n            .into_par_iter()\r\n            .map(|i| unsafe {\r\n                // i \u003c F::ORDER_U64 by construction so this is safe.\r\n                F::from_canonical_unchecked(i)\r\n            })\r\n            .find_any(|witness| self.clone().check_witness(bits, *witness))\r\n            .expect(\"failed to find witness\");\r\n        assert!(self.check_witness(bits, witness));\r\n        witness\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e GrindingChallenger\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    type Witness = F;\r\n\r\n    #[instrument(name = \"grind for proof-of-work witness\", skip_all)]\r\n    fn grind(\u0026mut self, bits: usize) -\u003e Self::Witness {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U32);\r\n        let witness = (0..F::ORDER_U32)\r\n            .into_par_iter()\r\n            .map(|i| unsafe {\r\n                // i \u003c F::ORDER_U32 by construction so this is safe.\r\n                F::from_canonical_unchecked(i)\r\n            })\r\n            .find_any(|witness| self.clone().check_witness(bits, *witness))\r\n            .expect(\"failed to find witness\");\r\n        assert!(self.check_witness(bits, witness));\r\n        witness\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":3314649325744685055}},{"line":17,"address":[],"length":0,"stats":{"Line":3314649325744685055}},{"line":18,"address":[],"length":0,"stats":{"Line":3314649325744685055}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":3963167672086036554}},{"line":39,"address":[],"length":0,"stats":{"Line":3963167672086036554}},{"line":41,"address":[],"length":0,"stats":{"Line":3963167672086036534}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":21},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","hash_challenger.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_symmetric::CryptographicHasher;\r\n\r\nuse crate::{CanObserve, CanSample};\r\n\r\n/// A generic challenger that uses a cryptographic hash function to generate challenges.\r\n#[derive(Clone, Debug)]\r\npub struct HashChallenger\u003cT, H, const OUT_LEN: usize\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; OUT_LEN]\u003e,\r\n{\r\n    /// Buffer to store observed values before hashing.\r\n    input_buffer: Vec\u003cT\u003e,\r\n    /// Buffer to store hashed output values, which are consumed when sampling.\r\n    output_buffer: Vec\u003cT\u003e,\r\n    /// The cryptographic hash function used for generating challenges.\r\n    hasher: H,\r\n}\r\n\r\nimpl\u003cT, H, const OUT_LEN: usize\u003e HashChallenger\u003cT, H, OUT_LEN\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; OUT_LEN]\u003e,\r\n{\r\n    pub fn new(initial_state: Vec\u003cT\u003e, hasher: H) -\u003e Self {\r\n        Self {\r\n            input_buffer: initial_state,\r\n            output_buffer: vec![],\r\n            hasher,\r\n        }\r\n    }\r\n\r\n    fn flush(\u0026mut self) {\r\n        let inputs = self.input_buffer.drain(..);\r\n        let output = self.hasher.hash_iter(inputs);\r\n\r\n        self.output_buffer = output.to_vec();\r\n\r\n        // Chaining values.\r\n        self.input_buffer.extend(output.to_vec());\r\n    }\r\n}\r\n\r\nimpl\u003cT, H, const OUT_LEN: usize\u003e CanObserve\u003cT\u003e for HashChallenger\u003cT, H, OUT_LEN\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; OUT_LEN]\u003e,\r\n{\r\n    fn observe(\u0026mut self, value: T) {\r\n        // Any buffered output is now invalid.\r\n        self.output_buffer.clear();\r\n\r\n        self.input_buffer.push(value);\r\n    }\r\n}\r\n\r\nimpl\u003cT, H, const N: usize, const OUT_LEN: usize\u003e CanObserve\u003c[T; N]\u003e\r\n    for HashChallenger\u003cT, H, OUT_LEN\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; OUT_LEN]\u003e,\r\n{\r\n    fn observe(\u0026mut self, values: [T; N]) {\r\n        for value in values {\r\n            self.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT, H, const OUT_LEN: usize\u003e CanSample\u003cT\u003e for HashChallenger\u003cT, H, OUT_LEN\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; OUT_LEN]\u003e,\r\n{\r\n    fn sample(\u0026mut self) -\u003e T {\r\n        if self.output_buffer.is_empty() {\r\n            self.flush();\r\n        }\r\n        self.output_buffer\r\n            .pop()\r\n            .expect(\"Output buffer should be non-empty\")\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_goldilocks::Goldilocks;\r\n\r\n    use super::*;\r\n\r\n    const OUT_LEN: usize = 2;\r\n    type F = Goldilocks;\r\n\r\n    #[derive(Clone)]\r\n    struct TestHasher {}\r\n\r\n    impl CryptographicHasher\u003cF, [F; OUT_LEN]\u003e for TestHasher {\r\n        /// A very simple hash iterator. From an input of type `IntoIterator\u003cItem = Goldilocks\u003e`,\r\n        /// it outputs the sum of its elements and its length (as a field element).\r\n        fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [F; OUT_LEN]\r\n        where\r\n            I: IntoIterator\u003cItem = F\u003e,\r\n        {\r\n            let (sum, len) = input\r\n                .into_iter()\r\n                .fold((F::ZERO, 0_usize), |(acc_sum, acc_len), f| {\r\n                    (acc_sum + f, acc_len + 1)\r\n                });\r\n            [sum, F::from_usize(len)]\r\n        }\r\n\r\n        /// A very simple slice hash iterator. From an input of type `IntoIterator\u003cItem = \u0026'a [Goldilocks]\u003e`,\r\n        /// it outputs the sum of its elements and its length (as a field element).\r\n        fn hash_iter_slices\u003c'a, I\u003e(\u0026self, input: I) -\u003e [F; OUT_LEN]\r\n        where\r\n            I: IntoIterator\u003cItem = \u0026'a [F]\u003e,\r\n            F: 'a,\r\n        {\r\n            let (sum, len) = input\r\n                .into_iter()\r\n                .fold((F::ZERO, 0_usize), |(acc_sum, acc_len), n| {\r\n                    (\r\n                        acc_sum + n.iter().fold(F::ZERO, |acc, f| acc + *f),\r\n                        acc_len + n.len(),\r\n                    )\r\n                });\r\n            [sum, F::from_usize(len)]\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_challenger() {\r\n        let initial_state = (1..11_u8).map(F::from_u8).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let test_hasher = TestHasher {};\r\n        let mut hash_challenger = HashChallenger::new(initial_state.clone(), test_hasher);\r\n\r\n        assert_eq!(hash_challenger.input_buffer, initial_state);\r\n        assert_eq!(hash_challenger.output_buffer, vec![]);\r\n\r\n        hash_challenger.flush();\r\n\r\n        let expected_sum = F::from_u8(55);\r\n        let expected_len = F::from_u8(10);\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![expected_sum, expected_len]\r\n        );\r\n        assert_eq!(\r\n            hash_challenger.output_buffer,\r\n            vec![expected_sum, expected_len]\r\n        );\r\n\r\n        let new_element = F::from_u8(11);\r\n        hash_challenger.observe(new_element);\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![expected_sum, expected_len, new_element]\r\n        );\r\n        assert_eq!(hash_challenger.output_buffer, vec![]);\r\n\r\n        let new_expected_len = 3;\r\n        let new_expected_sum = 76;\r\n\r\n        let new_element = hash_challenger.sample();\r\n        assert_eq!(new_element, F::from_u8(new_expected_len));\r\n        assert_eq!(\r\n            hash_challenger.output_buffer,\r\n            [F::from_u8(new_expected_sum)]\r\n        )\r\n    }\r\n\r\n    #[test]\r\n    fn test_hash_challenger_flush() {\r\n        let initial_state = (1..11_u8).map(F::from_u8).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let test_hasher = TestHasher {};\r\n        let mut hash_challenger = HashChallenger::new(initial_state.clone(), test_hasher);\r\n\r\n        // Sample twice to ensure flush happens\r\n        let first_sample = hash_challenger.sample();\r\n\r\n        let second_sample = hash_challenger.sample();\r\n\r\n        // Verify that the first sample is the length of 1..11, (i.e. 10).\r\n        assert_eq!(first_sample, F::from_u8(10));\r\n        //  Verify that the second sample is the sum of numbers from 1 to 10 (i.e. 55)\r\n        assert_eq!(second_sample, F::from_u8(55));\r\n\r\n        // Verify that the output buffer is now empty\r\n        assert!(hash_challenger.output_buffer.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_observe_single_value() {\r\n        let test_hasher = TestHasher {};\r\n        // Initial state non-empty\r\n        let mut hash_challenger = HashChallenger::new(vec![F::from_u8(123)], test_hasher);\r\n\r\n        // Observe a single value\r\n        let value = F::from_u8(42);\r\n        hash_challenger.observe(value);\r\n\r\n        // Check that the input buffer contains the initial and observed values\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![F::from_u8(123), F::from_u8(42)]\r\n        );\r\n        // Check that the output buffer is empty (clears after observation)\r\n        assert!(hash_challenger.output_buffer.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_observe_array() {\r\n        let test_hasher = TestHasher {};\r\n        // Initial state non-empty\r\n        let mut hash_challenger = HashChallenger::new(vec![F::from_u8(123)], test_hasher);\r\n\r\n        // Observe an array of values\r\n        let values = [F::from_u8(1), F::from_u8(2), F::from_u8(3)];\r\n        hash_challenger.observe(values);\r\n\r\n        // Check that the input buffer contains the values\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![F::from_u8(123), F::from_u8(1), F::from_u8(2), F::from_u8(3)]\r\n        );\r\n        // Check that the output buffer is empty (clears after observation)\r\n        assert!(hash_challenger.output_buffer.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_sample_output_buffer() {\r\n        let test_hasher = TestHasher {};\r\n        let initial_state = vec![F::from_u8(5), F::from_u8(10)];\r\n        let mut hash_challenger = HashChallenger::new(initial_state.clone(), test_hasher);\r\n\r\n        let sample = hash_challenger.sample();\r\n        // Verify that the sample is the length of the initial state\r\n        assert_eq!(sample, F::from_u8(2));\r\n        // Check that the output buffer contains the sum of the initial state\r\n        assert_eq!(hash_challenger.output_buffer, vec![F::from_u8(15)]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_flush_empty_buffer() {\r\n        let test_hasher = TestHasher {};\r\n        let mut hash_challenger = HashChallenger::new(vec![], test_hasher);\r\n\r\n        // Flush empty buffer\r\n        hash_challenger.flush();\r\n\r\n        // Check that the input and output buffers contain the sum and length of the empty buffer\r\n        assert_eq!(hash_challenger.input_buffer, vec![F::ZERO, F::ZERO]);\r\n        assert_eq!(hash_challenger.output_buffer, vec![F::ZERO, F::ZERO]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_flush_with_data() {\r\n        let test_hasher = TestHasher {};\r\n        // Initial state non-empty\r\n        let initial_state = vec![F::from_u8(1), F::from_u8(2)];\r\n        let mut hash_challenger = HashChallenger::new(initial_state.clone(), test_hasher);\r\n\r\n        hash_challenger.flush();\r\n\r\n        // Check that the input buffer contains the sum and length of the initial state\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![F::from_u8(3), F::from_u8(2)]\r\n        );\r\n        // Check that the output buffer contains the sum and length of the initial state\r\n        assert_eq!(\r\n            hash_challenger.output_buffer,\r\n            vec![F::from_u8(3), F::from_u8(2)]\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_sample_after_observe() {\r\n        let test_hasher = TestHasher {};\r\n        let initial_state = vec![F::from_u8(1), F::from_u8(2)];\r\n        let mut hash_challenger = HashChallenger::new(initial_state.clone(), test_hasher);\r\n\r\n        // Observe will clear the output buffer\r\n        hash_challenger.observe(F::from_u8(3));\r\n\r\n        // Verify that the output buffer is empty\r\n        assert!(hash_challenger.output_buffer.is_empty());\r\n\r\n        // Verify the new value is in the input buffer\r\n        assert_eq!(\r\n            hash_challenger.input_buffer,\r\n            vec![F::from_u8(1), F::from_u8(2), F::from_u8(3)]\r\n        );\r\n\r\n        let sample = hash_challenger.sample();\r\n\r\n        // Length of initial state + observed value\r\n        assert_eq!(sample, F::from_u8(3));\r\n    }\r\n\r\n    #[test]\r\n    fn test_sample_with_non_empty_output_buffer() {\r\n        let test_hasher = TestHasher {};\r\n        let mut hash_challenger = HashChallenger::new(vec![], test_hasher);\r\n\r\n        hash_challenger.output_buffer = vec![F::from_u8(42), F::from_u8(24)];\r\n\r\n        let sample = hash_challenger.sample();\r\n\r\n        // Sample will pop the last element from the output buffer\r\n        assert_eq!(sample, F::from_u8(24));\r\n\r\n        // Check that the output buffer is now one element shorter\r\n        assert_eq!(hash_challenger.output_buffer, vec![F::from_u8(42)]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_output_buffer_cleared_on_observe() {\r\n        let test_hasher = TestHasher {};\r\n        let mut hash_challenger = HashChallenger::new(vec![], test_hasher);\r\n\r\n        // Populate artificially the output buffer\r\n        hash_challenger.output_buffer.push(F::from_u8(42));\r\n\r\n        // Ensure the output buffer is populated\r\n        assert!(!hash_challenger.output_buffer.is_empty());\r\n\r\n        // Observe a new value\r\n        hash_challenger.observe(F::from_u8(3));\r\n\r\n        // Verify that the output buffer is cleared after observing\r\n        assert!(hash_challenger.output_buffer.is_empty());\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":1729382256910270532}},{"line":31,"address":[],"length":0,"stats":{"Line":1729382256910270532}},{"line":36,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":37,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":38,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":40,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":43,"address":[],"length":0,"stats":{"Line":12826251738751172608}},{"line":52,"address":[],"length":0,"stats":{"Line":7133701809754865722}},{"line":54,"address":[],"length":0,"stats":{"Line":7133701809754865722}},{"line":56,"address":[],"length":0,"stats":{"Line":7133701809754865722}},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":78,"address":[],"length":0,"stats":{"Line":9367487224930631738}},{"line":79,"address":[],"length":0,"stats":{"Line":3530822107858469196}},{"line":80,"address":[],"length":0,"stats":{"Line":12610078956637389074}},{"line":82,"address":[],"length":0,"stats":{"Line":9367487224930631738}}],"covered":17,"coverable":17},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","lib.rs"],"content":"//! Utilities for generating Fiat-Shamir challenges based on an IOP's transcript.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod duplex_challenger;\r\nmod grinding_challenger;\r\nmod hash_challenger;\r\nmod multi_field_challenger;\r\nmod serializing_challenger;\r\n\r\nuse alloc::vec::Vec;\r\nuse core::array;\r\n\r\npub use duplex_challenger::*;\r\npub use grinding_challenger::*;\r\npub use hash_challenger::*;\r\npub use multi_field_challenger::*;\r\nuse p3_field::{Field, Serializable};\r\npub use serializing_challenger::*;\r\n\r\npub trait CanObserve\u003cT\u003e {\r\n    fn observe(\u0026mut self, value: T);\r\n\r\n    fn observe_slice(\u0026mut self, values: \u0026[T])\r\n    where\r\n        T: Clone,\r\n    {\r\n        for value in values {\r\n            self.observe(value.clone());\r\n        }\r\n    }\r\n}\r\n\r\npub trait CanSample\u003cT\u003e {\r\n    fn sample(\u0026mut self) -\u003e T;\r\n\r\n    fn sample_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e [T; N] {\r\n        array::from_fn(|_| self.sample())\r\n    }\r\n\r\n    fn sample_vec(\u0026mut self, n: usize) -\u003e Vec\u003cT\u003e {\r\n        (0..n).map(|_| self.sample()).collect()\r\n    }\r\n}\r\n\r\npub trait CanSampleBits\u003cT\u003e {\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e T;\r\n}\r\n\r\npub trait FieldChallenger\u003cF: Field\u003e:\r\n    CanObserve\u003cF\u003e + CanSample\u003cF\u003e + CanSampleBits\u003cusize\u003e + Sync\r\n{\r\n    fn observe_algebra_element\u003cA: Serializable\u003cF\u003e\u003e(\u0026mut self, alg_elem: A) {\r\n        self.observe_slice(alg_elem.serialize_as_slice());\r\n    }\r\n\r\n    fn sample_algebra_element\u003cA: Serializable\u003cF\u003e\u003e(\u0026mut self) -\u003e A {\r\n        let vec = self.sample_vec(A::DIMENSION);\r\n        A::deserialize_slice(\u0026vec)\r\n    }\r\n}\r\n\r\nimpl\u003cC, T\u003e CanObserve\u003cT\u003e for \u0026mut C\r\nwhere\r\n    C: CanObserve\u003cT\u003e,\r\n{\r\n    #[inline(always)]\r\n    fn observe(\u0026mut self, value: T) {\r\n        (*self).observe(value)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn observe_slice(\u0026mut self, values: \u0026[T])\r\n    where\r\n        T: Clone,\r\n    {\r\n        (*self).observe_slice(values)\r\n    }\r\n}\r\n\r\nimpl\u003cC, T\u003e CanSample\u003cT\u003e for \u0026mut C\r\nwhere\r\n    C: CanSample\u003cT\u003e,\r\n{\r\n    #[inline(always)]\r\n    fn sample(\u0026mut self) -\u003e T {\r\n        (*self).sample()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn sample_array\u003cconst N: usize\u003e(\u0026mut self) -\u003e [T; N] {\r\n        (*self).sample_array()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn sample_vec(\u0026mut self, n: usize) -\u003e Vec\u003cT\u003e {\r\n        (*self).sample_vec(n)\r\n    }\r\n}\r\n\r\nimpl\u003cC, T\u003e CanSampleBits\u003cT\u003e for \u0026mut C\r\nwhere\r\n    C: CanSampleBits\u003cT\u003e,\r\n{\r\n    #[inline(always)]\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e T {\r\n        (*self).sample_bits(bits)\r\n    }\r\n}\r\n\r\nimpl\u003cC, F: Field\u003e FieldChallenger\u003cF\u003e for \u0026mut C\r\nwhere\r\n    C: FieldChallenger\u003cF\u003e,\r\n{\r\n    #[inline(always)]\r\n    fn observe_algebra_element\u003cEF: Serializable\u003cF\u003e\u003e(\u0026mut self, ext: EF) {\r\n        (*self).observe_algebra_element(ext)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn sample_algebra_element\u003cEF: Serializable\u003cF\u003e\u003e(\u0026mut self) -\u003e EF {\r\n        (*self).sample_algebra_element()\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":1152921504606847010}},{"line":30,"address":[],"length":0,"stats":{"Line":3674937295934324732}},{"line":31,"address":[],"length":0,"stats":{"Line":15276209936040722430}},{"line":39,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":40,"address":[],"length":0,"stats":{"Line":4179340454199820302}},{"line":43,"address":[],"length":0,"stats":{"Line":12538021362599460897}},{"line":44,"address":[],"length":0,"stats":{"Line":7926335344172073301}},{"line":55,"address":[],"length":0,"stats":{"Line":11529215046068469763}},{"line":56,"address":[],"length":0,"stats":{"Line":11529215046068469763}},{"line":59,"address":[],"length":0,"stats":{"Line":12465963768561532929}},{"line":60,"address":[],"length":0,"stats":{"Line":12465963768561532929}},{"line":61,"address":[],"length":0,"stats":{"Line":12465963768561532929}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":28},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","multi_field_challenger.rs"],"content":"use alloc::string::String;\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{reduce_32, split_32, Field, PrimeField, PrimeField32, Serializable};\r\nuse p3_symmetric::{CryptographicPermutation, Hash};\r\n\r\nuse crate::{CanObserve, CanSample, CanSampleBits, FieldChallenger};\r\n\r\n/// A challenger that operates natively on PF but produces challenges of F: PrimeField32.\r\n///\r\n/// Used for optimizing the cost of recursive proof verification of STARKs in SNARKs.\r\n///\r\n/// SAFETY: There are some bias complications with using this challenger. In particular,\r\n/// samples are actually random in [0, 2^64) and then reduced to be in F.\r\n#[derive(Clone, Debug)]\r\npub struct MultiField32Challenger\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: Field,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    sponge_state: [PF; WIDTH],\r\n    input_buffer: Vec\u003cF\u003e,\r\n    output_buffer: Vec\u003cF\u003e,\r\n    permutation: P,\r\n    num_f_elms: usize,\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: Field,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    pub fn new(permutation: P) -\u003e Result\u003cSelf, String\u003e {\r\n        if F::order() \u003e= PF::order() {\r\n            return Err(String::from(\"F::order() must be less than PF::order()\"));\r\n        }\r\n        let num_f_elms = PF::bits() / 64;\r\n        Ok(Self {\r\n            sponge_state: [PF::default(); WIDTH],\r\n            input_buffer: vec![],\r\n            output_buffer: vec![],\r\n            permutation,\r\n            num_f_elms,\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn duplexing(\u0026mut self) {\r\n        assert!(self.input_buffer.len() \u003c= self.num_f_elms * RATE);\r\n\r\n        for (i, f_chunk) in self.input_buffer.chunks(self.num_f_elms).enumerate() {\r\n            self.sponge_state[i] = reduce_32(f_chunk);\r\n        }\r\n        self.input_buffer.clear();\r\n\r\n        // Apply the permutation.\r\n        self.permutation.permute_mut(\u0026mut self.sponge_state);\r\n\r\n        self.output_buffer.clear();\r\n        for \u0026pf_val in self.sponge_state.iter() {\r\n            let f_vals = split_32(pf_val, self.num_f_elms);\r\n            for f_val in f_vals {\r\n                self.output_buffer.push(f_val);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e FieldChallenger\u003cF\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cF\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, value: F) {\r\n        // Any buffered output is now invalid.\r\n        self.output_buffer.clear();\r\n\r\n        self.input_buffer.push(value);\r\n\r\n        if self.input_buffer.len() == self.num_f_elms * RATE {\r\n            self.duplexing();\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const N: usize, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003c[F; N]\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, values: [F; N]) {\r\n        for value in values {\r\n            self.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const N: usize, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cHash\u003cF, PF, N\u003e\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, PF, N\u003e) {\r\n        for pf_val in values {\r\n            let f_vals: Vec\u003cF\u003e = split_32(pf_val, self.num_f_elms);\r\n            for f_val in f_vals {\r\n                self.observe(f_val);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// for TrivialPcs\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e CanObserve\u003cVec\u003cVec\u003cF\u003e\u003e\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn observe(\u0026mut self, valuess: Vec\u003cVec\u003cF\u003e\u003e) {\r\n        for values in valuess {\r\n            for value in values {\r\n                self.observe(value);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, PF, P, const WIDTH: usize, const RATE: usize\u003e CanSample\u003cEF\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    EF: Serializable\u003cF\u003e,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn sample(\u0026mut self) -\u003e EF {\r\n        EF::deserialize_fn(|_| {\r\n            // If we have buffered inputs, we must perform a duplexing so that the challenge will\r\n            // reflect them. Or if we've run out of outputs, we must perform a duplexing to get more.\r\n            if !self.input_buffer.is_empty() || self.output_buffer.is_empty() {\r\n                self.duplexing();\r\n            }\r\n\r\n            self.output_buffer\r\n                .pop()\r\n                .expect(\"Output buffer should be non-empty\")\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize\u003e CanSampleBits\u003cusize\u003e\r\n    for MultiField32Challenger\u003cF, PF, P, WIDTH, RATE\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e usize {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U32);\r\n        let rand_f: F = self.sample();\r\n        let rand_usize = rand_f.as_canonical_u32() as usize;\r\n        rand_usize \u0026 ((1 \u003c\u003c bits) - 1)\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":51},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","challenger","src","serializing_challenger.rs"],"content":"use alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse p3_field::{PrimeField32, PrimeField64, Serializable};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_symmetric::{CryptographicHasher, Hash};\r\nuse p3_util::log2_ceil_u64;\r\nuse tracing::instrument;\r\n\r\nuse crate::{\r\n    CanObserve, CanSample, CanSampleBits, FieldChallenger, GrindingChallenger, HashChallenger,\r\n};\r\n\r\n/// Given a challenger that can observe and sample bytes, produces a challenger that is able to\r\n/// sample and observe field elements of a `PrimeField32`.\r\n///\r\n/// **Observing**:\r\n/// -  Takes a field element will serialize it into a byte array and observe each byte.\r\n///\r\n/// **Sampling**:\r\n/// -  Samples a field element in a prime field of size `p` by sampling uniformly an element in the\r\n///    range (0..1 \u003c\u003c log_2(p)). This avoids modulo bias.\r\n#[derive(Clone, Debug)]\r\npub struct SerializingChallenger32\u003cF, Inner\u003e {\r\n    inner: Inner,\r\n    _marker: PhantomData\u003cF\u003e,\r\n}\r\n\r\n/// Given a challenger that can observe and sample bytes, produces a challenger that is able to\r\n/// sample and observe field elements of a `PrimeField64` field.\r\n///\r\n/// **Observing**:\r\n/// -  Takes a field element will serialize it into a byte array and observe each byte.\r\n///\r\n/// **Sampling**:\r\n/// -  Samples a field element in a prime field of size `p` by sampling uniformly an element in the\r\n///    range (0..1 \u003c\u003c log_2(p)). This avoids modulo bias.\r\n#[derive(Clone, Debug)]\r\npub struct SerializingChallenger64\u003cF, Inner\u003e {\r\n    inner: Inner,\r\n    _marker: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF: PrimeField32, Inner: CanObserve\u003cu8\u003e\u003e SerializingChallenger32\u003cF, Inner\u003e {\r\n    pub const fn new(inner: Inner) -\u003e Self {\r\n        Self {\r\n            inner,\r\n            _marker: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, H\u003e SerializingChallenger32\u003cF, HashChallenger\u003cu8, H, 32\u003e\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    H: CryptographicHasher\u003cu8, [u8; 32]\u003e,\r\n{\r\n    pub fn from_hasher(initial_state: Vec\u003cu8\u003e, hasher: H) -\u003e Self {\r\n        Self::new(HashChallenger::new(initial_state, hasher))\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField32, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cF\u003e for SerializingChallenger32\u003cF, Inner\u003e {\r\n    fn observe(\u0026mut self, value: F) {\r\n        self.inner\r\n            .observe_slice(\u0026value.to_unique_u32().to_le_bytes());\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField32, const N: usize, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cHash\u003cF, u8, N\u003e\u003e\r\n    for SerializingChallenger32\u003cF, Inner\u003e\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, u8, N\u003e) {\r\n        for value in values {\r\n            self.inner.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField32, const N: usize, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cHash\u003cF, u64, N\u003e\u003e\r\n    for SerializingChallenger32\u003cF, Inner\u003e\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, u64, N\u003e) {\r\n        for value in values {\r\n            self.inner.observe_slice(\u0026value.to_le_bytes());\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, Inner\u003e CanSample\u003cEF\u003e for SerializingChallenger32\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    EF: Serializable\u003cF\u003e,\r\n    Inner: CanSample\u003cu8\u003e,\r\n{\r\n    fn sample(\u0026mut self) -\u003e EF {\r\n        let modulus = F::ORDER_U32;\r\n        let log_size = log2_ceil_u64(F::ORDER_U64);\r\n        // We use u64 to avoid overflow in the case that log_size = 32.\r\n        let pow_of_two_bound = ((1u64 \u003c\u003c log_size) - 1) as u32;\r\n        // Perform rejection sampling over the uniform range (0..log2_ceil(p))\r\n        let sample_base = |inner: \u0026mut Inner| loop {\r\n            let value = u32::from_le_bytes(inner.sample_array());\r\n            let value = value \u0026 pow_of_two_bound;\r\n            if value \u003c modulus {\r\n                return unsafe {\r\n                    // This is safe as value \u003c F::ORDER_U32.\r\n                    F::from_canonical_unchecked(value)\r\n                };\r\n            }\r\n        };\r\n        EF::deserialize_fn(|_| sample_base(\u0026mut self.inner))\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e CanSampleBits\u003cusize\u003e for SerializingChallenger32\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    Inner: CanSample\u003cu8\u003e,\r\n{\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e usize {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        // Limiting the number of bits to the field size\r\n        assert!((1 \u003c\u003c bits) \u003c= F::ORDER_U64 as usize);\r\n        let rand_usize = u32::from_le_bytes(self.inner.sample_array()) as usize;\r\n        rand_usize \u0026 ((1 \u003c\u003c bits) - 1)\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e GrindingChallenger for SerializingChallenger32\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    Inner: CanSample\u003cu8\u003e + CanObserve\u003cu8\u003e + Clone + Send + Sync,\r\n{\r\n    type Witness = F;\r\n\r\n    #[instrument(name = \"grind for proof-of-work witness\", skip_all)]\r\n    fn grind(\u0026mut self, bits: usize) -\u003e Self::Witness {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U32);\r\n        let witness = (0..F::ORDER_U32)\r\n            .into_par_iter()\r\n            .map(|i| unsafe {\r\n                // i \u003c F::ORDER_U32 by construction so this is safe.\r\n                F::from_canonical_unchecked(i)\r\n            })\r\n            .find_any(|witness| self.clone().check_witness(bits, *witness))\r\n            .expect(\"failed to find witness\");\r\n        assert!(self.check_witness(bits, witness));\r\n        witness\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e FieldChallenger\u003cF\u003e for SerializingChallenger32\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    Inner: CanSample\u003cu8\u003e + CanObserve\u003cu8\u003e + Clone + Send + Sync,\r\n{\r\n}\r\n\r\nimpl\u003cF: PrimeField64, Inner: CanObserve\u003cu8\u003e\u003e SerializingChallenger64\u003cF, Inner\u003e {\r\n    pub const fn new(inner: Inner) -\u003e Self {\r\n        Self {\r\n            inner,\r\n            _marker: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, H\u003e SerializingChallenger64\u003cF, HashChallenger\u003cu8, H, 32\u003e\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    H: CryptographicHasher\u003cu8, [u8; 32]\u003e,\r\n{\r\n    pub fn from_hasher(initial_state: Vec\u003cu8\u003e, hasher: H) -\u003e Self {\r\n        Self::new(HashChallenger::new(initial_state, hasher))\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField64, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cF\u003e for SerializingChallenger64\u003cF, Inner\u003e {\r\n    fn observe(\u0026mut self, value: F) {\r\n        self.inner\r\n            .observe_slice(\u0026value.to_unique_u64().to_le_bytes());\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField64, const N: usize, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cHash\u003cF, u8, N\u003e\u003e\r\n    for SerializingChallenger64\u003cF, Inner\u003e\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, u8, N\u003e) {\r\n        for value in values {\r\n            self.inner.observe(value);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeField64, const N: usize, Inner: CanObserve\u003cu8\u003e\u003e CanObserve\u003cHash\u003cF, u64, N\u003e\u003e\r\n    for SerializingChallenger64\u003cF, Inner\u003e\r\n{\r\n    fn observe(\u0026mut self, values: Hash\u003cF, u64, N\u003e) {\r\n        for value in values {\r\n            self.inner.observe_slice(\u0026value.to_le_bytes());\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, Inner\u003e CanSample\u003cEF\u003e for SerializingChallenger64\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    EF: Serializable\u003cF\u003e,\r\n    Inner: CanSample\u003cu8\u003e,\r\n{\r\n    fn sample(\u0026mut self) -\u003e EF {\r\n        let modulus = F::ORDER_U64;\r\n        let log_size = log2_ceil_u64(F::ORDER_U64) as u32;\r\n        // We use u128 to avoid overflow in the case that log_size = 64.\r\n        let pow_of_two_bound = ((1u128 \u003c\u003c log_size) - 1) as u64;\r\n\r\n        // Perform rejection sampling over the uniform range (0..log2_ceil(p))\r\n        let sample_base = |inner: \u0026mut Inner| loop {\r\n            let value = u64::from_le_bytes(inner.sample_array());\r\n            let value = value \u0026 pow_of_two_bound;\r\n            if value \u003c modulus {\r\n                return unsafe {\r\n                    // This is safe as value \u003c F::ORDER_U64.\r\n                    F::from_canonical_unchecked(value)\r\n                };\r\n            }\r\n        };\r\n        EF::deserialize_fn(|_| sample_base(\u0026mut self.inner))\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e CanSampleBits\u003cusize\u003e for SerializingChallenger64\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    Inner: CanSample\u003cu8\u003e,\r\n{\r\n    fn sample_bits(\u0026mut self, bits: usize) -\u003e usize {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        // Limiting the number of bits to the field size\r\n        assert!((1 \u003c\u003c bits) \u003c= F::ORDER_U64 as usize);\r\n        let rand_usize = u64::from_le_bytes(self.inner.sample_array()) as usize;\r\n        rand_usize \u0026 ((1 \u003c\u003c bits) - 1)\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e GrindingChallenger for SerializingChallenger64\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    Inner: CanSample\u003cu8\u003e + CanObserve\u003cu8\u003e + Clone + Send + Sync,\r\n{\r\n    type Witness = F;\r\n\r\n    #[instrument(name = \"grind for proof-of-work witness\", skip_all)]\r\n    fn grind(\u0026mut self, bits: usize) -\u003e Self::Witness {\r\n        assert!(bits \u003c (usize::BITS as usize));\r\n        assert!((1 \u003c\u003c bits) \u003c F::ORDER_U64);\r\n        let witness = (0..F::ORDER_U64)\r\n            .into_par_iter()\r\n            .map(|i| unsafe {\r\n                // i \u003c F::ORDER_U64 by construction so this is safe.\r\n                F::from_canonical_unchecked(i)\r\n            })\r\n            .find_any(|witness| self.clone().check_witness(bits, *witness))\r\n            .expect(\"failed to find witness\");\r\n        assert!(self.check_witness(bits, witness));\r\n        witness\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e FieldChallenger\u003cF\u003e for SerializingChallenger64\u003cF, Inner\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    Inner: CanSample\u003cu8\u003e + CanObserve\u003cu8\u003e + Clone + Send + Sync,\r\n{\r\n}\r\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":58,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":64,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":65,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":66,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":73,"address":[],"length":0,"stats":{"Line":14267403619509731427}},{"line":74,"address":[],"length":0,"stats":{"Line":432345564227567721}},{"line":75,"address":[],"length":0,"stats":{"Line":13835058055282163714}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":2882303761517117528}},{"line":97,"address":[],"length":0,"stats":{"Line":2882303761517117528}},{"line":98,"address":[],"length":0,"stats":{"Line":2882303761517117528}},{"line":100,"address":[],"length":0,"stats":{"Line":2882303761517117528}},{"line":102,"address":[],"length":0,"stats":{"Line":6341068275337658470}},{"line":103,"address":[],"length":0,"stats":{"Line":3458764513820540950}},{"line":104,"address":[],"length":0,"stats":{"Line":3458764513820540950}},{"line":105,"address":[],"length":0,"stats":{"Line":3458764513820540950}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":3458764513820540942}},{"line":112,"address":[],"length":0,"stats":{"Line":9223372036854775984}},{"line":121,"address":[],"length":0,"stats":{"Line":12610078956637388808}},{"line":122,"address":[],"length":0,"stats":{"Line":12610078956637388808}},{"line":124,"address":[],"length":0,"stats":{"Line":12610078956637388858}},{"line":125,"address":[],"length":0,"stats":{"Line":12610078956637388858}},{"line":126,"address":[],"length":0,"stats":{"Line":12610078956637388858}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":13330654897016668168}},{"line":145,"address":[],"length":0,"stats":{"Line":13330654897016668168}},{"line":147,"address":[],"length":0,"stats":{"Line":13330654897016668214}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}}],"covered":27,"coverable":74},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","benches","cfft.rs"],"content":"use criterion::measurement::Measurement;\r\nuse criterion::{criterion_group, criterion_main, BenchmarkGroup, BenchmarkId, Criterion};\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_circle::{CircleDomain, CircleEvaluations};\r\nuse p3_dft::{Radix2Bowers, Radix2Dit, Radix2DitParallel, TwoAdicSubgroupDft};\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_util::pretty_name;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::thread_rng;\r\n\r\nfn bench_lde(c: \u0026mut Criterion) {\r\n    let log_n = 18;\r\n    let log_w = 8;\r\n\r\n    let mut g = c.benchmark_group(\"lde\");\r\n    g.sample_size(10);\r\n    lde_cfft(\u0026mut g, log_n, log_w);\r\n    lde_twoadic::\u003cBabyBear, Radix2Dit\u003c_\u003e, _\u003e(\u0026mut g, log_n, log_w);\r\n    lde_twoadic::\u003cBabyBear, Radix2DitParallel\u003c_\u003e, _\u003e(\u0026mut g, log_n, log_w);\r\n    lde_twoadic::\u003cBabyBear, Radix2Bowers, _\u003e(\u0026mut g, log_n, log_w);\r\n}\r\n\r\nfn lde_cfft\u003cM: Measurement\u003e(g: \u0026mut BenchmarkGroup\u003cM\u003e, log_n: usize, log_w: usize) {\r\n    type F = Mersenne31;\r\n    let m = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1 \u003c\u003c log_w);\r\n    g.bench_with_input(\r\n        BenchmarkId::new(\"Cfft\u003cM31\u003e\", format!(\"log_n={log_n},log_w={log_w}\")),\r\n        \u0026m,\r\n        |b, m| {\r\n            b.iter_batched(\r\n                || m.clone(),\r\n                |m| {\r\n                    let evals =\r\n                        CircleEvaluations::from_natural_order(CircleDomain::standard(log_n), m);\r\n                    evals.extrapolate(CircleDomain::standard(log_n + 1))\r\n                },\r\n                criterion::BatchSize::LargeInput,\r\n            )\r\n        },\r\n    );\r\n}\r\n\r\nfn lde_twoadic\u003cF: TwoAdicField, Dft: TwoAdicSubgroupDft\u003cF\u003e, M: Measurement\u003e(\r\n    g: \u0026mut BenchmarkGroup\u003cM\u003e,\r\n    log_n: usize,\r\n    log_w: usize,\r\n) where\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let m = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1 \u003c\u003c log_w);\r\n    g.bench_with_input(\r\n        BenchmarkId::new(\r\n            format!(\"{},{}\", pretty_name::\u003cF\u003e(), pretty_name::\u003cDft\u003e()),\r\n            format!(\"log_n={log_n},log_w={log_w}\"),\r\n        ),\r\n        \u0026(dft, m),\r\n        |b, (dft, m)| {\r\n            b.iter_batched(\r\n                || (dft.clone(), m.clone()),\r\n                |(dft, m)| dft.coset_lde_batch(m, 1, F::GENERATOR),\r\n                criterion::BatchSize::LargeInput,\r\n            )\r\n        },\r\n    );\r\n}\r\n\r\ncriterion_group!(benches, bench_lde);\r\ncriterion_main!(benches);\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":26},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","examples","lde.rs"],"content":"use std::hint::black_box;\r\nuse std::time::{Duration, Instant};\r\n\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_circle::{CircleDomain, CircleEvaluations};\r\nuse p3_dft::{Radix2DitParallel, TwoAdicSubgroupDft};\r\nuse p3_field::Field;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse rand::thread_rng;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\ntype F = Mersenne31;\r\n\r\nfn go\u003cM: Matrix\u003cF\u003e\u003e(evals: CircleEvaluations\u003cF, M\u003e, log_n: usize) -\u003e CircleEvaluations\u003cF\u003e {\r\n    evals.extrapolate(CircleDomain::standard(log_n))\r\n}\r\n\r\nfn main() {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    let mut args = std::env::args().skip(1);\r\n    let log_n = args.next().map(|s| s.parse().unwrap()).unwrap_or(16);\r\n    let log_w = args.next().map(|s| s.parse().unwrap()).unwrap_or(8);\r\n    println!(\"log_n={log_n}, log_w={log_w}\");\r\n\r\n    let m = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1 \u003c\u003c log_w);\r\n    let evals = CircleEvaluations::from_natural_order(CircleDomain::standard(log_n), m);\r\n\r\n    println!(\"warming up for 1s...\");\r\n    let t0 = Instant::now();\r\n    while Instant::now().duration_since(t0) \u003c Duration::from_secs(1) {\r\n        black_box(go(black_box(evals.clone()), log_n + 1));\r\n    }\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    black_box(go(black_box(evals), log_n + 1));\r\n\r\n    let m = RowMajorMatrix::\u003cBabyBear\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1 \u003c\u003c log_w);\r\n    black_box(Radix2DitParallel::default().coset_lde_batch(black_box(m), 1, BabyBear::GENERATOR));\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","cfft.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{iterate, izip, Itertools};\r\nuse p3_commit::PolynomialSpace;\r\nuse p3_dft::{divide_by_height, Butterfly, DifButterfly, DitButterfly};\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::{batch_multiplicative_inverse, ExtensionField, Field};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_ceil_usize, log2_strict_usize, reverse_slice_index_bits};\r\nuse tracing::{debug_span, instrument};\r\n\r\nuse crate::domain::CircleDomain;\r\nuse crate::point::{compute_lagrange_den_batched, Point};\r\nuse crate::{cfft_permute_index, cfft_permute_slice, CfftPermutable, CfftView};\r\n\r\n#[derive(Clone)]\r\npub struct CircleEvaluations\u003cF, M = RowMajorMatrix\u003cF\u003e\u003e {\r\n    pub(crate) domain: CircleDomain\u003cF\u003e,\r\n    pub(crate) values: M,\r\n}\r\n\r\nimpl\u003cF: Copy + Send + Sync, M: Matrix\u003cF\u003e\u003e CircleEvaluations\u003cF, M\u003e {\r\n    pub(crate) fn from_cfft_order(domain: CircleDomain\u003cF\u003e, values: M) -\u003e Self {\r\n        assert_eq!(1 \u003c\u003c domain.log_n, values.height());\r\n        Self { domain, values }\r\n    }\r\n    pub fn from_natural_order(\r\n        domain: CircleDomain\u003cF\u003e,\r\n        values: M,\r\n    ) -\u003e CircleEvaluations\u003cF, CfftView\u003cM\u003e\u003e {\r\n        CircleEvaluations::from_cfft_order(domain, values.cfft_perm_rows())\r\n    }\r\n    pub fn to_cfft_order(self) -\u003e M {\r\n        self.values\r\n    }\r\n    pub fn to_natural_order(self) -\u003e CfftView\u003cM\u003e {\r\n        self.values.cfft_perm_rows()\r\n    }\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable, M: Matrix\u003cF\u003e\u003e CircleEvaluations\u003cF, M\u003e {\r\n    #[instrument(skip_all, fields(dims = %self.values.dimensions()))]\r\n    pub fn interpolate(self) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let CircleEvaluations { domain, values } = self;\r\n        let mut values = debug_span!(\"to_rmm\").in_scope(|| values.to_row_major_matrix());\r\n\r\n        let mut twiddles = debug_span!(\"twiddles\").in_scope(|| {\r\n            compute_twiddles(domain)\r\n                .into_iter()\r\n                .map(|ts| {\r\n                    batch_multiplicative_inverse(\u0026ts)\r\n                        .into_iter()\r\n                        .map(|t| DifButterfly(t))\r\n                        .collect_vec()\r\n                })\r\n                .peekable()\r\n        });\r\n\r\n        assert_eq!(twiddles.len(), domain.log_n);\r\n\r\n        let par_twiddles = twiddles\r\n            .peeking_take_while(|ts| ts.len() \u003e= desired_num_jobs())\r\n            .collect_vec();\r\n        if let Some(min_blks) = par_twiddles.last().map(|ts| ts.len()) {\r\n            let max_blk_sz = values.height() / min_blks;\r\n            debug_span!(\"par_layers\", log_min_blks = log2_strict_usize(min_blks)).in_scope(|| {\r\n                values\r\n                    .par_row_chunks_exact_mut(max_blk_sz)\r\n                    .enumerate()\r\n                    .for_each(|(chunk_i, submat)| {\r\n                        for ts in \u0026par_twiddles {\r\n                            let twiddle_chunk_sz = ts.len() / min_blks;\r\n                            let twiddle_chunk = \u0026ts\r\n                                [(twiddle_chunk_sz * chunk_i)..(twiddle_chunk_sz * (chunk_i + 1))];\r\n                            serial_layer(submat.values, twiddle_chunk);\r\n                        }\r\n                    });\r\n            });\r\n        }\r\n\r\n        for ts in twiddles {\r\n            par_within_blk_layer(\u0026mut values.values, \u0026ts);\r\n        }\r\n\r\n        // TODO: omit this?\r\n        divide_by_height(\u0026mut values);\r\n        values\r\n    }\r\n\r\n    #[instrument(skip_all, fields(dims = %self.values.dimensions()))]\r\n    pub fn extrapolate(\r\n        self,\r\n        target_domain: CircleDomain\u003cF\u003e,\r\n    ) -\u003e CircleEvaluations\u003cF, RowMajorMatrix\u003cF\u003e\u003e {\r\n        assert!(target_domain.log_n \u003e= self.domain.log_n);\r\n        CircleEvaluations::\u003cF\u003e::evaluate(target_domain, self.interpolate())\r\n    }\r\n\r\n    pub fn evaluate_at_point\u003cEF: ExtensionField\u003cF\u003e\u003e(\u0026self, point: Point\u003cEF\u003e) -\u003e Vec\u003cEF\u003e {\r\n        // Compute z_H\r\n        let lagrange_num = self.domain.zeroifier(point);\r\n\r\n        // Permute the domain to get it into the right format.\r\n        let permuted_points = cfft_permute_slice(\u0026self.domain.points().collect_vec());\r\n\r\n        // Compute the lagrange denominators. This is batched as it lets us make use of batched_multiplicative_inverse.\r\n        let lagrange_den = compute_lagrange_den_batched(\u0026permuted_points, point, self.domain.log_n);\r\n\r\n        // The columnwise_dot_product here consumes about 5% of the runtime for example prove_poseidon2_m31_keccak.\r\n        // Definitely something worth optimising further.\r\n        self.values\r\n            .columnwise_dot_product(\u0026lagrange_den)\r\n            .into_iter()\r\n            .map(|x| x * lagrange_num)\r\n            .collect_vec()\r\n    }\r\n\r\n    #[cfg(test)]\r\n    pub(crate) fn dim(\u0026self) -\u003e usize\r\n    where\r\n        M: Clone,\r\n    {\r\n        let coeffs = self.clone().interpolate();\r\n        for (i, mut row) in coeffs.rows().enumerate() {\r\n            if row.all(|x| x.is_zero()) {\r\n                return i;\r\n            }\r\n        }\r\n        coeffs.height()\r\n    }\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e CircleEvaluations\u003cF, RowMajorMatrix\u003cF\u003e\u003e {\r\n    #[instrument(skip_all, fields(dims = %coeffs.dimensions()))]\r\n    pub fn evaluate(domain: CircleDomain\u003cF\u003e, mut coeffs: RowMajorMatrix\u003cF\u003e) -\u003e Self {\r\n        let log_n = log2_strict_usize(coeffs.height());\r\n        assert!(log_n \u003c= domain.log_n);\r\n\r\n        if log_n \u003c domain.log_n {\r\n            // We could simply pad coeffs like this:\r\n            // coeffs.pad_to_height(target_domain.size(), F::ZERO);\r\n            // But the first `added_bits` layers will simply fill out the zeros\r\n            // with the lower order values. (In `DitButterfly`, `x_2` is 0, so\r\n            // both `x_1` and `x_2` are set to `x_1`).\r\n            // So instead we directly repeat the coeffs and skip the initial layers.\r\n            debug_span!(\"extend coeffs\").in_scope(|| {\r\n                coeffs.values.reserve(domain.size() * coeffs.width());\r\n                for _ in log_n..domain.log_n {\r\n                    coeffs.values.extend_from_within(..);\r\n                }\r\n            });\r\n        }\r\n        assert_eq!(coeffs.height(), 1 \u003c\u003c domain.log_n);\r\n\r\n        let mut twiddles = debug_span!(\"twiddles\").in_scope(|| {\r\n            compute_twiddles(domain)\r\n                .into_iter()\r\n                .map(|ts| ts.into_iter().map(|t| DitButterfly(t)).collect_vec())\r\n                .rev()\r\n                .skip(domain.log_n - log_n)\r\n                .peekable()\r\n        });\r\n\r\n        for ts in twiddles.peeking_take_while(|ts| ts.len() \u003c desired_num_jobs()) {\r\n            par_within_blk_layer(\u0026mut coeffs.values, \u0026ts);\r\n        }\r\n\r\n        let par_twiddles = twiddles.collect_vec();\r\n        if let Some(min_blks) = par_twiddles.first().map(|ts| ts.len()) {\r\n            let max_blk_sz = coeffs.height() / min_blks;\r\n            debug_span!(\"par_layers\", log_min_blks = log2_strict_usize(min_blks)).in_scope(|| {\r\n                coeffs\r\n                    .par_row_chunks_exact_mut(max_blk_sz)\r\n                    .enumerate()\r\n                    .for_each(|(chunk_i, submat)| {\r\n                        for ts in \u0026par_twiddles {\r\n                            let twiddle_chunk_sz = ts.len() / min_blks;\r\n                            let twiddle_chunk = \u0026ts\r\n                                [(twiddle_chunk_sz * chunk_i)..(twiddle_chunk_sz * (chunk_i + 1))];\r\n                            serial_layer(submat.values, twiddle_chunk);\r\n                        }\r\n                    });\r\n            });\r\n        }\r\n\r\n        Self::from_cfft_order(domain, coeffs)\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn serial_layer\u003cF: Field, B: Butterfly\u003cF\u003e\u003e(values: \u0026mut [F], twiddles: \u0026[B]) {\r\n    let blk_sz = values.len() / twiddles.len();\r\n    for (\u0026t, blk) in izip!(twiddles, values.chunks_exact_mut(blk_sz)) {\r\n        let (lo, hi) = blk.split_at_mut(blk_sz / 2);\r\n        t.apply_to_rows(lo, hi);\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[instrument(level = \"debug\", skip_all, fields(log_blks = log2_strict_usize(twiddles.len())))]\r\nfn par_within_blk_layer\u003cF: Field, B: Butterfly\u003cF\u003e\u003e(values: \u0026mut [F], twiddles: \u0026[B]) {\r\n    let blk_sz = values.len() / twiddles.len();\r\n    for (\u0026t, blk) in izip!(twiddles, values.chunks_exact_mut(blk_sz)) {\r\n        let (lo, hi) = blk.split_at_mut(blk_sz / 2);\r\n        let job_sz = core::cmp::max(1, lo.len() \u003e\u003e log2_ceil_usize(desired_num_jobs()));\r\n        lo.par_chunks_mut(job_sz)\r\n            .zip(hi.par_chunks_mut(job_sz))\r\n            .for_each(|(lo_job, hi_job)| t.apply_to_rows(lo_job, hi_job));\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn desired_num_jobs() -\u003e usize {\r\n    16 * current_num_threads()\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e CircleDomain\u003cF\u003e {\r\n    pub(crate) fn y_twiddles(\u0026self) -\u003e Vec\u003cF\u003e {\r\n        let mut ys = self.coset0().map(|p| p.y).collect_vec();\r\n        reverse_slice_index_bits(\u0026mut ys);\r\n        ys\r\n    }\r\n    pub(crate) fn nth_y_twiddle(\u0026self, index: usize) -\u003e F {\r\n        self.nth_point(cfft_permute_index(index \u003c\u003c 1, self.log_n)).y\r\n    }\r\n    pub(crate) fn x_twiddles(\u0026self, layer: usize) -\u003e Vec\u003cF\u003e {\r\n        let gen = self.gen() * (1 \u003c\u003c layer);\r\n        let shift = self.shift * (1 \u003c\u003c layer);\r\n        let mut xs = iterate(shift, move |\u0026p| p + gen)\r\n            .map(|p| p.x)\r\n            .take(1 \u003c\u003c (self.log_n - layer - 2))\r\n            .collect_vec();\r\n        reverse_slice_index_bits(\u0026mut xs);\r\n        xs\r\n    }\r\n    pub(crate) fn nth_x_twiddle(\u0026self, index: usize) -\u003e F {\r\n        (self.shift + self.gen() * index).x\r\n    }\r\n}\r\n\r\nfn compute_twiddles\u003cF: ComplexExtendable\u003e(domain: CircleDomain\u003cF\u003e) -\u003e Vec\u003cVec\u003cF\u003e\u003e {\r\n    assert!(domain.log_n \u003e= 1);\r\n    let mut pts = domain.coset0().collect_vec();\r\n    reverse_slice_index_bits(\u0026mut pts);\r\n    let mut twiddles = vec![pts.iter().map(|p| p.y).collect_vec()];\r\n    if domain.log_n \u003e= 2 {\r\n        twiddles.push(pts.iter().step_by(2).map(|p| p.x).collect_vec());\r\n        for i in 0..(domain.log_n - 2) {\r\n            let prev = twiddles.last().unwrap();\r\n            assert_eq!(prev.len(), 1 \u003c\u003c (domain.log_n - 2 - i));\r\n            let cur = prev\r\n                .iter()\r\n                .step_by(2)\r\n                .map(|x| x.square().double() - F::ONE)\r\n                .collect_vec();\r\n            twiddles.push(cur);\r\n        }\r\n    }\r\n    twiddles\r\n}\r\n\r\npub fn circle_basis\u003cF: Field\u003e(p: Point\u003cF\u003e, log_n: usize) -\u003e Vec\u003cF\u003e {\r\n    let mut b = vec![F::ONE, p.y];\r\n    let mut x = p.x;\r\n    for _ in 0..(log_n - 1) {\r\n        for i in 0..b.len() {\r\n            b.push(b[i] * x);\r\n        }\r\n        x = x.square().double() - F::ONE;\r\n    }\r\n    assert_eq!(b.len(), 1 \u003c\u003c log_n);\r\n    b\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use itertools::iproduct;\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_mersenne_31::Mersenne31;\r\n    use rand::{random, thread_rng};\r\n\r\n    use super::*;\r\n\r\n    type F = Mersenne31;\r\n    type EF = BinomialExtensionField\u003cF, 3\u003e;\r\n\r\n    #[test]\r\n    fn test_cfft_icfft() {\r\n        for (log_n, width) in iproduct!(2..5, [1, 4, 11]) {\r\n            let shift = Point::generator(F::CIRCLE_TWO_ADICITY) * random();\r\n            let domain = CircleDomain::\u003cF\u003e::new(log_n, shift);\r\n            let trace = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, width);\r\n            let coeffs = CircleEvaluations::from_natural_order(domain, trace.clone()).interpolate();\r\n            assert_eq!(\r\n                CircleEvaluations::evaluate(domain, coeffs.clone())\r\n                    .to_natural_order()\r\n                    .to_row_major_matrix(),\r\n                trace,\r\n                \"icfft(cfft(evals)) is identity\",\r\n            );\r\n            for (i, pt) in domain.points().enumerate() {\r\n                assert_eq!(\r\n                    \u0026*trace.row_slice(i),\r\n                    coeffs.columnwise_dot_product(\u0026circle_basis(pt, log_n)),\r\n                    \"coeffs can be evaluated with circle_basis\",\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_extrapolation() {\r\n        for (log_n, log_blowup) in iproduct!(2..5, [1, 2, 3]) {\r\n            let evals = CircleEvaluations::\u003cF\u003e::from_natural_order(\r\n                CircleDomain::standard(log_n),\r\n                RowMajorMatrix::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 11),\r\n            );\r\n            let lde = evals\r\n                .clone()\r\n                .extrapolate(CircleDomain::standard(log_n + log_blowup));\r\n\r\n            let coeffs = evals.interpolate();\r\n            let lde_coeffs = lde.interpolate();\r\n\r\n            for r in 0..coeffs.height() {\r\n                assert_eq!(\u0026*coeffs.row_slice(r), \u0026*lde_coeffs.row_slice(r));\r\n            }\r\n            for r in coeffs.height()..lde_coeffs.height() {\r\n                assert!(lde_coeffs.row(r).all(|x| x.is_zero()));\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn eval_at_point_matches_cfft() {\r\n        for (log_n, width) in iproduct!(2..5, [1, 4, 11]) {\r\n            let evals = CircleEvaluations::\u003cF\u003e::from_natural_order(\r\n                CircleDomain::standard(log_n),\r\n                RowMajorMatrix::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, width),\r\n            );\r\n\r\n            let pt = Point::\u003cEF\u003e::from_projective_line(random());\r\n\r\n            assert_eq!(\r\n                evals.clone().evaluate_at_point(pt),\r\n                evals\r\n                    .interpolate()\r\n                    .columnwise_dot_product(\u0026circle_basis(pt, log_n))\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn eval_at_point_matches_lde() {\r\n        for (log_n, width, log_blowup) in iproduct!(2..8, [1, 4, 11], [1, 2]) {\r\n            let evals = CircleEvaluations::\u003cF\u003e::from_natural_order(\r\n                CircleDomain::standard(log_n),\r\n                RowMajorMatrix::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, width),\r\n            );\r\n            let lde = evals\r\n                .clone()\r\n                .extrapolate(CircleDomain::standard(log_n + log_blowup));\r\n            let zeta = Point::\u003cEF\u003e::from_projective_line(random());\r\n            assert_eq!(evals.evaluate_at_point(zeta), lde.evaluate_at_point(zeta));\r\n            assert_eq!(\r\n                evals.evaluate_at_point(zeta),\r\n                evals\r\n                    .interpolate()\r\n                    .columnwise_dot_product(\u0026circle_basis(zeta, log_n))\r\n            );\r\n            assert_eq!(\r\n                lde.evaluate_at_point(zeta),\r\n                lde.interpolate()\r\n                    .columnwise_dot_product(\u0026circle_basis(zeta, log_n + log_blowup))\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":15636497906230362126}},{"line":27,"address":[],"length":0,"stats":{"Line":15636497906230362126}},{"line":30,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":34,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":36,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":37,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":39,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":40,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":10664523917613334581}},{"line":50,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":51,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":52,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":53,"address":[],"length":0,"stats":{"Line":3242591731706757132}},{"line":54,"address":[],"length":0,"stats":{"Line":11024811887802974220}},{"line":55,"address":[],"length":0,"stats":{"Line":11024811887802974220}},{"line":56,"address":[],"length":0,"stats":{"Line":10952754293765046442}},{"line":57,"address":[],"length":0,"stats":{"Line":11024811887802974220}},{"line":59,"address":[],"length":0,"stats":{"Line":10664523917613334528}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":12033618204333965311}},{"line":67,"address":[],"length":0,"stats":{"Line":14267403619509731329}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":70,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":71,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":72,"address":[],"length":0,"stats":{"Line":14267403619509731328}},{"line":73,"address":[],"length":0,"stats":{"Line":16573246628723425283}},{"line":74,"address":[],"length":0,"stats":{"Line":14987979559889010716}},{"line":75,"address":[],"length":0,"stats":{"Line":3458764513820540938}},{"line":76,"address":[],"length":0,"stats":{"Line":3458764513820540938}},{"line":77,"address":[],"length":0,"stats":{"Line":3458764513820540938}},{"line":78,"address":[],"length":0,"stats":{"Line":3458764513820540938}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":104,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":107,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":110,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":114,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":115,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":117,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":122,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":126,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":127,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":128,"address":[],"length":0,"stats":{"Line":16933534598913064961}},{"line":129,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":18302628885633695747}},{"line":150,"address":[],"length":0,"stats":{"Line":18302628885633695747}},{"line":151,"address":[],"length":0,"stats":{"Line":9655717601082343427}},{"line":152,"address":[],"length":0,"stats":{"Line":9799832789158199296}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":159,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":160,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113784020}},{"line":162,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":163,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":164,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":167,"address":[],"length":0,"stats":{"Line":7133701809754865703}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":14771806777775226882}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":14771806777775226880}},{"line":175,"address":[],"length":0,"stats":{"Line":14771806777775226880}},{"line":176,"address":[],"length":0,"stats":{"Line":14771806777775226880}},{"line":177,"address":[],"length":0,"stats":{"Line":14771806777775226880}},{"line":178,"address":[],"length":0,"stats":{"Line":11313042263954685992}},{"line":179,"address":[],"length":0,"stats":{"Line":11529215046068469836}},{"line":180,"address":[],"length":0,"stats":{"Line":17293822569102704652}},{"line":181,"address":[],"length":0,"stats":{"Line":17293822569102704652}},{"line":182,"address":[],"length":0,"stats":{"Line":17293822569102704652}},{"line":183,"address":[],"length":0,"stats":{"Line":17293822569102704652}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":13835058055282163711}},{"line":195,"address":[],"length":0,"stats":{"Line":13835058055282163711}},{"line":196,"address":[],"length":0,"stats":{"Line":16140901064495857781}},{"line":197,"address":[],"length":0,"stats":{"Line":1152921504606847035}},{"line":198,"address":[],"length":0,"stats":{"Line":1152921504606847035}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":5188146770730811581}},{"line":216,"address":[],"length":0,"stats":{"Line":6701356245527298061}},{"line":217,"address":[],"length":0,"stats":{"Line":6701356245527298061}},{"line":221,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":222,"address":[],"length":0,"stats":{"Line":2449958197289549861}},{"line":223,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":224,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":226,"address":[],"length":0,"stats":{"Line":1297036692682702858}},{"line":227,"address":[],"length":0,"stats":{"Line":1297036692682702858}},{"line":229,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":230,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":231,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":232,"address":[],"length":0,"stats":{"Line":8791026472627208219}},{"line":233,"address":[],"length":0,"stats":{"Line":8791026472627208247}},{"line":234,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":236,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":237,"address":[],"length":0,"stats":{"Line":288230376151711755}},{"line":239,"address":[],"length":0,"stats":{"Line":12249790986447749120}},{"line":240,"address":[],"length":0,"stats":{"Line":12249790986447749120}},{"line":244,"address":[],"length":0,"stats":{"Line":11601272640106397728}},{"line":245,"address":[],"length":0,"stats":{"Line":11601272640106397728}},{"line":246,"address":[],"length":0,"stats":{"Line":11601272640106397698}},{"line":247,"address":[],"length":0,"stats":{"Line":11601272640106397698}},{"line":248,"address":[],"length":0,"stats":{"Line":10880696699727118429}},{"line":249,"address":[],"length":0,"stats":{"Line":11601272640106397698}},{"line":250,"address":[],"length":0,"stats":{"Line":16501189034685497354}},{"line":251,"address":[],"length":0,"stats":{"Line":3530822107858468868}},{"line":252,"address":[],"length":0,"stats":{"Line":10592466323575406594}},{"line":253,"address":[],"length":0,"stats":{"Line":10592466323575406594}},{"line":254,"address":[],"length":0,"stats":{"Line":10592466323575406587}},{"line":257,"address":[],"length":0,"stats":{"Line":11385099857992614001}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":11601272640106397698}},{"line":265,"address":[],"length":0,"stats":{"Line":11889503016258109463}},{"line":266,"address":[],"length":0,"stats":{"Line":11889503016258109463}},{"line":267,"address":[],"length":0,"stats":{"Line":11889503016258109463}},{"line":268,"address":[],"length":0,"stats":{"Line":11889503016258109463}},{"line":269,"address":[],"length":0,"stats":{"Line":3746994889972252671}},{"line":270,"address":[],"length":0,"stats":{"Line":11096869481840902144}},{"line":272,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":274,"address":[],"length":0,"stats":{"Line":11889503016258109441}},{"line":275,"address":[],"length":0,"stats":{"Line":11889503016258109440}}],"covered":112,"coverable":140},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","deep_quotient.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::{batch_multiplicative_inverse, dot_product, ExtensionField};\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::log2_strict_usize;\r\nuse tracing::instrument;\r\n\r\nuse crate::domain::CircleDomain;\r\nuse crate::point::Point;\r\nuse crate::{cfft_permute_slice, CircleEvaluations};\r\n\r\n/// Compute numerator and denominator of the \"vanishing part\" of the DEEP quotient\r\n/// Section 6, Remark 21 of Circle Starks (page 30 of first edition PDF)\r\n/// Re(1/v_gamma) + alpha^L Im(1/v_gamma)\r\n/// (Other \"part\" is \\bar g - \\bar v_gamma)\r\npub(crate) fn deep_quotient_vanishing_part\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    x: Point\u003cF\u003e,\r\n    zeta: Point\u003cEF\u003e,\r\n    alpha_pow_width: EF,\r\n) -\u003e (EF, EF) {\r\n    let (re_v_zeta, im_v_zeta) = x.v_p(zeta);\r\n    (\r\n        re_v_zeta - alpha_pow_width * im_v_zeta,\r\n        re_v_zeta.square() + im_v_zeta.square(),\r\n    )\r\n}\r\n\r\npub(crate) fn deep_quotient_reduce_row\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    alpha: EF,\r\n    x: Point\u003cF\u003e,\r\n    zeta: Point\u003cEF\u003e,\r\n    ps_at_x: \u0026[F],\r\n    ps_at_zeta: \u0026[EF],\r\n) -\u003e EF {\r\n    let (vp_num, vp_denom) =\r\n        deep_quotient_vanishing_part(x, zeta, alpha.exp_u64(ps_at_x.len() as u64));\r\n    (vp_num / vp_denom)\r\n        * dot_product::\u003cEF, _, _\u003e(\r\n            alpha.powers(),\r\n            izip!(ps_at_x, ps_at_zeta).map(|(\u0026p_at_x, \u0026p_at_zeta)| -p_at_zeta + p_at_x),\r\n        )\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable, M: Matrix\u003cF\u003e\u003e CircleEvaluations\u003cF, M\u003e {\r\n    /// Same as `deep_quotient_reduce_row`, but reduces a whole matrix into a column, taking advantage of batch inverses.\r\n    #[instrument(skip_all, fields(dims = %self.values.dimensions()))]\r\n    pub(crate) fn deep_quotient_reduce\u003cEF: ExtensionField\u003cF\u003e\u003e(\r\n        \u0026self,\r\n        alpha: EF,\r\n        zeta: Point\u003cEF\u003e,\r\n        ps_at_zeta: \u0026[EF],\r\n    ) -\u003e Vec\u003cEF\u003e {\r\n        let alpha_pow_width = alpha.exp_u64(self.values.width() as u64);\r\n        let points = cfft_permute_slice(\u0026self.domain.points().collect_vec());\r\n        let (vp_nums, vp_denoms): (Vec\u003c_\u003e, Vec\u003c_\u003e) = points\r\n            .into_iter()\r\n            .map(|x| deep_quotient_vanishing_part(x, zeta, alpha_pow_width))\r\n            .unzip();\r\n        let vp_denom_invs = batch_multiplicative_inverse(\u0026vp_denoms);\r\n\r\n        let alpha_reduced_ps_at_zeta: EF = dot_product(alpha.powers(), ps_at_zeta.iter().copied());\r\n\r\n        self.values\r\n            .dot_ext_powers(alpha)\r\n            .zip(vp_nums.into_par_iter())\r\n            .zip(vp_denom_invs.into_par_iter())\r\n            .map(|((reduced_ps_at_x, vp_num), vp_denom_inv)| {\r\n                vp_num * vp_denom_inv * (reduced_ps_at_x - alpha_reduced_ps_at_zeta)\r\n            })\r\n            .collect()\r\n    }\r\n}\r\n\r\n/// Given evaluations over lde_domain, extract the multiple of the vanishing poly of orig_domain\r\n/// See Section 4.3, Lemma 6: \u003c v_n, f \u003e = 0 for any f in FFT space\r\n/// So, we find the \"error\" (a scalar multiple of v_n) and remove it\r\n/// |lde_domain| \u003e |orig_domain|\r\n#[instrument(skip_all, fields(bits = log2_strict_usize(lde.len())))]\r\npub fn extract_lambda\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    lde: \u0026mut [EF],\r\n    log_blowup: usize,\r\n) -\u003e EF {\r\n    let log_lde_size = log2_strict_usize(lde.len());\r\n    // let num_cosets = 1 \u003c\u003c (log_lde_size - orig_domain.log_n);\r\n\r\n    // v_n is constant on cosets of the same size as orig_domain, so we only have\r\n    // as many unique values as we have cosets.\r\n    let v_d_init = CircleDomain::\u003cF\u003e::standard(log_lde_size)\r\n        .points()\r\n        .take(1 \u003c\u003c log_blowup)\r\n        .map(|p| p.v_n(log_lde_size - log_blowup))\r\n        .collect_vec();\r\n\r\n    // The unique values are repeated over the rest of the domain like\r\n    // 0 1 2 .. n-1 n n n-1 .. 1 0 0 1 ..\r\n    let v_d = v_d_init\r\n        .iter()\r\n        .chain(v_d_init.iter().rev())\r\n        .cycle()\r\n        .copied();\r\n\r\n    // \u003c v_d, v_d \u003e\r\n    // This formula was determined experimentally...\r\n    let v_d_2 = F::TWO.exp_u64(log_lde_size as u64 - 1);\r\n\r\n    let v_d = v_d.take(lde.len()).collect_vec();\r\n    let v_d = cfft_permute_slice(\u0026v_d);\r\n\r\n    let lambda =\r\n        dot_product::\u003cEF, _, _\u003e(lde.iter().copied(), v_d.iter().copied()) * v_d_2.inverse();\r\n\r\n    for (y, v_x) in izip!(lde, v_d) {\r\n        *y -= lambda * v_x;\r\n    }\r\n\r\n    lambda\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use p3_mersenne_31::Mersenne31;\r\n    use rand::{random, thread_rng};\r\n\r\n    use super::*;\r\n\r\n    type F = Mersenne31;\r\n    type EF = BinomialExtensionField\u003cF, 3\u003e;\r\n\r\n    #[test]\r\n    fn reduce_row_same_as_reduce_matrix() {\r\n        let domain = CircleDomain::standard(5);\r\n        let evals = CircleEvaluations::from_cfft_order(\r\n            domain,\r\n            RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c domain.log_n, 1 \u003c\u003c 3),\r\n        );\r\n\r\n        let alpha: EF = random();\r\n        let zeta: Point\u003cEF\u003e = Point::from_projective_line(random());\r\n        let ps_at_zeta = evals.evaluate_at_point(zeta);\r\n\r\n        let mat_reduced = evals.deep_quotient_reduce(alpha, zeta, \u0026ps_at_zeta);\r\n        let row_reduced = evals\r\n            .to_natural_order()\r\n            .rows()\r\n            .zip(domain.points())\r\n            .map(|(ps_at_x, x)| {\r\n                deep_quotient_reduce_row(alpha, x, zeta, \u0026ps_at_x.collect_vec(), \u0026ps_at_zeta)\r\n            })\r\n            .collect_vec();\r\n        assert_eq!(cfft_permute_slice(\u0026mat_reduced), row_reduced);\r\n    }\r\n\r\n    #[test]\r\n    fn reduce_evaluations_low_degree() {\r\n        let log_n = 5;\r\n        let log_blowup = 1;\r\n        let evals = CircleEvaluations::from_cfft_order(\r\n            CircleDomain::standard(log_n),\r\n            RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1 \u003c\u003c 3),\r\n        );\r\n        let lde = evals\r\n            .clone()\r\n            .extrapolate(CircleDomain::standard(log_n + log_blowup));\r\n        assert!(lde.dim() \u003c= (1 \u003c\u003c log_n));\r\n\r\n        let alpha: EF = random();\r\n        let zeta: Point\u003cEF\u003e = Point::from_projective_line(random());\r\n\r\n        let ps_at_zeta = evals.evaluate_at_point(zeta);\r\n        let reduced0 = CircleEvaluations::\u003cF\u003e::from_cfft_order(\r\n            CircleDomain::standard(log_n + log_blowup),\r\n            RowMajorMatrix::new_col(lde.deep_quotient_reduce(alpha, zeta, \u0026ps_at_zeta))\r\n                .flatten_to_base(),\r\n        );\r\n        assert!(reduced0.dim() \u003c= (1 \u003c\u003c log_n) + 1);\r\n\r\n        let not_ps_at_zeta = evals.evaluate_at_point(zeta.double());\r\n        let reduced1 = CircleEvaluations::\u003cF\u003e::from_cfft_order(\r\n            CircleDomain::standard(log_n + log_blowup),\r\n            RowMajorMatrix::new_col(lde.deep_quotient_reduce(alpha, zeta, \u0026not_ps_at_zeta))\r\n                .flatten_to_base(),\r\n        );\r\n        assert!(reduced1.dim() \u003e (1 \u003c\u003c log_n) + 1);\r\n    }\r\n\r\n    #[test]\r\n    fn reduce_multiple_evaluations() {\r\n        let domain = CircleDomain::standard(5);\r\n        let lde_domain = CircleDomain::standard(8);\r\n\r\n        let alpha: EF = random();\r\n        let zeta: Point\u003cEF\u003e = Point::from_projective_line(random());\r\n\r\n        let mut alpha_offset = EF::ONE;\r\n        let mut ros = vec![EF::ZERO; 1 \u003c\u003c lde_domain.log_n];\r\n\r\n        for _ in 0..4 {\r\n            let evals = CircleEvaluations::from_cfft_order(\r\n                domain,\r\n                RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c domain.log_n, 1 \u003c\u003c 3),\r\n            );\r\n            let ps_at_zeta = evals.evaluate_at_point(zeta);\r\n            let lde = evals.extrapolate(lde_domain);\r\n            assert!(lde.dim() \u003c= (1 \u003c\u003c domain.log_n) + 1);\r\n            let mat_ros = lde.deep_quotient_reduce(alpha, zeta, \u0026ps_at_zeta);\r\n            for (ro, mat_ro) in izip!(\u0026mut ros, mat_ros) {\r\n                *ro += alpha_offset * mat_ro;\r\n            }\r\n            alpha_offset *= alpha.exp_u64(2 * lde.values.width() as u64);\r\n        }\r\n\r\n        let ros = CircleEvaluations::from_cfft_order(\r\n            lde_domain,\r\n            RowMajorMatrix::new_col(ros).flatten_to_base(),\r\n        );\r\n        assert!(ros.dim() \u003c= (1 \u003c\u003c domain.log_n) + 1);\r\n    }\r\n\r\n    #[test]\r\n    fn test_extract_lambda() {\r\n        let log_n = 5;\r\n        for log_blowup in [1, 2, 3] {\r\n            let mut coeffs = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), (1 \u003c\u003c log_n) + 1, 1);\r\n            coeffs.pad_to_height(1 \u003c\u003c (log_n + log_blowup), F::ZERO);\r\n\r\n            let domain = CircleDomain::standard(log_n + log_blowup);\r\n            let mut lde = CircleEvaluations::evaluate(domain, coeffs.clone()).values;\r\n\r\n            let lambda = extract_lambda(\u0026mut lde.values, log_blowup);\r\n            assert_eq!(lambda, coeffs.get(1 \u003c\u003c log_n, 0));\r\n\r\n            let coeffs2 =\r\n                CircleEvaluations::from_cfft_order(domain, RowMajorMatrix::new_col(lde.values))\r\n                    .interpolate()\r\n                    .values;\r\n            assert_eq!(\u0026coeffs2[..(1 \u003c\u003c log_n)], \u0026coeffs.values[..(1 \u003c\u003c log_n)]);\r\n            assert_eq!(lambda, coeffs.values[1 \u003c\u003c log_n]);\r\n            assert_eq!(coeffs2[1 \u003c\u003c log_n], F::ZERO);\r\n            assert_eq!(\r\n                \u0026coeffs2[(1 \u003c\u003c log_n) + 1..],\r\n                \u0026coeffs.values[(1 \u003c\u003c log_n) + 1..]\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":15132094747964866568}},{"line":24,"address":[],"length":0,"stats":{"Line":15132094747964866568}},{"line":26,"address":[],"length":0,"stats":{"Line":15132094747964866568}},{"line":27,"address":[],"length":0,"stats":{"Line":15132094747964866568}},{"line":31,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":38,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":39,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":40,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":41,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":42,"address":[],"length":0,"stats":{"Line":13402712491054596108}},{"line":43,"address":[],"length":0,"stats":{"Line":16285016252571713561}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":1729382256910270624}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":1729382256910270623}},{"line":71,"address":[],"length":0,"stats":{"Line":1729382256910270623}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":14123288431433875603}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":37},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","domain.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{iterate, Itertools};\r\nuse p3_commit::{LagrangeSelectors, PolynomialSpace};\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::ExtensionField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::{log2_ceil_usize, log2_strict_usize};\r\nuse tracing::instrument;\r\n\r\nuse crate::point::Point;\r\n\r\n/// A twin-coset of the circle group on F. It has a power-of-two size and an arbitrary shift.\r\n///\r\n/// X is generator, O is the first coset, goes counterclockwise\r\n/// ```text\r\n///   O X .\r\n///  .     .\r\n/// .       O \u003c- start = shift\r\n/// .   .   - (1,0)\r\n/// O       .\r\n///  .     .\r\n///   . . O\r\n/// ```\r\n///\r\n/// For ordering reasons, the other half will start at gen / shift:\r\n/// ```text\r\n///   . X O  \u003c- start = gen/shift\r\n///  .     .\r\n/// O       .\r\n/// .   .   - (1,0)\r\n/// .       O\r\n///  .     .\r\n///   O . .\r\n/// ```\r\n///\r\n/// The full domain is the interleaving of these two cosets\r\n#[derive(Copy, Clone, PartialEq, Eq, Debug)]\r\npub struct CircleDomain\u003cF\u003e {\r\n    // log_n corresponds to the log size of the WHOLE domain\r\n    pub(crate) log_n: usize,\r\n    pub(crate) shift: Point\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e CircleDomain\u003cF\u003e {\r\n    pub const fn new(log_n: usize, shift: Point\u003cF\u003e) -\u003e Self {\r\n        Self { log_n, shift }\r\n    }\r\n    pub fn standard(log_n: usize) -\u003e Self {\r\n        Self {\r\n            log_n,\r\n            shift: Point::generator(log_n + 1),\r\n        }\r\n    }\r\n    fn is_standard(\u0026self) -\u003e bool {\r\n        self.shift == Point::generator(self.log_n + 1)\r\n    }\r\n    pub(crate) fn gen(\u0026self) -\u003e Point\u003cF\u003e {\r\n        Point::generator(self.log_n - 1)\r\n    }\r\n    pub(crate) fn coset0(\u0026self) -\u003e impl Iterator\u003cItem = Point\u003cF\u003e\u003e {\r\n        let g = self.gen();\r\n        iterate(self.shift, move |\u0026p| p + g).take(1 \u003c\u003c (self.log_n - 1))\r\n    }\r\n    fn coset1(\u0026self) -\u003e impl Iterator\u003cItem = Point\u003cF\u003e\u003e {\r\n        let g = self.gen();\r\n        iterate(g - self.shift, move |\u0026p| p + g).take(1 \u003c\u003c (self.log_n - 1))\r\n    }\r\n    pub(crate) fn points(\u0026self) -\u003e impl Iterator\u003cItem = Point\u003cF\u003e\u003e {\r\n        self.coset0().interleave(self.coset1())\r\n    }\r\n    pub(crate) fn nth_point(\u0026self, idx: usize) -\u003e Point\u003cF\u003e {\r\n        let (idx, lsb) = (idx \u003e\u003e 1, idx \u0026 1);\r\n        if lsb == 0 {\r\n            self.shift + self.gen() * idx\r\n        } else {\r\n            -self.shift + self.gen() * (idx + 1)\r\n        }\r\n    }\r\n\r\n    pub(crate) fn zeroifier\u003cEF: ExtensionField\u003cF\u003e\u003e(\u0026self, at: Point\u003cEF\u003e) -\u003e EF {\r\n        at.v_n(self.log_n) - self.shift.v_n(self.log_n)\r\n    }\r\n\r\n    pub(crate) fn s_p\u003cEF: ExtensionField\u003cF\u003e\u003e(\u0026self, p: Point\u003cF\u003e, at: Point\u003cEF\u003e) -\u003e EF {\r\n        self.zeroifier(at) / p.v_tilde_p(at)\r\n    }\r\n\r\n    pub(crate) fn s_p_normalized\u003cEF: ExtensionField\u003cF\u003e\u003e(\u0026self, p: Point\u003cF\u003e, at: Point\u003cEF\u003e) -\u003e EF {\r\n        self.zeroifier(at) / (p.v_tilde_p(at) * p.s_p_at_p(self.log_n))\r\n    }\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e PolynomialSpace for CircleDomain\u003cF\u003e {\r\n    type Val = F;\r\n\r\n    fn size(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_n\r\n    }\r\n\r\n    fn first_point(\u0026self) -\u003e Self::Val {\r\n        self.shift.to_projective_line().unwrap()\r\n    }\r\n\r\n    fn next_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\u0026self, x: Ext) -\u003e Option\u003cExt\u003e {\r\n        // Only in standard position do we have an algebraic expression to access the next point.\r\n        if self.is_standard() {\r\n            (Point::from_projective_line(x) + Point::generator(self.log_n)).to_projective_line()\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    fn create_disjoint_domain(\u0026self, min_size: usize) -\u003e Self {\r\n        // Right now we simply guarantee the domain is disjoint by returning a\r\n        // larger standard position coset, which is fine because we always ask for a larger\r\n        // domain. If we wanted good performance for a disjoint domain of the same size,\r\n        // we could change the shift. Also we could support nonstandard twin cosets.\r\n        assert!(\r\n            self.is_standard(),\r\n            \"create_disjoint_domain not currently supported for nonstandard twin cosets\"\r\n        );\r\n        let log_n = log2_ceil_usize(min_size);\r\n        // Any standard position coset that is not the same size as us will be disjoint.\r\n        Self::standard(if log_n == self.log_n {\r\n            log_n + 1\r\n        } else {\r\n            log_n\r\n        })\r\n    }\r\n\r\n    /// Decompose a domain into disjoint twin-cosets.\r\n    fn split_domains(\u0026self, num_chunks: usize) -\u003e Vec\u003cSelf\u003e {\r\n        assert!(self.is_standard());\r\n        let log_chunks = log2_strict_usize(num_chunks);\r\n        self.points()\r\n            .take(num_chunks)\r\n            .map(|shift| CircleDomain {\r\n                log_n: self.log_n - log_chunks,\r\n                shift,\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn split_evals(\r\n        \u0026self,\r\n        num_chunks: usize,\r\n        evals: RowMajorMatrix\u003cSelf::Val\u003e,\r\n    ) -\u003e Vec\u003cRowMajorMatrix\u003cSelf::Val\u003e\u003e {\r\n        let log_chunks = log2_strict_usize(num_chunks);\r\n        assert!(evals.height() \u003e\u003e (log_chunks + 1) \u003e= 1);\r\n        let width = evals.width();\r\n        let mut values: Vec\u003cVec\u003cSelf::Val\u003e\u003e = vec![vec![]; num_chunks];\r\n        evals\r\n            .rows()\r\n            .enumerate()\r\n            .for_each(|(i, row)| values[forward_backward_index(i, num_chunks)].extend(row));\r\n        values\r\n            .into_iter()\r\n            .map(|v| RowMajorMatrix::new(v, width))\r\n            .collect()\r\n    }\r\n\r\n    fn zp_at_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\u0026self, point: Ext) -\u003e Ext {\r\n        self.zeroifier(Point::from_projective_line(point))\r\n    }\r\n\r\n    fn selectors_at_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\r\n        \u0026self,\r\n        point: Ext,\r\n    ) -\u003e LagrangeSelectors\u003cExt\u003e {\r\n        let point = Point::from_projective_line(point);\r\n        LagrangeSelectors {\r\n            is_first_row: self.s_p(self.shift, point),\r\n            is_last_row: self.s_p(-self.shift, point),\r\n            is_transition: Ext::ONE - self.s_p_normalized(-self.shift, point),\r\n            inv_zeroifier: self.zeroifier(point).inverse(),\r\n        }\r\n    }\r\n\r\n    /*\r\n    chunks=2:\r\n\r\n          1 . 1\r\n         .     .\r\n        0       0 \u003c-- start\r\n        .   .   - (1,0)\r\n        0       0\r\n         .     .\r\n          1 . 1\r\n\r\n\r\n    idx -\u003e which chunk to put it in:\r\n    chunks=2: 0 1 1 0 0 1 1 0 0 1 1 0 0 1 1 0\r\n    chunks=4: 0 1 2 3 3 2 1 0 0 1 2 3 3 2 1 0\r\n    */\r\n    // wow, really slow!\r\n    // todo: batch inverses\r\n    #[instrument(skip_all, fields(log_n = %coset.log_n))]\r\n    fn selectors_on_coset(\u0026self, coset: Self) -\u003e LagrangeSelectors\u003cVec\u003cSelf::Val\u003e\u003e {\r\n        let sels = coset\r\n            .points()\r\n            .map(|p| self.selectors_at_point(p.to_projective_line().unwrap()))\r\n            .collect_vec();\r\n        LagrangeSelectors {\r\n            is_first_row: sels.iter().map(|s| s.is_first_row).collect(),\r\n            is_last_row: sels.iter().map(|s| s.is_last_row).collect(),\r\n            is_transition: sels.iter().map(|s| s.is_transition).collect(),\r\n            inv_zeroifier: sels.iter().map(|s| s.inv_zeroifier).collect(),\r\n        }\r\n    }\r\n}\r\n\r\n// 0 1 2 .. len-1 len len len-1 .. 1 0 0 1 ..\r\nfn forward_backward_index(mut i: usize, len: usize) -\u003e usize {\r\n    i %= 2 * len;\r\n    if i \u003c len {\r\n        i\r\n    } else {\r\n        2 * len - 1 - i\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use core::iter;\r\n\r\n    use hashbrown::HashSet;\r\n    use itertools::izip;\r\n    use p3_field::{batch_multiplicative_inverse, PrimeCharacteristicRing};\r\n    use p3_mersenne_31::Mersenne31;\r\n    use rand::thread_rng;\r\n\r\n    use super::*;\r\n    use crate::CircleEvaluations;\r\n\r\n    fn assert_is_twin_coset\u003cF: ComplexExtendable\u003e(d: CircleDomain\u003cF\u003e) {\r\n        let pts = d.points().collect_vec();\r\n        let half_n = pts.len() \u003e\u003e 1;\r\n        for (\u0026l, \u0026r) in izip!(\u0026pts[..half_n], pts[half_n..].iter().rev()) {\r\n            assert_eq!(l, -r);\r\n        }\r\n    }\r\n\r\n    fn do_test_circle_domain(log_n: usize, width: usize) {\r\n        let n = 1 \u003c\u003c log_n;\r\n\r\n        type F = Mersenne31;\r\n        let d = CircleDomain::\u003cF\u003e::standard(log_n);\r\n\r\n        // we can move around the circle and end up where we started\r\n        let p0 = d.first_point();\r\n        let mut p1 = p0;\r\n        for i in 0..(n - 1) {\r\n            // nth_point is correct\r\n            assert_eq!(Point::from_projective_line(p1), d.nth_point(i));\r\n            p1 = d.next_point(p1).unwrap();\r\n            assert_ne!(p1, p0);\r\n        }\r\n        assert_eq!(d.next_point(p1).unwrap(), p0);\r\n\r\n        // .points() is the same as first_point -\u003e next_point\r\n        let mut uni_point = d.first_point();\r\n        for p in d.points() {\r\n            assert_eq!(Point::from_projective_line(uni_point), p);\r\n            uni_point = d.next_point(uni_point).unwrap();\r\n        }\r\n\r\n        // disjoint domain is actually disjoint, and large enough\r\n        let seen: HashSet\u003cPoint\u003cF\u003e\u003e = d.points().collect();\r\n        for disjoint_size in [10, 100, n - 5, n + 15] {\r\n            let dd = d.create_disjoint_domain(disjoint_size);\r\n            assert!(dd.size() \u003e= disjoint_size);\r\n            for pt in dd.points() {\r\n                assert!(!seen.contains(\u0026pt));\r\n            }\r\n        }\r\n\r\n        // zp is zero\r\n        for p in d.points() {\r\n            assert_eq!(d.zp_at_point(p.to_projective_line().unwrap()), F::ZERO);\r\n        }\r\n\r\n        // split domains\r\n        let evals = RowMajorMatrix::rand(\u0026mut thread_rng(), n, width);\r\n        let orig: Vec\u003c(Point\u003cF\u003e, Vec\u003cF\u003e)\u003e = d\r\n            .points()\r\n            .zip(evals.rows().map(|r| r.collect_vec()))\r\n            .collect();\r\n        for num_chunks in [1, 2, 4, 8] {\r\n            let mut combined = vec![];\r\n\r\n            let sds = d.split_domains(num_chunks);\r\n            assert_eq!(sds.len(), num_chunks);\r\n            let ses = d.split_evals(num_chunks, evals.clone());\r\n            assert_eq!(ses.len(), num_chunks);\r\n            for (sd, se) in izip!(sds, ses) {\r\n                // Split domains are twin cosets\r\n                assert_is_twin_coset(sd);\r\n                // Split domains have correct size wrt original domain\r\n                assert_eq!(sd.size() * num_chunks, d.size());\r\n                assert_eq!(se.width(), evals.width());\r\n                assert_eq!(se.height() * num_chunks, d.size());\r\n                combined.extend(sd.points().zip(se.rows().map(|r| r.collect_vec())));\r\n            }\r\n            // Union of split domains and evals is the original domain and evals\r\n            assert_eq!(\r\n                orig.iter().map(|x| x.0).collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                combined.iter().map(|x| x.0).collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                \"union of split domains is orig domain\"\r\n            );\r\n            assert_eq!(\r\n                orig.iter().map(|x| \u0026x.1).collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                combined.iter().map(|x| \u0026x.1).collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                \"union of split evals is orig evals\"\r\n            );\r\n            assert_eq!(\r\n                orig.iter().collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                combined.iter().collect::\u003cHashSet\u003c_\u003e\u003e(),\r\n                \"split domains and evals correspond to orig domains and evals\"\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn selectors() {\r\n        type F = Mersenne31;\r\n        let log_n = 8;\r\n        let n = 1 \u003c\u003c log_n;\r\n\r\n        let d = CircleDomain::\u003cF\u003e::standard(log_n);\r\n        let coset = d.create_disjoint_domain(n);\r\n        let sels = d.selectors_on_coset(coset);\r\n\r\n        // selectors_on_coset matches selectors_at_point\r\n        let mut pt = coset.first_point();\r\n        for i in 0..coset.size() {\r\n            let pt_sels = d.selectors_at_point(pt);\r\n            assert_eq!(sels.is_first_row[i], pt_sels.is_first_row);\r\n            assert_eq!(sels.is_last_row[i], pt_sels.is_last_row);\r\n            assert_eq!(sels.is_transition[i], pt_sels.is_transition);\r\n            assert_eq!(sels.inv_zeroifier[i], pt_sels.inv_zeroifier);\r\n            pt = coset.next_point(pt).unwrap();\r\n        }\r\n\r\n        let coset_to_d = |evals: \u0026[F]| {\r\n            let evals = CircleEvaluations::from_natural_order(\r\n                coset,\r\n                RowMajorMatrix::new_col(evals.to_vec()),\r\n            );\r\n            let coeffs = evals.interpolate().to_row_major_matrix();\r\n            let (lo, hi) = coeffs.split_rows(n);\r\n            assert_eq!(hi.values, vec![F::ZERO; n]);\r\n            CircleEvaluations::evaluate(d, lo.to_row_major_matrix())\r\n                .to_natural_order()\r\n                .to_row_major_matrix()\r\n                .values\r\n        };\r\n\r\n        // Nonzero at first point, zero everywhere else on domain\r\n        let is_first_row = coset_to_d(\u0026sels.is_first_row);\r\n        assert_ne!(is_first_row[0], F::ZERO);\r\n        assert_eq!(\u0026is_first_row[1..], \u0026vec![F::ZERO; n - 1]);\r\n\r\n        // Nonzero at last point, zero everywhere else on domain\r\n        let is_last_row = coset_to_d(\u0026sels.is_last_row);\r\n        assert_eq!(\u0026is_last_row[..n - 1], \u0026vec![F::ZERO; n - 1]);\r\n        assert_ne!(is_last_row[n - 1], F::ZERO);\r\n\r\n        // Nonzero everywhere on domain but last point\r\n        let is_transition = coset_to_d(\u0026sels.is_transition);\r\n        assert_ne!(\u0026is_transition[..n - 1], \u0026vec![F::ZERO; n - 1]);\r\n        assert_eq!(is_transition[n - 1], F::ZERO);\r\n\r\n        // Zeroifier coefficients look like [0.. (n times), 1, 0.. (n-1 times)]\r\n        let z_coeffs = CircleEvaluations::from_natural_order(\r\n            coset,\r\n            RowMajorMatrix::new_col(batch_multiplicative_inverse(\u0026sels.inv_zeroifier)),\r\n        )\r\n        .interpolate()\r\n        .to_row_major_matrix()\r\n        .values;\r\n        assert_eq!(\r\n            z_coeffs,\r\n            iter::empty()\r\n                .chain(iter::repeat(F::ZERO).take(n))\r\n                .chain(iter::once(F::ONE))\r\n                .chain(iter::repeat(F::ZERO).take(n - 1))\r\n                .collect_vec()\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_circle_domain() {\r\n        do_test_circle_domain(4, 8);\r\n        do_test_circle_domain(10, 32);\r\n    }\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":51,"address":[],"length":0,"stats":{"Line":16501189034685497346}},{"line":54,"address":[],"length":0,"stats":{"Line":16501189034685497346}},{"line":57,"address":[],"length":0,"stats":{"Line":4395513236313604097}},{"line":58,"address":[],"length":0,"stats":{"Line":4395513236313604097}},{"line":60,"address":[],"length":0,"stats":{"Line":11529215046068469894}},{"line":61,"address":[],"length":0,"stats":{"Line":11529215046068469894}},{"line":63,"address":[],"length":0,"stats":{"Line":7638104968020361260}},{"line":64,"address":[],"length":0,"stats":{"Line":7638104968020361260}},{"line":65,"address":[],"length":0,"stats":{"Line":6557241057451442266}},{"line":67,"address":[],"length":0,"stats":{"Line":3170534137668829310}},{"line":68,"address":[],"length":0,"stats":{"Line":3170534137668829310}},{"line":69,"address":[],"length":0,"stats":{"Line":11529215046068470312}},{"line":71,"address":[],"length":0,"stats":{"Line":3170534137668829254}},{"line":72,"address":[],"length":0,"stats":{"Line":3170534137668829254}},{"line":74,"address":[],"length":0,"stats":{"Line":6629298651489370148}},{"line":75,"address":[],"length":0,"stats":{"Line":6629298651489370148}},{"line":76,"address":[],"length":0,"stats":{"Line":6629298651489370148}},{"line":77,"address":[],"length":0,"stats":{"Line":18230571291595767831}},{"line":79,"address":[],"length":0,"stats":{"Line":6845471433603153933}},{"line":83,"address":[],"length":0,"stats":{"Line":9583660007044476042}},{"line":84,"address":[],"length":0,"stats":{"Line":9583660007044476042}},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711756}},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711756}},{"line":91,"address":[],"length":0,"stats":{"Line":144115188075855891}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855891}},{"line":99,"address":[],"length":0,"stats":{"Line":12754194144713244681}},{"line":100,"address":[],"length":0,"stats":{"Line":12754194144713244681}},{"line":103,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":104,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":107,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":109,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":110,"address":[],"length":0,"stats":{"Line":2594073385365405706}},{"line":112,"address":[],"length":0,"stats":{"Line":18446744073709551606}},{"line":116,"address":[],"length":0,"stats":{"Line":936748722493063178}},{"line":121,"address":[],"length":0,"stats":{"Line":936748722493063178}},{"line":122,"address":[],"length":0,"stats":{"Line":936748722493063178}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":125,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":127,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":128,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":135,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":136,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":137,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":138,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":139,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":140,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":141,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":142,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":147,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":152,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":153,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":154,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":155,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":159,"address":[],"length":0,"stats":{"Line":6052837899185946651}},{"line":160,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":162,"address":[],"length":0,"stats":{"Line":3891110078048108566}},{"line":166,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":167,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":174,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":176,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":177,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":179,"address":[],"length":0,"stats":{"Line":144115188075855882}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":8}},{"line":209,"address":[],"length":0,"stats":{"Line":8}},{"line":210,"address":[],"length":0,"stats":{"Line":8}},{"line":211,"address":[],"length":0,"stats":{"Line":8}},{"line":217,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":218,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":219,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":220,"address":[],"length":0,"stats":{"Line":2305843009213693974}},{"line":222,"address":[],"length":0,"stats":{"Line":2305843009213693930}}],"covered":76,"coverable":79},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","folding.rs"],"content":"use alloc::vec::Vec;\r\nuse core::fmt::Debug;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::Itertools;\r\nuse p3_commit::Mmcs;\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::{batch_multiplicative_inverse, ExtensionField};\r\nuse p3_fri::FriGenericConfig;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::{log2_strict_usize, reverse_bits_len};\r\n\r\nuse crate::domain::CircleDomain;\r\nuse crate::{CircleInputProof, InputError};\r\n\r\npub(crate) struct CircleFriGenericConfig\u003cF, InputProof, InputError\u003e(\r\n    pub(crate) PhantomData\u003c(F, InputProof, InputError)\u003e,\r\n);\r\n\r\npub(crate) type CircleFriConfig\u003cVal, Challenge, InputMmcs, FriMmcs\u003e = CircleFriGenericConfig\u003c\r\n    Val,\r\n    CircleInputProof\u003cVal, Challenge, InputMmcs, FriMmcs\u003e,\r\n    InputError\u003c\u003cInputMmcs as Mmcs\u003cVal\u003e\u003e::Error, \u003cFriMmcs as Mmcs\u003cChallenge\u003e\u003e::Error\u003e,\r\n\u003e;\r\n\r\nimpl\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e, InputProof, InputError: Debug\u003e\r\n    FriGenericConfig\u003cEF\u003e for CircleFriGenericConfig\u003cF, InputProof, InputError\u003e\r\n{\r\n    type InputProof = InputProof;\r\n    type InputError = InputError;\r\n\r\n    fn extra_query_index_bits(\u0026self) -\u003e usize {\r\n        1\r\n    }\r\n\r\n    fn fold_row(\r\n        \u0026self,\r\n        index: usize,\r\n        log_folded_height: usize,\r\n        beta: EF,\r\n        evals: impl Iterator\u003cItem = EF\u003e,\r\n    ) -\u003e EF {\r\n        fold_x_row(index, log_folded_height, beta, evals)\r\n    }\r\n\r\n    fn fold_matrix\u003cM: Matrix\u003cEF\u003e\u003e(\u0026self, beta: EF, m: M) -\u003e Vec\u003cEF\u003e {\r\n        fold_x(beta, m)\r\n    }\r\n}\r\n\r\nfn fold\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    evals: impl Matrix\u003cEF\u003e,\r\n    beta: EF,\r\n    twiddles: \u0026[F],\r\n) -\u003e Vec\u003cEF\u003e {\r\n    evals\r\n        .rows()\r\n        .zip(twiddles)\r\n        .map(|(mut row, \u0026t)| {\r\n            let (lo, hi) = row.next_tuple().unwrap();\r\n            let sum = lo + hi;\r\n            let diff = (lo - hi) * t;\r\n            (sum + beta * diff).halve()\r\n        })\r\n        .collect_vec()\r\n}\r\n\r\npub(crate) fn fold_y\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    beta: EF,\r\n    evals: impl Matrix\u003cEF\u003e,\r\n) -\u003e Vec\u003cEF\u003e {\r\n    assert_eq!(evals.width(), 2);\r\n    let log_n = log2_strict_usize(evals.height()) + 1;\r\n    fold(\r\n        evals,\r\n        beta,\r\n        \u0026batch_multiplicative_inverse(\u0026CircleDomain::standard(log_n).y_twiddles()),\r\n    )\r\n}\r\n\r\npub(crate) fn fold_y_row\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    index: usize,\r\n    log_folded_height: usize,\r\n    beta: EF,\r\n    evals: impl Iterator\u003cItem = EF\u003e,\r\n) -\u003e EF {\r\n    let evals = evals.collect_vec();\r\n    assert_eq!(evals.len(), 2);\r\n    let t = CircleDomain::\u003cF\u003e::standard(log_folded_height + 1)\r\n        .nth_y_twiddle(index)\r\n        .inverse();\r\n    let sum = evals[0] + evals[1];\r\n    let diff = (evals[0] - evals[1]) * t;\r\n    (sum + beta * diff).halve()\r\n}\r\n\r\npub(crate) fn fold_x\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    beta: EF,\r\n    evals: impl Matrix\u003cEF\u003e,\r\n) -\u003e Vec\u003cEF\u003e {\r\n    let log_n = log2_strict_usize(evals.width() * evals.height());\r\n    // +1 because twiddles after the first layer come from the x coordinates of the larger domain.\r\n    let domain = CircleDomain::standard(log_n + 1);\r\n    fold(\r\n        evals,\r\n        beta,\r\n        \u0026batch_multiplicative_inverse(\u0026domain.x_twiddles(0)),\r\n    )\r\n}\r\n\r\npub(crate) fn fold_x_row\u003cF: ComplexExtendable, EF: ExtensionField\u003cF\u003e\u003e(\r\n    index: usize,\r\n    log_folded_height: usize,\r\n    beta: EF,\r\n    evals: impl Iterator\u003cItem = EF\u003e,\r\n) -\u003e EF {\r\n    let evals = evals.collect_vec();\r\n    assert_eq!(evals.len(), 2);\r\n    let log_arity = log2_strict_usize(evals.len());\r\n\r\n    let t = CircleDomain::\u003cF\u003e::standard(log_folded_height + log_arity + 1)\r\n        .nth_x_twiddle(reverse_bits_len(index, log_folded_height))\r\n        .inverse();\r\n\r\n    let sum = evals[0] + evals[1];\r\n    let diff = (evals[0] - evals[1]) * t;\r\n    (sum + beta * diff).halve()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use itertools::iproduct;\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use p3_mersenne_31::Mersenne31;\r\n    use rand::{random, thread_rng};\r\n\r\n    use super::*;\r\n    use crate::CircleEvaluations;\r\n\r\n    type F = Mersenne31;\r\n    type EF = BinomialExtensionField\u003cF, 3\u003e;\r\n\r\n    #[test]\r\n    fn fold_matrix_same_as_row() {\r\n        let log_folded_height = 5;\r\n        let m = RowMajorMatrix::\u003cEF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_folded_height, 2);\r\n        let beta: EF = random();\r\n\r\n        let mat_y_folded = fold_y::\u003cF, EF\u003e(beta, m.as_view());\r\n        let row_y_folded = (0..(1 \u003c\u003c log_folded_height))\r\n            .map(|i| fold_y_row::\u003cF, EF\u003e(i, log_folded_height, beta, m.row(i)))\r\n            .collect_vec();\r\n        assert_eq!(mat_y_folded, row_y_folded);\r\n\r\n        let mat_x_folded = fold_x::\u003cF, EF\u003e(beta, m.as_view());\r\n        let row_x_folded = (0..(1 \u003c\u003c log_folded_height))\r\n            .map(|i| fold_x_row::\u003cF, EF\u003e(i, log_folded_height, beta, m.row(i)))\r\n            .collect_vec();\r\n        assert_eq!(mat_x_folded, row_x_folded);\r\n    }\r\n\r\n    #[test]\r\n    fn folded_matrix_remains_low_degree() {\r\n        let vec_dim = |evals: \u0026[F]| {\r\n            CircleEvaluations::from_cfft_order(\r\n                CircleDomain::standard(log2_strict_usize(evals.len())),\r\n                RowMajorMatrix::new_col(evals.to_vec()),\r\n            )\r\n            .dim()\r\n        };\r\n\r\n        for (log_n, log_blowup) in iproduct!(3..6, 1..4) {\r\n            let mut values = CircleEvaluations::evaluate(\r\n                CircleDomain::standard(log_n + log_blowup),\r\n                RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c log_n, 1),\r\n            )\r\n            .to_cfft_order()\r\n            .values;\r\n\r\n            values = fold_y(random(), RowMajorMatrix::new(values, 2));\r\n            assert_eq!(vec_dim(\u0026values), values.len() \u003e\u003e log_blowup);\r\n            for _ in 0..(log_n - 1) {\r\n                values = fold_x(random(), RowMajorMatrix::new(values, 2));\r\n                assert_eq!(vec_dim(\u0026values), values.len() \u003e\u003e log_blowup);\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1729382256910270548}},{"line":33,"address":[],"length":0,"stats":{"Line":1729382256910270548}},{"line":36,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":43,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":46,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":47,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":51,"address":[],"length":0,"stats":{"Line":11601272640106397701}},{"line":56,"address":[],"length":0,"stats":{"Line":11601272640106397701}},{"line":58,"address":[],"length":0,"stats":{"Line":11601272640106397701}},{"line":59,"address":[],"length":0,"stats":{"Line":15492382718154506254}},{"line":60,"address":[],"length":0,"stats":{"Line":3891110078048108553}},{"line":61,"address":[],"length":0,"stats":{"Line":3891110078048108553}},{"line":62,"address":[],"length":0,"stats":{"Line":3891110078048108553}},{"line":63,"address":[],"length":0,"stats":{"Line":3891110078048108553}},{"line":68,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":72,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":73,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":75,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":76,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":77,"address":[],"length":0,"stats":{"Line":11313042263954685952}},{"line":81,"address":[],"length":0,"stats":{"Line":1297036692682702858}},{"line":87,"address":[],"length":0,"stats":{"Line":1297036692682702858}},{"line":88,"address":[],"length":0,"stats":{"Line":1297036692682702858}},{"line":89,"address":[],"length":0,"stats":{"Line":1297036692682702853}},{"line":90,"address":[],"length":0,"stats":{"Line":1297036692682702853}},{"line":92,"address":[],"length":0,"stats":{"Line":1297036692682702853}},{"line":93,"address":[],"length":0,"stats":{"Line":1297036692682702853}},{"line":94,"address":[],"length":0,"stats":{"Line":1297036692682702853}},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":111,"address":[],"length":0,"stats":{"Line":12249790986447749138}},{"line":117,"address":[],"length":0,"stats":{"Line":12249790986447749138}},{"line":118,"address":[],"length":0,"stats":{"Line":12249790986447749138}},{"line":119,"address":[],"length":0,"stats":{"Line":12249790986447749130}},{"line":121,"address":[],"length":0,"stats":{"Line":12249790986447749130}},{"line":122,"address":[],"length":0,"stats":{"Line":12249790986447749130}},{"line":125,"address":[],"length":0,"stats":{"Line":12249790986447749130}},{"line":126,"address":[],"length":0,"stats":{"Line":12249790986447749130}},{"line":127,"address":[],"length":0,"stats":{"Line":12249790986447749130}}],"covered":43,"coverable":43},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","lib.rs"],"content":"//! A framework for operating over the unit circle of a finite field,\r\n//! following the [Circle STARKs paper](https://eprint.iacr.org/2024/278) by Habck, Levit and Papini.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod cfft;\r\nmod deep_quotient;\r\nmod domain;\r\nmod folding;\r\nmod ordering;\r\nmod pcs;\r\nmod point;\r\nmod proof;\r\nmod prover;\r\nmod verifier;\r\n\r\npub use cfft::*;\r\npub use domain::*;\r\npub use ordering::*;\r\npub use pcs::*;\r\npub use proof::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","ordering.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::row_index_mapped::{RowIndexMap, RowIndexMappedView};\r\nuse p3_matrix::Matrix;\r\nuse p3_util::{log2_strict_usize, reverse_bits_len};\r\n\r\n#[inline]\r\npub(crate) fn cfft_permute_index(index: usize, log_n: usize) -\u003e usize {\r\n    let (index, lsb) = (index \u003e\u003e 1, index \u0026 1);\r\n    reverse_bits_len(\r\n        if lsb == 0 {\r\n            index\r\n        } else {\r\n            (1 \u003c\u003c log_n) - index - 1\r\n        },\r\n        log_n,\r\n    )\r\n}\r\n\r\npub(crate) fn cfft_permute_slice\u003cT: Clone\u003e(xs: \u0026[T]) -\u003e Vec\u003cT\u003e {\r\n    let log_n = log2_strict_usize(xs.len());\r\n    (0..xs.len())\r\n        .map(|i| xs[cfft_permute_index(i, log_n)].clone())\r\n        .collect()\r\n}\r\n\r\npub(crate) fn cfft_permute_slice_chunked_in_place\u003cT\u003e(xs: \u0026mut [T], chunk_size: usize) {\r\n    assert_eq!(xs.len() % chunk_size, 0);\r\n    let n_chunks = xs.len() / chunk_size;\r\n    let log_n = log2_strict_usize(n_chunks);\r\n    for i in 0..n_chunks {\r\n        let j = cfft_permute_index(i, log_n);\r\n        if i \u003c j {\r\n            // somehow this is slightly faster than the unsafe block below\r\n            for k in 0..chunk_size {\r\n                xs.swap(i * chunk_size + k, j * chunk_size + k);\r\n            }\r\n            /*\r\n            unsafe {\r\n                core::ptr::swap_nonoverlapping(\r\n                    xs.as_mut_ptr().add(i * chunk_size),\r\n                    xs.as_mut_ptr().add(j * chunk_size),\r\n                    chunk_size,\r\n                );\r\n            }\r\n            */\r\n        }\r\n    }\r\n}\r\n\r\npub type CfftView\u003cM\u003e = RowIndexMappedView\u003cCfftPerm, M\u003e;\r\n\r\n#[derive(Copy, Clone)]\r\npub struct CfftPerm {\r\n    log_height: usize,\r\n}\r\n\r\nimpl RowIndexMap for CfftPerm {\r\n    fn height(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_height\r\n    }\r\n    fn map_row_index(\u0026self, r: usize) -\u003e usize {\r\n        cfft_permute_index(r, self.log_height)\r\n    }\r\n    fn to_row_major_matrix\u003cT: Clone + Send + Sync, Inner: Matrix\u003cT\u003e\u003e(\r\n        \u0026self,\r\n        inner: Inner,\r\n    ) -\u003e RowMajorMatrix\u003cT\u003e {\r\n        let mut inner = inner.to_row_major_matrix();\r\n        cfft_permute_slice_chunked_in_place(\u0026mut inner.values, inner.width);\r\n        inner\r\n    }\r\n}\r\n\r\npub(crate) trait CfftPermutable\u003cT: Send + Sync\u003e: Matrix\u003cT\u003e + Sized {\r\n    fn cfft_perm_rows(self) -\u003e CfftView\u003cSelf\u003e;\r\n}\r\n\r\nimpl\u003cT: Send + Sync, M: Matrix\u003cT\u003e\u003e CfftPermutable\u003cT\u003e for M {\r\n    fn cfft_perm_rows(self) -\u003e CfftView\u003cM\u003e {\r\n        RowIndexMappedView {\r\n            index_map: CfftPerm {\r\n                log_height: log2_strict_usize(self.height()),\r\n            },\r\n            inner: self,\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use itertools::Itertools;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn ordering() {\r\n        // reference ordering derived by hand\r\n        assert_eq!(\r\n            (0..8).map(|i| cfft_permute_index(i, 3)).collect_vec(),\r\n            \u0026[0, 7, 4, 3, 2, 5, 6, 1],\r\n        );\r\n        for log_n in 1..5 {\r\n            let n = 1 \u003c\u003c log_n;\r\n            let sigma = |i| cfft_permute_index(i, log_n);\r\n            for i in 0..n {\r\n                // involution: ((i)) = i\r\n                assert_eq!(sigma(sigma(i)), i);\r\n            }\r\n            // perm_slice same as perm_idx\r\n            assert_eq!(\r\n                cfft_permute_slice(\u0026(0..n).collect_vec()),\r\n                (0..n).map(sigma).collect_vec()\r\n            );\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":1297036692682703033}},{"line":10,"address":[],"length":0,"stats":{"Line":1297036692682703033}},{"line":12,"address":[],"length":0,"stats":{"Line":1297036692682703033}},{"line":13,"address":[],"length":0,"stats":{"Line":15492382718154506843}},{"line":15,"address":[],"length":0,"stats":{"Line":1080863910568918694}},{"line":17,"address":[],"length":0,"stats":{"Line":1297036692682703033}},{"line":21,"address":[],"length":0,"stats":{"Line":14123288431433875463}},{"line":22,"address":[],"length":0,"stats":{"Line":14123288431433875463}},{"line":23,"address":[],"length":0,"stats":{"Line":14123288431433875463}},{"line":24,"address":[],"length":0,"stats":{"Line":9799832789158199356}},{"line":28,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":29,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":30,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":31,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":32,"address":[],"length":0,"stats":{"Line":15780613094306217984}},{"line":33,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":34,"address":[],"length":0,"stats":{"Line":11240984669916758016}},{"line":36,"address":[],"length":0,"stats":{"Line":11889503016258109584}},{"line":37,"address":[],"length":0,"stats":{"Line":720575940379279393}},{"line":60,"address":[],"length":0,"stats":{"Line":6341068275337658434}},{"line":61,"address":[],"length":0,"stats":{"Line":6341068275337658434}},{"line":63,"address":[],"length":0,"stats":{"Line":4899916394579099660}},{"line":64,"address":[],"length":0,"stats":{"Line":4899916394579099660}},{"line":66,"address":[],"length":0,"stats":{"Line":4539628424389460244}},{"line":70,"address":[],"length":0,"stats":{"Line":4539628424389460244}},{"line":71,"address":[],"length":0,"stats":{"Line":4539628424389460244}},{"line":72,"address":[],"length":0,"stats":{"Line":4539628424389460244}},{"line":81,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":83,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":29,"coverable":29},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","pcs.rs"],"content":"use alloc::borrow::Cow;\r\nuse alloc::collections::BTreeMap;\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::{Mmcs, OpenedValues, Pcs, PolynomialSpace};\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::{ExtensionField, Field};\r\nuse p3_fri::verifier::FriError;\r\nuse p3_fri::FriConfig;\r\nuse p3_matrix::dense::{DenseMatrix, RowMajorMatrix};\r\nuse p3_matrix::row_index_mapped::RowIndexMappedView;\r\nuse p3_matrix::{Dimensions, Matrix};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::log2_strict_usize;\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::info_span;\r\n\r\nuse crate::deep_quotient::{deep_quotient_reduce_row, extract_lambda};\r\nuse crate::domain::CircleDomain;\r\nuse crate::folding::{fold_y, fold_y_row, CircleFriConfig, CircleFriGenericConfig};\r\nuse crate::point::Point;\r\nuse crate::prover::prove;\r\nuse crate::verifier::verify;\r\nuse crate::{cfft_permute_index, CfftPerm, CfftPermutable, CircleEvaluations, CircleFriProof};\r\n\r\n#[derive(Debug)]\r\npub struct CirclePcs\u003cVal: Field, InputMmcs, FriMmcs\u003e {\r\n    pub mmcs: InputMmcs,\r\n    pub fri_config: FriConfig\u003cFriMmcs\u003e,\r\n    pub _phantom: PhantomData\u003cVal\u003e,\r\n}\r\n\r\nimpl\u003cVal: Field, InputMmcs, FriMmcs\u003e CirclePcs\u003cVal, InputMmcs, FriMmcs\u003e {\r\n    pub fn new(mmcs: InputMmcs, fri_config: FriConfig\u003cFriMmcs\u003e) -\u003e Self {\r\n        Self {\r\n            mmcs,\r\n            fri_config,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound = \"\")]\r\npub struct BatchOpening\u003cVal: Field, InputMmcs: Mmcs\u003cVal\u003e\u003e {\r\n    pub(crate) opened_values: Vec\u003cVec\u003cVal\u003e\u003e,\r\n    pub(crate) opening_proof: \u003cInputMmcs as Mmcs\u003cVal\u003e\u003e::Proof,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound = \"\")]\r\npub struct CircleInputProof\u003c\r\n    Val: Field,\r\n    Challenge: Field,\r\n    InputMmcs: Mmcs\u003cVal\u003e,\r\n    FriMmcs: Mmcs\u003cChallenge\u003e,\r\n\u003e {\r\n    input_openings: Vec\u003cBatchOpening\u003cVal, InputMmcs\u003e\u003e,\r\n    first_layer_siblings: Vec\u003cChallenge\u003e,\r\n    first_layer_proof: FriMmcs::Proof,\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum InputError\u003cInputMmcsError, FriMmcsError\u003e {\r\n    InputMmcsError(InputMmcsError),\r\n    FirstLayerMmcsError(FriMmcsError),\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound(\r\n    serialize = \"Witness: Serialize\",\r\n    deserialize = \"Witness: Deserialize\u003c'de\u003e\"\r\n))]\r\npub struct CirclePcsProof\u003c\r\n    Val: Field,\r\n    Challenge: Field,\r\n    InputMmcs: Mmcs\u003cVal\u003e,\r\n    FriMmcs: Mmcs\u003cChallenge\u003e,\r\n    Witness,\r\n\u003e {\r\n    first_layer_commitment: FriMmcs::Commitment,\r\n    lambdas: Vec\u003cChallenge\u003e,\r\n    fri_proof: CircleFriProof\u003c\r\n        Challenge,\r\n        FriMmcs,\r\n        Witness,\r\n        CircleInputProof\u003cVal, Challenge, InputMmcs, FriMmcs\u003e,\r\n    \u003e,\r\n}\r\n\r\nimpl\u003cVal, InputMmcs, FriMmcs, Challenge, Challenger\u003e Pcs\u003cChallenge, Challenger\u003e\r\n    for CirclePcs\u003cVal, InputMmcs, FriMmcs\u003e\r\nwhere\r\n    Val: ComplexExtendable,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    InputMmcs: Mmcs\u003cVal\u003e,\r\n    FriMmcs: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + GrindingChallenger + CanObserve\u003cFriMmcs::Commitment\u003e,\r\n{\r\n    type Domain = CircleDomain\u003cVal\u003e;\r\n    type Commitment = InputMmcs::Commitment;\r\n    type ProverData = InputMmcs::ProverData\u003cRowMajorMatrix\u003cVal\u003e\u003e;\r\n    type EvaluationsOnDomain\u003c'a\u003e = RowIndexMappedView\u003cCfftPerm, DenseMatrix\u003cVal, Cow\u003c'a, [Val]\u003e\u003e\u003e;\r\n    type Proof = CirclePcsProof\u003cVal, Challenge, InputMmcs, FriMmcs, Challenger::Witness\u003e;\r\n    type Error = FriError\u003cFriMmcs::Error, InputError\u003cInputMmcs::Error, FriMmcs::Error\u003e\u003e;\r\n\r\n    fn natural_domain_for_degree(\u0026self, degree: usize) -\u003e Self::Domain {\r\n        CircleDomain::standard(log2_strict_usize(degree))\r\n    }\r\n\r\n    fn commit(\r\n        \u0026self,\r\n        evaluations: Vec\u003c(Self::Domain, RowMajorMatrix\u003cVal\u003e)\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData) {\r\n        let ldes = evaluations\r\n            .into_iter()\r\n            .map(|(domain, evals)| {\r\n                assert!(\r\n                    domain.log_n \u003e= 2,\r\n                    \"CirclePcs cannot commit to a matrix with fewer than 4 rows.\",\r\n                    // (because we bivariate fold one bit, and fri needs one more bit)\r\n                );\r\n                CircleEvaluations::from_natural_order(domain, evals)\r\n                    .extrapolate(CircleDomain::standard(\r\n                        domain.log_n + self.fri_config.log_blowup,\r\n                    ))\r\n                    .to_cfft_order()\r\n            })\r\n            .collect_vec();\r\n        let (comm, mmcs_data) = self.mmcs.commit(ldes);\r\n        (comm, mmcs_data)\r\n    }\r\n\r\n    fn get_evaluations_on_domain\u003c'a\u003e(\r\n        \u0026self,\r\n        data: \u0026'a Self::ProverData,\r\n        idx: usize,\r\n        domain: Self::Domain,\r\n    ) -\u003e Self::EvaluationsOnDomain\u003c'a\u003e {\r\n        let mat = self.mmcs.get_matrices(data)[idx].as_view();\r\n        let committed_domain = CircleDomain::standard(log2_strict_usize(mat.height()));\r\n        if domain == committed_domain {\r\n            mat.as_cow().cfft_perm_rows()\r\n        } else {\r\n            CircleEvaluations::from_cfft_order(committed_domain, mat)\r\n                .extrapolate(domain)\r\n                .to_cfft_order()\r\n                .as_cow()\r\n                .cfft_perm_rows()\r\n        }\r\n    }\r\n\r\n    fn open(\r\n        \u0026self,\r\n        // For each round,\r\n        rounds: Vec\u003c(\r\n            \u0026Self::ProverData,\r\n            // for each matrix,\r\n            Vec\u003c\r\n                // points to open\r\n                Vec\u003cChallenge\u003e,\r\n            \u003e,\r\n        )\u003e,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e (OpenedValues\u003cChallenge\u003e, Self::Proof) {\r\n        // Open matrices at points\r\n        let values: OpenedValues\u003cChallenge\u003e = rounds\r\n            .iter()\r\n            .map(|(data, points_for_mats)| {\r\n                let mats = self.mmcs.get_matrices(data);\r\n                izip!(mats, points_for_mats)\r\n                    .map(|(mat, points_for_mat)| {\r\n                        let log_height = log2_strict_usize(mat.height());\r\n                        // It was committed in cfft order.\r\n                        let evals = CircleEvaluations::from_cfft_order(\r\n                            CircleDomain::standard(log_height),\r\n                            mat.as_view(),\r\n                        );\r\n                        points_for_mat\r\n                            .iter()\r\n                            .map(|\u0026zeta| {\r\n                                let zeta = Point::from_projective_line(zeta);\r\n                                let ps_at_zeta =\r\n                                    info_span!(\"compute opened values with Lagrange interpolation\")\r\n                                        .in_scope(|| evals.evaluate_at_point(zeta));\r\n                                ps_at_zeta\r\n                                    .iter()\r\n                                    .for_each(|\u0026p| challenger.observe_algebra_element(p));\r\n                                ps_at_zeta\r\n                            })\r\n                            .collect()\r\n                    })\r\n                    .collect()\r\n            })\r\n            .collect();\r\n\r\n        // Batch combination challenge\r\n        let alpha: Challenge = challenger.sample_algebra_element();\r\n\r\n        /*\r\n        We are reducing columns (\"ro\" = reduced opening) with powers of alpha:\r\n          ro = .. + ^n c_n + ^(n+1) c_(n+1) + ..\r\n        But we want to precompute small powers of alpha, and batch the columns. So we can do:\r\n          ro = .. + ^n (^0 c_n + ^1 c_(n+1) + ..) + ..\r\n        reusing the ^0, ^1, etc., then at the end of each column batch we multiply by the ^n.\r\n        (Due to circle stark specifics, we need 2 powers of  for each column, so actually ^(2n)).\r\n        We store this ^(2n), the running reducing factor per log_height, and call it the \"alpha offset\".\r\n        */\r\n\r\n        // log_height -\u003e (alpha offset, reduced openings column)\r\n        let mut reduced_openings: BTreeMap\u003cusize, (Challenge, Vec\u003cChallenge\u003e)\u003e = BTreeMap::new();\r\n\r\n        rounds\r\n            .iter()\r\n            .zip(values.iter())\r\n            .for_each(|((data, points_for_mats), values)| {\r\n                let mats = self.mmcs.get_matrices(data);\r\n                izip!(mats, points_for_mats, values).for_each(|(mat, points_for_mat, values)| {\r\n                    let log_height = log2_strict_usize(mat.height());\r\n                    // It was committed in cfft order.\r\n                    let evals = CircleEvaluations::from_cfft_order(\r\n                        CircleDomain::standard(log_height),\r\n                        mat.as_view(),\r\n                    );\r\n\r\n                    let (alpha_offset, reduced_opening_for_log_height) =\r\n                        reduced_openings.entry(log_height).or_insert_with(|| {\r\n                            (Challenge::ONE, vec![Challenge::ZERO; 1 \u003c\u003c log_height])\r\n                        });\r\n\r\n                    points_for_mat\r\n                        .iter()\r\n                        .zip(values.iter())\r\n                        .for_each(|(\u0026zeta, ps_at_zeta)| {\r\n                            let zeta = Point::from_projective_line(zeta);\r\n\r\n                            // Reduce this matrix, as a deep quotient, into one column with powers of .\r\n                            let mat_ros = evals.deep_quotient_reduce(alpha, zeta, ps_at_zeta);\r\n\r\n                            // Fold it into our running reduction, offset by alpha_offset.\r\n                            reduced_opening_for_log_height\r\n                                .par_iter_mut()\r\n                                .zip(mat_ros)\r\n                                .for_each(|(ro, mat_ro)| {\r\n                                    *ro += *alpha_offset * mat_ro;\r\n                                });\r\n\r\n                            // Update alpha_offset from ^i -\u003e ^(i + 2 * width)\r\n                            *alpha_offset *= alpha.exp_u64(2 * evals.values.width() as u64);\r\n                        });\r\n                });\r\n            });\r\n\r\n        // Iterate over our reduced columns and extract lambda - the multiple of the vanishing polynomial\r\n        // which may appear in the reduced quotient due to CFFT dimension gap.\r\n\r\n        let mut lambdas = vec![];\r\n        let mut log_heights = vec![];\r\n        let first_layer_mats: Vec\u003cRowMajorMatrix\u003cChallenge\u003e\u003e = reduced_openings\r\n            .into_iter()\r\n            .map(|(log_height, (_, mut ro))| {\r\n                assert!(log_height \u003e 0);\r\n                log_heights.push(log_height);\r\n                let lambda = extract_lambda(\u0026mut ro, self.fri_config.log_blowup);\r\n                lambdas.push(lambda);\r\n                // Prepare for first layer fold with 2 siblings per leaf.\r\n                RowMajorMatrix::new(ro, 2)\r\n            })\r\n            .collect();\r\n        let log_max_height = log_heights.iter().max().copied().unwrap();\r\n\r\n        // Commit to reduced openings at each log_height, so we can challenge a global\r\n        // folding factor for all first layers, which we use for a \"manual\" (not part of p3-fri) fold.\r\n        // This is necessary because the first layer of folding uses different twiddles, so it's easiest\r\n        // to do it here, before p3-fri.\r\n\r\n        let (first_layer_commitment, first_layer_data) =\r\n            self.fri_config.mmcs.commit(first_layer_mats);\r\n        challenger.observe(first_layer_commitment.clone());\r\n        let bivariate_beta: Challenge = challenger.sample_algebra_element();\r\n\r\n        // Fold all first layers at bivariate_beta.\r\n\r\n        let fri_input: Vec\u003cVec\u003cChallenge\u003e\u003e = self\r\n            .fri_config\r\n            .mmcs\r\n            .get_matrices(\u0026first_layer_data)\r\n            .into_iter()\r\n            .map(|m| fold_y(bivariate_beta, m.as_view()))\r\n            // Reverse, because FRI expects descending by height\r\n            .rev()\r\n            .collect();\r\n\r\n        let g: CircleFriConfig\u003cVal, Challenge, InputMmcs, FriMmcs\u003e =\r\n            CircleFriGenericConfig(PhantomData);\r\n\r\n        let fri_proof = prove(\u0026g, \u0026self.fri_config, fri_input, challenger, |index| {\r\n            // CircleFriFolder asks for an extra query index bit, so we use that here to index\r\n            // the first layer fold.\r\n\r\n            // Open the input (big opening, lots of columns) at the full index...\r\n            let input_openings = rounds\r\n                .iter()\r\n                .map(|(data, _)| {\r\n                    let log_max_batch_height = log2_strict_usize(self.mmcs.get_max_height(data));\r\n                    let reduced_index = index \u003e\u003e (log_max_height - log_max_batch_height);\r\n                    let (opened_values, opening_proof) = self.mmcs.open_batch(reduced_index, data);\r\n                    BatchOpening {\r\n                        opened_values,\r\n                        opening_proof,\r\n                    }\r\n                })\r\n                .collect();\r\n\r\n            // We committed to first_layer in pairs, so open the reduced index and include the sibling\r\n            // as part of the input proof.\r\n            let (first_layer_values, first_layer_proof) = self\r\n                .fri_config\r\n                .mmcs\r\n                .open_batch(index \u003e\u003e 1, \u0026first_layer_data);\r\n            let first_layer_siblings = izip!(\u0026first_layer_values, \u0026log_heights)\r\n                .map(|(v, log_height)| {\r\n                    let reduced_index = index \u003e\u003e (log_max_height - log_height);\r\n                    let sibling_index = (reduced_index \u0026 1) ^ 1;\r\n                    v[sibling_index]\r\n                })\r\n                .collect();\r\n            CircleInputProof {\r\n                input_openings,\r\n                first_layer_siblings,\r\n                first_layer_proof,\r\n            }\r\n        });\r\n\r\n        (\r\n            values,\r\n            CirclePcsProof {\r\n                first_layer_commitment,\r\n                lambdas,\r\n                fri_proof,\r\n            },\r\n        )\r\n    }\r\n\r\n    fn verify(\r\n        \u0026self,\r\n        // For each round:\r\n        rounds: Vec\u003c(\r\n            Self::Commitment,\r\n            // for each matrix:\r\n            Vec\u003c(\r\n                // its domain,\r\n                Self::Domain,\r\n                // for each point:\r\n                Vec\u003c(\r\n                    // the point,\r\n                    Challenge,\r\n                    // values at the point\r\n                    Vec\u003cChallenge\u003e,\r\n                )\u003e,\r\n            )\u003e,\r\n        )\u003e,\r\n        proof: \u0026Self::Proof,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        // Write evaluations to challenger\r\n        for (_, round) in rounds.iter() {\r\n            for (_, mat) in round.iter() {\r\n                for (_, point) in mat.iter() {\r\n                    point\r\n                        .iter()\r\n                        .for_each(|\u0026opening| challenger.observe_algebra_element(opening));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Batch combination challenge\r\n        let alpha: Challenge = challenger.sample_algebra_element();\r\n        challenger.observe(proof.first_layer_commitment.clone());\r\n        let bivariate_beta: Challenge = challenger.sample_algebra_element();\r\n\r\n        // +1 to account for first layer\r\n        let log_global_max_height =\r\n            proof.fri_proof.commit_phase_commits.len() + self.fri_config.log_blowup + 1;\r\n\r\n        let g: CircleFriConfig\u003cVal, Challenge, InputMmcs, FriMmcs\u003e =\r\n            CircleFriGenericConfig(PhantomData);\r\n\r\n        verify(\r\n            \u0026g,\r\n            \u0026self.fri_config,\r\n            \u0026proof.fri_proof,\r\n            challenger,\r\n            |index, input_proof| {\r\n                // log_height -\u003e (alpha_offset, ro)\r\n                let mut reduced_openings = BTreeMap::\u003cusize, (Challenge, Challenge)\u003e::new();\r\n\r\n                let CircleInputProof {\r\n                    input_openings,\r\n                    first_layer_siblings,\r\n                    first_layer_proof,\r\n                } = input_proof;\r\n\r\n                for (batch_opening, (batch_commit, mats)) in izip!(input_openings, \u0026rounds) {\r\n                    let batch_heights: Vec\u003cusize\u003e = mats\r\n                        .iter()\r\n                        .map(|(domain, _)| (domain.size() \u003c\u003c self.fri_config.log_blowup))\r\n                        .collect_vec();\r\n                    let batch_dims: Vec\u003cDimensions\u003e = batch_heights\r\n                        .iter()\r\n                        // todo: mmcs doesn't really need width\r\n                        .map(|\u0026height| Dimensions { width: 0, height })\r\n                        .collect_vec();\r\n\r\n                    let (dims, idx) = if let Some(log_batch_max_height) =\r\n                        batch_heights.iter().max().map(|x| log2_strict_usize(*x))\r\n                    {\r\n                        (\r\n                            \u0026batch_dims[..],\r\n                            index \u003e\u003e (log_global_max_height - log_batch_max_height),\r\n                        )\r\n                    } else {\r\n                        // Empty batch?\r\n                        (\u0026[][..], 0)\r\n                    };\r\n\r\n                    self.mmcs\r\n                        .verify_batch(\r\n                            batch_commit,\r\n                            dims,\r\n                            idx,\r\n                            \u0026batch_opening.opened_values,\r\n                            \u0026batch_opening.opening_proof,\r\n                        )\r\n                        .map_err(InputError::InputMmcsError)?;\r\n\r\n                    for (ps_at_x, (mat_domain, mat_points_and_values)) in\r\n                        izip!(\u0026batch_opening.opened_values, mats)\r\n                    {\r\n                        let log_height = mat_domain.log_n + self.fri_config.log_blowup;\r\n                        let bits_reduced = log_global_max_height - log_height;\r\n                        let orig_idx = cfft_permute_index(index \u003e\u003e bits_reduced, log_height);\r\n\r\n                        let committed_domain = CircleDomain::standard(log_height);\r\n                        let x = committed_domain.nth_point(orig_idx);\r\n\r\n                        let (alpha_offset, ro) = reduced_openings\r\n                            .entry(log_height)\r\n                            .or_insert((Challenge::ONE, Challenge::ZERO));\r\n                        let alpha_pow_width_2 = alpha.exp_u64(ps_at_x.len() as u64).square();\r\n\r\n                        for (zeta_uni, ps_at_zeta) in mat_points_and_values {\r\n                            let zeta = Point::from_projective_line(*zeta_uni);\r\n\r\n                            *ro += *alpha_offset\r\n                                * deep_quotient_reduce_row(alpha, x, zeta, ps_at_x, ps_at_zeta);\r\n\r\n                            *alpha_offset *= alpha_pow_width_2;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Verify bivariate fold and lambda correction\r\n\r\n                let (mut fri_input, fl_dims, fl_leaves): (Vec\u003c_\u003e, Vec\u003c_\u003e, Vec\u003c_\u003e) =\r\n                    izip!(reduced_openings, first_layer_siblings, \u0026proof.lambdas)\r\n                        .map(|((log_height, (_, ro)), \u0026fl_sib, \u0026lambda)| {\r\n                            assert!(log_height \u003e 0);\r\n\r\n                            let orig_size = log_height - self.fri_config.log_blowup;\r\n                            let bits_reduced = log_global_max_height - log_height;\r\n                            let orig_idx = cfft_permute_index(index \u003e\u003e bits_reduced, log_height);\r\n\r\n                            let lde_domain = CircleDomain::standard(log_height);\r\n                            let p: Point\u003cVal\u003e = lde_domain.nth_point(orig_idx);\r\n\r\n                            let lambda_corrected = ro - lambda * p.v_n(orig_size);\r\n\r\n                            let mut fl_values = vec![lambda_corrected; 2];\r\n                            fl_values[((index \u003e\u003e bits_reduced) \u0026 1) ^ 1] = fl_sib;\r\n\r\n                            let fri_input = (\r\n                                // - 1 here is because we have already folded a layer.\r\n                                log_height - 1,\r\n                                fold_y_row(\r\n                                    index \u003e\u003e (bits_reduced + 1),\r\n                                    // - 1 here is log_arity.\r\n                                    log_height - 1,\r\n                                    bivariate_beta,\r\n                                    fl_values.iter().cloned(),\r\n                                ),\r\n                            );\r\n\r\n                            let fl_dims = Dimensions {\r\n                                width: 0,\r\n                                height: 1 \u003c\u003c (log_height - 1),\r\n                            };\r\n\r\n                            (fri_input, fl_dims, fl_values)\r\n                        })\r\n                        .multiunzip();\r\n\r\n                // sort descending\r\n                fri_input.reverse();\r\n\r\n                self.fri_config\r\n                    .mmcs\r\n                    .verify_batch(\r\n                        \u0026proof.first_layer_commitment,\r\n                        \u0026fl_dims,\r\n                        index \u003e\u003e 1,\r\n                        \u0026fl_leaves,\r\n                        first_layer_proof,\r\n                    )\r\n                    .map_err(InputError::FirstLayerMmcsError)?;\r\n\r\n                Ok(fri_input)\r\n            },\r\n        )\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_challenger::{HashChallenger, SerializingChallenger32};\r\n    use p3_commit::ExtensionMmcs;\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_fri::create_test_fri_config;\r\n    use p3_keccak::Keccak256Hash;\r\n    use p3_merkle_tree::MerkleTreeMmcs;\r\n    use p3_mersenne_31::Mersenne31;\r\n    use p3_symmetric::{CompressionFunctionFromHasher, SerializingHasher32};\r\n    use rand::{Rng, SeedableRng};\r\n    use rand_chacha::ChaCha8Rng;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn circle_pcs() {\r\n        // Very simple pcs test. More rigorous tests in p3_fri/tests/pcs.\r\n\r\n        let mut rng = ChaCha8Rng::from_seed([0; 32]);\r\n\r\n        type Val = Mersenne31;\r\n        type Challenge = BinomialExtensionField\u003cMersenne31, 3\u003e;\r\n\r\n        type ByteHash = Keccak256Hash;\r\n        type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n        let byte_hash = ByteHash {};\r\n        let field_hash = FieldHash::new(byte_hash);\r\n\r\n        type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n        let compress = MyCompress::new(byte_hash);\r\n\r\n        type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n        let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n        type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n        let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n        type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n        let fri_config = create_test_fri_config(challenge_mmcs);\r\n\r\n        type Pcs = CirclePcs\u003cVal, ValMmcs, ChallengeMmcs\u003e;\r\n        let pcs = Pcs {\r\n            mmcs: val_mmcs,\r\n            fri_config,\r\n            _phantom: PhantomData,\r\n        };\r\n\r\n        let log_n = 10;\r\n\r\n        let d = \u003cPcs as p3_commit::Pcs\u003cChallenge, Challenger\u003e\u003e::natural_domain_for_degree(\r\n            \u0026pcs,\r\n            1 \u003c\u003c log_n,\r\n        );\r\n\r\n        let evals = RowMajorMatrix::rand(\u0026mut rng, 1 \u003c\u003c log_n, 1);\r\n\r\n        let (comm, data) =\r\n            \u003cPcs as p3_commit::Pcs\u003cChallenge, Challenger\u003e\u003e::commit(\u0026pcs, vec![(d, evals)]);\r\n\r\n        let zeta: Challenge = rng.gen();\r\n\r\n        let mut chal = Challenger::from_hasher(vec![], byte_hash);\r\n        let (values, proof) = pcs.open(vec![(\u0026data, vec![vec![zeta]])], \u0026mut chal);\r\n\r\n        let mut chal = Challenger::from_hasher(vec![], byte_hash);\r\n        pcs.verify(\r\n            vec![(comm, vec![(d, vec![(zeta, values[0][0][0].clone())])])],\r\n            \u0026proof,\r\n            \u0026mut chal,\r\n        )\r\n        .expect(\"verify err\");\r\n    }\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":13907115649320091648}},{"line":112,"address":[],"length":0,"stats":{"Line":13907115649320091648}},{"line":115,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":119,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":121,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":122,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":123,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":128,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":129,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":131,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":134,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":135,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":144,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":145,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":146,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":147,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":171,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":173,"address":[],"length":0,"stats":{"Line":8935141660703064071}},{"line":174,"address":[],"length":0,"stats":{"Line":5116089176692883463}},{"line":175,"address":[],"length":0,"stats":{"Line":5116089176692883463}},{"line":176,"address":[],"length":0,"stats":{"Line":720575940379279367}},{"line":177,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":179,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":180,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":181,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":183,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":184,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":185,"address":[],"length":0,"stats":{"Line":9799832789158199443}},{"line":186,"address":[],"length":0,"stats":{"Line":14195346025471803539}},{"line":187,"address":[],"length":0,"stats":{"Line":14195346025471803539}},{"line":188,"address":[],"length":0,"stats":{"Line":14195346025471803539}},{"line":189,"address":[],"length":0,"stats":{"Line":14195346025471803428}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":14051230837395947520}},{"line":197,"address":[],"length":0,"stats":{"Line":5116089176692883463}},{"line":202,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":204,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":205,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":206,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":207,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":208,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":209,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":210,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":211,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":212,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":215,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":217,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":219,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":220,"address":[],"length":0,"stats":{"Line":8935141660703064065}},{"line":221,"address":[],"length":0,"stats":{"Line":5116089176692883457}},{"line":222,"address":[],"length":0,"stats":{"Line":720575940379279366}},{"line":223,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":225,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":226,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":227,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":230,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":231,"address":[],"length":0,"stats":{"Line":6196953087261802501}},{"line":232,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":235,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":236,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":237,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":238,"address":[],"length":0,"stats":{"Line":9799832789158199301}},{"line":239,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":242,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":245,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":246,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":247,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":248,"address":[],"length":0,"stats":{"Line":4395513236313604102}},{"line":249,"address":[],"length":0,"stats":{"Line":8646911284551352326}},{"line":253,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":261,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":262,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":263,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":265,"address":[],"length":0,"stats":{"Line":14411518807585587208}},{"line":266,"address":[],"length":0,"stats":{"Line":10592466323575406600}},{"line":267,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":268,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":269,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":271,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":274,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":281,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":282,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":283,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":284,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":288,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":289,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":290,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":291,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":293,"address":[],"length":0,"stats":{"Line":18230571291595767808}},{"line":298,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":299,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":301,"address":[],"length":0,"stats":{"Line":8863084066665136128}},{"line":306,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":307,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":308,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":309,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":310,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":311,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":312,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":313,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":314,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":317,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":321,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":322,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":323,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":324,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":325,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":326,"address":[],"length":0,"stats":{"Line":4035225266123964418}},{"line":327,"address":[],"length":0,"stats":{"Line":17437937757178560514}},{"line":328,"address":[],"length":0,"stats":{"Line":17437937757178560514}},{"line":329,"address":[],"length":0,"stats":{"Line":17437937757178560514}},{"line":331,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":332,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":333,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":334,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":335,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":340,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":341,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":342,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":343,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":344,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":349,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":371,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":372,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":373,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":374,"address":[],"length":0,"stats":{"Line":14195346025471803392}},{"line":376,"address":[],"length":0,"stats":{"Line":15348267530078650368}},{"line":382,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":383,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":384,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":387,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":388,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":390,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":391,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":394,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":395,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":396,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":397,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":398,"address":[],"length":0,"stats":{"Line":8863084066665136134}},{"line":400,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":402,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":403,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":404,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":405,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":406,"address":[],"length":0,"stats":{"Line":5044031582654955526}},{"line":408,"address":[],"length":0,"stats":{"Line":8935141660703064070}},{"line":409,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":410,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":411,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":412,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":413,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":414,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":416,"address":[],"length":0,"stats":{"Line":13114482114902884357}},{"line":417,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":419,"address":[],"length":0,"stats":{"Line":7782220156096217086}},{"line":420,"address":[],"length":0,"stats":{"Line":11673330234144325639}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":432,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":433,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":434,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":435,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":436,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":437,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":439,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":441,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":442,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":444,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":445,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":446,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":448,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":449,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":451,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":452,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":453,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":454,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":456,"address":[],"length":0,"stats":{"Line":1729382256910270485}},{"line":457,"address":[],"length":0,"stats":{"Line":11096869481840902151}},{"line":459,"address":[],"length":0,"stats":{"Line":11096869481840902151}},{"line":460,"address":[],"length":0,"stats":{"Line":11096869481840902151}},{"line":462,"address":[],"length":0,"stats":{"Line":11096869481840902151}},{"line":469,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":470,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":471,"address":[],"length":0,"stats":{"Line":4035225266123964419}},{"line":472,"address":[],"length":0,"stats":{"Line":17437937757178560514}},{"line":474,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":475,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":476,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":478,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":479,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":481,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":483,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":484,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":486,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":488,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":489,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":490,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":492,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":493,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":494,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":498,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":499,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":500,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":503,"address":[],"length":0,"stats":{"Line":17437937757178560517}},{"line":505,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":508,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":510,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":511,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":512,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":513,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":514,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":515,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":516,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":517,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":519,"address":[],"length":0,"stats":{"Line":5044031582654955522}},{"line":521,"address":[],"length":0,"stats":{"Line":5044031582654955520}}],"covered":219,"coverable":228},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","point.rs"],"content":"use alloc::vec::Vec;\r\nuse core::ops::{Add, AddAssign, Mul, Neg, Sub};\r\n\r\nuse p3_field::extension::ComplexExtendable;\r\nuse p3_field::{batch_multiplicative_inverse, ExtensionField, Field};\r\n\r\n/// Affine representation of a point on the circle.\r\n/// x^2 + y^2 == 1\r\n// _private is to prevent construction so we can debug assert the invariant\r\n#[allow(clippy::manual_non_exhaustive)]\r\n#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\r\npub struct Point\u003cF\u003e {\r\n    pub x: F,\r\n    pub y: F,\r\n    _private: (),\r\n}\r\n\r\nimpl\u003cF: Field\u003e Point\u003cF\u003e {\r\n    #[inline]\r\n    pub fn new(x: F, y: F) -\u003e Point\u003cF\u003e {\r\n        debug_assert_eq!(x.square() + y.square(), F::ONE);\r\n        Point { x, y, _private: () }\r\n    }\r\n\r\n    const ZERO: Self = Self {\r\n        x: F::ONE,\r\n        y: F::ZERO,\r\n        _private: (),\r\n    };\r\n\r\n    /// Circle STARKs, Section 3, Lemma 1: (page 4 of the first revision PDF)\r\n    /// ```ignore\r\n    /// (x, y) = ((1-t^2)/(1+t^2), 2t/(1+t^2))\r\n    /// ```\r\n    /// Panics if t^2 = -1, corresponding to either of the points at infinity\r\n    /// (on the projective *circle*) (1 : i : 0)\r\n    pub fn from_projective_line(t: F) -\u003e Self {\r\n        let t2 = t.square();\r\n        let inv_denom = (F::ONE + t2).try_inverse().expect(\"t^2 = -1\");\r\n        Self::new((F::ONE - t2) * inv_denom, t.double() * inv_denom)\r\n    }\r\n\r\n    /// Circle STARKs, Section 3, Lemma 1: (page 4 of the first revision PDF)\r\n    /// ```ignore\r\n    /// t = y / (x + 1)\r\n    /// ```\r\n    /// Returns None if self.x = -1, corresponding to Inf on the projective line\r\n    ///\r\n    /// This is also used as a selector polynomial, with a simple zero at (1,0)\r\n    /// and a simple pole at (-1,0), which in the paper is called v_0\r\n    /// Circle STARKs, Section 5.1, Lemma 11 (page 21 of the first revision PDF)\r\n    pub fn to_projective_line(self) -\u003e Option\u003cF\u003e {\r\n        (self.x + F::ONE).try_inverse().map(|x| x * self.y)\r\n    }\r\n\r\n    /// The \"squaring map\", or doubling in additive notation, denoted (x,y)\r\n    /// Circle STARKs, Section 3.1, Equation 1: (page 5 of the first revision PDF)\r\n    pub fn double(self) -\u003e Self {\r\n        Self::new(self.x.square().double() - F::ONE, self.x.double() * self.y)\r\n    }\r\n\r\n    /// Evaluate the vanishing polynomial for the standard position coset of size 2^log_n\r\n    /// at this point\r\n    /// Circle STARKs, Section 3.3, Equation 8 (page 10 of the first revision PDF)\r\n    pub fn v_n(mut self, log_n: usize) -\u003e F {\r\n        for _ in 0..(log_n - 1) {\r\n            self.x = self.x.square().double() - F::ONE; // TODO: replace this by a custom field impl.\r\n        }\r\n        self.x\r\n    }\r\n\r\n    /// Compute a product of successive `v_n`'s.\r\n    ///\r\n    /// More explicitly this computes `(1..log_n).map(|i| self.v_n(i)).product()`\r\n    /// but uses far fewer `self.x.square().double() - F::ONE` steps compared to the naive implementation.\r\n    pub fn v_n_prod(mut self, log_n: usize) -\u003e F {\r\n        let mut output = self.x;\r\n        for _ in 0..(log_n - 2) {\r\n            self.x = self.x.square().double() - F::ONE; // TODO: replace this by a custom field impl.\r\n            output *= self.x;\r\n        }\r\n        output\r\n    }\r\n\r\n    /// Evaluate the selector function which is zero at `self` and nonzero elsewhere, at `at`.\r\n    /// Called v_0 . T_p or v_p(x,y) in the paper, used for constraint selectors.\r\n    /// Panics if p = -self, the pole.\r\n    /// Section 5.1, Lemma 11 of Circle Starks (page 21 of first edition PDF)\r\n    pub fn v_tilde_p\u003cEF: ExtensionField\u003cF\u003e\u003e(self, at: Point\u003cEF\u003e) -\u003e EF {\r\n        (at - self).to_projective_line().unwrap()\r\n    }\r\n\r\n    /// The concrete value of the selector s_P = v_n / (v_0 . T_p) at P=self, used for normalization.\r\n    /// Circle STARKs, Section 5.1, Remark 16 (page 22 of the first revision PDF)\r\n    pub fn s_p_at_p(self, log_n: usize) -\u003e F {\r\n        -self.v_n_prod(log_n).mul_2exp_u64((2 * log_n - 1) as u64) * self.y\r\n    }\r\n\r\n    /// Evaluate the alternate single-point vanishing function v_p(x), used for DEEP quotient.\r\n    /// Returns (a, b), representing the complex number a + bi.\r\n    /// Simple zero at p, simple pole at +-infinity.\r\n    /// Circle STARKs, Section 3.3, Equation 11 (page 11 of the first edition PDF).\r\n    pub fn v_p\u003cEF: ExtensionField\u003cF\u003e\u003e(self, at: Point\u003cEF\u003e) -\u003e (EF, EF) {\r\n        let diff = -at + self;\r\n        (EF::ONE - diff.x, -diff.y)\r\n    }\r\n}\r\n\r\n/// Compute (v_P(x,y) * s_p)^{-1} for each element in the list.\r\n/// This takes advantage of batched inversion.\r\npub fn compute_lagrange_den_batched\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e(\r\n    points: \u0026[Point\u003cF\u003e],\r\n    at: Point\u003cEF\u003e,\r\n    log_n: usize,\r\n) -\u003e Vec\u003cEF\u003e {\r\n    // This following line costs about 2% of the runtime for example prove_poseidon2_m31_keccak.\r\n    // Would be nice to find further speedups.\r\n    // Maybe modify to use packed fields here?\r\n    let (numer, denom): (Vec\u003c_\u003e, Vec\u003c_\u003e) = points\r\n        .iter()\r\n        .map(|\u0026pt| {\r\n            let diff = at - pt;\r\n            let numer = diff.x + F::ONE;\r\n            let denom = diff.y * pt.s_p_at_p(log_n);\r\n            (numer, denom)\r\n        })\r\n        .unzip();\r\n\r\n    let inv_d = batch_multiplicative_inverse(\u0026denom);\r\n\r\n    numer\r\n        .iter()\r\n        .zip(inv_d.iter())\r\n        .map(|(\u0026num, \u0026inv_d)| num * inv_d)\r\n        .collect()\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e Point\u003cF\u003e {\r\n    pub fn generator(log_n: usize) -\u003e Self {\r\n        let g = F::circle_two_adic_generator(log_n);\r\n        Self::new(g.real(), g.imag())\r\n    }\r\n}\r\n\r\n/// Circle STARKs, Section 3.1, Equation 2: (page 5 of the first revision PDF)\r\n/// The inverse map J(x,y) = (x,-y)\r\nimpl\u003cF: Field\u003e Neg for Point\u003cF\u003e {\r\n    type Output = Self;\r\n    fn neg(mut self) -\u003e Self::Output {\r\n        self.y = -self.y;\r\n        self\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e Add\u003cPoint\u003cF\u003e\u003e for Point\u003cEF\u003e {\r\n    type Output = Self;\r\n    fn add(self, rhs: Point\u003cF\u003e) -\u003e Self::Output {\r\n        Self::new(\r\n            self.x * rhs.x - self.y * rhs.y,\r\n            self.x * rhs.y + self.y * rhs.x,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e AddAssign for Point\u003cF\u003e {\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e Sub\u003cPoint\u003cF\u003e\u003e for Point\u003cEF\u003e {\r\n    type Output = Self;\r\n    fn sub(self, rhs: Point\u003cF\u003e) -\u003e Self::Output {\r\n        Self::new(\r\n            self.x * rhs.x + self.y * rhs.y,\r\n            self.y * rhs.x - self.x * rhs.y,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e Mul\u003cusize\u003e for Point\u003cF\u003e {\r\n    type Output = Self;\r\n    fn mul(mut self, mut rhs: usize) -\u003e Self::Output {\r\n        let mut res = Self::ZERO;\r\n        while rhs != 0 {\r\n            if rhs \u0026 1 == 1 {\r\n                res += self;\r\n            }\r\n            rhs \u003e\u003e= 1;\r\n            self = self.double();\r\n        }\r\n        res\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_mersenne_31::Mersenne31;\r\n\r\n    use super::*;\r\n\r\n    type F = Mersenne31;\r\n    type Pt = Point\u003cF\u003e;\r\n\r\n    #[test]\r\n    fn test_arithmetic() {\r\n        let one = Pt::generator(3);\r\n        assert_eq!(one - one, Pt::ZERO);\r\n        assert_eq!(one + one, one * 2);\r\n        assert_eq!(one + one + one, one * 3);\r\n        assert_eq!(one * 7, -one);\r\n        assert_eq!(one * 8, Pt::ZERO);\r\n\r\n        let gen = Pt::generator(10);\r\n        let log_n = 10;\r\n        let vn_prod_gen = (1..log_n).map(|i| gen.v_n(i)).product();\r\n        assert_eq!(gen.v_n_prod(log_n), vn_prod_gen);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":13330654897016668236}},{"line":21,"address":[],"length":0,"stats":{"Line":8214565720323786113}},{"line":22,"address":[],"length":0,"stats":{"Line":13330654897016668236}},{"line":37,"address":[],"length":0,"stats":{"Line":12682136550675317219}},{"line":38,"address":[],"length":0,"stats":{"Line":12682136550675317219}},{"line":39,"address":[],"length":0,"stats":{"Line":12682136550675317219}},{"line":40,"address":[],"length":0,"stats":{"Line":12682136550675317219}},{"line":52,"address":[],"length":0,"stats":{"Line":4827858800541171762}},{"line":53,"address":[],"length":0,"stats":{"Line":14483576401623515288}},{"line":58,"address":[],"length":0,"stats":{"Line":13474770085092524116}},{"line":59,"address":[],"length":0,"stats":{"Line":13474770085092524116}},{"line":65,"address":[],"length":0,"stats":{"Line":5476377146882524255}},{"line":66,"address":[],"length":0,"stats":{"Line":4179340454199821453}},{"line":67,"address":[],"length":0,"stats":{"Line":17149707381026848814}},{"line":69,"address":[],"length":0,"stats":{"Line":5476377146882523539}},{"line":76,"address":[],"length":0,"stats":{"Line":17221764975064776897}},{"line":77,"address":[],"length":0,"stats":{"Line":17221764975064776897}},{"line":78,"address":[],"length":0,"stats":{"Line":3746994889972253078}},{"line":79,"address":[],"length":0,"stats":{"Line":4971973988617027797}},{"line":80,"address":[],"length":0,"stats":{"Line":4971973988617027797}},{"line":82,"address":[],"length":0,"stats":{"Line":17221764975064778091}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567719}},{"line":90,"address":[],"length":0,"stats":{"Line":432345564227567719}},{"line":95,"address":[],"length":0,"stats":{"Line":17149707381026848902}},{"line":96,"address":[],"length":0,"stats":{"Line":17149707381026848902}},{"line":103,"address":[],"length":0,"stats":{"Line":15132094747964866641}},{"line":104,"address":[],"length":0,"stats":{"Line":15132094747964866641}},{"line":105,"address":[],"length":0,"stats":{"Line":15132094747964866641}},{"line":111,"address":[],"length":0,"stats":{"Line":7277816997830721678}},{"line":119,"address":[],"length":0,"stats":{"Line":7277816997830721678}},{"line":121,"address":[],"length":0,"stats":{"Line":5836665117072162958}},{"line":122,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":123,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":124,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":125,"address":[],"length":0,"stats":{"Line":17005592192950992896}},{"line":129,"address":[],"length":0,"stats":{"Line":7277816997830721678}},{"line":131,"address":[],"length":0,"stats":{"Line":7277816997830721678}},{"line":133,"address":[],"length":0,"stats":{"Line":7277816997830721678}},{"line":134,"address":[],"length":0,"stats":{"Line":13114482114902884839}},{"line":139,"address":[],"length":0,"stats":{"Line":17365880163140632785}},{"line":140,"address":[],"length":0,"stats":{"Line":17365880163140632785}},{"line":141,"address":[],"length":0,"stats":{"Line":17365880163140632785}},{"line":149,"address":[],"length":0,"stats":{"Line":15636497906230362185}},{"line":150,"address":[],"length":0,"stats":{"Line":15636497906230362185}},{"line":151,"address":[],"length":0,"stats":{"Line":15636497906230362185}},{"line":157,"address":[],"length":0,"stats":{"Line":12826251738751172643}},{"line":159,"address":[],"length":0,"stats":{"Line":12826251738751172643}},{"line":160,"address":[],"length":0,"stats":{"Line":12826251738751172643}},{"line":166,"address":[],"length":0,"stats":{"Line":9799832789158200112}},{"line":167,"address":[],"length":0,"stats":{"Line":9799832789158200112}},{"line":173,"address":[],"length":0,"stats":{"Line":2233785415175766312}},{"line":175,"address":[],"length":0,"stats":{"Line":2233785415175766312}},{"line":176,"address":[],"length":0,"stats":{"Line":2233785415175766312}},{"line":183,"address":[],"length":0,"stats":{"Line":1945555039024054305}},{"line":184,"address":[],"length":0,"stats":{"Line":1945555039024054305}},{"line":185,"address":[],"length":0,"stats":{"Line":15348267530078650530}},{"line":186,"address":[],"length":0,"stats":{"Line":4755801206503243911}},{"line":187,"address":[],"length":0,"stats":{"Line":9799832789158199332}},{"line":189,"address":[],"length":0,"stats":{"Line":13402712491054596225}},{"line":190,"address":[],"length":0,"stats":{"Line":13402712491054596225}},{"line":192,"address":[],"length":0,"stats":{"Line":1945555039024054335}}],"covered":61,"coverable":61},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","proof.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_commit::Mmcs;\r\nuse p3_field::Field;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound(\r\n    serialize = \"Witness: Serialize, InputProof: Serialize\",\r\n    deserialize = \"Witness: Deserialize\u003c'de\u003e, InputProof: Deserialize\u003c'de\u003e\"\r\n))]\r\npub struct CircleFriProof\u003cF: Field, M: Mmcs\u003cF\u003e, Witness, InputProof\u003e {\r\n    pub commit_phase_commits: Vec\u003cM::Commitment\u003e,\r\n    pub query_proofs: Vec\u003cCircleQueryProof\u003cF, M, InputProof\u003e\u003e,\r\n    // This could become Vec\u003cFC::Challenge\u003e if this library was generalized to support non-constant\r\n    // final polynomials.\r\n    pub final_poly: F,\r\n    pub pow_witness: Witness,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound(\r\n    serialize = \"InputProof: Serialize\",\r\n    deserialize = \"InputProof: Deserialize\u003c'de\u003e\",\r\n))]\r\npub struct CircleQueryProof\u003cF: Field, M: Mmcs\u003cF\u003e, InputProof\u003e {\r\n    pub input_proof: InputProof,\r\n    /// For each commit phase commitment, this contains openings of a commit phase codeword at the\r\n    /// queried location, along with an opening proof.\r\n    pub commit_phase_openings: Vec\u003cCircleCommitPhaseProofStep\u003cF, M\u003e\u003e,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\n#[serde(bound = \"\")]\r\npub struct CircleCommitPhaseProofStep\u003cF: Field, M: Mmcs\u003cF\u003e\u003e {\r\n    /// The opening of the commit phase codeword at the sibling location.\r\n    // This may change to Vec\u003cFC::Challenge\u003e if the library is generalized to support other FRI\r\n    // folding arities besides 2, meaning that there can be multiple siblings.\r\n    pub sibling_value: F,\r\n\r\n    pub opening_proof: M::Proof,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","prover.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::iter;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::Mmcs;\r\nuse p3_field::{ExtensionField, Field};\r\nuse p3_fri::{FriConfig, FriGenericConfig};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_util::log2_strict_usize;\r\nuse tracing::{info_span, instrument};\r\n\r\nuse crate::{CircleCommitPhaseProofStep, CircleFriProof, CircleQueryProof};\r\n\r\n#[instrument(name = \"FRI prover\", skip_all)]\r\npub fn prove\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    inputs: Vec\u003cVec\u003cChallenge\u003e\u003e,\r\n    challenger: \u0026mut Challenger,\r\n    open_input: impl Fn(usize) -\u003e G::InputProof,\r\n) -\u003e CircleFriProof\u003cChallenge, M, Challenger::Witness, G::InputProof\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + GrindingChallenger + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    // check sorted descending\r\n    assert!(inputs\r\n        .iter()\r\n        .tuple_windows()\r\n        .all(|(l, r)| l.len() \u003e= r.len()));\r\n\r\n    let log_max_height = log2_strict_usize(inputs[0].len());\r\n\r\n    let commit_phase_result = commit_phase(g, config, inputs, challenger);\r\n\r\n    let pow_witness = challenger.grind(config.proof_of_work_bits);\r\n\r\n    let query_proofs = info_span!(\"query phase\").in_scope(|| {\r\n        iter::repeat_with(|| challenger.sample_bits(log_max_height + g.extra_query_index_bits()))\r\n            .take(config.num_queries)\r\n            .map(|index| CircleQueryProof {\r\n                input_proof: open_input(index),\r\n                commit_phase_openings: answer_query(\r\n                    config,\r\n                    \u0026commit_phase_result.data,\r\n                    index \u003e\u003e g.extra_query_index_bits(),\r\n                ),\r\n            })\r\n            .collect()\r\n    });\r\n\r\n    CircleFriProof {\r\n        commit_phase_commits: commit_phase_result.commits,\r\n        query_proofs,\r\n        final_poly: commit_phase_result.final_poly,\r\n        pow_witness,\r\n    }\r\n}\r\n\r\nstruct CommitPhaseResult\u003cF: Field, M: Mmcs\u003cF\u003e\u003e {\r\n    commits: Vec\u003cM::Commitment\u003e,\r\n    data: Vec\u003cM::ProverData\u003cRowMajorMatrix\u003cF\u003e\u003e\u003e,\r\n    final_poly: F,\r\n}\r\n\r\n#[instrument(name = \"commit phase\", skip_all)]\r\nfn commit_phase\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    inputs: Vec\u003cVec\u003cChallenge\u003e\u003e,\r\n    challenger: \u0026mut Challenger,\r\n) -\u003e CommitPhaseResult\u003cChallenge, M\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    let mut inputs_iter = inputs.into_iter().peekable();\r\n    let mut folded = inputs_iter.next().unwrap();\r\n    let mut commits = vec![];\r\n    let mut data = vec![];\r\n\r\n    while folded.len() \u003e config.blowup() {\r\n        let leaves = RowMajorMatrix::new(folded, 2);\r\n        let (commit, prover_data) = config.mmcs.commit_matrix(leaves);\r\n        challenger.observe(commit.clone());\r\n\r\n        let beta: Challenge = challenger.sample_algebra_element();\r\n        // We passed ownership of `current` to the MMCS, so get a reference to it\r\n        let leaves = config.mmcs.get_matrices(\u0026prover_data).pop().unwrap();\r\n        folded = g.fold_matrix(beta, leaves.as_view());\r\n\r\n        commits.push(commit);\r\n        data.push(prover_data);\r\n\r\n        if let Some(v) = inputs_iter.next_if(|v| v.len() == folded.len()) {\r\n            izip!(\u0026mut folded, v).for_each(|(c, x)| *c += x);\r\n        }\r\n    }\r\n\r\n    // We should be left with `blowup` evaluations of a constant polynomial.\r\n    assert_eq!(folded.len(), config.blowup());\r\n    let final_poly = folded[0];\r\n    for x in folded {\r\n        assert_eq!(x, final_poly);\r\n    }\r\n    challenger.observe_algebra_element(final_poly);\r\n\r\n    CommitPhaseResult {\r\n        commits,\r\n        data,\r\n        final_poly,\r\n    }\r\n}\r\n\r\nfn answer_query\u003cF, M\u003e(\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    commit_phase_commits: \u0026[M::ProverData\u003cRowMajorMatrix\u003cF\u003e\u003e],\r\n    index: usize,\r\n) -\u003e Vec\u003cCircleCommitPhaseProofStep\u003cF, M\u003e\u003e\r\nwhere\r\n    F: Field,\r\n    M: Mmcs\u003cF\u003e,\r\n{\r\n    commit_phase_commits\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(i, commit)| {\r\n            let index_i = index \u003e\u003e i;\r\n            let index_i_sibling = index_i ^ 1;\r\n            let index_pair = index_i \u003e\u003e 1;\r\n\r\n            let (mut opened_rows, opening_proof) = config.mmcs.open_batch(index_pair, commit);\r\n            assert_eq!(opened_rows.len(), 1);\r\n            let opened_row = opened_rows.pop().unwrap();\r\n            assert_eq!(opened_row.len(), 2, \"Committed data should be in pairs\");\r\n            let sibling_value = opened_row[index_i_sibling % 2];\r\n\r\n            CircleCommitPhaseProofStep {\r\n                sibling_value,\r\n                opening_proof,\r\n            }\r\n        })\r\n        .collect()\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":3819052484010180630}},{"line":44,"address":[],"length":0,"stats":{"Line":12682136550675316780}},{"line":45,"address":[],"length":0,"stats":{"Line":3819052484010180630}},{"line":46,"address":[],"length":0,"stats":{"Line":8863084066665136151}},{"line":47,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":48,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":49,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":50,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":51,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":54,"address":[],"length":0,"stats":{"Line":3819052484010180630}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":6917529027641081866}},{"line":104,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":5044031582654955568}},{"line":132,"address":[],"length":0,"stats":{"Line":5044031582654955568}},{"line":135,"address":[],"length":0,"stats":{"Line":14987979559889010736}},{"line":136,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":137,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":138,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":140,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":141,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":142,"address":[],"length":0,"stats":{"Line":9943947977234055178}},{"line":143,"address":[],"length":0,"stats":{"Line":9943947977234055178}},{"line":144,"address":[],"length":0,"stats":{"Line":9943947977234055178}},{"line":146,"address":[],"length":0,"stats":{"Line":9943947977234055178}},{"line":147,"address":[],"length":0,"stats":{"Line":9943947977234055178}},{"line":148,"address":[],"length":0,"stats":{"Line":9943947977234055178}}],"covered":27,"coverable":53},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","twiddles.rs"],"content":"use alloc::vec::Vec;\r\nuse core::mem;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::extension::{Complex, ComplexExtendable};\r\nuse p3_field::{batch_multiplicative_inverse, Field};\r\nuse p3_util::linear_map::LinearMap;\r\nuse tracing::instrument;\r\n\r\nuse crate::domain::CircleDomain;\r\n\r\n#[derive(Debug, Default)]\r\npub(crate) struct TwiddleCache\u003cF: Field\u003e(\r\n    // (log_n, shift) -\u003e (twiddles, inverse_twiddles)\r\n    #[allow(clippy::type_complexity)]\r\n    LinearMap\u003c(usize, Complex\u003cF\u003e), (Vec\u003cVec\u003cF\u003e\u003e, Option\u003cVec\u003cVec\u003cF\u003e\u003e\u003e)\u003e,\r\n);\r\n\r\nimpl\u003cF: ComplexExtendable\u003e TwiddleCache\u003cF\u003e {\r\n    pub(crate) fn get_twiddles(\r\n        \u0026mut self,\r\n        log_n: usize,\r\n        shift: Complex\u003cF\u003e,\r\n        inv: bool,\r\n    ) -\u003e \u0026Vec\u003cVec\u003cF\u003e\u003e {\r\n        let cache = self\r\n            .0\r\n            .get_or_insert_with((log_n, shift), || (compute_twiddles(log_n, shift), None));\r\n        if !inv {\r\n            \u0026cache.0\r\n        } else {\r\n            cache.1.get_or_insert_with(|| {\r\n                cache\r\n                    .0\r\n                    .iter()\r\n                    .map(|xs| batch_multiplicative_inverse(xs))\r\n                    .collect()\r\n            })\r\n        }\r\n    }\r\n}\r\n\r\n/// Computes all (non-inverted) twiddles for the FFT over a circle domain of size 2^log_n, for all layers of the FFT.\r\n#[instrument(skip(shift))]\r\nfn compute_twiddles\u003cF: ComplexExtendable\u003e(log_n: usize, shift: Complex\u003cF\u003e) -\u003e Vec\u003cVec\u003cF\u003e\u003e {\r\n    let size = 1 \u003c\u003c (log_n - 1);\r\n\r\n    let init_domain = CircleDomain::new(log_n, shift)\r\n        .points()\r\n        .take(size)\r\n        .collect_vec();\r\n\r\n    // After the first step we only need the real part.\r\n    let mut working_domain: Vec\u003c_\u003e = init_domain\r\n        .iter()\r\n        .take(size / 2)\r\n        .map(|x| x.real())\r\n        .collect();\r\n\r\n    (0..log_n)\r\n        .map(|i| {\r\n            let size = working_domain.len();\r\n            let output = if i == 0 {\r\n                // The twiddles in step one are the inverse imaginary parts.\r\n                init_domain.iter().map(|x| x.imag()).collect_vec()\r\n            } else {\r\n                let new_working_domain = working_domain\r\n                    .iter()\r\n                    .take(size / 2)\r\n                    // When we square a point, the real part changes as x -\u003e 2x^2 - 1.\r\n                    .map(|x| x.square().double() - F::ONE)\r\n                    .collect();\r\n                mem::replace(\u0026mut working_domain, new_working_domain)\r\n            };\r\n            output\r\n        })\r\n        .collect()\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":30},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","circle","src","verifier.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::Mmcs;\r\nuse p3_field::{ExtensionField, Field};\r\nuse p3_fri::verifier::FriError;\r\nuse p3_fri::{FriConfig, FriGenericConfig};\r\nuse p3_matrix::Dimensions;\r\n\r\nuse crate::{CircleCommitPhaseProofStep, CircleFriProof};\r\n\r\npub fn verify\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    proof: \u0026CircleFriProof\u003cChallenge, M, Challenger::Witness, G::InputProof\u003e,\r\n    challenger: \u0026mut Challenger,\r\n    open_input: impl Fn(usize, \u0026G::InputProof) -\u003e Result\u003cVec\u003c(usize, Challenge)\u003e, G::InputError\u003e,\r\n) -\u003e Result\u003c(), FriError\u003cM::Error, G::InputError\u003e\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + GrindingChallenger + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    let betas: Vec\u003cChallenge\u003e = proof\r\n        .commit_phase_commits\r\n        .iter()\r\n        .map(|comm| {\r\n            challenger.observe(comm.clone());\r\n            challenger.sample_algebra_element()\r\n        })\r\n        .collect();\r\n    challenger.observe_algebra_element(proof.final_poly);\r\n\r\n    if proof.query_proofs.len() != config.num_queries {\r\n        return Err(FriError::InvalidProofShape);\r\n    }\r\n\r\n    // Check PoW.\r\n    if !challenger.check_witness(config.proof_of_work_bits, proof.pow_witness) {\r\n        return Err(FriError::InvalidPowWitness);\r\n    }\r\n\r\n    let log_max_height = proof.commit_phase_commits.len() + config.log_blowup;\r\n\r\n    for qp in \u0026proof.query_proofs {\r\n        let index = challenger.sample_bits(log_max_height + g.extra_query_index_bits());\r\n        let ro = open_input(index, \u0026qp.input_proof).map_err(FriError::InputError)?;\r\n\r\n        debug_assert!(\r\n            ro.iter().tuple_windows().all(|((l, _), (r, _))| l \u003e r),\r\n            \"reduced openings sorted by height descending\"\r\n        );\r\n\r\n        let folded_eval = verify_query(\r\n            g,\r\n            config,\r\n            index \u003e\u003e g.extra_query_index_bits(),\r\n            izip!(\r\n                \u0026betas,\r\n                \u0026proof.commit_phase_commits,\r\n                \u0026qp.commit_phase_openings\r\n            ),\r\n            ro,\r\n            log_max_height,\r\n        )?;\r\n\r\n        if folded_eval != proof.final_poly {\r\n            return Err(FriError::FinalPolyMismatch);\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\ntype CommitStep\u003c'a, F, M\u003e = (\r\n    \u0026'a F,\r\n    \u0026'a \u003cM as Mmcs\u003cF\u003e\u003e::Commitment,\r\n    \u0026'a CircleCommitPhaseProofStep\u003cF, M\u003e,\r\n);\r\n\r\nfn verify_query\u003c'a, G, F, M\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    mut index: usize,\r\n    steps: impl Iterator\u003cItem = CommitStep\u003c'a, F, M\u003e\u003e,\r\n    reduced_openings: Vec\u003c(usize, F)\u003e,\r\n    log_max_height: usize,\r\n) -\u003e Result\u003cF, FriError\u003cM::Error, G::InputError\u003e\u003e\r\nwhere\r\n    F: Field,\r\n    M: Mmcs\u003cF\u003e + 'a,\r\n    G: FriGenericConfig\u003cF\u003e,\r\n{\r\n    let mut folded_eval = F::ZERO;\r\n    let mut ro_iter = reduced_openings.into_iter().peekable();\r\n\r\n    for (log_folded_height, (\u0026beta, comm, opening)) in izip!((0..log_max_height).rev(), steps) {\r\n        if let Some((_, ro)) = ro_iter.next_if(|(lh, _)| *lh == log_folded_height + 1) {\r\n            folded_eval += ro;\r\n        }\r\n\r\n        let index_sibling = index ^ 1;\r\n        let index_pair = index \u003e\u003e 1;\r\n\r\n        let mut evals = vec![folded_eval; 2];\r\n        evals[index_sibling % 2] = opening.sibling_value;\r\n\r\n        let dims = \u0026[Dimensions {\r\n            width: 2,\r\n            height: 1 \u003c\u003c log_folded_height,\r\n        }];\r\n        config\r\n            .mmcs\r\n            .verify_batch(\r\n                comm,\r\n                dims,\r\n                index_pair,\r\n                \u0026[evals.clone()],\r\n                \u0026opening.opening_proof,\r\n            )\r\n            .map_err(FriError::CommitPhaseMmcsError)?;\r\n\r\n        index = index_pair;\r\n\r\n        folded_eval = g.fold_row(index, log_folded_height, beta, evals.into_iter());\r\n    }\r\n\r\n    debug_assert!(index \u003c config.blowup(), \"index was {}\", index);\r\n    debug_assert!(\r\n        ro_iter.next().is_none(),\r\n        \"verifier reduced_openings were not in descending order?\"\r\n    );\r\n\r\n    Ok(folded_eval)\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":28,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":29,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":31,"address":[],"length":0,"stats":{"Line":2089670227099910149}},{"line":32,"address":[],"length":0,"stats":{"Line":16717361816799281157}},{"line":33,"address":[],"length":0,"stats":{"Line":16717361816799281157}},{"line":36,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":38,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":49,"address":[],"length":0,"stats":{"Line":13907115649320091648}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":4035225266123964428}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":60,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":61,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":62,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":63,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":64,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":65,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":67,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":68,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":85,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":98,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":99,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":101,"address":[],"length":0,"stats":{"Line":14987979559889010689}},{"line":102,"address":[],"length":0,"stats":{"Line":864691128455135226}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":107,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":109,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":110,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":112,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":113,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":114,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":116,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":117,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":119,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":120,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":121,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":122,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":123,"address":[],"length":0,"stats":{"Line":9943947977234055169}},{"line":125,"address":[],"length":0,"stats":{"Line":9943947977234055170}},{"line":127,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":129,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":132,"address":[],"length":0,"stats":{"Line":10088063165309911039}},{"line":133,"address":[],"length":0,"stats":{"Line":5044031582654955524}},{"line":134,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":5044031582654955524}}],"covered":49,"coverable":58},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","adapters","extension_mmcs.rs"],"content":"use alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\nuse core::ops::Deref;\r\n\r\nuse p3_field::{ExtensionField, Field};\r\nuse p3_matrix::extension::FlatMatrixView;\r\nuse p3_matrix::{Dimensions, Matrix};\r\n\r\nuse crate::Mmcs;\r\n\r\n#[derive(Clone, Debug)]\r\npub struct ExtensionMmcs\u003cF, EF, InnerMmcs\u003e {\r\n    inner: InnerMmcs,\r\n    _phantom: PhantomData\u003c(F, EF)\u003e,\r\n}\r\n\r\nimpl\u003cF, EF, InnerMmcs\u003e ExtensionMmcs\u003cF, EF, InnerMmcs\u003e {\r\n    pub const fn new(inner: InnerMmcs) -\u003e Self {\r\n        Self {\r\n            inner,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, InnerMmcs\u003e Mmcs\u003cEF\u003e for ExtensionMmcs\u003cF, EF, InnerMmcs\u003e\r\nwhere\r\n    F: Field,\r\n    EF: ExtensionField\u003cF\u003e,\r\n    InnerMmcs: Mmcs\u003cF\u003e,\r\n{\r\n    type ProverData\u003cM\u003e = InnerMmcs::ProverData\u003cFlatMatrixView\u003cF, EF, M\u003e\u003e;\r\n    type Commitment = InnerMmcs::Commitment;\r\n    type Proof = InnerMmcs::Proof;\r\n    type Error = InnerMmcs::Error;\r\n\r\n    fn commit\u003cM: Matrix\u003cEF\u003e\u003e(\u0026self, inputs: Vec\u003cM\u003e) -\u003e (Self::Commitment, Self::ProverData\u003cM\u003e) {\r\n        self.inner\r\n            .commit(inputs.into_iter().map(FlatMatrixView::new).collect())\r\n    }\r\n\r\n    fn open_batch\u003cM: Matrix\u003cEF\u003e\u003e(\r\n        \u0026self,\r\n        index: usize,\r\n        prover_data: \u0026Self::ProverData\u003cM\u003e,\r\n    ) -\u003e (Vec\u003cVec\u003cEF\u003e\u003e, Self::Proof) {\r\n        let (opened_base_values, proof) = self.inner.open_batch(index, prover_data);\r\n        let opened_ext_values = opened_base_values\r\n            .into_iter()\r\n            .map(|row| {\r\n                row.chunks(EF::DIMENSION)\r\n                    .map(EF::deserialize_slice)\r\n                    .collect()\r\n            })\r\n            .collect();\r\n        (opened_ext_values, proof)\r\n    }\r\n\r\n    fn get_matrices\u003c'a, M: Matrix\u003cEF\u003e\u003e(\u0026self, prover_data: \u0026'a Self::ProverData\u003cM\u003e) -\u003e Vec\u003c\u0026'a M\u003e {\r\n        self.inner\r\n            .get_matrices(prover_data)\r\n            .into_iter()\r\n            .map(|mat| mat.deref())\r\n            .collect()\r\n    }\r\n\r\n    fn verify_batch(\r\n        \u0026self,\r\n        commit: \u0026Self::Commitment,\r\n        dimensions: \u0026[Dimensions],\r\n        index: usize,\r\n        opened_values: \u0026[Vec\u003cEF\u003e],\r\n        proof: \u0026Self::Proof,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        let opened_base_values: Vec\u003cVec\u003cF\u003e\u003e = opened_values\r\n            .iter()\r\n            .map(|row| {\r\n                row.iter()\r\n                    .flat_map(|el| el.serialize_as_slice())\r\n                    .copied()\r\n                    .collect()\r\n            })\r\n            .collect();\r\n        let base_dimensions = dimensions\r\n            .iter()\r\n            .map(|dim| Dimensions {\r\n                width: dim.width * EF::DIMENSION,\r\n                height: dim.height,\r\n            })\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        self.inner\r\n            .verify_batch(commit, \u0026base_dimensions, index, \u0026opened_base_values, proof)\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":2522015791327477776}},{"line":37,"address":[],"length":0,"stats":{"Line":4755801206503243778}},{"line":38,"address":[],"length":0,"stats":{"Line":4755801206503243778}},{"line":39,"address":[],"length":0,"stats":{"Line":4755801206503243778}},{"line":42,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":47,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":48,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":50,"address":[],"length":0,"stats":{"Line":4035225266123964417}},{"line":51,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":52,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":53,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":56,"address":[],"length":0,"stats":{"Line":5044031582654955521}},{"line":59,"address":[],"length":0,"stats":{"Line":4755801206503243799}},{"line":60,"address":[],"length":0,"stats":{"Line":4755801206503243799}},{"line":61,"address":[],"length":0,"stats":{"Line":4755801206503243799}},{"line":63,"address":[],"length":0,"stats":{"Line":2594073385365405768}},{"line":67,"address":[],"length":0,"stats":{"Line":5044031582654955529}},{"line":75,"address":[],"length":0,"stats":{"Line":5044031582654955529}},{"line":77,"address":[],"length":0,"stats":{"Line":4035225266123964463}},{"line":78,"address":[],"length":0,"stats":{"Line":17437937757178560550}},{"line":79,"address":[],"length":0,"stats":{"Line":14411518807585587296}},{"line":80,"address":[],"length":0,"stats":{"Line":17437937757178560550}},{"line":81,"address":[],"length":0,"stats":{"Line":17437937757178560550}},{"line":84,"address":[],"length":0,"stats":{"Line":5044031582654955529}},{"line":86,"address":[],"length":0,"stats":{"Line":4035225266123964448}},{"line":87,"address":[],"length":0,"stats":{"Line":17437937757178560535}},{"line":88,"address":[],"length":0,"stats":{"Line":17437937757178560535}},{"line":91,"address":[],"length":0,"stats":{"Line":5044031582654955529}},{"line":92,"address":[],"length":0,"stats":{"Line":5044031582654955529}}],"covered":29,"coverable":29},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","adapters","mod.rs"],"content":"//! Adapters for converting between different types of commitment schemes.\r\n\r\nmod extension_mmcs;\r\npub use extension_mmcs::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","domain.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::{\r\n    batch_multiplicative_inverse, cyclic_subgroup_coset_known_order, ExtensionField, Field,\r\n    TwoAdicField,\r\n};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::{log2_ceil_usize, log2_strict_usize};\r\n\r\n#[derive(Debug)]\r\npub struct LagrangeSelectors\u003cT\u003e {\r\n    pub is_first_row: T,\r\n    pub is_last_row: T,\r\n    pub is_transition: T,\r\n    pub inv_zeroifier: T,\r\n}\r\n\r\npub trait PolynomialSpace: Copy {\r\n    type Val: Field;\r\n\r\n    fn size(\u0026self) -\u003e usize;\r\n\r\n    fn first_point(\u0026self) -\u003e Self::Val;\r\n\r\n    // This is only defined for cosets.\r\n    fn next_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\u0026self, x: Ext) -\u003e Option\u003cExt\u003e;\r\n\r\n    // There are many choices for this, but we must pick a canonical one\r\n    // for both prover/verifier determinism and LDE caching.\r\n    fn create_disjoint_domain(\u0026self, min_size: usize) -\u003e Self;\r\n\r\n    /// Split this domain into `num_chunks` even chunks.\r\n    /// `num_chunks` is assumed to be a power of two.\r\n    fn split_domains(\u0026self, num_chunks: usize) -\u003e Vec\u003cSelf\u003e;\r\n    // Split the evals into chunks of evals, corresponding to each domain\r\n    // from `split_domains`.\r\n    fn split_evals(\r\n        \u0026self,\r\n        num_chunks: usize,\r\n        evals: RowMajorMatrix\u003cSelf::Val\u003e,\r\n    ) -\u003e Vec\u003cRowMajorMatrix\u003cSelf::Val\u003e\u003e;\r\n\r\n    fn zp_at_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\u0026self, point: Ext) -\u003e Ext;\r\n\r\n    // Unnormalized\r\n    fn selectors_at_point\u003cExt: ExtensionField\u003cSelf::Val\u003e\u003e(\r\n        \u0026self,\r\n        point: Ext,\r\n    ) -\u003e LagrangeSelectors\u003cExt\u003e;\r\n\r\n    // Unnormalized\r\n    fn selectors_on_coset(\u0026self, coset: Self) -\u003e LagrangeSelectors\u003cVec\u003cSelf::Val\u003e\u003e;\r\n}\r\n\r\n#[derive(Copy, Clone, Debug)]\r\npub struct TwoAdicMultiplicativeCoset\u003cVal: TwoAdicField\u003e {\r\n    pub log_n: usize,\r\n    pub shift: Val,\r\n}\r\n\r\nimpl\u003cVal: TwoAdicField\u003e TwoAdicMultiplicativeCoset\u003cVal\u003e {\r\n    fn gen(\u0026self) -\u003e Val {\r\n        Val::two_adic_generator(self.log_n)\r\n    }\r\n}\r\n\r\nimpl\u003cVal: TwoAdicField\u003e PolynomialSpace for TwoAdicMultiplicativeCoset\u003cVal\u003e {\r\n    type Val = Val;\r\n\r\n    fn size(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_n\r\n    }\r\n\r\n    fn first_point(\u0026self) -\u003e Self::Val {\r\n        self.shift\r\n    }\r\n    fn next_point\u003cExt: ExtensionField\u003cVal\u003e\u003e(\u0026self, x: Ext) -\u003e Option\u003cExt\u003e {\r\n        Some(x * self.gen())\r\n    }\r\n\r\n    fn create_disjoint_domain(\u0026self, min_size: usize) -\u003e Self {\r\n        Self {\r\n            log_n: log2_ceil_usize(min_size),\r\n            shift: self.shift * Val::GENERATOR,\r\n        }\r\n    }\r\n    fn split_domains(\u0026self, num_chunks: usize) -\u003e Vec\u003cSelf\u003e {\r\n        let log_chunks = log2_strict_usize(num_chunks);\r\n        (0..num_chunks)\r\n            .map(|i| Self {\r\n                log_n: self.log_n - log_chunks,\r\n                shift: self.shift * self.gen().exp_u64(i as u64),\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn split_evals(\r\n        \u0026self,\r\n        num_chunks: usize,\r\n        evals: RowMajorMatrix\u003cSelf::Val\u003e,\r\n    ) -\u003e Vec\u003cRowMajorMatrix\u003cSelf::Val\u003e\u003e {\r\n        // todo less copy\r\n        (0..num_chunks)\r\n            .map(|i| {\r\n                evals\r\n                    .as_view()\r\n                    .vertically_strided(num_chunks, i)\r\n                    .to_row_major_matrix()\r\n            })\r\n            .collect()\r\n    }\r\n    fn zp_at_point\u003cExt: ExtensionField\u003cVal\u003e\u003e(\u0026self, point: Ext) -\u003e Ext {\r\n        (point * self.shift.inverse()).exp_power_of_2(self.log_n) - Ext::ONE\r\n    }\r\n\r\n    fn selectors_at_point\u003cExt: ExtensionField\u003cVal\u003e\u003e(\u0026self, point: Ext) -\u003e LagrangeSelectors\u003cExt\u003e {\r\n        let unshifted_point = point * self.shift.inverse();\r\n        let z_h = unshifted_point.exp_power_of_2(self.log_n) - Ext::ONE;\r\n        LagrangeSelectors {\r\n            is_first_row: z_h / (unshifted_point - Ext::ONE),\r\n            is_last_row: z_h / (unshifted_point - self.gen().inverse()),\r\n            is_transition: unshifted_point - self.gen().inverse(),\r\n            inv_zeroifier: z_h.inverse(),\r\n        }\r\n    }\r\n\r\n    fn selectors_on_coset(\u0026self, coset: Self) -\u003e LagrangeSelectors\u003cVec\u003cVal\u003e\u003e {\r\n        assert_eq!(self.shift, Val::ONE);\r\n        assert_ne!(coset.shift, Val::ONE);\r\n        assert!(coset.log_n \u003e= self.log_n);\r\n        let rate_bits = coset.log_n - self.log_n;\r\n\r\n        let s_pow_n = coset.shift.exp_power_of_2(self.log_n);\r\n        // evals of Z_H(X) = X^n - 1\r\n        let evals = Val::two_adic_generator(rate_bits)\r\n            .powers()\r\n            .take(1 \u003c\u003c rate_bits)\r\n            .map(|x| s_pow_n * x - Val::ONE)\r\n            .collect_vec();\r\n\r\n        let xs = cyclic_subgroup_coset_known_order(coset.gen(), coset.shift, 1 \u003c\u003c coset.log_n)\r\n            .collect_vec();\r\n\r\n        let single_point_selector = |i: u64| {\r\n            let coset_i = self.gen().exp_u64(i);\r\n            let denoms = xs.iter().map(|\u0026x| x - coset_i).collect_vec();\r\n            let invs = batch_multiplicative_inverse(\u0026denoms);\r\n            evals\r\n                .iter()\r\n                .cycle()\r\n                .zip(invs)\r\n                .map(|(\u0026z_h, inv)| z_h * inv)\r\n                .collect_vec()\r\n        };\r\n\r\n        let subgroup_last = self.gen().inverse();\r\n\r\n        LagrangeSelectors {\r\n            is_first_row: single_point_selector(0),\r\n            is_last_row: single_point_selector((1 \u003c\u003c self.log_n) - 1),\r\n            is_transition: xs.into_iter().map(|x| x - subgroup_last).collect(),\r\n            inv_zeroifier: batch_multiplicative_inverse(\u0026evals)\r\n                .into_iter()\r\n                .cycle()\r\n                .take(1 \u003c\u003c coset.log_n)\r\n                .collect(),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":65,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":72,"address":[],"length":0,"stats":{"Line":16357073846609641843}},{"line":73,"address":[],"length":0,"stats":{"Line":16357073846609641843}},{"line":76,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":77,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":79,"address":[],"length":0,"stats":{"Line":1297036692682702880}},{"line":80,"address":[],"length":0,"stats":{"Line":1297036692682702880}},{"line":83,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":85,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":86,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":89,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":90,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":91,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":92,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":93,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":94,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":99,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":105,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":106,"address":[],"length":0,"stats":{"Line":2233785415175766040}},{"line":107,"address":[],"length":0,"stats":{"Line":1585267068834414616}},{"line":108,"address":[],"length":0,"stats":{"Line":1585267068834414616}},{"line":109,"address":[],"length":0,"stats":{"Line":1585267068834414616}},{"line":110,"address":[],"length":0,"stats":{"Line":1585267068834414616}},{"line":114,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":115,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":118,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":119,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":120,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":122,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":123,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":124,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":125,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":129,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":130,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":131,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":132,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":133,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":135,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":137,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":139,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":140,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":143,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":146,"address":[],"length":0,"stats":{"Line":1945555039024054284}},{"line":147,"address":[],"length":0,"stats":{"Line":1297036692682702860}},{"line":148,"address":[],"length":0,"stats":{"Line":3891110078048108568}},{"line":149,"address":[],"length":0,"stats":{"Line":1297036692682702860}},{"line":150,"address":[],"length":0,"stats":{"Line":1297036692682702860}},{"line":153,"address":[],"length":0,"stats":{"Line":1297036692682702860}},{"line":154,"address":[],"length":0,"stats":{"Line":3891110078048108592}},{"line":158,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":161,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":162,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":163,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":164,"address":[],"length":0,"stats":{"Line":648518346341351424}}],"covered":55,"coverable":55},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","lib.rs"],"content":"//! A framework for various (not necessarily hiding) cryptographic commitment schemes.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod adapters;\r\nmod domain;\r\nmod mmcs;\r\nmod pcs;\r\n\r\n#[cfg(any(test, feature = \"test-utils\"))]\r\npub mod testing;\r\n\r\npub use adapters::*;\r\npub use domain::*;\r\npub use mmcs::*;\r\npub use pcs::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","mmcs.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt::Debug;\r\n\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::{Dimensions, Matrix};\r\nuse serde::de::DeserializeOwned;\r\nuse serde::Serialize;\r\n\r\n/// A \"Mixed Matrix Commitment Scheme\" (MMCS) is a generalization of a vector commitment scheme.\r\n///\r\n/// It supports committing to matrices and then opening rows. It is also batch-oriented; one can commit\r\n/// to a batch of matrices at once even if their widths and heights differ.\r\n///\r\n/// When a particular row index is opened, it is interpreted directly as a row index for matrices\r\n/// with the largest height. For matrices with smaller heights, some bits of the row index are\r\n/// removed (from the least-significant side) to get the effective row index. These semantics are\r\n/// useful in the FRI protocol. See the documentation for `open_batch` for more details.\r\npub trait Mmcs\u003cT: Send + Sync\u003e: Clone {\r\n    type ProverData\u003cM\u003e;\r\n    type Commitment: Clone + Serialize + DeserializeOwned;\r\n    type Proof: Clone + Serialize + DeserializeOwned;\r\n    type Error: Debug;\r\n\r\n    fn commit\u003cM: Matrix\u003cT\u003e\u003e(\u0026self, inputs: Vec\u003cM\u003e) -\u003e (Self::Commitment, Self::ProverData\u003cM\u003e);\r\n\r\n    fn commit_matrix\u003cM: Matrix\u003cT\u003e\u003e(\u0026self, input: M) -\u003e (Self::Commitment, Self::ProverData\u003cM\u003e) {\r\n        self.commit(vec![input])\r\n    }\r\n\r\n    fn commit_vec(\u0026self, input: Vec\u003cT\u003e) -\u003e (Self::Commitment, Self::ProverData\u003cRowMajorMatrix\u003cT\u003e\u003e)\r\n    where\r\n        T: Clone + Send + Sync,\r\n    {\r\n        self.commit_matrix(RowMajorMatrix::new_col(input))\r\n    }\r\n\r\n    /// Opens a batch of rows from committed matrices\r\n    /// returns `(openings, proof)`\r\n    /// where `openings` is a vector whose `i`th element is the `j`th row of the ith matrix `M[i]`,\r\n    /// and `j = index \u003e\u003e (log2_ceil(max_height) - log2_ceil(M[i].height))`.\r\n    fn open_batch\u003cM: Matrix\u003cT\u003e\u003e(\r\n        \u0026self,\r\n        index: usize,\r\n        prover_data: \u0026Self::ProverData\u003cM\u003e,\r\n    ) -\u003e (Vec\u003cVec\u003cT\u003e\u003e, Self::Proof);\r\n\r\n    /// Get the matrices that were committed to.\r\n    fn get_matrices\u003c'a, M: Matrix\u003cT\u003e\u003e(\u0026self, prover_data: \u0026'a Self::ProverData\u003cM\u003e) -\u003e Vec\u003c\u0026'a M\u003e;\r\n\r\n    fn get_matrix_heights\u003cM: Matrix\u003cT\u003e\u003e(\u0026self, prover_data: \u0026Self::ProverData\u003cM\u003e) -\u003e Vec\u003cusize\u003e {\r\n        self.get_matrices(prover_data)\r\n            .iter()\r\n            .map(|matrix| matrix.height())\r\n            .collect()\r\n    }\r\n\r\n    /// Get the largest height of any committed matrix.\r\n    fn get_max_height\u003cM: Matrix\u003cT\u003e\u003e(\u0026self, prover_data: \u0026Self::ProverData\u003cM\u003e) -\u003e usize {\r\n        self.get_matrix_heights(prover_data)\r\n            .into_iter()\r\n            .max()\r\n            .unwrap_or_else(|| panic!(\"No committed matrices?\"))\r\n    }\r\n\r\n    /// Verify a batch opening.\r\n    /// `index` is the row index we're opening for each matrix, following the same\r\n    /// semantics as `open_batch`.\r\n    /// `dimensions` is a slice whose ith element is the dimensions of the matrix being opened\r\n    /// in the ith opening\r\n    fn verify_batch(\r\n        \u0026self,\r\n        commit: \u0026Self::Commitment,\r\n        dimensions: \u0026[Dimensions],\r\n        index: usize,\r\n        opened_values: \u0026[Vec\u003cT\u003e],\r\n        proof: \u0026Self::Proof,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e;\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":1008806316530991106}},{"line":28,"address":[],"length":0,"stats":{"Line":1008806316530991106}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":51,"address":[],"length":0,"stats":{"Line":12610078956637388830}},{"line":52,"address":[],"length":0,"stats":{"Line":12610078956637388830}},{"line":54,"address":[],"length":0,"stats":{"Line":14123288431433875514}},{"line":59,"address":[],"length":0,"stats":{"Line":12610078956637388820}},{"line":60,"address":[],"length":0,"stats":{"Line":12610078956637388820}},{"line":63,"address":[],"length":0,"stats":{"Line":6773413839565226254}}],"covered":10,"coverable":10},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","pcs.rs"],"content":"//! Traits for polynomial commitment schemes.\r\n\r\nuse alloc::vec::Vec;\r\nuse core::fmt::Debug;\r\n\r\nuse p3_field::ExtensionField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse serde::de::DeserializeOwned;\r\nuse serde::Serialize;\r\n\r\nuse crate::PolynomialSpace;\r\n\r\npub type Val\u003cD\u003e = \u003cD as PolynomialSpace\u003e::Val;\r\n\r\n/// A (not necessarily hiding) polynomial commitment scheme, for committing to (batches of) polynomials\r\n// TODO: Should we have a super-trait for weakly-binding PCSs, like FRI outside unique decoding radius?\r\npub trait Pcs\u003cChallenge, Challenger\u003e\r\nwhere\r\n    Challenge: ExtensionField\u003cVal\u003cSelf::Domain\u003e\u003e,\r\n{\r\n    type Domain: PolynomialSpace;\r\n\r\n    /// The commitment that's sent to the verifier.\r\n    type Commitment: Clone + Serialize + DeserializeOwned;\r\n\r\n    /// Data that the prover stores for committed polynomials, to help the prover with opening.\r\n    type ProverData;\r\n\r\n    /// Type of the output of `get_evaluations_on_domain`.\r\n    type EvaluationsOnDomain\u003c'a\u003e: Matrix\u003cVal\u003cSelf::Domain\u003e\u003e + 'a;\r\n\r\n    /// The opening argument.\r\n    type Proof: Clone + Serialize + DeserializeOwned;\r\n\r\n    type Error: Debug;\r\n\r\n    /// This should return a coset domain (s.t. Domain::next_point returns Some)\r\n    fn natural_domain_for_degree(\u0026self, degree: usize) -\u003e Self::Domain;\r\n\r\n    #[allow(clippy::type_complexity)]\r\n    fn commit(\r\n        \u0026self,\r\n        evaluations: Vec\u003c(Self::Domain, RowMajorMatrix\u003cVal\u003cSelf::Domain\u003e\u003e)\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData);\r\n\r\n    fn get_evaluations_on_domain\u003c'a\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData,\r\n        idx: usize,\r\n        domain: Self::Domain,\r\n    ) -\u003e Self::EvaluationsOnDomain\u003c'a\u003e;\r\n\r\n    fn open(\r\n        \u0026self,\r\n        // For each round,\r\n        rounds: Vec\u003c(\r\n            \u0026Self::ProverData,\r\n            // for each matrix,\r\n            Vec\u003c\r\n                // points to open\r\n                Vec\u003cChallenge\u003e,\r\n            \u003e,\r\n        )\u003e,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e (OpenedValues\u003cChallenge\u003e, Self::Proof);\r\n\r\n    #[allow(clippy::type_complexity)]\r\n    fn verify(\r\n        \u0026self,\r\n        // For each round:\r\n        rounds: Vec\u003c(\r\n            Self::Commitment,\r\n            // for each matrix:\r\n            Vec\u003c(\r\n                // its domain,\r\n                Self::Domain,\r\n                // for each point:\r\n                Vec\u003c(\r\n                    // the point,\r\n                    Challenge,\r\n                    // values at the point\r\n                    Vec\u003cChallenge\u003e,\r\n                )\u003e,\r\n            )\u003e,\r\n        )\u003e,\r\n        proof: \u0026Self::Proof,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e;\r\n}\r\n\r\npub type OpenedValues\u003cF\u003e = Vec\u003cOpenedValuesForRound\u003cF\u003e\u003e;\r\npub type OpenedValuesForRound\u003cF\u003e = Vec\u003cOpenedValuesForMatrix\u003cF\u003e\u003e;\r\npub type OpenedValuesForMatrix\u003cF\u003e = Vec\u003cOpenedValuesForPoint\u003cF\u003e\u003e;\r\npub type OpenedValuesForPoint\u003cF\u003e = Vec\u003cF\u003e;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","commit","src","testing.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse p3_challenger::CanSample;\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::{ExtensionField, Field, TwoAdicField};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::log2_strict_usize;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::{OpenedValues, Pcs, PolynomialSpace, TwoAdicMultiplicativeCoset};\r\n\r\n/// A trivial PCS: its commitment is simply the coefficients of each poly.\r\n#[derive(Debug)]\r\npub struct TrivialPcs\u003cVal: TwoAdicField, Dft: TwoAdicSubgroupDft\u003cVal\u003e\u003e {\r\n    pub dft: Dft,\r\n    // degree bound\r\n    pub log_n: usize,\r\n    pub _phantom: PhantomData\u003cVal\u003e,\r\n}\r\n\r\npub fn eval_coeffs_at_pt\u003cF: Field, EF: ExtensionField\u003cF\u003e\u003e(\r\n    coeffs: \u0026RowMajorMatrix\u003cF\u003e,\r\n    x: EF,\r\n) -\u003e Vec\u003cEF\u003e {\r\n    let mut acc = vec![EF::ZERO; coeffs.width()];\r\n    for r in (0..coeffs.height()).rev() {\r\n        let row = coeffs.row_slice(r);\r\n        for (acc_c, row_c) in acc.iter_mut().zip(row.as_ref().iter()) {\r\n            *acc_c *= x;\r\n            *acc_c += *row_c;\r\n        }\r\n    }\r\n    acc\r\n}\r\n\r\nimpl\u003cVal, Dft, Challenge, Challenger\u003e Pcs\u003cChallenge, Challenger\u003e for TrivialPcs\u003cVal, Dft\u003e\r\nwhere\r\n    Val: TwoAdicField,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    Challenger: CanSample\u003cChallenge\u003e,\r\n\r\n    Dft: TwoAdicSubgroupDft\u003cVal\u003e,\r\n\r\n    Vec\u003cVec\u003cVal\u003e\u003e: Serialize + for\u003c'de\u003e Deserialize\u003c'de\u003e,\r\n{\r\n    type Domain = TwoAdicMultiplicativeCoset\u003cVal\u003e;\r\n    type Commitment = Vec\u003cVec\u003cVal\u003e\u003e;\r\n    type ProverData = Vec\u003cRowMajorMatrix\u003cVal\u003e\u003e;\r\n    type EvaluationsOnDomain\u003c'a\u003e = Dft::Evaluations;\r\n    type Proof = ();\r\n    type Error = ();\r\n\r\n    fn natural_domain_for_degree(\u0026self, degree: usize) -\u003e Self::Domain {\r\n        TwoAdicMultiplicativeCoset {\r\n            log_n: log2_strict_usize(degree),\r\n            shift: Val::ONE,\r\n        }\r\n    }\r\n\r\n    fn commit(\r\n        \u0026self,\r\n        evaluations: Vec\u003c(Self::Domain, RowMajorMatrix\u003cVal\u003e)\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData) {\r\n        let coeffs: Vec\u003c_\u003e = evaluations\r\n            .into_iter()\r\n            .map(|(domain, evals)| {\r\n                let log_domain_size = log2_strict_usize(domain.size());\r\n                // for now, only commit on larger domain than natural\r\n                assert!(log_domain_size \u003e= self.log_n);\r\n                assert_eq!(domain.size(), evals.height());\r\n                // coset_idft_batch\r\n                let mut coeffs = self.dft.idft_batch(evals);\r\n                coeffs\r\n                    .rows_mut()\r\n                    .zip(domain.shift.inverse().powers())\r\n                    .for_each(|(row, weight)| {\r\n                        row.iter_mut().for_each(|coeff| {\r\n                            *coeff *= weight;\r\n                        })\r\n                    });\r\n                coeffs\r\n            })\r\n            .collect();\r\n        (\r\n            coeffs.clone().into_iter().map(|m| m.values).collect(),\r\n            coeffs,\r\n        )\r\n    }\r\n\r\n    fn get_evaluations_on_domain\u003c'a\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData,\r\n        idx: usize,\r\n        domain: Self::Domain,\r\n    ) -\u003e Self::EvaluationsOnDomain\u003c'a\u003e {\r\n        let mut coeffs = prover_data[idx].clone();\r\n        assert!(domain.log_n \u003e= self.log_n);\r\n        coeffs.values.resize(\r\n            coeffs.values.len() \u003c\u003c (domain.log_n - self.log_n),\r\n            Val::ZERO,\r\n        );\r\n        self.dft.coset_dft_batch(coeffs, domain.shift)\r\n    }\r\n\r\n    fn open(\r\n        \u0026self,\r\n        // For each round,\r\n        rounds: Vec\u003c(\r\n            \u0026Self::ProverData,\r\n            // for each matrix,\r\n            Vec\u003c\r\n                // points to open\r\n                Vec\u003cChallenge\u003e,\r\n            \u003e,\r\n        )\u003e,\r\n        _challenger: \u0026mut Challenger,\r\n    ) -\u003e (OpenedValues\u003cChallenge\u003e, Self::Proof) {\r\n        (\r\n            rounds\r\n                .into_iter()\r\n                .map(|(coeffs_for_round, points_for_round)| {\r\n                    coeffs_for_round\r\n                        .iter()\r\n                        .zip(points_for_round)\r\n                        .map(|(coeffs_for_mat, points_for_mat)| {\r\n                            points_for_mat\r\n                                .into_iter()\r\n                                .map(|pt| eval_coeffs_at_pt(coeffs_for_mat, pt))\r\n                                .collect()\r\n                        })\r\n                        .collect()\r\n                })\r\n                .collect(),\r\n            (),\r\n        )\r\n    }\r\n\r\n    // This is a testing function, so we allow panics for convenience.\r\n    #[allow(clippy::panic_in_result_fn)]\r\n    fn verify(\r\n        \u0026self,\r\n        // For each round:\r\n        rounds: Vec\u003c(\r\n            Self::Commitment,\r\n            // for each matrix:\r\n            Vec\u003c(\r\n                // its domain,\r\n                Self::Domain,\r\n                // for each point:\r\n                Vec\u003c(\r\n                    Challenge,\r\n                    // values at this point\r\n                    Vec\u003cChallenge\u003e,\r\n                )\u003e,\r\n            )\u003e,\r\n        )\u003e,\r\n        _proof: \u0026Self::Proof,\r\n        _challenger: \u0026mut Challenger,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        for (comm, round_opening) in rounds {\r\n            for (coeff_vec, (domain, points_and_values)) in comm.into_iter().zip(round_opening) {\r\n                let width = coeff_vec.len() / domain.size();\r\n                assert_eq!(width * domain.size(), coeff_vec.len());\r\n                let coeffs = RowMajorMatrix::new(coeff_vec, width);\r\n                for (pt, values) in points_and_values {\r\n                    assert_eq!(eval_coeffs_at_pt(\u0026coeffs, pt), values);\r\n                }\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":28,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":29,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":2017612633061982236}},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":67,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":69,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":70,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":72,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":73,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":75,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":76,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":77,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":78,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":79,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":88,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":93,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":99,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":100,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":105,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":108,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":122,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":123,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":124,"address":[],"length":0,"stats":{"Line":648518346341351435}},{"line":125,"address":[],"length":0,"stats":{"Line":432345564227567627}},{"line":126,"address":[],"length":0,"stats":{"Line":432345564227567627}},{"line":127,"address":[],"length":0,"stats":{"Line":432345564227567627}},{"line":128,"address":[],"length":0,"stats":{"Line":1224979098644775135}},{"line":129,"address":[],"length":0,"stats":{"Line":792633534417207508}},{"line":130,"address":[],"length":0,"stats":{"Line":792633534417207508}},{"line":131,"address":[],"length":0,"stats":{"Line":2594073385365406904}},{"line":132,"address":[],"length":0,"stats":{"Line":792633534417207508}},{"line":134,"address":[],"length":0,"stats":{"Line":432345564227567627}},{"line":136,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":143,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":163,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":164,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":165,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":166,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":167,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":168,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":49,"coverable":56},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","benches","fft.rs"],"content":"use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_dft::{Radix2Bowers, Radix2Dit, Radix2DitParallel, TwoAdicSubgroupDft};\r\nuse p3_field::extension::Complex;\r\nuse p3_field::TwoAdicField;\r\nuse p3_goldilocks::Goldilocks;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_mersenne_31::{Mersenne31, Mersenne31ComplexRadix2Dit, Mersenne31Dft};\r\nuse p3_monty_31::dft::RecursiveDft;\r\nuse p3_util::pretty_name;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::thread_rng;\r\n\r\nfn bench_fft(c: \u0026mut Criterion) {\r\n    // log_sizes correspond to the sizes of DFT we want to benchmark;\r\n    // for the DFT over the quadratic extension \"Mersenne31Complex\" a\r\n    // fairer comparison is to use half sizes, which is the log minus 1.\r\n    let log_sizes = \u0026[14, 16, 18, 20, 22];\r\n    let log_half_sizes = \u0026[13, 15, 17];\r\n\r\n    const BATCH_SIZE: usize = 256;\r\n\r\n    fft::\u003cBabyBear, Radix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cBabyBear, RecursiveDft\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cBabyBear, Radix2Bowers, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cBabyBear, Radix2DitParallel\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cGoldilocks, Radix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cGoldilocks, Radix2Bowers, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cGoldilocks, Radix2DitParallel\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    fft::\u003cComplex\u003cMersenne31\u003e, Radix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_half_sizes);\r\n    fft::\u003cComplex\u003cMersenne31\u003e, Radix2Bowers, BATCH_SIZE\u003e(c, log_half_sizes);\r\n    fft::\u003cComplex\u003cMersenne31\u003e, Radix2DitParallel\u003c_\u003e, BATCH_SIZE\u003e(c, log_half_sizes);\r\n\r\n    fft::\u003cComplex\u003cMersenne31\u003e, Mersenne31ComplexRadix2Dit, BATCH_SIZE\u003e(c, log_half_sizes);\r\n    m31_fft::\u003cRadix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    m31_fft::\u003cMersenne31ComplexRadix2Dit, BATCH_SIZE\u003e(c, log_sizes);\r\n\r\n    ifft::\u003cGoldilocks, Radix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n\r\n    coset_lde::\u003cBabyBear, RecursiveDft\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    coset_lde::\u003cBabyBear, Radix2Dit\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    coset_lde::\u003cBabyBear, Radix2Bowers, BATCH_SIZE\u003e(c, log_sizes);\r\n    coset_lde::\u003cBabyBear, Radix2DitParallel\u003c_\u003e, BATCH_SIZE\u003e(c, log_sizes);\r\n    coset_lde::\u003cGoldilocks, Radix2Bowers, BATCH_SIZE\u003e(c, log_sizes);\r\n}\r\n\r\nfn fft\u003cF, Dft, const BATCH_SIZE: usize\u003e(c: \u0026mut Criterion, log_sizes: \u0026[usize])\r\nwhere\r\n    F: TwoAdicField,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut group = c.benchmark_group(format!(\r\n        \"fft/{}/{}/ncols={}\",\r\n        pretty_name::\u003cF\u003e(),\r\n        pretty_name::\u003cDft\u003e(),\r\n        BATCH_SIZE\r\n    ));\r\n    group.sample_size(10);\r\n\r\n    let mut rng = thread_rng();\r\n    for n_log in log_sizes {\r\n        let n = 1 \u003c\u003c n_log;\r\n\r\n        let messages = RowMajorMatrix::rand(\u0026mut rng, n, BATCH_SIZE);\r\n\r\n        let dft = Dft::default();\r\n        group.bench_with_input(BenchmarkId::from_parameter(n), \u0026dft, |b, dft| {\r\n            b.iter(|| {\r\n                dft.dft_batch(messages.clone());\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nfn m31_fft\u003cDft, const BATCH_SIZE: usize\u003e(c: \u0026mut Criterion, log_sizes: \u0026[usize])\r\nwhere\r\n    Dft: TwoAdicSubgroupDft\u003cComplex\u003cMersenne31\u003e\u003e,\r\n    Standard: Distribution\u003cMersenne31\u003e,\r\n{\r\n    let mut group = c.benchmark_group(format!(\r\n        \"m31_fft::\u003c{}, {}\u003e\",\r\n        pretty_name::\u003cDft\u003e(),\r\n        BATCH_SIZE\r\n    ));\r\n    group.sample_size(10);\r\n\r\n    let mut rng = thread_rng();\r\n    for n_log in log_sizes {\r\n        let n = 1 \u003c\u003c n_log;\r\n\r\n        let messages = RowMajorMatrix::rand(\u0026mut rng, n, BATCH_SIZE);\r\n\r\n        group.bench_function(BenchmarkId::from_parameter(n), |b| {\r\n            b.iter(|| {\r\n                Mersenne31Dft::dft_batch::\u003cDft\u003e(messages.clone());\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nfn ifft\u003cF, Dft, const BATCH_SIZE: usize\u003e(c: \u0026mut Criterion, log_sizes: \u0026[usize])\r\nwhere\r\n    F: TwoAdicField,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut group = c.benchmark_group(format!(\r\n        \"ifft/{}/{}/ncols={}\",\r\n        pretty_name::\u003cF\u003e(),\r\n        pretty_name::\u003cDft\u003e(),\r\n        BATCH_SIZE\r\n    ));\r\n    group.sample_size(10);\r\n\r\n    let mut rng = thread_rng();\r\n    for n_log in log_sizes {\r\n        let n = 1 \u003c\u003c n_log;\r\n\r\n        let messages = RowMajorMatrix::rand(\u0026mut rng, n, BATCH_SIZE);\r\n\r\n        let dft = Dft::default();\r\n        group.bench_with_input(BenchmarkId::from_parameter(n), \u0026dft, |b, dft| {\r\n            b.iter(|| {\r\n                dft.idft_batch(messages.clone());\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nfn coset_lde\u003cF, Dft, const BATCH_SIZE: usize\u003e(c: \u0026mut Criterion, log_sizes: \u0026[usize])\r\nwhere\r\n    F: TwoAdicField,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut group = c.benchmark_group(format!(\r\n        \"coset_lde/{}/{}/ncols={}\",\r\n        pretty_name::\u003cF\u003e(),\r\n        pretty_name::\u003cDft\u003e(),\r\n        BATCH_SIZE\r\n    ));\r\n    group.sample_size(10);\r\n\r\n    let mut rng = thread_rng();\r\n    for n_log in log_sizes {\r\n        let n = 1 \u003c\u003c n_log;\r\n\r\n        let messages = RowMajorMatrix::rand(\u0026mut rng, n, BATCH_SIZE);\r\n\r\n        let dft = Dft::default();\r\n        group.bench_with_input(BenchmarkId::from_parameter(n), \u0026dft, |b, dft| {\r\n            b.iter(|| {\r\n                dft.coset_lde_batch(messages.clone(), 1, F::GENERATOR);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\ncriterion_group!(benches, bench_fft);\r\ncriterion_main!(benches);\r\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":54},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","butterflies.rs"],"content":"use core::mem::MaybeUninit;\r\n\r\nuse itertools::izip;\r\nuse p3_field::{Field, PackedField, PackedValue};\r\n\r\npub trait Butterfly\u003cF: Field\u003e: Copy + Send + Sync {\r\n    fn apply\u003cPF: PackedField\u003cScalar = F\u003e\u003e(\u0026self, x_1: PF, x_2: PF) -\u003e (PF, PF);\r\n\r\n    #[inline]\r\n    fn apply_in_place\u003cPF: PackedField\u003cScalar = F\u003e\u003e(\u0026self, x_1: \u0026mut PF, x_2: \u0026mut PF) {\r\n        (*x_1, *x_2) = self.apply(*x_1, *x_2);\r\n    }\r\n\r\n    #[inline]\r\n    fn apply_to_rows(\u0026self, row_1: \u0026mut [F], row_2: \u0026mut [F]) {\r\n        let (shorts_1, suffix_1) = F::Packing::pack_slice_with_suffix_mut(row_1);\r\n        let (shorts_2, suffix_2) = F::Packing::pack_slice_with_suffix_mut(row_2);\r\n        debug_assert_eq!(shorts_1.len(), shorts_2.len());\r\n        debug_assert_eq!(suffix_1.len(), suffix_2.len());\r\n        for (x_1, x_2) in shorts_1.iter_mut().zip(shorts_2) {\r\n            self.apply_in_place(x_1, x_2);\r\n        }\r\n        for (x_1, x_2) in suffix_1.iter_mut().zip(suffix_2) {\r\n            self.apply_in_place(x_1, x_2);\r\n        }\r\n    }\r\n\r\n    /// Like `apply_to_rows`, but out-of-place.\r\n    #[inline]\r\n    fn apply_to_rows_oop(\r\n        \u0026self,\r\n        src_1: \u0026[F],\r\n        dst_1: \u0026mut [MaybeUninit\u003cF\u003e],\r\n        src_2: \u0026[F],\r\n        dst_2: \u0026mut [MaybeUninit\u003cF\u003e],\r\n    ) {\r\n        let (src_shorts_1, src_suffix_1) = F::Packing::pack_slice_with_suffix(src_1);\r\n        let (src_shorts_2, src_suffix_2) = F::Packing::pack_slice_with_suffix(src_2);\r\n        let (dst_shorts_1, dst_suffix_1) =\r\n            F::Packing::pack_maybe_uninit_slice_with_suffix_mut(dst_1);\r\n        let (dst_shorts_2, dst_suffix_2) =\r\n            F::Packing::pack_maybe_uninit_slice_with_suffix_mut(dst_2);\r\n        debug_assert_eq!(src_shorts_1.len(), src_shorts_2.len());\r\n        debug_assert_eq!(src_suffix_1.len(), src_suffix_2.len());\r\n        debug_assert_eq!(dst_shorts_1.len(), dst_shorts_2.len());\r\n        debug_assert_eq!(dst_suffix_1.len(), dst_suffix_2.len());\r\n        for (s_1, s_2, d_1, d_2) in izip!(src_shorts_1, src_shorts_2, dst_shorts_1, dst_shorts_2) {\r\n            let (res_1, res_2) = self.apply::\u003cF::Packing\u003e(*s_1, *s_2);\r\n            d_1.write(res_1);\r\n            d_2.write(res_2);\r\n        }\r\n        for (s_1, s_2, d_1, d_2) in izip!(src_suffix_1, src_suffix_2, dst_suffix_1, dst_suffix_2) {\r\n            let (res_1, res_2) = self.apply::\u003cF\u003e(*s_1, *s_2);\r\n            d_1.write(res_1);\r\n            d_2.write(res_2);\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\npub struct DifButterfly\u003cF\u003e(pub F);\r\nimpl\u003cF: Field\u003e Butterfly\u003cF\u003e for DifButterfly\u003cF\u003e {\r\n    #[inline]\r\n    fn apply\u003cPF: PackedField\u003cScalar = F\u003e\u003e(\u0026self, x_1: PF, x_2: PF) -\u003e (PF, PF) {\r\n        (x_1 + x_2, (x_1 - x_2) * self.0)\r\n    }\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\npub struct DitButterfly\u003cF\u003e(pub F);\r\nimpl\u003cF: Field\u003e Butterfly\u003cF\u003e for DitButterfly\u003cF\u003e {\r\n    #[inline]\r\n    fn apply\u003cPF: PackedField\u003cScalar = F\u003e\u003e(\u0026self, x_1: PF, x_2: PF) -\u003e (PF, PF) {\r\n        let x_2_twiddle = x_2 * self.0;\r\n        (x_1 + x_2_twiddle, x_1 - x_2_twiddle)\r\n    }\r\n}\r\n\r\n/// Butterfly with twiddle factor 1 (works in either DIT or DIF).\r\n#[derive(Copy, Clone)]\r\npub struct TwiddleFreeButterfly;\r\nimpl\u003cF: Field\u003e Butterfly\u003cF\u003e for TwiddleFreeButterfly {\r\n    #[inline]\r\n    fn apply\u003cPF: PackedField\u003cScalar = F\u003e\u003e(\u0026self, x_1: PF, x_2: PF) -\u003e (PF, PF) {\r\n        (x_1 + x_2, x_1 - x_2)\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":13979173243358019576}},{"line":11,"address":[],"length":0,"stats":{"Line":13979173243358019576}},{"line":15,"address":[],"length":0,"stats":{"Line":3314649325744685179}},{"line":16,"address":[],"length":0,"stats":{"Line":3314649325744685179}},{"line":17,"address":[],"length":0,"stats":{"Line":3314649325744685179}},{"line":18,"address":[],"length":0,"stats":{"Line":6629298651489371107}},{"line":19,"address":[],"length":0,"stats":{"Line":6629298651489371107}},{"line":20,"address":[],"length":0,"stats":{"Line":1873497444986131783}},{"line":21,"address":[],"length":0,"stats":{"Line":8502796096475499110}},{"line":23,"address":[],"length":0,"stats":{"Line":12538021362599461735}},{"line":24,"address":[],"length":0,"stats":{"Line":13835058055282164111}},{"line":30,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":37,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":38,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":39,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":40,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":41,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":42,"address":[],"length":0,"stats":{"Line":11313042263954688327}},{"line":43,"address":[],"length":0,"stats":{"Line":4179340454199822709}},{"line":44,"address":[],"length":0,"stats":{"Line":4179340454199822709}},{"line":45,"address":[],"length":0,"stats":{"Line":4179340454199822709}},{"line":46,"address":[],"length":0,"stats":{"Line":4179340454199822709}},{"line":47,"address":[],"length":0,"stats":{"Line":936748722493065635}},{"line":48,"address":[],"length":0,"stats":{"Line":13258597302978740270}},{"line":49,"address":[],"length":0,"stats":{"Line":13258597302978740270}},{"line":50,"address":[],"length":0,"stats":{"Line":13258597302978740270}},{"line":52,"address":[],"length":0,"stats":{"Line":6557241057451442301}},{"line":53,"address":[],"length":0,"stats":{"Line":16068843470457929774}},{"line":54,"address":[],"length":0,"stats":{"Line":16068843470457929774}},{"line":55,"address":[],"length":0,"stats":{"Line":16068843470457929774}},{"line":64,"address":[],"length":0,"stats":{"Line":18014398509481985509}},{"line":65,"address":[],"length":0,"stats":{"Line":18014398509481985509}},{"line":73,"address":[],"length":0,"stats":{"Line":3530822107858475850}},{"line":74,"address":[],"length":0,"stats":{"Line":3530822107858475850}},{"line":75,"address":[],"length":0,"stats":{"Line":3530822107858475850}},{"line":84,"address":[],"length":0,"stats":{"Line":11889503016258110807}},{"line":85,"address":[],"length":0,"stats":{"Line":11889503016258110807}}],"covered":37,"coverable":37},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","lib.rs"],"content":"//! This crate contains some DFT implementations.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod butterflies;\r\nmod naive;\r\nmod radix_2_bowers;\r\nmod radix_2_dit;\r\nmod radix_2_dit_parallel;\r\nmod traits;\r\nmod util;\r\n\r\npub use butterflies::*;\r\npub use naive::*;\r\npub use radix_2_bowers::*;\r\npub use radix_2_dit::*;\r\npub use radix_2_dit_parallel::*;\r\npub use traits::*;\r\npub use util::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","naive.rs"],"content":"use alloc::vec;\r\n\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::TwoAdicSubgroupDft;\r\n\r\n#[derive(Default, Clone, Debug)]\r\npub struct NaiveDft;\r\n\r\nimpl\u003cF: TwoAdicField\u003e TwoAdicSubgroupDft\u003cF\u003e for NaiveDft {\r\n    type Evaluations = RowMajorMatrix\u003cF\u003e;\r\n    fn dft_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let w = mat.width();\r\n        let h = mat.height();\r\n        let log_h = log2_strict_usize(h);\r\n        let g = F::two_adic_generator(log_h);\r\n\r\n        let mut res = RowMajorMatrix::new(vec![F::ZERO; w * h], w);\r\n        for (res_r, point) in g.powers().take(h).enumerate() {\r\n            for (src_r, point_power) in point.powers().take(h).enumerate() {\r\n                for c in 0..w {\r\n                    res.values[res_r * w + c] += point_power * mat.values[src_r * w + c]\r\n                }\r\n            }\r\n        }\r\n\r\n        res\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_field::{Field, PrimeCharacteristicRing};\r\n    use p3_goldilocks::Goldilocks;\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use rand::thread_rng;\r\n\r\n    use crate::{NaiveDft, TwoAdicSubgroupDft};\r\n\r\n    #[test]\r\n    fn basic() {\r\n        type F = BabyBear;\r\n\r\n        // A few polynomials:\r\n        // 5 + 4x\r\n        // 2 + 3x\r\n        // 0\r\n        let mat = RowMajorMatrix::new(\r\n            vec![\r\n                F::from_u8(5),\r\n                F::from_u8(2),\r\n                F::ZERO,\r\n                F::from_u8(4),\r\n                F::from_u8(3),\r\n                F::ZERO,\r\n            ],\r\n            3,\r\n        );\r\n\r\n        let dft = NaiveDft.dft_batch(mat);\r\n        // Expected evaluations on {1, -1}:\r\n        // 9, 1\r\n        // 5, -1\r\n        // 0, 0\r\n        assert_eq!(\r\n            dft,\r\n            RowMajorMatrix::new(\r\n                vec![\r\n                    F::from_u8(9),\r\n                    F::from_u8(5),\r\n                    F::ZERO,\r\n                    F::ONE,\r\n                    F::NEG_ONE,\r\n                    F::ZERO,\r\n                ],\r\n                3,\r\n            )\r\n        )\r\n    }\r\n\r\n    #[test]\r\n    fn dft_idft_consistency() {\r\n        type F = Goldilocks;\r\n        let mut rng = thread_rng();\r\n        let original = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 3);\r\n        let dft = NaiveDft.dft_batch(original.clone());\r\n        let idft = NaiveDft.idft_batch(dft);\r\n        assert_eq!(original, idft);\r\n    }\r\n\r\n    #[test]\r\n    fn coset_dft_idft_consistency() {\r\n        type F = Goldilocks;\r\n        let generator = F::GENERATOR;\r\n        let mut rng = thread_rng();\r\n        let original = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 8, 3);\r\n        let dft = NaiveDft.coset_dft_batch(original.clone(), generator);\r\n        let idft = NaiveDft.coset_idft_batch(dft, generator);\r\n        assert_eq!(original, idft);\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":16,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":17,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":18,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":19,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":21,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":22,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":23,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":24,"address":[],"length":0,"stats":{"Line":10952754293765527046}},{"line":25,"address":[],"length":0,"stats":{"Line":17437937757179041286}},{"line":30,"address":[],"length":0,"stats":{"Line":6557241057451442536}}],"covered":11,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","radix_2_bowers.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{Field, Powers, TwoAdicField};\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixViewMut};\r\nuse p3_matrix::util::reverse_matrix_index_bits;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_strict_usize, reverse_bits, reverse_slice_index_bits};\r\nuse tracing::instrument;\r\n\r\nuse crate::butterflies::{Butterfly, DifButterfly, DitButterfly, TwiddleFreeButterfly};\r\nuse crate::util::divide_by_height;\r\nuse crate::TwoAdicSubgroupDft;\r\n\r\n/// The Bowers G FFT algorithm.\r\n/// See: \"Improved Twiddle Access for Fast Fourier Transforms\"\r\n#[derive(Default, Clone)]\r\npub struct Radix2Bowers;\r\n\r\nimpl\u003cF: TwoAdicField\u003e TwoAdicSubgroupDft\u003cF\u003e for Radix2Bowers {\r\n    type Evaluations = RowMajorMatrix\u003cF\u003e;\r\n\r\n    fn dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        bowers_g(\u0026mut mat.as_view_mut());\r\n        mat\r\n    }\r\n\r\n    /// Compute the inverse DFT of each column in `mat`.\r\n    fn idft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        bowers_g_t(\u0026mut mat.as_view_mut());\r\n        divide_by_height(\u0026mut mat);\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        mat\r\n    }\r\n\r\n    fn lde_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e, added_bits: usize) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        bowers_g_t(\u0026mut mat.as_view_mut());\r\n        divide_by_height(\u0026mut mat);\r\n        mat = mat.bit_reversed_zero_pad(added_bits);\r\n        bowers_g(\u0026mut mat.as_view_mut());\r\n        mat\r\n    }\r\n\r\n    #[instrument(skip_all, fields(dims = %mat.dimensions(), added_bits))]\r\n    fn coset_lde_batch(\r\n        \u0026self,\r\n        mut mat: RowMajorMatrix\u003cF\u003e,\r\n        added_bits: usize,\r\n        shift: F,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let h = mat.height();\r\n        // If F isn't a PrimeField, (and is thus an extension field) it's much cheaper to\r\n        // invert in F::PrimeSubfield.\r\n        let h_inv_subfield = F::PrimeSubfield::from_int(h).inverse();\r\n        let h_inv = F::from_prime_subfield(h_inv_subfield);\r\n\r\n        bowers_g_t(\u0026mut mat.as_view_mut());\r\n\r\n        // Rescale coefficients in two ways:\r\n        // - divide by height (since we're doing an inverse DFT)\r\n        // - multiply by powers of the coset shift (see default coset LDE impl for an explanation)\r\n        let weights = Powers {\r\n            base: shift,\r\n            current: h_inv,\r\n        }\r\n        .take(h);\r\n        for (row, weight) in weights.enumerate() {\r\n            // reverse_bits because mat is encoded in bit-reversed order\r\n            mat.scale_row(reverse_bits(row, h), weight);\r\n        }\r\n\r\n        mat = mat.bit_reversed_zero_pad(added_bits);\r\n\r\n        bowers_g(\u0026mut mat.as_view_mut());\r\n\r\n        mat\r\n    }\r\n}\r\n\r\n/// Executes the Bowers G network. This is like a DFT, except it assumes the input is in\r\n/// bit-reversed order.\r\nfn bowers_g\u003cF: TwoAdicField\u003e(mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e) {\r\n    let h = mat.height();\r\n    let log_h = log2_strict_usize(h);\r\n\r\n    let root = F::two_adic_generator(log_h);\r\n    let mut twiddles: Vec\u003c_\u003e = root.powers().take(h / 2).map(DifButterfly).collect();\r\n    reverse_slice_index_bits(\u0026mut twiddles);\r\n\r\n    let log_h = log2_strict_usize(mat.height());\r\n    for log_half_block_size in 0..log_h {\r\n        butterfly_layer(mat, 1 \u003c\u003c log_half_block_size, \u0026twiddles)\r\n    }\r\n}\r\n\r\n/// Executes the Bowers G^T network. This is like an inverse DFT, except we skip rescaling by\r\n/// 1/height, and the output is bit-reversed.\r\nfn bowers_g_t\u003cF: TwoAdicField\u003e(mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e) {\r\n    let h = mat.height();\r\n    let log_h = log2_strict_usize(h);\r\n\r\n    let root_inv = F::two_adic_generator(log_h).inverse();\r\n    let mut twiddles: Vec\u003c_\u003e = root_inv.powers().take(h / 2).map(DitButterfly).collect();\r\n    reverse_slice_index_bits(\u0026mut twiddles);\r\n\r\n    let log_h = log2_strict_usize(mat.height());\r\n    for log_half_block_size in (0..log_h).rev() {\r\n        butterfly_layer(mat, 1 \u003c\u003c log_half_block_size, \u0026twiddles)\r\n    }\r\n}\r\n\r\nfn butterfly_layer\u003cF: Field, B: Butterfly\u003cF\u003e\u003e(\r\n    mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e,\r\n    half_block_size: usize,\r\n    twiddles: \u0026[B],\r\n) {\r\n    mat.par_row_chunks_exact_mut(2 * half_block_size)\r\n        .enumerate()\r\n        .for_each(|(block, mut chunks)| {\r\n            let (mut hi_chunks, mut lo_chunks) = chunks.split_rows_mut(half_block_size);\r\n            hi_chunks\r\n                .par_rows_mut()\r\n                .zip(lo_chunks.par_rows_mut())\r\n                .for_each(|(hi_chunk, lo_chunk)| {\r\n                    if block == 0 {\r\n                        TwiddleFreeButterfly.apply_to_rows(hi_chunk, lo_chunk)\r\n                    } else {\r\n                        twiddles[block].apply_to_rows(hi_chunk, lo_chunk);\r\n                    }\r\n                });\r\n        });\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":25,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":26,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":27,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":31,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":32,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":33,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":34,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":35,"address":[],"length":0,"stats":{"Line":6413125869375586304}},{"line":38,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":39,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":40,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":41,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":42,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":43,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":85,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":86,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":88,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":89,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":90,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":92,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":93,"address":[],"length":0,"stats":{"Line":10592466323575406592}},{"line":94,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":100,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":101,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":102,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":104,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":105,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":106,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":108,"address":[],"length":0,"stats":{"Line":8574853690513424384}},{"line":109,"address":[],"length":0,"stats":{"Line":7493989779944505344}},{"line":110,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":114,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":119,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":121,"address":[],"length":0,"stats":{"Line":864691128455135326}},{"line":122,"address":[],"length":0,"stats":{"Line":864691128455135329}},{"line":123,"address":[],"length":0,"stats":{"Line":864691128455135329}},{"line":124,"address":[],"length":0,"stats":{"Line":864691128455135329}},{"line":125,"address":[],"length":0,"stats":{"Line":864691128455135329}},{"line":126,"address":[],"length":0,"stats":{"Line":11096869481840902434}},{"line":127,"address":[],"length":0,"stats":{"Line":10232178353385767105}},{"line":128,"address":[],"length":0,"stats":{"Line":864691128455136198}},{"line":130,"address":[],"length":0,"stats":{"Line":4179340454199820027}}],"covered":44,"coverable":54},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","radix_2_dit.rs"],"content":"use alloc::collections::BTreeMap;\r\nuse alloc::vec::Vec;\r\nuse core::cell::RefCell;\r\n\r\nuse p3_field::{Field, TwoAdicField};\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixViewMut};\r\nuse p3_matrix::util::reverse_matrix_index_bits;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::butterflies::{Butterfly, DitButterfly, TwiddleFreeButterfly};\r\nuse crate::TwoAdicSubgroupDft;\r\n\r\n/// The DIT FFT algorithm.\r\n#[derive(Default, Clone, Debug)]\r\npub struct Radix2Dit\u003cF: TwoAdicField\u003e {\r\n    /// Memoized twiddle factors for each length log_n.\r\n    twiddles: RefCell\u003cBTreeMap\u003cusize, Vec\u003cF\u003e\u003e\u003e,\r\n}\r\n\r\nimpl\u003cF: TwoAdicField\u003e TwoAdicSubgroupDft\u003cF\u003e for Radix2Dit\u003cF\u003e {\r\n    type Evaluations = RowMajorMatrix\u003cF\u003e;\r\n\r\n    fn dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let h = mat.height();\r\n        let log_h = log2_strict_usize(h);\r\n\r\n        // Compute twiddle factors, or take memoized ones if already available.\r\n        let mut twiddles_ref_mut = self.twiddles.borrow_mut();\r\n        let twiddles = twiddles_ref_mut.entry(log_h).or_insert_with(|| {\r\n            let root = F::two_adic_generator(log_h);\r\n            root.powers().take(1 \u003c\u003c log_h).collect()\r\n        });\r\n\r\n        // DIT butterfly\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        for layer in 0..log_h {\r\n            dit_layer(\u0026mut mat.as_view_mut(), layer, twiddles);\r\n        }\r\n        mat\r\n    }\r\n}\r\n\r\n/// One layer of a DIT butterfly network.\r\nfn dit_layer\u003cF: Field\u003e(mat: \u0026mut RowMajorMatrixViewMut\u003c'_, F\u003e, layer: usize, twiddles: \u0026[F]) {\r\n    let h = mat.height();\r\n    let log_h = log2_strict_usize(h);\r\n    let layer_rev = log_h - 1 - layer;\r\n\r\n    let half_block_size = 1 \u003c\u003c layer;\r\n    let block_size = half_block_size * 2;\r\n\r\n    mat.par_row_chunks_exact_mut(block_size)\r\n        .for_each(|mut block_chunks| {\r\n            let (mut hi_chunks, mut lo_chunks) = block_chunks.split_rows_mut(half_block_size);\r\n            hi_chunks\r\n                .par_rows_mut()\r\n                .zip(lo_chunks.par_rows_mut())\r\n                .enumerate()\r\n                .for_each(|(ind, (hi_chunk, lo_chunk))| {\r\n                    if ind == 0 {\r\n                        TwiddleFreeButterfly.apply_to_rows(hi_chunk, lo_chunk)\r\n                    } else {\r\n                        DitButterfly(twiddles[ind \u003c\u003c layer_rev]).apply_to_rows(hi_chunk, lo_chunk)\r\n                    }\r\n                });\r\n        });\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":26,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":27,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":30,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":31,"address":[],"length":0,"stats":{"Line":7277816997830721736}},{"line":32,"address":[],"length":0,"stats":{"Line":720575940379279560}},{"line":33,"address":[],"length":0,"stats":{"Line":720575940379279560}},{"line":37,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":38,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":39,"address":[],"length":0,"stats":{"Line":17437937757178560512}},{"line":41,"address":[],"length":0,"stats":{"Line":6557241057451442180}},{"line":46,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":47,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":48,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":49,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":51,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":52,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":54,"address":[],"length":0,"stats":{"Line":17437937757178560515}},{"line":55,"address":[],"length":0,"stats":{"Line":14051230837395947525}},{"line":56,"address":[],"length":0,"stats":{"Line":15060037153926938626}},{"line":57,"address":[],"length":0,"stats":{"Line":15060037153926938626}},{"line":58,"address":[],"length":0,"stats":{"Line":15060037153926938626}},{"line":59,"address":[],"length":0,"stats":{"Line":15060037153926938626}},{"line":60,"address":[],"length":0,"stats":{"Line":15060037153926938626}},{"line":61,"address":[],"length":0,"stats":{"Line":12538021362599461065}},{"line":62,"address":[],"length":0,"stats":{"Line":15924728282382074055}},{"line":63,"address":[],"length":0,"stats":{"Line":15060037153926939629}},{"line":65,"address":[],"length":0,"stats":{"Line":17726168133330271251}}],"covered":28,"coverable":28},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","radix_2_dit_parallel.rs"],"content":"use alloc::collections::BTreeMap;\r\nuse alloc::slice;\r\nuse alloc::vec::Vec;\r\nuse core::cell::RefCell;\r\nuse core::mem::{transmute, MaybeUninit};\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{Field, Powers, TwoAdicField};\r\nuse p3_matrix::bitrev::{BitReversableMatrix, BitReversalPerm, BitReversedMatrixView};\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixView, RowMajorMatrixViewMut};\r\nuse p3_matrix::util::reverse_matrix_index_bits;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_strict_usize, reverse_bits_len, reverse_slice_index_bits};\r\nuse tracing::{debug_span, instrument};\r\n\r\nuse crate::butterflies::{Butterfly, DitButterfly};\r\nuse crate::TwoAdicSubgroupDft;\r\n\r\n/// A parallel FFT algorithm which divides a butterfly network's layers into two halves.\r\n///\r\n/// For the first half, we apply a butterfly network with smaller blocks in earlier layers,\r\n/// i.e. either DIT or Bowers G. Then we bit-reverse, and for the second half, we continue executing\r\n/// the same network but in bit-reversed order. This way we're always working with small blocks,\r\n/// so within each half, we can have a certain amount of parallelism with no cross-thread\r\n/// communication.\r\n#[derive(Default, Clone, Debug)]\r\npub struct Radix2DitParallel\u003cF\u003e {\r\n    /// Twiddles based on roots of unity, used in the forward DFT.\r\n    twiddles: RefCell\u003cBTreeMap\u003cusize, VectorPair\u003cF\u003e\u003e\u003e,\r\n\r\n    /// A map from `(log_h, shift)` to forward DFT twiddles with that coset shift baked in.\r\n    #[allow(clippy::type_complexity)]\r\n    coset_twiddles: RefCell\u003cBTreeMap\u003c(usize, F), Vec\u003cVec\u003cF\u003e\u003e\u003e\u003e,\r\n\r\n    /// Twiddles based on inverse roots of unity, used in the inverse DFT.\r\n    inverse_twiddles: RefCell\u003cBTreeMap\u003cusize, VectorPair\u003cF\u003e\u003e\u003e,\r\n}\r\n\r\n/// A pair of vectors, one with twiddle factors in their natural order, the other bit-reversed.\r\n#[derive(Default, Clone, Debug)]\r\nstruct VectorPair\u003cF\u003e {\r\n    twiddles: Vec\u003cF\u003e,\r\n    bitrev_twiddles: Vec\u003cF\u003e,\r\n}\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn compute_twiddles\u003cF: TwoAdicField + Ord\u003e(log_h: usize) -\u003e VectorPair\u003cF\u003e {\r\n    let half_h = (1 \u003c\u003c log_h) \u003e\u003e 1;\r\n    let root = F::two_adic_generator(log_h);\r\n    let twiddles: Vec\u003cF\u003e = root.powers().take(half_h).collect();\r\n    let mut bit_reversed_twiddles = twiddles.clone();\r\n    reverse_slice_index_bits(\u0026mut bit_reversed_twiddles);\r\n    VectorPair {\r\n        twiddles,\r\n        bitrev_twiddles: bit_reversed_twiddles,\r\n    }\r\n}\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn compute_coset_twiddles\u003cF: TwoAdicField + Ord\u003e(log_h: usize, shift: F) -\u003e Vec\u003cVec\u003cF\u003e\u003e {\r\n    // In general either div_floor or div_ceil would work, but here we prefer div_ceil because it\r\n    // lets us assume below that the \"first half\" of the network has at least one layer of\r\n    // butterflies, even in the case of log_h = 1.\r\n    let mid = log_h.div_ceil(2);\r\n    let h = 1 \u003c\u003c log_h;\r\n    let root = F::two_adic_generator(log_h);\r\n\r\n    (0..log_h)\r\n        .map(|layer| {\r\n            let shift_power = shift.exp_power_of_2(layer);\r\n            let powers = Powers {\r\n                base: root.exp_power_of_2(layer),\r\n                current: shift_power,\r\n            };\r\n            let mut twiddles: Vec\u003c_\u003e = powers.take(h \u003e\u003e (layer + 1)).collect();\r\n            let layer_rev = log_h - 1 - layer;\r\n            if layer_rev \u003e= mid {\r\n                reverse_slice_index_bits(\u0026mut twiddles);\r\n            }\r\n            twiddles\r\n        })\r\n        .collect()\r\n}\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn compute_inverse_twiddles\u003cF: TwoAdicField + Ord\u003e(log_h: usize) -\u003e VectorPair\u003cF\u003e {\r\n    let half_h = (1 \u003c\u003c log_h) \u003e\u003e 1;\r\n    let root_inv = F::two_adic_generator(log_h).inverse();\r\n    let twiddles: Vec\u003cF\u003e = root_inv.powers().take(half_h).collect();\r\n    let mut bit_reversed_twiddles = twiddles.clone();\r\n\r\n    // In the middle of the coset LDE, we're in bit-reversed order.\r\n    reverse_slice_index_bits(\u0026mut bit_reversed_twiddles);\r\n\r\n    VectorPair {\r\n        twiddles,\r\n        bitrev_twiddles: bit_reversed_twiddles,\r\n    }\r\n}\r\n\r\nimpl\u003cF: TwoAdicField + Ord\u003e TwoAdicSubgroupDft\u003cF\u003e for Radix2DitParallel\u003cF\u003e {\r\n    type Evaluations = BitReversedMatrixView\u003cRowMajorMatrix\u003cF\u003e\u003e;\r\n\r\n    fn dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e) -\u003e Self::Evaluations {\r\n        let h = mat.height();\r\n        let log_h = log2_strict_usize(h);\r\n\r\n        // Compute twiddle factors, or take memoized ones if already available.\r\n        let mut twiddles_ref_mut = self.twiddles.borrow_mut();\r\n        let twiddles = twiddles_ref_mut\r\n            .entry(log_h)\r\n            .or_insert_with(|| compute_twiddles(log_h));\r\n\r\n        let mid = log_h.div_ceil(2);\r\n\r\n        // The first half looks like a normal DIT.\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        first_half(\u0026mut mat, mid, \u0026twiddles.twiddles);\r\n\r\n        // For the second half, we flip the DIT, working in bit-reversed order.\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        second_half(\u0026mut mat, mid, \u0026twiddles.bitrev_twiddles, None);\r\n\r\n        mat.bit_reverse_rows()\r\n    }\r\n\r\n    #[instrument(skip_all, fields(dims = %mat.dimensions(), added_bits = added_bits))]\r\n    fn coset_lde_batch(\r\n        \u0026self,\r\n        mut mat: RowMajorMatrix\u003cF\u003e,\r\n        added_bits: usize,\r\n        shift: F,\r\n    ) -\u003e Self::Evaluations {\r\n        let w = mat.width;\r\n        let h = mat.height();\r\n        let log_h = log2_strict_usize(h);\r\n        let mid = log_h.div_ceil(2);\r\n\r\n        let mut inverse_twiddles_ref_mut = self.inverse_twiddles.borrow_mut();\r\n        let inverse_twiddles = inverse_twiddles_ref_mut\r\n            .entry(log_h)\r\n            .or_insert_with(|| compute_inverse_twiddles(log_h));\r\n\r\n        // The first half looks like a normal DIT.\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        first_half(\u0026mut mat, mid, \u0026inverse_twiddles.twiddles);\r\n\r\n        // For the second half, we flip the DIT, working in bit-reversed order.\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        // We'll also scale by 1/h, as per the usual inverse DFT algorithm.\r\n        // If F isn't a PrimeField, (and is thus an extension field) it's much cheaper to\r\n        // invert in F::PrimeSubfield.\r\n        let h_inv_subfield = F::PrimeSubfield::from_int(h).try_inverse();\r\n        let scale = h_inv_subfield.map(F::from_prime_subfield);\r\n        second_half(\u0026mut mat, mid, \u0026inverse_twiddles.bitrev_twiddles, scale);\r\n        // We skip the final bit-reversal, since the next FFT expects bit-reversed input.\r\n\r\n        let lde_elems = w * (h \u003c\u003c added_bits);\r\n        let elems_to_add = lde_elems - w * h;\r\n        debug_span!(\"reserve_exact\").in_scope(|| mat.values.reserve_exact(elems_to_add));\r\n\r\n        let g_big = F::two_adic_generator(log_h + added_bits);\r\n\r\n        let mat_ptr = mat.values.as_mut_ptr();\r\n        let rest_ptr = unsafe { (mat_ptr as *mut MaybeUninit\u003cF\u003e).add(w * h) };\r\n        let first_slice: \u0026mut [F] = unsafe { slice::from_raw_parts_mut(mat_ptr, w * h) };\r\n        let rest_slice: \u0026mut [MaybeUninit\u003cF\u003e] =\r\n            unsafe { slice::from_raw_parts_mut(rest_ptr, lde_elems - w * h) };\r\n        let mut first_coset_mat = RowMajorMatrixViewMut::new(first_slice, w);\r\n        let mut rest_cosets_mat = rest_slice\r\n            .chunks_exact_mut(w * h)\r\n            .map(|slice| RowMajorMatrixViewMut::new(slice, w))\r\n            .collect_vec();\r\n\r\n        for coset_idx in 1..(1 \u003c\u003c added_bits) {\r\n            let total_shift = g_big.exp_u64(coset_idx as u64) * shift;\r\n            let coset_idx = reverse_bits_len(coset_idx, added_bits);\r\n            let dest = \u0026mut rest_cosets_mat[coset_idx - 1]; // - 1 because we removed the first matrix.\r\n            coset_dft_oop(self, \u0026first_coset_mat.as_view(), dest, total_shift);\r\n        }\r\n\r\n        // Now run a forward DFT on the very first coset, this time in-place.\r\n        coset_dft(self, \u0026mut first_coset_mat.as_view_mut(), shift);\r\n\r\n        // SAFETY: We wrote all values above.\r\n        unsafe {\r\n            mat.values.set_len(lde_elems);\r\n        }\r\n        BitReversalPerm::new_view(mat)\r\n    }\r\n}\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn coset_dft\u003cF: TwoAdicField + Ord\u003e(\r\n    dft: \u0026Radix2DitParallel\u003cF\u003e,\r\n    mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e,\r\n    shift: F,\r\n) {\r\n    let log_h = log2_strict_usize(mat.height());\r\n    let mid = log_h.div_ceil(2);\r\n\r\n    let mut twiddles_ref_mut = dft.coset_twiddles.borrow_mut();\r\n    let twiddles = twiddles_ref_mut\r\n        .entry((log_h, shift))\r\n        .or_insert_with(|| compute_coset_twiddles(log_h, shift));\r\n\r\n    // The first half looks like a normal DIT.\r\n    first_half_general(mat, mid, twiddles);\r\n\r\n    // For the second half, we flip the DIT, working in bit-reversed order.\r\n    reverse_matrix_index_bits(mat);\r\n\r\n    second_half_general(mat, mid, twiddles);\r\n}\r\n\r\n/// Like `coset_dft`, except out-of-place.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn coset_dft_oop\u003cF: TwoAdicField + Ord\u003e(\r\n    dft: \u0026Radix2DitParallel\u003cF\u003e,\r\n    src: \u0026RowMajorMatrixView\u003cF\u003e,\r\n    dst_maybe: \u0026mut RowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e,\r\n    shift: F,\r\n) {\r\n    assert_eq!(src.dimensions(), dst_maybe.dimensions());\r\n\r\n    let log_h = log2_strict_usize(dst_maybe.height());\r\n\r\n    if log_h == 0 {\r\n        // This is an edge case where first_half_general_oop doesn't work, as it expects there to be\r\n        // at least one layer in the network, so we just copy instead.\r\n        let src_maybe = unsafe {\r\n            transmute::\u003c\u0026RowMajorMatrixView\u003cF\u003e, \u0026RowMajorMatrixView\u003cMaybeUninit\u003cF\u003e\u003e\u003e(src)\r\n        };\r\n        dst_maybe.copy_from(src_maybe);\r\n        return;\r\n    }\r\n\r\n    let mid = log_h.div_ceil(2);\r\n\r\n    let mut twiddles_ref_mut = dft.coset_twiddles.borrow_mut();\r\n    let twiddles = twiddles_ref_mut\r\n        .entry((log_h, shift))\r\n        .or_insert_with(|| compute_coset_twiddles(log_h, shift));\r\n\r\n    // The first half looks like a normal DIT.\r\n    first_half_general_oop(src, dst_maybe, mid, twiddles);\r\n\r\n    // dst is now initialized.\r\n    let dst = unsafe {\r\n        transmute::\u003c\u0026mut RowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e, \u0026mut RowMajorMatrixViewMut\u003cF\u003e\u003e(\r\n            dst_maybe,\r\n        )\r\n    };\r\n\r\n    // For the second half, we flip the DIT, working in bit-reversed order.\r\n    reverse_matrix_index_bits(dst);\r\n\r\n    second_half_general(dst, mid, twiddles);\r\n}\r\n\r\n/// This can be used as the first half of a DIT butterfly network.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn first_half\u003cF: Field\u003e(mat: \u0026mut RowMajorMatrix\u003cF\u003e, mid: usize, twiddles: \u0026[F]) {\r\n    let log_h = log2_strict_usize(mat.height());\r\n\r\n    // max block size: 2^mid\r\n    mat.par_row_chunks_exact_mut(1 \u003c\u003c mid)\r\n        .for_each(|mut submat| {\r\n            let mut backwards = false;\r\n            for layer in 0..mid {\r\n                let layer_rev = log_h - 1 - layer;\r\n                let layer_pow = 1 \u003c\u003c layer_rev;\r\n                dit_layer(\r\n                    \u0026mut submat,\r\n                    layer,\r\n                    twiddles.iter().copied().step_by(layer_pow),\r\n                    backwards,\r\n                );\r\n                backwards = !backwards;\r\n            }\r\n        });\r\n}\r\n\r\n/// Like `first_half`, except supporting different twiddle factors per layer, enabling coset shifts\r\n/// to be baked into them.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn first_half_general\u003cF: Field\u003e(\r\n    mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e,\r\n    mid: usize,\r\n    twiddles: \u0026[Vec\u003cF\u003e],\r\n) {\r\n    let log_h = log2_strict_usize(mat.height());\r\n    mat.par_row_chunks_exact_mut(1 \u003c\u003c mid)\r\n        .for_each(|mut submat| {\r\n            let mut backwards = false;\r\n            for layer in 0..mid {\r\n                let layer_rev = log_h - 1 - layer;\r\n                dit_layer(\r\n                    \u0026mut submat,\r\n                    layer,\r\n                    twiddles[layer_rev].iter().copied(),\r\n                    backwards,\r\n                );\r\n                backwards = !backwards;\r\n            }\r\n        });\r\n}\r\n\r\n/// Like `first_half_general`, except out-of-place.\r\n///\r\n/// Assumes there's at least one layer in the network, i.e. `src.height() \u003e 1`.\r\n/// Undefined behavior otherwise.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn first_half_general_oop\u003cF: Field\u003e(\r\n    src: \u0026RowMajorMatrixView\u003cF\u003e,\r\n    dst_maybe: \u0026mut RowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e,\r\n    mid: usize,\r\n    twiddles: \u0026[Vec\u003cF\u003e],\r\n) {\r\n    let log_h = log2_strict_usize(src.height());\r\n    src.par_row_chunks_exact(1 \u003c\u003c mid)\r\n        .zip(dst_maybe.par_row_chunks_exact_mut(1 \u003c\u003c mid))\r\n        .for_each(|(src_submat, mut dst_submat_maybe)| {\r\n            debug_assert_eq!(src_submat.dimensions(), dst_submat_maybe.dimensions());\r\n\r\n            // The first layer is special, done out-of-place.\r\n            // (Recall from the mid definition that there must be at least one layer here.)\r\n            let layer_rev = log_h - 1;\r\n            dit_layer_oop(\r\n                \u0026src_submat,\r\n                \u0026mut dst_submat_maybe,\r\n                0,\r\n                twiddles[layer_rev].iter().copied(),\r\n            );\r\n\r\n            // submat is now initialized.\r\n            let mut dst_submat = unsafe {\r\n                transmute::\u003cRowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e, RowMajorMatrixViewMut\u003cF\u003e\u003e(\r\n                    dst_submat_maybe,\r\n                )\r\n            };\r\n\r\n            // Subsequent layers.\r\n            let mut backwards = true;\r\n            for layer in 1..mid {\r\n                let layer_rev = log_h - 1 - layer;\r\n                dit_layer(\r\n                    \u0026mut dst_submat,\r\n                    layer,\r\n                    twiddles[layer_rev].iter().copied(),\r\n                    backwards,\r\n                );\r\n                backwards = !backwards;\r\n            }\r\n        });\r\n}\r\n\r\n/// This can be used as the second half of a DIT butterfly network. It works in bit-reversed order.\r\n///\r\n/// The optional `scale` parameter is used to scale the matrix by a constant factor. Normally that\r\n/// would be a separate step, but it's best to merge it into a butterfly network a just to avoid a\r\n/// separate pass through main memory.\r\n#[instrument(level = \"debug\", skip_all)]\r\n#[inline(always)] // To avoid branch on scale\r\nfn second_half\u003cF: Field\u003e(\r\n    mat: \u0026mut RowMajorMatrix\u003cF\u003e,\r\n    mid: usize,\r\n    twiddles_rev: \u0026[F],\r\n    scale: Option\u003cF\u003e,\r\n) {\r\n    let log_h = log2_strict_usize(mat.height());\r\n\r\n    // max block size: 2^(log_h - mid)\r\n    mat.par_row_chunks_exact_mut(1 \u003c\u003c (log_h - mid))\r\n        .enumerate()\r\n        .for_each(|(thread, mut submat)| {\r\n            let mut backwards = false;\r\n            if let Some(scale) = scale {\r\n                submat.scale(scale);\r\n            }\r\n            for layer in mid..log_h {\r\n                let first_block = thread \u003c\u003c (layer - mid);\r\n                dit_layer_rev(\r\n                    \u0026mut submat,\r\n                    log_h,\r\n                    layer,\r\n                    twiddles_rev[first_block..].iter().copied(),\r\n                    backwards,\r\n                );\r\n                backwards = !backwards;\r\n            }\r\n        });\r\n}\r\n\r\n/// Like `second_half`, except supporting different twiddle factors per layer, enabling coset shifts\r\n/// to be baked into them.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn second_half_general\u003cF: Field\u003e(\r\n    mat: \u0026mut RowMajorMatrixViewMut\u003cF\u003e,\r\n    mid: usize,\r\n    twiddles_rev: \u0026[Vec\u003cF\u003e],\r\n) {\r\n    let log_h = log2_strict_usize(mat.height());\r\n    mat.par_row_chunks_exact_mut(1 \u003c\u003c (log_h - mid))\r\n        .enumerate()\r\n        .for_each(|(thread, mut submat)| {\r\n            let mut backwards = false;\r\n            for layer in mid..log_h {\r\n                let layer_rev = log_h - 1 - layer;\r\n                let first_block = thread \u003c\u003c (layer - mid);\r\n                dit_layer_rev(\r\n                    \u0026mut submat,\r\n                    log_h,\r\n                    layer,\r\n                    twiddles_rev[layer_rev][first_block..].iter().copied(),\r\n                    backwards,\r\n                );\r\n                backwards = !backwards;\r\n            }\r\n        });\r\n}\r\n\r\n/// One layer of a DIT butterfly network.\r\nfn dit_layer\u003cF: Field\u003e(\r\n    submat: \u0026mut RowMajorMatrixViewMut\u003c'_, F\u003e,\r\n    layer: usize,\r\n    twiddles: impl Iterator\u003cItem = F\u003e + Clone,\r\n    backwards: bool,\r\n) {\r\n    let half_block_size = 1 \u003c\u003c layer;\r\n    let block_size = half_block_size * 2;\r\n    let width = submat.width();\r\n    debug_assert!(submat.height() \u003e= block_size);\r\n\r\n    let process_block = |block: \u0026mut [F]| {\r\n        let (lows, highs) = block.split_at_mut(half_block_size * width);\r\n\r\n        for (lo, hi, twiddle) in izip!(\r\n            lows.chunks_mut(width),\r\n            highs.chunks_mut(width),\r\n            twiddles.clone()\r\n        ) {\r\n            DitButterfly(twiddle).apply_to_rows(lo, hi);\r\n        }\r\n    };\r\n\r\n    let blocks = submat.values.chunks_mut(block_size * width);\r\n    if backwards {\r\n        for block in blocks.rev() {\r\n            process_block(block);\r\n        }\r\n    } else {\r\n        for block in blocks {\r\n            process_block(block);\r\n        }\r\n    }\r\n}\r\n\r\n/// One layer of a DIT butterfly network.\r\nfn dit_layer_oop\u003cF: Field\u003e(\r\n    src: \u0026RowMajorMatrixView\u003cF\u003e,\r\n    dst: \u0026mut RowMajorMatrixViewMut\u003c'_, MaybeUninit\u003cF\u003e\u003e,\r\n    layer: usize,\r\n    twiddles: impl Iterator\u003cItem = F\u003e + Clone,\r\n) {\r\n    debug_assert_eq!(src.dimensions(), dst.dimensions());\r\n    let half_block_size = 1 \u003c\u003c layer;\r\n    let block_size = half_block_size * 2;\r\n    let width = dst.width();\r\n    debug_assert!(dst.height() \u003e= block_size);\r\n\r\n    let src_chunks = src.values.chunks(block_size * width);\r\n    let dst_chunks = dst.values.chunks_mut(block_size * width);\r\n    for (src_block, dst_block) in src_chunks.zip(dst_chunks) {\r\n        let (src_lows, src_highs) = src_block.split_at(half_block_size * width);\r\n        let (dst_lows, dst_highs) = dst_block.split_at_mut(half_block_size * width);\r\n\r\n        for (src_lo, dst_lo, src_hi, dst_hi, twiddle) in izip!(\r\n            src_lows.chunks(width),\r\n            dst_lows.chunks_mut(width),\r\n            src_highs.chunks(width),\r\n            dst_highs.chunks_mut(width),\r\n            twiddles.clone()\r\n        ) {\r\n            DitButterfly(twiddle).apply_to_rows_oop(src_lo, dst_lo, src_hi, dst_hi);\r\n        }\r\n    }\r\n}\r\n\r\n/// Like `dit_layer`, except the matrix and twiddles are encoded in bit-reversed order.\r\n/// This can also be viewed as a layer of the Bowers G^T network.\r\nfn dit_layer_rev\u003cF: Field\u003e(\r\n    submat: \u0026mut RowMajorMatrixViewMut\u003c'_, F\u003e,\r\n    log_h: usize,\r\n    layer: usize,\r\n    twiddles_rev: impl DoubleEndedIterator\u003cItem = F\u003e + ExactSizeIterator,\r\n    backwards: bool,\r\n) {\r\n    let layer_rev = log_h - 1 - layer;\r\n\r\n    let half_block_size = 1 \u003c\u003c layer_rev;\r\n    let block_size = half_block_size * 2;\r\n    let width = submat.width();\r\n    debug_assert!(submat.height() \u003e= block_size);\r\n\r\n    let blocks_and_twiddles = submat\r\n        .values\r\n        .chunks_mut(block_size * width)\r\n        .zip(twiddles_rev);\r\n    if backwards {\r\n        for (block, twiddle) in blocks_and_twiddles.rev() {\r\n            let (lo, hi) = block.split_at_mut(half_block_size * width);\r\n            DitButterfly(twiddle).apply_to_rows(lo, hi)\r\n        }\r\n    } else {\r\n        for (block, twiddle) in blocks_and_twiddles {\r\n            let (lo, hi) = block.split_at_mut(half_block_size * width);\r\n            DitButterfly(twiddle).apply_to_rows(lo, hi)\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":72,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":73,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":74,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":75,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":77,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":78,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":79,"address":[],"length":0,"stats":{"Line":13402712491054596116}},{"line":80,"address":[],"length":0,"stats":{"Line":14267403619509731330}},{"line":82,"address":[],"length":0,"stats":{"Line":17582052945254416402}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":107,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":108,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":111,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":112,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":113,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":114,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":116,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":119,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":120,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":123,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":124,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":126,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":4827858800541172353}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":12610078956637388800}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":5836665117072162824}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":8791026472627208207}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":13330654897016668326}},{"line":271,"address":[],"length":0,"stats":{"Line":13330654897016668326}},{"line":272,"address":[],"length":0,"stats":{"Line":216172782113783994}},{"line":273,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":274,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":275,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":276,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":277,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":278,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":279,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":281,"address":[],"length":0,"stats":{"Line":11889503016258109450}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":6917529027641081902}},{"line":297,"address":[],"length":0,"stats":{"Line":6917529027641081902}},{"line":298,"address":[],"length":0,"stats":{"Line":12826251738751172660}},{"line":299,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":300,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":301,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":302,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":303,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":304,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":306,"address":[],"length":0,"stats":{"Line":12177733392409821187}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":326,"address":[],"length":0,"stats":{"Line":7926335344172072969}},{"line":330,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":331,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":332,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":333,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":334,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":335,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":339,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":340,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":341,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":346,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":347,"address":[],"length":0,"stats":{"Line":3170534137668829200}},{"line":348,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":349,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":350,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":351,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":352,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":353,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":355,"address":[],"length":0,"stats":{"Line":10808639105689190408}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":720575940379279370}},{"line":379,"address":[],"length":0,"stats":{"Line":720575940379279370}},{"line":380,"address":[],"length":0,"stats":{"Line":8574853690513424389}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":6196953087261802526}},{"line":384,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":385,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":386,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":387,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":388,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":389,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":390,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":392,"address":[],"length":0,"stats":{"Line":2738188573441261578}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":72057594037927939}},{"line":409,"address":[],"length":0,"stats":{"Line":72057594037927939}},{"line":410,"address":[],"length":0,"stats":{"Line":2377900603251621927}},{"line":411,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":412,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":413,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":414,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":415,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":416,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":417,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":418,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":420,"address":[],"length":0,"stats":{"Line":10376293541461622802}},{"line":426,"address":[],"length":0,"stats":{"Line":5476377146882523139}},{"line":432,"address":[],"length":0,"stats":{"Line":5476377146882523139}},{"line":433,"address":[],"length":0,"stats":{"Line":5476377146882523139}},{"line":434,"address":[],"length":0,"stats":{"Line":5476377146882523139}},{"line":435,"address":[],"length":0,"stats":{"Line":10952754293765046310}},{"line":437,"address":[],"length":0,"stats":{"Line":864691128455135315}},{"line":438,"address":[],"length":0,"stats":{"Line":13835058055282163792}},{"line":440,"address":[],"length":0,"stats":{"Line":7926335344172073333}},{"line":441,"address":[],"length":0,"stats":{"Line":13835058055282163792}},{"line":442,"address":[],"length":0,"stats":{"Line":13835058055282163792}},{"line":443,"address":[],"length":0,"stats":{"Line":13835058055282163792}},{"line":445,"address":[],"length":0,"stats":{"Line":12538021362599461157}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":8214565720323784808}},{"line":452,"address":[],"length":0,"stats":{"Line":9943947977234055183}},{"line":455,"address":[],"length":0,"stats":{"Line":1729382256910270530}},{"line":456,"address":[],"length":0,"stats":{"Line":5044031582654955552}},{"line":462,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":468,"address":[],"length":0,"stats":{"Line":7926335344172072969}},{"line":469,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":470,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":471,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":472,"address":[],"length":0,"stats":{"Line":7926335344172072969}},{"line":474,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":475,"address":[],"length":0,"stats":{"Line":13186539708940812289}},{"line":476,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":477,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":478,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":480,"address":[],"length":0,"stats":{"Line":4179340454199820304}},{"line":481,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":482,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":483,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":484,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":485,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":487,"address":[],"length":0,"stats":{"Line":11313042263954685960}},{"line":494,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":501,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":503,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":504,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":505,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":506,"address":[],"length":0,"stats":{"Line":7782220156096217239}},{"line":508,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":509,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":510,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":511,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":512,"address":[],"length":0,"stats":{"Line":13114482114902884398}},{"line":513,"address":[],"length":0,"stats":{"Line":288230376151711890}},{"line":514,"address":[],"length":0,"stats":{"Line":17870283321406128169}},{"line":515,"address":[],"length":0,"stats":{"Line":17870283321406128169}},{"line":518,"address":[],"length":0,"stats":{"Line":18302628885633695809}},{"line":519,"address":[],"length":0,"stats":{"Line":3026418949592973374}},{"line":520,"address":[],"length":0,"stats":{"Line":3026418949592973374}}],"covered":144,"coverable":229},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","traits.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::bitrev::BitReversableMatrix;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::util::swap_rows;\r\nuse p3_matrix::Matrix;\r\n\r\nuse crate::util::{coset_shift_cols, divide_by_height};\r\n\r\npub trait TwoAdicSubgroupDft\u003cF: TwoAdicField\u003e: Clone + Default {\r\n    // Effectively this is either RowMajorMatrix or BitReversedMatrixView\u003cRowMajorMatrix\u003e.\r\n    // Always owned.\r\n    type Evaluations: BitReversableMatrix\u003cF\u003e + 'static;\r\n\r\n    /// Compute the discrete Fourier transform (DFT) `vec`.\r\n    fn dft(\u0026self, vec: Vec\u003cF\u003e) -\u003e Vec\u003cF\u003e {\r\n        self.dft_batch(RowMajorMatrix::new_col(vec))\r\n            .to_row_major_matrix()\r\n            .values\r\n    }\r\n\r\n    /// Compute the discrete Fourier transform (DFT) of each column in `mat`.\r\n    /// This is the only method an implementer needs to define, all other\r\n    /// methods can be derived from this one.\r\n    fn dft_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e) -\u003e Self::Evaluations;\r\n\r\n    /// Compute the \"coset DFT\" of `vec`. This can be viewed as interpolation onto a coset of a\r\n    /// multiplicative subgroup, rather than the subgroup itself.\r\n    fn coset_dft(\u0026self, vec: Vec\u003cF\u003e, shift: F) -\u003e Vec\u003cF\u003e {\r\n        self.coset_dft_batch(RowMajorMatrix::new_col(vec), shift)\r\n            .to_row_major_matrix()\r\n            .values\r\n    }\r\n\r\n    /// Compute the \"coset DFT\" of each column in `mat`. This can be viewed as interpolation onto a\r\n    /// coset of a multiplicative subgroup, rather than the subgroup itself.\r\n    fn coset_dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e, shift: F) -\u003e Self::Evaluations {\r\n        // Observe that\r\n        //     y_i = \\sum_j c_j (s g^i)^j\r\n        //         = \\sum_j (c_j s^j) (g^i)^j\r\n        // which has the structure of an ordinary DFT, except each coefficient c_j is first replaced\r\n        // by c_j s^j.\r\n        coset_shift_cols(\u0026mut mat, shift);\r\n        self.dft_batch(mat)\r\n    }\r\n\r\n    /// Compute the inverse DFT of `vec`.\r\n    fn idft(\u0026self, vec: Vec\u003cF\u003e) -\u003e Vec\u003cF\u003e {\r\n        self.idft_batch(RowMajorMatrix::new(vec, 1)).values\r\n    }\r\n\r\n    /// Compute the inverse DFT of each column in `mat`.\r\n    fn idft_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let mut dft = self.dft_batch(mat).to_row_major_matrix();\r\n        let h = dft.height();\r\n\r\n        divide_by_height(\u0026mut dft);\r\n\r\n        for row in 1..h / 2 {\r\n            swap_rows(\u0026mut dft, row, h - row);\r\n        }\r\n\r\n        dft\r\n    }\r\n\r\n    /// Compute the \"coset iDFT\" of `vec`. This can be viewed as an inverse operation of\r\n    /// \"coset DFT\", that interpolates over a coset of a multiplicative subgroup, rather than\r\n    /// subgroup itself.\r\n    fn coset_idft(\u0026self, vec: Vec\u003cF\u003e, shift: F) -\u003e Vec\u003cF\u003e {\r\n        self.coset_idft_batch(RowMajorMatrix::new(vec, 1), shift)\r\n            .values\r\n    }\r\n\r\n    /// Compute the \"coset iDFT\" of each column in `mat`. This can be viewed as an inverse operation\r\n    /// of \"coset DFT\", that interpolates over a coset of a multiplicative subgroup, rather than the\r\n    /// subgroup itself.\r\n    fn coset_idft_batch(\u0026self, mut mat: RowMajorMatrix\u003cF\u003e, shift: F) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        mat = self.idft_batch(mat);\r\n        coset_shift_cols(\u0026mut mat, shift.inverse());\r\n        mat\r\n    }\r\n\r\n    /// Compute the low-degree extension of `vec` onto a larger subgroup.\r\n    fn lde(\u0026self, vec: Vec\u003cF\u003e, added_bits: usize) -\u003e Vec\u003cF\u003e {\r\n        self.lde_batch(RowMajorMatrix::new(vec, 1), added_bits)\r\n            .to_row_major_matrix()\r\n            .values\r\n    }\r\n\r\n    /// Compute the low-degree extension of each column in `mat` onto a larger subgroup.\r\n    fn lde_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e, added_bits: usize) -\u003e Self::Evaluations {\r\n        let mut coeffs = self.idft_batch(mat);\r\n        coeffs\r\n            .values\r\n            .resize(coeffs.values.len() \u003c\u003c added_bits, F::ZERO);\r\n        self.dft_batch(coeffs)\r\n    }\r\n\r\n    /// Compute the low-degree extension of each column in `mat` onto a coset of a larger subgroup.\r\n    fn coset_lde(\u0026self, vec: Vec\u003cF\u003e, added_bits: usize, shift: F) -\u003e Vec\u003cF\u003e {\r\n        self.coset_lde_batch(RowMajorMatrix::new(vec, 1), added_bits, shift)\r\n            .to_row_major_matrix()\r\n            .values\r\n    }\r\n\r\n    /// Compute the low-degree extension of each column in `mat` onto a coset of a larger subgroup.\r\n    fn coset_lde_batch(\r\n        \u0026self,\r\n        mat: RowMajorMatrix\u003cF\u003e,\r\n        added_bits: usize,\r\n        shift: F,\r\n    ) -\u003e Self::Evaluations {\r\n        let mut coeffs = self.idft_batch(mat);\r\n        // PANICS: possible panic if the new resized length overflows\r\n        coeffs.values.resize(\r\n            coeffs\r\n                .values\r\n                .len()\r\n                .checked_shl(added_bits.try_into().unwrap())\r\n                .unwrap(),\r\n            F::ZERO,\r\n        );\r\n        self.coset_dft_batch(coeffs, shift)\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":18,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":19,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":20,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":15204152342002794505}},{"line":44,"address":[],"length":0,"stats":{"Line":15204152342002794505}},{"line":45,"address":[],"length":0,"stats":{"Line":15204152342002794505}},{"line":49,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":50,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":54,"address":[],"length":0,"stats":{"Line":7638104968021803975}},{"line":55,"address":[],"length":0,"stats":{"Line":7638104968021803975}},{"line":56,"address":[],"length":0,"stats":{"Line":7638104968021803975}},{"line":58,"address":[],"length":0,"stats":{"Line":7638104968021803975}},{"line":60,"address":[],"length":0,"stats":{"Line":4179340454201263039}},{"line":61,"address":[],"length":0,"stats":{"Line":16717361816799281148}},{"line":64,"address":[],"length":0,"stats":{"Line":7638104968020361415}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":79,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":80,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":81,"address":[],"length":0,"stats":{"Line":7998392938210000896}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":93,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":94,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":95,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":96,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":97,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":102,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":114,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":116,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":117,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":118,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":119,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":120,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":121,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":122,"address":[],"length":0,"stats":{"Line":6989586621679009792}},{"line":124,"address":[],"length":0,"stats":{"Line":6989586621679009792}}],"covered":40,"coverable":51},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","dft","src","util.rs"],"content":"use core::borrow::BorrowMut;\r\n\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::Field;\r\nuse p3_matrix::dense::{DenseMatrix, DenseStorage, RowMajorMatrix};\r\nuse p3_matrix::Matrix;\r\nuse tracing::instrument;\r\n\r\n/// Divide each coefficient of the given matrix by its height.\r\n#[instrument(skip_all, fields(dims = %mat.dimensions()))]\r\npub fn divide_by_height\u003cF: Field, S: DenseStorage\u003cF\u003e + BorrowMut\u003c[F]\u003e\u003e(\r\n    mat: \u0026mut DenseMatrix\u003cF, S\u003e,\r\n) {\r\n    // If F isn't a PrimeField, (and is thus an extension field) it's much cheaper to\r\n    // invert in F::PrimeSubfield.\r\n    let h_inv_subfield = F::PrimeSubfield::from_int(mat.height()).inverse();\r\n    mat.scale(F::from_prime_subfield(h_inv_subfield))\r\n}\r\n\r\n/// Multiply each element of row `i` of `mat` by `shift**i`.\r\npub(crate) fn coset_shift_cols\u003cF: Field\u003e(mat: \u0026mut RowMajorMatrix\u003cF\u003e, shift: F) {\r\n    mat.rows_mut()\r\n        .zip(shift.powers())\r\n        .for_each(|(row, weight)| {\r\n            row.iter_mut().for_each(|coeff| {\r\n                *coeff *= weight;\r\n            })\r\n        });\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":4755801206503243791}},{"line":22,"address":[],"length":0,"stats":{"Line":4755801206503243791}},{"line":23,"address":[],"length":0,"stats":{"Line":4755801206503243791}},{"line":24,"address":[],"length":0,"stats":{"Line":16285016252571713551}},{"line":25,"address":[],"length":0,"stats":{"Line":1152921504606847030}},{"line":26,"address":[],"length":0,"stats":{"Line":8070450532247928886}}],"covered":6,"coverable":8},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","examples","prove_prime_field_31.rs"],"content":"use clap::Parser;\r\nuse p3_baby_bear::{BabyBear, GenericPoseidon2LinearLayersBabyBear, Poseidon2BabyBear};\r\nuse p3_blake3_air::Blake3Air;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_examples::airs::ProofObjective;\r\nuse p3_examples::dfts::DftChoice;\r\nuse p3_examples::parsers::{DftOptions, FieldOptions, MerkleHashOptions, ProofOptions};\r\nuse p3_examples::proofs::{\r\n    prove_m31_keccak, prove_m31_poseidon2, prove_monty31_keccak, prove_monty31_poseidon2,\r\n    report_result,\r\n};\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_keccak_air::KeccakAir;\r\nuse p3_koala_bear::{GenericPoseidon2LinearLayersKoalaBear, KoalaBear, Poseidon2KoalaBear};\r\nuse p3_mersenne_31::{GenericPoseidon2LinearLayersMersenne31, Mersenne31, Poseidon2Mersenne31};\r\nuse p3_monty_31::dft::RecursiveDft;\r\nuse p3_poseidon2_air::{RoundConstants, VectorizedPoseidon2Air};\r\nuse rand::thread_rng;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\n// General constants for constructing the Poseidon2 AIR.\r\nconst P2_WIDTH: usize = 16;\r\nconst P2_HALF_FULL_ROUNDS: usize = 4;\r\nconst P2_LOG_VECTOR_LEN: u8 = 3;\r\nconst P2_VECTOR_LEN: usize = 1 \u003c\u003c P2_LOG_VECTOR_LEN;\r\n\r\n#[derive(Parser, Debug)]\r\n#[command(version, about, long_about = None)]\r\nstruct Args {\r\n    /// The field to use for our proof.\r\n    #[arg(short, long, ignore_case = true, value_enum)]\r\n    field: FieldOptions,\r\n\r\n    /// What we are trying to prove.\r\n    #[arg(short, long, ignore_case = true, value_enum)]\r\n    objective: ProofOptions,\r\n\r\n    /// The log base 2 of the desired trace length.\r\n    #[arg(short, long)]\r\n    log_trace_length: u8,\r\n\r\n    /// The discrete fourier transform to use in the proof.\r\n    #[arg(short, long, ignore_case = true, value_enum, default_value_t = DftOptions::None)]\r\n    discrete_fourier_transform: DftOptions,\r\n\r\n    /// The hash function to use when assembling the Merkle tree.\r\n    #[arg(short, long, ignore_case = true, value_enum)]\r\n    merkle_hash: MerkleHashOptions,\r\n}\r\n\r\nfn main() {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    let args = Args::parse();\r\n\r\n    let trace_height = 1 \u003c\u003c args.log_trace_length;\r\n\r\n    let num_hashes = match args.objective {\r\n        ProofOptions::Blake3Permutations =\u003e {\r\n            println!(\"Proving 2^{} Blake-3 permutations\", {\r\n                args.log_trace_length\r\n            });\r\n            trace_height\r\n        }\r\n        ProofOptions::Poseidon2Permutations =\u003e {\r\n            println!(\"Proving 2^{} native Poseidon-2 permutations\", {\r\n                args.log_trace_length + P2_LOG_VECTOR_LEN\r\n            });\r\n            trace_height \u003c\u003c P2_LOG_VECTOR_LEN\r\n        }\r\n        ProofOptions::KeccakFPermutations =\u003e {\r\n            let num_hashes = trace_height / 24;\r\n            println!(\"Proving {num_hashes} Keccak-F permutations\");\r\n            num_hashes\r\n        }\r\n    };\r\n\r\n    match args.field {\r\n        FieldOptions::KoalaBear =\u003e {\r\n            type EF = BinomialExtensionField\u003cKoalaBear, 4\u003e;\r\n\r\n            let proof_goal = match args.objective {\r\n                ProofOptions::Blake3Permutations =\u003e ProofObjective::Blake3(Blake3Air {}),\r\n                ProofOptions::KeccakFPermutations =\u003e ProofObjective::Keccak(KeccakAir {}),\r\n                ProofOptions::Poseidon2Permutations =\u003e {\r\n                    let constants = RoundConstants::from_rng(\u0026mut thread_rng());\r\n\r\n                    // Field specific constants for constructing the Poseidon2 AIR.\r\n                    const SBOX_DEGREE: u64 = 3;\r\n                    const SBOX_REGISTERS: usize = 0;\r\n                    const PARTIAL_ROUNDS: usize = 20;\r\n\r\n                    let p2_air: VectorizedPoseidon2Air\u003c\r\n                        KoalaBear,\r\n                        GenericPoseidon2LinearLayersKoalaBear,\r\n                        P2_WIDTH,\r\n                        SBOX_DEGREE,\r\n                        SBOX_REGISTERS,\r\n                        P2_HALF_FULL_ROUNDS,\r\n                        PARTIAL_ROUNDS,\r\n                        P2_VECTOR_LEN,\r\n                    \u003e = VectorizedPoseidon2Air::new(constants);\r\n                    ProofObjective::Poseidon2(p2_air)\r\n                }\r\n            };\r\n\r\n            let dft = match args.discrete_fourier_transform {\r\n                DftOptions::RecursiveDft =\u003e DftChoice::Recursive(RecursiveDft::new(trace_height \u003c\u003c 1)),\r\n                DftOptions::Radix2DitParallel =\u003e DftChoice::Parallel(Radix2DitParallel::default()),\r\n                DftOptions::None =\u003e panic!(\"Please specify what dft to use. Options are recursive-dft and radix-2-dit-parallel\"),\r\n            };\r\n\r\n            match args.merkle_hash {\r\n                MerkleHashOptions::KeccakF =\u003e {\r\n                    let result = prove_monty31_keccak::\u003c_, EF, _, _\u003e(proof_goal, dft, num_hashes);\r\n                    report_result(result);\r\n                }\r\n                MerkleHashOptions::Poseidon2 =\u003e {\r\n                    let perm16 = Poseidon2KoalaBear::\u003c16\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let perm24 = Poseidon2KoalaBear::\u003c24\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let result = prove_monty31_poseidon2::\u003c_, EF, _, _, _, _\u003e(\r\n                        proof_goal, dft, num_hashes, perm16, perm24,\r\n                    );\r\n                    report_result(result);\r\n                }\r\n            };\r\n        }\r\n        FieldOptions::BabyBear =\u003e {\r\n            type EF = BinomialExtensionField\u003cBabyBear, 4\u003e;\r\n\r\n            let proof_goal = match args.objective {\r\n                ProofOptions::Blake3Permutations =\u003e ProofObjective::Blake3(Blake3Air {}),\r\n                ProofOptions::KeccakFPermutations =\u003e ProofObjective::Keccak(KeccakAir {}),\r\n                ProofOptions::Poseidon2Permutations =\u003e {\r\n                    let constants = RoundConstants::from_rng(\u0026mut thread_rng());\r\n\r\n                    // Field specific constants for constructing the Poseidon2 AIR.\r\n                    const SBOX_DEGREE: u64 = 7;\r\n                    const SBOX_REGISTERS: usize = 1;\r\n                    const PARTIAL_ROUNDS: usize = 13;\r\n\r\n                    let p2_air: VectorizedPoseidon2Air\u003c\r\n                        BabyBear,\r\n                        GenericPoseidon2LinearLayersBabyBear,\r\n                        P2_WIDTH,\r\n                        SBOX_DEGREE,\r\n                        SBOX_REGISTERS,\r\n                        P2_HALF_FULL_ROUNDS,\r\n                        PARTIAL_ROUNDS,\r\n                        P2_VECTOR_LEN,\r\n                    \u003e = VectorizedPoseidon2Air::new(constants);\r\n                    ProofObjective::Poseidon2(p2_air)\r\n                }\r\n            };\r\n\r\n            let dft = match args.discrete_fourier_transform {\r\n                DftOptions::RecursiveDft =\u003e DftChoice::Recursive(RecursiveDft::new(trace_height \u003c\u003c 1)),\r\n                DftOptions::Radix2DitParallel =\u003e DftChoice::Parallel(Radix2DitParallel::default()),\r\n                DftOptions::None =\u003e panic!(\"Please specify what dft to use. Options are recursive-dft and radix-2-dit-parallel\"),\r\n            };\r\n\r\n            match args.merkle_hash {\r\n                MerkleHashOptions::KeccakF =\u003e {\r\n                    let result = prove_monty31_keccak::\u003c_, EF, _, _\u003e(proof_goal, dft, num_hashes);\r\n                    report_result(result);\r\n                }\r\n                MerkleHashOptions::Poseidon2 =\u003e {\r\n                    let perm16 = Poseidon2BabyBear::\u003c16\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let perm24 = Poseidon2BabyBear::\u003c24\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let result = prove_monty31_poseidon2::\u003c_, EF, _, _, _, _\u003e(\r\n                        proof_goal, dft, num_hashes, perm16, perm24,\r\n                    );\r\n                    report_result(result);\r\n                }\r\n            };\r\n        }\r\n        FieldOptions::Mersenne31 =\u003e {\r\n            type EF = BinomialExtensionField\u003cMersenne31, 3\u003e;\r\n\r\n            let proof_goal = match args.objective {\r\n                ProofOptions::Blake3Permutations =\u003e ProofObjective::Blake3(Blake3Air {}),\r\n                ProofOptions::KeccakFPermutations =\u003e ProofObjective::Keccak(KeccakAir {}),\r\n                ProofOptions::Poseidon2Permutations =\u003e {\r\n                    let constants = RoundConstants::from_rng(\u0026mut thread_rng());\r\n\r\n                    // Field specific constants for constructing the Poseidon2 AIR.\r\n                    const SBOX_DEGREE: u64 = 5;\r\n                    const SBOX_REGISTERS: usize = 1;\r\n                    const PARTIAL_ROUNDS: usize = 14;\r\n\r\n                    let p2_air: VectorizedPoseidon2Air\u003c\r\n                        Mersenne31,\r\n                        GenericPoseidon2LinearLayersMersenne31,\r\n                        P2_WIDTH,\r\n                        SBOX_DEGREE,\r\n                        SBOX_REGISTERS,\r\n                        P2_HALF_FULL_ROUNDS,\r\n                        PARTIAL_ROUNDS,\r\n                        P2_VECTOR_LEN,\r\n                    \u003e = VectorizedPoseidon2Air::new(constants);\r\n                    ProofObjective::Poseidon2(p2_air)\r\n                }\r\n            };\r\n\r\n            match args.discrete_fourier_transform {\r\n                DftOptions::None =\u003e {}\r\n                _ =\u003e panic!(\"Currently there are no available DFT options when using Mersenne31. Please remove the --discrete_fourier_transform flag.\"),\r\n            };\r\n\r\n            match args.merkle_hash {\r\n                MerkleHashOptions::KeccakF =\u003e {\r\n                    let result = prove_m31_keccak(proof_goal, num_hashes);\r\n                    report_result(result);\r\n                }\r\n                MerkleHashOptions::Poseidon2 =\u003e {\r\n                    let perm16 = Poseidon2Mersenne31::\u003c16\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let perm24 = Poseidon2Mersenne31::\u003c24\u003e::new_from_rng_128(\u0026mut thread_rng());\r\n                    let result = prove_m31_poseidon2::\u003c_, EF, _, _, _\u003e(\r\n                        proof_goal, num_hashes, perm16, perm24,\r\n                    );\r\n                    report_result(result);\r\n                }\r\n            };\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","airs.rs"],"content":"use p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_blake3_air::Blake3Air;\r\nuse p3_challenger::FieldChallenger;\r\nuse p3_commit::PolynomialSpace;\r\nuse p3_field::{ExtensionField, Field, PrimeField64};\r\nuse p3_keccak_air::KeccakAir;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\r\nuse p3_poseidon2_air::VectorizedPoseidon2Air;\r\nuse p3_uni_stark::{\r\n    DebugConstraintBuilder, ProverConstraintFolder, StarkGenericConfig, SymbolicAirBuilder,\r\n    SymbolicExpression, VerifierConstraintFolder,\r\n};\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\n\r\n/// An enum containing the three different AIR's.\r\n///\r\n/// This implements `AIR` by passing to whatever the contained struct is.\r\npub enum ProofObjective\u003c\r\n    F: Field,\r\n    LinearLayers,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n    const VECTOR_LEN: usize,\r\n\u003e {\r\n    Blake3(Blake3Air),\r\n    Keccak(KeccakAir),\r\n    Poseidon2(\r\n        VectorizedPoseidon2Air\u003c\r\n            F,\r\n            LinearLayers,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n            VECTOR_LEN,\r\n        \u003e,\r\n    ),\r\n}\r\n\r\n/// An AIR for a hash function used for example proofs and benchmarking.\r\n///\r\n/// A key feature is the ability to randomly generate a trace which proves\r\n/// the output of some number of hashes using a given hash function.\r\npub trait ExampleHashAir\u003cF: Field, SC: StarkGenericConfig\u003e:\r\n    BaseAir\u003cF\u003e\r\n    + for\u003c'a\u003e Air\u003cDebugConstraintBuilder\u003c'a, F\u003e\u003e\r\n    + Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e\r\n    + for\u003c'a\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e\r\n    + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e\r\n{\r\n    fn generate_trace_rows(\r\n        \u0026self,\r\n        num_hashes: usize,\r\n        extra_capacity_bits: usize,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e\r\n    where\r\n        Standard: Distribution\u003cF\u003e;\r\n}\r\n\r\nimpl\u003c\r\n        F: Field,\r\n        LinearLayers: Sync,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e BaseAir\u003cF\u003e\r\n    for ProofObjective\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    #[inline]\r\n    fn width(\u0026self) -\u003e usize {\r\n        match self {\r\n            ProofObjective::Blake3(b3_air) =\u003e \u003cBlake3Air as BaseAir\u003cF\u003e\u003e::width(b3_air),\r\n            ProofObjective::Poseidon2(p2_air) =\u003e p2_air.width(),\r\n            ProofObjective::Keccak(k_air) =\u003e \u003cKeccakAir as BaseAir\u003cF\u003e\u003e::width(k_air),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        AB: AirBuilder,\r\n        LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e Air\u003cAB\u003e\r\n    for ProofObjective\u003c\r\n        AB::F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    #[inline]\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        match self {\r\n            ProofObjective::Blake3(b3_air) =\u003e b3_air.eval(builder),\r\n            ProofObjective::Poseidon2(p2_air) =\u003e p2_air.eval(builder),\r\n            ProofObjective::Keccak(k_air) =\u003e k_air.eval(builder),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        F: PrimeField64,\r\n        Domain: PolynomialSpace\u003cVal = F\u003e,\r\n        EF: ExtensionField\u003cF\u003e,\r\n        Challenger: FieldChallenger\u003cF\u003e,\r\n        Pcs: p3_commit::Pcs\u003cEF, Challenger, Domain = Domain\u003e,\r\n        SC: StarkGenericConfig\u003cPcs = Pcs, Challenge = EF, Challenger = Challenger\u003e,\r\n        LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e\r\n            + GenericPoseidon2LinearLayers\u003cSymbolicExpression\u003cF\u003e, WIDTH\u003e\r\n            + GenericPoseidon2LinearLayers\u003c\u003cF as Field\u003e::Packing, WIDTH\u003e\r\n            + GenericPoseidon2LinearLayers\u003cEF, WIDTH\u003e,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e ExampleHashAir\u003cF, SC\u003e\r\n    for ProofObjective\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    #[inline]\r\n    fn generate_trace_rows(\r\n        \u0026self,\r\n        num_hashes: usize,\r\n        extra_capacity_bits: usize,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e\r\n    where\r\n        Standard: Distribution\u003cF\u003e,\r\n    {\r\n        match self {\r\n            ProofObjective::Blake3(b3_air) =\u003e {\r\n                b3_air.generate_trace_rows(num_hashes, extra_capacity_bits)\r\n            }\r\n            ProofObjective::Poseidon2(p2_air) =\u003e {\r\n                p2_air.generate_vectorized_trace_rows(num_hashes, extra_capacity_bits)\r\n            }\r\n            ProofObjective::Keccak(k_air) =\u003e {\r\n                k_air.generate_trace_rows(num_hashes, extra_capacity_bits)\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","dfts.rs"],"content":"use p3_dft::{Radix2DitParallel, TwoAdicSubgroupDft};\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::bitrev::BitReversedMatrixView;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_monty_31::dft::RecursiveDft;\r\n\r\n/// An enum containing several different options for discrete Fourier Transform.\r\n///\r\n/// This implements `TwoAdicSubgroupDft` by passing to whatever the contained struct is.\r\n#[derive(Clone, Debug)]\r\npub enum DftChoice\u003cF\u003e {\r\n    Recursive(RecursiveDft\u003cF\u003e),\r\n    Parallel(Radix2DitParallel\u003cF\u003e),\r\n}\r\n\r\nimpl\u003cF: Default\u003e Default for DftChoice\u003cF\u003e {\r\n    // We have to fix a default for the `TwoAdicSubgroupDft` trait. We choose `Radix2DitParallel` as one of the features\r\n    // of `RecursiveDft` is that it works better when initialized with knowledge of the expected size.\r\n    fn default() -\u003e Self {\r\n        DftChoice::\u003cF\u003e::Parallel(Radix2DitParallel::\u003cF\u003e::default())\r\n    }\r\n}\r\n\r\nimpl\u003cF: TwoAdicField\u003e TwoAdicSubgroupDft\u003cF\u003e for DftChoice\u003cF\u003e\r\nwhere\r\n    RecursiveDft\u003cF\u003e: TwoAdicSubgroupDft\u003cF, Evaluations = BitReversedMatrixView\u003cRowMajorMatrix\u003cF\u003e\u003e\u003e,\r\n    Radix2DitParallel\u003cF\u003e:\r\n        TwoAdicSubgroupDft\u003cF, Evaluations = BitReversedMatrixView\u003cRowMajorMatrix\u003cF\u003e\u003e\u003e,\r\n{\r\n    type Evaluations = BitReversedMatrixView\u003cRowMajorMatrix\u003cF\u003e\u003e;\r\n\r\n    #[inline]\r\n    fn dft_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e) -\u003e Self::Evaluations {\r\n        match self {\r\n            DftChoice::\u003cF\u003e::Recursive(inner_dft) =\u003e inner_dft.dft_batch(mat),\r\n            DftChoice::\u003cF\u003e::Parallel(inner_dft) =\u003e inner_dft.dft_batch(mat),\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn coset_dft_batch(\u0026self, mat: RowMajorMatrix\u003cF\u003e, shift: F) -\u003e Self::Evaluations {\r\n        match self {\r\n            DftChoice::\u003cF\u003e::Recursive(inner_dft) =\u003e inner_dft.coset_dft_batch(mat, shift),\r\n            DftChoice::\u003cF\u003e::Parallel(inner_dft) =\u003e inner_dft.coset_dft_batch(mat, shift),\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn coset_lde_batch(\r\n        \u0026self,\r\n        mat: RowMajorMatrix\u003cF\u003e,\r\n        added_bits: usize,\r\n        shift: F,\r\n    ) -\u003e Self::Evaluations {\r\n        match self {\r\n            DftChoice::\u003cF\u003e::Recursive(inner_dft) =\u003e {\r\n                inner_dft.coset_lde_batch(mat, added_bits, shift)\r\n            }\r\n            DftChoice::\u003cF\u003e::Parallel(inner_dft) =\u003e {\r\n                inner_dft.coset_lde_batch(mat, added_bits, shift)\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","lib.rs"],"content":"pub mod airs;\r\npub mod dfts;\r\npub mod parsers;\r\npub mod proofs;\r\npub mod types;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","parsers.rs"],"content":"//! This file contains a collection of Enums which allow a nice command line interface.\r\n//!\r\n//! For each enum, we allow the user to specify the enum either using the whole string or any substring\r\n//! which fully determines the choice. We additionally add a few extra aliases if other natural ones exist.\r\n//!\r\n//! For most of the enums, this allows the user to\r\n\r\nuse clap::builder::PossibleValue;\r\nuse clap::ValueEnum;\r\n\r\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\r\npub enum FieldOptions {\r\n    BabyBear,\r\n    KoalaBear,\r\n    Mersenne31,\r\n}\r\n\r\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\r\npub enum ProofOptions {\r\n    Blake3Permutations,\r\n    KeccakFPermutations,\r\n    Poseidon2Permutations,\r\n}\r\n\r\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\r\npub enum DftOptions {\r\n    None,\r\n    Radix2DitParallel,\r\n    RecursiveDft,\r\n}\r\n\r\n#[derive(Debug, Copy, Clone, PartialEq, Eq)]\r\npub enum MerkleHashOptions {\r\n    KeccakF,\r\n    Poseidon2,\r\n}\r\n\r\n/// Produce a collection of PossibleValue's for an Enum variant.\r\n///\r\n/// We allow any prefix of the full name which uniquely determines the variant.\r\n/// We additionally allow the user to specify a collection of aliases which are\r\n/// not prefixes. For each alias, we also allow any unique prefix of that alias.\r\n///\r\n/// For example, for the `KoalaBear` variant of `FieldOptions`, running\r\n/// `get_aliases(\"koala-bear\", 1, vec![(\"koalabear\", 6), (\"kb\", 2)])` produces the following set of\r\n/// allowed strings:\r\n///\r\n/// `koala-bear, k, ko, koa, koal, koala, koala-, koala-b, koala-be, koala-bea, koalab, koalabe, koalabea, koalabear, kb`\r\nfn get_aliases(\r\n    base: \u0026'static str,\r\n    min_unique_base_prefix: usize,\r\n    alias: Option\u003cVec\u003c(\u0026'static str, usize)\u003e\u003e,\r\n) -\u003e PossibleValue {\r\n    match alias {\r\n        None =\u003e PossibleValue::new(base)\r\n            .aliases((min_unique_base_prefix..base.len()).map(|i| \u0026base[..i])),\r\n        Some(vec) =\u003e PossibleValue::new(base).aliases(\r\n            (min_unique_base_prefix..base.len())\r\n                .map(|i| \u0026base[..i])\r\n                .chain(vec.into_iter().flat_map(|(alias, min_unique)| {\r\n                    (min_unique..alias.len() + 1).map(|i| \u0026alias[..i])\r\n                })),\r\n        ),\r\n    }\r\n}\r\n\r\nimpl ValueEnum for FieldOptions {\r\n    fn value_variants\u003c'a\u003e() -\u003e \u0026'a [Self] {\r\n        \u0026[\r\n            FieldOptions::BabyBear,\r\n            FieldOptions::KoalaBear,\r\n            FieldOptions::Mersenne31,\r\n        ]\r\n    }\r\n\r\n    fn to_possible_value(\u0026self) -\u003e Option\u003cPossibleValue\u003e {\r\n        Some(match self {\r\n            FieldOptions::BabyBear =\u003e {\r\n                get_aliases(\"baby-bear\", 1, Some(vec![(\"babybear\", 5), (\"bb\", 2)]))\r\n            }\r\n            FieldOptions::KoalaBear =\u003e {\r\n                get_aliases(\"koala-bear\", 1, Some(vec![(\"koalabear\", 6), (\"kb\", 2)]))\r\n            }\r\n            FieldOptions::Mersenne31 =\u003e {\r\n                get_aliases(\"mersenne-31\", 1, Some(vec![(\"mersenne31\", 9), (\"m31\", 2)]))\r\n            }\r\n        })\r\n    }\r\n}\r\n\r\nimpl ValueEnum for ProofOptions {\r\n    fn value_variants\u003c'a\u003e() -\u003e \u0026'a [Self] {\r\n        \u0026[\r\n            ProofOptions::Blake3Permutations,\r\n            ProofOptions::Poseidon2Permutations,\r\n            ProofOptions::KeccakFPermutations,\r\n        ]\r\n    }\r\n\r\n    fn to_possible_value(\u0026self) -\u003e Option\u003cPossibleValue\u003e {\r\n        Some(match self {\r\n            ProofOptions::Blake3Permutations =\u003e get_aliases(\r\n                \"blake-3-permutations\",\r\n                1,\r\n                Some(vec![(\"blake3-permutations\", 6), (\"b3\", 2)]),\r\n            ),\r\n            ProofOptions::KeccakFPermutations =\u003e get_aliases(\r\n                \"keccak-f-permutations\",\r\n                1,\r\n                Some(vec![(\"keccakf-permutations\", 7), (\"kf\", 2)]),\r\n            ),\r\n            ProofOptions::Poseidon2Permutations =\u003e get_aliases(\r\n                \"poseidon-2-permutations\",\r\n                1,\r\n                Some(vec![(\"poseidon2-permutations\", 9), (\"p2\", 2)]),\r\n            ),\r\n        })\r\n    }\r\n}\r\n\r\nimpl ValueEnum for DftOptions {\r\n    fn value_variants\u003c'a\u003e() -\u003e \u0026'a [Self] {\r\n        \u0026[\r\n            DftOptions::Radix2DitParallel,\r\n            DftOptions::RecursiveDft,\r\n            DftOptions::None,\r\n        ]\r\n    }\r\n\r\n    fn to_possible_value(\u0026self) -\u003e Option\u003cPossibleValue\u003e {\r\n        Some(match self {\r\n            DftOptions::RecursiveDft =\u003e {\r\n                get_aliases(\"recursive-dft\", 2, Some(vec![(\"recursivedft\", 10)]))\r\n            }\r\n            DftOptions::Radix2DitParallel =\u003e get_aliases(\r\n                \"radix-2-dit-parallel\",\r\n                2,\r\n                Some(vec![(\"radix2ditparallel\", 6), (\"parallel\", 1)]),\r\n            ),\r\n            DftOptions::None =\u003e PossibleValue::new(\"\"),\r\n        })\r\n    }\r\n}\r\n\r\nimpl ValueEnum for MerkleHashOptions {\r\n    fn value_variants\u003c'a\u003e() -\u003e \u0026'a [Self] {\r\n        \u0026[MerkleHashOptions::Poseidon2, MerkleHashOptions::KeccakF]\r\n    }\r\n\r\n    fn to_possible_value(\u0026self) -\u003e Option\u003cPossibleValue\u003e {\r\n        Some(match self {\r\n            MerkleHashOptions::KeccakF =\u003e {\r\n                get_aliases(\"keccak-f\", 1, Some(vec![(\"keccakf\", 7), (\"kf\", 2)]))\r\n            }\r\n            MerkleHashOptions::Poseidon2 =\u003e {\r\n                get_aliases(\"poseidon-2\", 1, Some(vec![(\"poseidon2\", 9), (\"p2\", 2)]))\r\n            }\r\n        })\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","proofs.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_challenger::{DuplexChallenger, SerializingChallenger32};\r\nuse p3_circle::CirclePcs;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::extension::{BinomialExtensionField, ComplexExtendable};\r\nuse p3_field::{ExtensionField, Field, PrimeField32, PrimeField64, TwoAdicField};\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_keccak::{Keccak256Hash, KeccakF};\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_symmetric::{CryptographicPermutation, PaddingFreeSponge, SerializingHasher32To64};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\n\r\nuse crate::airs::ExampleHashAir;\r\nuse crate::types::{\r\n    KeccakCircleStarkConfig, KeccakCompressionFunction, KeccakMerkleMmcs, KeccakStarkConfig,\r\n    Poseidon2CircleStarkConfig, Poseidon2Compression, Poseidon2MerkleMmcs, Poseidon2Sponge,\r\n    Poseidon2StarkConfig,\r\n};\r\n\r\n/// Produce a MerkleTreeMmcs which uses the KeccakF permutation.\r\nfn get_keccak_mmcs\u003cF: Field\u003e() -\u003e KeccakMerkleMmcs\u003cF\u003e {\r\n    let u64_hash = PaddingFreeSponge::\u003cKeccakF, 25, 17, 4\u003e::new(KeccakF {});\r\n\r\n    let field_hash = SerializingHasher32To64::new(u64_hash);\r\n\r\n    let compress = KeccakCompressionFunction::new(u64_hash);\r\n\r\n    KeccakMerkleMmcs::new(field_hash, compress)\r\n}\r\n\r\n/// Produce a MerkleTreeMmcs from a pair of cryptographic field permutations.\r\n///\r\n/// The first permutation will be used for compression and the second for more sponge hashing.\r\n/// Currently this is only intended to be used with a pair of Poseidon2 hashes of with 16 and 24\r\n/// but this can easily be generalised in future if we desire.\r\nfn get_poseidon2_mmcs\u003c\r\n    F: Field,\r\n    Perm16: CryptographicPermutation\u003c[F; 16]\u003e + CryptographicPermutation\u003c[F::Packing; 16]\u003e,\r\n    Perm24: CryptographicPermutation\u003c[F; 24]\u003e + CryptographicPermutation\u003c[F::Packing; 24]\u003e,\r\n\u003e(\r\n    perm16: Perm16,\r\n    perm24: Perm24,\r\n) -\u003e Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e {\r\n    let hash = Poseidon2Sponge::new(perm24.clone());\r\n\r\n    let compress = Poseidon2Compression::new(perm16.clone());\r\n\r\n    Poseidon2MerkleMmcs::\u003cF, _, _\u003e::new(hash, compress)\r\n}\r\n\r\n/// Prove the given ProofGoal using the Keccak hash function to build the merkle tree.\r\n///\r\n/// This allows the user to choose:\r\n/// - The Field\r\n/// - The Proof Goal (Choice of both hash function and desired number of hashes to prove)\r\n/// - The DFT\r\n#[inline]\r\npub fn prove_monty31_keccak\u003c\r\n    F: PrimeField32 + TwoAdicField,\r\n    EF: ExtensionField\u003cF\u003e + TwoAdicField,\r\n    DFT: TwoAdicSubgroupDft\u003cF\u003e,\r\n    PG: ExampleHashAir\u003cF, KeccakStarkConfig\u003cF, EF, DFT\u003e\u003e,\r\n\u003e(\r\n    proof_goal: PG,\r\n    dft: DFT,\r\n    num_hashes: usize,\r\n) -\u003e Result\u003c(), impl Debug\u003e\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let val_mmcs = get_keccak_mmcs();\r\n\r\n    let challenge_mmcs = ExtensionMmcs::\u003cF, EF, _\u003e::new(val_mmcs.clone());\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = proof_goal.generate_trace_rows(num_hashes, fri_config.log_blowup);\r\n\r\n    let pcs = TwoAdicFriPcs::new(dft, val_mmcs, fri_config);\r\n\r\n    let config = KeccakStarkConfig::new(pcs);\r\n\r\n    let mut proof_challenger = SerializingChallenger32::from_hasher(vec![], Keccak256Hash {});\r\n    let mut verif_challenger = SerializingChallenger32::from_hasher(vec![], Keccak256Hash {});\r\n\r\n    let proof = prove(\u0026config, \u0026proof_goal, \u0026mut proof_challenger, trace, \u0026vec![]);\r\n    verify(\u0026config, \u0026proof_goal, \u0026mut verif_challenger, \u0026proof, \u0026vec![])\r\n}\r\n\r\n/// Prove the given ProofGoal using the Poseidon2 hash function to build the merkle tree.\r\n///\r\n/// This allows the user to choose:\r\n/// - The Field\r\n/// - The Proof Goal (Choice of Hash function and number of hashes to prove)\r\n/// - The DFT\r\n#[inline]\r\npub fn prove_monty31_poseidon2\u003c\r\n    F: PrimeField32 + TwoAdicField,\r\n    EF: ExtensionField\u003cF\u003e + TwoAdicField,\r\n    DFT: TwoAdicSubgroupDft\u003cF\u003e,\r\n    Perm16: CryptographicPermutation\u003c[F; 16]\u003e + CryptographicPermutation\u003c[F::Packing; 16]\u003e,\r\n    Perm24: CryptographicPermutation\u003c[F; 24]\u003e + CryptographicPermutation\u003c[F::Packing; 24]\u003e,\r\n    PG: ExampleHashAir\u003cF, Poseidon2StarkConfig\u003cF, EF, DFT, Perm16, Perm24\u003e\u003e,\r\n\u003e(\r\n    proof_goal: PG,\r\n    dft: DFT,\r\n    num_hashes: usize,\r\n    perm16: Perm16,\r\n    perm24: Perm24,\r\n) -\u003e Result\u003c(), impl Debug\u003e\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let val_mmcs = get_poseidon2_mmcs::\u003cF, _, _\u003e(perm16, perm24.clone());\r\n\r\n    let challenge_mmcs = ExtensionMmcs::\u003cF, EF, _\u003e::new(val_mmcs.clone());\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = proof_goal.generate_trace_rows(num_hashes, fri_config.log_blowup);\r\n\r\n    let pcs = TwoAdicFriPcs::new(dft, val_mmcs, fri_config);\r\n\r\n    let config = StarkConfig::new(pcs);\r\n\r\n    let mut proof_challenger = DuplexChallenger::new(perm24.clone());\r\n    let mut verif_challenger = DuplexChallenger::new(perm24.clone());\r\n\r\n    let proof = prove(\u0026config, \u0026proof_goal, \u0026mut proof_challenger, trace, \u0026vec![]);\r\n    verify(\u0026config, \u0026proof_goal, \u0026mut verif_challenger, \u0026proof, \u0026vec![])\r\n}\r\n\r\n/// Prove the given ProofGoal using the Keccak hash function to build the merkle tree.\r\n///\r\n/// This fixes the field and Mersenne31 and makes use of the circle stark.\r\n///\r\n/// It currently allows the user to choose:\r\n/// - The Proof Goal (Choice of Hash function and number of hashes to prove)\r\n#[inline]\r\npub fn prove_m31_keccak\u003c\r\n    PG: ExampleHashAir\u003c\r\n        Mersenne31,\r\n        KeccakCircleStarkConfig\u003cMersenne31, BinomialExtensionField\u003cMersenne31, 3\u003e\u003e,\r\n    \u003e,\r\n\u003e(\r\n    proof_goal: PG,\r\n    num_hashes: usize,\r\n) -\u003e Result\u003c(), impl Debug\u003e {\r\n    type F = Mersenne31;\r\n    type EF = BinomialExtensionField\u003cMersenne31, 3\u003e;\r\n\r\n    let val_mmcs = get_keccak_mmcs();\r\n    let challenge_mmcs = ExtensionMmcs::\u003cF, EF, _\u003e::new(val_mmcs.clone());\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = proof_goal.generate_trace_rows(num_hashes, fri_config.log_blowup);\r\n\r\n    let pcs = CirclePcs::new(val_mmcs, fri_config);\r\n\r\n    let config = KeccakCircleStarkConfig::new(pcs);\r\n\r\n    let mut proof_challenger = SerializingChallenger32::from_hasher(vec![], Keccak256Hash {});\r\n    let mut verif_challenger = SerializingChallenger32::from_hasher(vec![], Keccak256Hash {});\r\n\r\n    let proof = prove(\u0026config, \u0026proof_goal, \u0026mut proof_challenger, trace, \u0026vec![]);\r\n    verify(\u0026config, \u0026proof_goal, \u0026mut verif_challenger, \u0026proof, \u0026vec![])\r\n}\r\n\r\n/// Prove the given ProofGoal using the Keccak hash function to build the merkle tree.\r\n///\r\n/// This fixes the field and Mersenne31 and makes use of the circle stark.\r\n///\r\n/// It currently allows the user to choose:\r\n/// - The Proof Goal (Choice of Hash function and number of hashes to prove)\r\n#[inline]\r\npub fn prove_m31_poseidon2\u003c\r\n    F: PrimeField64 + ComplexExtendable,\r\n    EF: ExtensionField\u003cF\u003e,\r\n    Perm16: CryptographicPermutation\u003c[F; 16]\u003e + CryptographicPermutation\u003c[F::Packing; 16]\u003e,\r\n    Perm24: CryptographicPermutation\u003c[F; 24]\u003e + CryptographicPermutation\u003c[F::Packing; 24]\u003e,\r\n    PG: ExampleHashAir\u003cF, Poseidon2CircleStarkConfig\u003cF, EF, Perm16, Perm24\u003e\u003e,\r\n\u003e(\r\n    proof_goal: PG,\r\n    num_hashes: usize,\r\n    perm16: Perm16,\r\n    perm24: Perm24,\r\n) -\u003e Result\u003c(), impl Debug\u003e\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let val_mmcs = get_poseidon2_mmcs::\u003cF, _, _\u003e(perm16, perm24.clone());\r\n\r\n    let challenge_mmcs = ExtensionMmcs::\u003cF, EF, _\u003e::new(val_mmcs.clone());\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = proof_goal.generate_trace_rows(num_hashes, fri_config.log_blowup);\r\n\r\n    let pcs = CirclePcs::new(val_mmcs, fri_config);\r\n\r\n    let config = Poseidon2CircleStarkConfig::new(pcs);\r\n\r\n    let mut proof_challenger = DuplexChallenger::new(perm24.clone());\r\n    let mut verif_challenger = DuplexChallenger::new(perm24.clone());\r\n\r\n    let proof = prove(\u0026config, \u0026proof_goal, \u0026mut proof_challenger, trace, \u0026vec![]);\r\n    verify(\u0026config, \u0026proof_goal, \u0026mut verif_challenger, \u0026proof, \u0026vec![])\r\n}\r\n\r\n/// Report the result of the proof.\r\n///\r\n/// Either print that the proof was successful or panic and return the error.\r\n#[inline]\r\npub fn report_result(result: Result\u003c(), impl Debug\u003e) {\r\n    if let Err(e) = result {\r\n        panic!(\"{:?}\", e);\r\n    } else {\r\n        println!(\"Proof Verified Successfully\")\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","examples","src","types.rs"],"content":"//! This contains a large number of type definitions which help simplify the code in other files and keep clippy happy.\r\n//!\r\n//! In particular this builds up to defining the types `KeccakStarkConfig`,\r\n//! `KeccakCircleStarkConfig`, `Poseidon2StarkConfig`, `Poseidon2CircleStarkConfig`.\r\n//! These are needed to define our proof functions.\r\n\r\nuse p3_challenger::{DuplexChallenger, HashChallenger, SerializingChallenger32};\r\nuse p3_circle::CirclePcs;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::Field;\r\nuse p3_fri::TwoAdicFriPcs;\r\nuse p3_keccak::{Keccak256Hash, KeccakF};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{\r\n    CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher32To64, TruncatedPermutation,\r\n};\r\nuse p3_uni_stark::StarkConfig;\r\n\r\n// Types related to using Keccak in the Merkle tree.\r\nconst KECCAK_VECTOR_LEN: usize = p3_keccak::VECTOR_LEN;\r\npub(crate) type KeccakCompressionFunction =\r\n    CompressionFunctionFromHasher\u003cPaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e, 2, 4\u003e;\r\npub(crate) type KeccakMerkleMmcs\u003cF\u003e = MerkleTreeMmcs\u003c\r\n    [F; KECCAK_VECTOR_LEN],\r\n    [u64; KECCAK_VECTOR_LEN],\r\n    SerializingHasher32To64\u003cPaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e\u003e,\r\n    KeccakCompressionFunction,\r\n    4,\r\n\u003e;\r\n\r\npub(crate) type KeccakStarkConfig\u003cF, EF, DFT\u003e = StarkConfig\u003c\r\n    TwoAdicFriPcs\u003cF, DFT, KeccakMerkleMmcs\u003cF\u003e, ExtensionMmcs\u003cF, EF, KeccakMerkleMmcs\u003cF\u003e\u003e\u003e,\r\n    EF,\r\n    SerializingChallenger32\u003cF, HashChallenger\u003cu8, Keccak256Hash, 32\u003e\u003e,\r\n\u003e;\r\npub(crate) type KeccakCircleStarkConfig\u003cF, EF\u003e = StarkConfig\u003c\r\n    CirclePcs\u003cF, KeccakMerkleMmcs\u003cF\u003e, ExtensionMmcs\u003cF, EF, KeccakMerkleMmcs\u003cF\u003e\u003e\u003e,\r\n    EF,\r\n    SerializingChallenger32\u003cF, HashChallenger\u003cu8, Keccak256Hash, 32\u003e\u003e,\r\n\u003e;\r\n\r\n// Types related to using Poseidon2 in the Merkle tree.\r\npub(crate) type Poseidon2Sponge\u003cPerm24\u003e = PaddingFreeSponge\u003cPerm24, 24, 16, 8\u003e;\r\npub(crate) type Poseidon2Compression\u003cPerm16\u003e = TruncatedPermutation\u003cPerm16, 2, 8, 16\u003e;\r\npub(crate) type Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e = MerkleTreeMmcs\u003c\r\n    \u003cF as Field\u003e::Packing,\r\n    \u003cF as Field\u003e::Packing,\r\n    Poseidon2Sponge\u003cPerm24\u003e,\r\n    Poseidon2Compression\u003cPerm16\u003e,\r\n    8,\r\n\u003e;\r\npub(crate) type Poseidon2StarkConfig\u003cF, EF, DFT, Perm16, Perm24\u003e = StarkConfig\u003c\r\n    TwoAdicFriPcs\u003c\r\n        F,\r\n        DFT,\r\n        Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e,\r\n        ExtensionMmcs\u003cF, EF, Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e\u003e,\r\n    \u003e,\r\n    EF,\r\n    DuplexChallenger\u003cF, Perm24, 24, 16\u003e,\r\n\u003e;\r\npub(crate) type Poseidon2CircleStarkConfig\u003cF, EF, Perm16, Perm24\u003e = StarkConfig\u003c\r\n    CirclePcs\u003c\r\n        F,\r\n        Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e,\r\n        ExtensionMmcs\u003cF, EF, Poseidon2MerkleMmcs\u003cF, Perm16, Perm24\u003e\u003e,\r\n    \u003e,\r\n    EF,\r\n    DuplexChallenger\u003cF, Perm24, 24, 16\u003e,\r\n\u003e;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","array.rs"],"content":"use core::array;\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse crate::batch_inverse::batch_multiplicative_inverse_general;\r\nuse crate::{Algebra, Field, PackedValue, PrimeCharacteristicRing};\r\n\r\n#[derive(Clone, Copy, Debug, Eq, PartialEq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct FieldArray\u003cF: Field, const N: usize\u003e(pub [F; N]);\r\n\r\nimpl\u003cF: Field, const N: usize\u003e FieldArray\u003cF, N\u003e {\r\n    pub(crate) fn inverse(\u0026self) -\u003e Self {\r\n        let mut result = Self::default();\r\n        batch_multiplicative_inverse_general(\u0026self.0, \u0026mut result.0, |x| x.inverse());\r\n        result\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Default for FieldArray\u003cF, N\u003e {\r\n    fn default() -\u003e Self {\r\n        Self::ZERO\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e From\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    fn from(val: F) -\u003e Self {\r\n        [val; N].into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e From\u003c[F; N]\u003e for FieldArray\u003cF, N\u003e {\r\n    fn from(arr: [F; N]) -\u003e Self {\r\n        Self(arr)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e PrimeCharacteristicRing for FieldArray\u003cF, N\u003e {\r\n    type PrimeSubfield = F::PrimeSubfield;\r\n\r\n    const ZERO: Self = FieldArray([F::ZERO; N]);\r\n    const ONE: Self = FieldArray([F::ONE; N]);\r\n    const TWO: Self = FieldArray([F::TWO; N]);\r\n    const NEG_ONE: Self = FieldArray([F::NEG_ONE; N]);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        F::from_prime_subfield(f).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Algebra\u003cF\u003e for FieldArray\u003cF, N\u003e {}\r\n\r\nunsafe impl\u003cF: Field, const N: usize\u003e PackedValue for FieldArray\u003cF, N\u003e {\r\n    type Value = F;\r\n\r\n    const WIDTH: usize = N;\r\n\r\n    fn from_slice(slice: \u0026[Self::Value]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026*slice.as_ptr().cast() }\r\n    }\r\n\r\n    fn from_slice_mut(slice: \u0026mut [Self::Value]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026mut *slice.as_mut_ptr().cast() }\r\n    }\r\n\r\n    fn from_fn\u003cFn\u003e(f: Fn) -\u003e Self\r\n    where\r\n        Fn: FnMut(usize) -\u003e Self::Value,\r\n    {\r\n        Self(array::from_fn(f))\r\n    }\r\n\r\n    fn as_slice(\u0026self) -\u003e \u0026[Self::Value] {\r\n        \u0026self.0\r\n    }\r\n\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Self::Value] {\r\n        \u0026mut self.0\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Add for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self::Output {\r\n        array::from_fn(|i| self.0[i] + rhs.0[i]).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Add\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: F) -\u003e Self::Output {\r\n        self.0.map(|x| x + rhs).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e AddAssign for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x += y);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e AddAssign\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: F) {\r\n        self.0.iter_mut().for_each(|x| *x += rhs);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Sub for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self::Output {\r\n        array::from_fn(|i| self.0[i] - rhs.0[i]).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Sub\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: F) -\u003e Self::Output {\r\n        self.0.map(|x| x - rhs).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e SubAssign for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x -= y);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e SubAssign\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: F) {\r\n        self.0.iter_mut().for_each(|x| *x -= rhs);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Neg for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self::Output {\r\n        self.0.map(|x| -x).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Mul for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self::Output {\r\n        array::from_fn(|i| self.0[i] * rhs.0[i]).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Mul\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: F) -\u003e Self::Output {\r\n        self.0.map(|x| x * rhs).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e MulAssign for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        self.0.iter_mut().zip(rhs.0).for_each(|(x, y)| *x *= y);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e MulAssign\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: F) {\r\n        self.0.iter_mut().for_each(|x| *x *= rhs);\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Div\u003cF\u003e for FieldArray\u003cF, N\u003e {\r\n    type Output = Self;\r\n\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: F) -\u003e Self::Output {\r\n        let rhs_inv = rhs.inverse();\r\n        self * rhs_inv\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Sum for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, const N: usize\u003e Product for FieldArray\u003cF, N\u003e {\r\n    #[inline]\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":5404319552844595459}},{"line":14,"address":[],"length":0,"stats":{"Line":5404319552844595459}},{"line":15,"address":[],"length":0,"stats":{"Line":16212958658533786202}},{"line":16,"address":[],"length":0,"stats":{"Line":5404319552844595459}},{"line":21,"address":[],"length":0,"stats":{"Line":5404319552844595231}},{"line":22,"address":[],"length":0,"stats":{"Line":5404319552844595231}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":7061644215716937766}},{"line":34,"address":[],"length":0,"stats":{"Line":7061644215716937766}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":7061644215716937766}},{"line":163,"address":[],"length":0,"stats":{"Line":5476377146882523362}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":11096869481840902185}},{"line":179,"address":[],"length":0,"stats":{"Line":4899916394579100106}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":57},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","batch_inverse.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_maybe_rayon::prelude::*;\r\nuse tracing::instrument;\r\n\r\nuse crate::field::Field;\r\nuse crate::{FieldArray, PackedValue, PrimeCharacteristicRing};\r\n\r\n/// Batch multiplicative inverses with Montgomery's trick\r\n/// This is Montgomery's trick. At a high level, we invert the product of the given field\r\n/// elements, then derive the individual inverses from that via multiplication.\r\n///\r\n/// The usual Montgomery trick involves calculating an array of cumulative products,\r\n/// resulting in a long dependency chain. To increase instruction-level parallelism, we\r\n/// compute WIDTH separate cumulative product arrays that only meet at the end.\r\n///\r\n/// # Panics\r\n/// This will panic if any of the inputs is zero.\r\n#[instrument(level = \"debug\", skip_all)]\r\npub fn batch_multiplicative_inverse\u003cF: Field\u003e(x: \u0026[F]) -\u003e Vec\u003cF\u003e {\r\n    // How many elements to invert in one thread.\r\n    const CHUNK_SIZE: usize = 1024;\r\n\r\n    let n = x.len();\r\n    let mut result = F::zero_vec(n);\r\n\r\n    x.par_chunks(CHUNK_SIZE)\r\n        .zip(result.par_chunks_mut(CHUNK_SIZE))\r\n        .for_each(|(x, result)| {\r\n            batch_multiplicative_inverse_helper(x, result);\r\n        });\r\n\r\n    result\r\n}\r\n\r\n/// Like `batch_multiplicative_inverse`, but writes the result to the given output buffer.\r\nfn batch_multiplicative_inverse_helper\u003cF: Field\u003e(x: \u0026[F], result: \u0026mut [F]) {\r\n    // Higher WIDTH increases instruction-level parallelism, but too high a value will cause us\r\n    // to run out of registers.\r\n    const WIDTH: usize = 4;\r\n\r\n    let n = x.len();\r\n    assert_eq!(result.len(), n);\r\n    if n % WIDTH != 0 {\r\n        // There isn't a very clean way to do this with FieldArray; for now just do it in serial.\r\n        // Another simple (though suboptimal) workaround would be to make two separate calls, one\r\n        // for the packed part and one for the remainder.\r\n        return batch_multiplicative_inverse_general(x, result, |x| x.inverse());\r\n    }\r\n\r\n    let x_packed = FieldArray::\u003cF, 4\u003e::pack_slice(x);\r\n    let result_packed = FieldArray::\u003cF, 4\u003e::pack_slice_mut(result);\r\n\r\n    batch_multiplicative_inverse_general(x_packed, result_packed, |x_packed| x_packed.inverse());\r\n}\r\n\r\n/// A simple single-threaded implementation of Montgomery's trick. Since not all `PrimeCharacteristicRing`s\r\n/// support inversion, this takes a custom inversion function.\r\npub(crate) fn batch_multiplicative_inverse_general\u003cF, Inv\u003e(x: \u0026[F], result: \u0026mut [F], inv: Inv)\r\nwhere\r\n    F: PrimeCharacteristicRing + Copy,\r\n    Inv: Fn(F) -\u003e F,\r\n{\r\n    let n = x.len();\r\n    assert_eq!(result.len(), n);\r\n    if n == 0 {\r\n        return;\r\n    }\r\n\r\n    result[0] = F::ONE;\r\n    for i in 1..n {\r\n        result[i] = result[i - 1] * x[i - 1];\r\n    }\r\n\r\n    let product = result[n - 1] * x[n - 1];\r\n    let mut inv = inv(product);\r\n\r\n    for i in (0..n).rev() {\r\n        result[i] *= inv;\r\n        inv *= x[i];\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":30,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":42,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":43,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":44,"address":[],"length":0,"stats":{"Line":9007199254740991998}},{"line":48,"address":[],"length":0,"stats":{"Line":16645304222761353240}},{"line":51,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":52,"address":[],"length":0,"stats":{"Line":5404319552844595199}},{"line":54,"address":[],"length":0,"stats":{"Line":10808639105689190399}},{"line":59,"address":[],"length":0,"stats":{"Line":16357073846609641493}},{"line":64,"address":[],"length":0,"stats":{"Line":16357073846609641493}},{"line":65,"address":[],"length":0,"stats":{"Line":16357073846609641493}},{"line":66,"address":[],"length":0,"stats":{"Line":16357073846609641470}},{"line":67,"address":[],"length":0,"stats":{"Line":14}},{"line":70,"address":[],"length":0,"stats":{"Line":16357073846609641470}},{"line":71,"address":[],"length":0,"stats":{"Line":4755801206503243770}},{"line":72,"address":[],"length":0,"stats":{"Line":2377900603251621885}},{"line":75,"address":[],"length":0,"stats":{"Line":16357073846609641490}},{"line":76,"address":[],"length":0,"stats":{"Line":16357073846609641490}},{"line":78,"address":[],"length":0,"stats":{"Line":5404319552844595212}},{"line":79,"address":[],"length":0,"stats":{"Line":3746994889972252669}},{"line":80,"address":[],"length":0,"stats":{"Line":3746994889972252669}}],"covered":23,"coverable":29},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","exponentiation.rs"],"content":"use crate::PrimeCharacteristicRing;\r\n\r\npub(crate) const fn bits_u64(n: u64) -\u003e usize {\r\n    (64 - n.leading_zeros()) as usize\r\n}\r\n\r\n/// Compute the exponential `x -\u003e x^1717986917` using a custom addition chain.\r\n///\r\n/// This map computes the fifth root of `x` if `x` is a member of the field `Mersenne31`.\r\n/// This follows from the computation: `5 * 1717986917 = 4*(2^31 - 2) + 1 = 1 mod p - 1`.\r\npub fn exp_1717986917\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n    // Note the binary expansion: 1717986917 = 1100110011001100110011001100101_2\r\n    // This uses 30 Squares + 7 Multiplications =\u003e 37 Operations total.\r\n    // Suspect it's possible to improve this with enough effort. For example 1717986918 takes only 4 Multiplications.\r\n    let p1 = val;\r\n    let p10 = p1.square();\r\n    let p11 = p10.clone() * p1;\r\n    let p101 = p10 * p11.clone();\r\n    let p110000 = p11.exp_power_of_2(4);\r\n    let p110011 = p110000 * p11.clone();\r\n    let p11001100000000 = p110011.exp_power_of_2(8);\r\n    let p11001100110011 = p11001100000000.clone() * p110011;\r\n    let p1100110000000000000000 = p11001100000000.exp_power_of_2(8);\r\n    let p1100110011001100110011 = p1100110000000000000000 * p11001100110011;\r\n    let p11001100110011001100110000 = p1100110011001100110011.exp_power_of_2(4);\r\n    let p11001100110011001100110011 = p11001100110011001100110000 * p11;\r\n    let p1100110011001100110011001100000 = p11001100110011001100110011.exp_power_of_2(5);\r\n    p1100110011001100110011001100000 * p101\r\n}\r\n\r\n/// Compute the exponential `x -\u003e x^1420470955` using a custom addition chain.\r\n///\r\n/// This map computes the third root of `x` if `x` is a member of the field `KoalaBear`.\r\n/// This follows from the computation: `3 * 1420470955 = 2*(2^31 - 2^24) + 1 = 1 mod (p - 1)`.\r\npub fn exp_1420470955\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n    // Note the binary expansion: 1420470955 = 1010100101010101010101010101011_2\r\n    // This uses 29 Squares + 7 Multiplications =\u003e 36 Operations total.\r\n    // Suspect it's possible to improve this with enough effort.\r\n    let p1 = val;\r\n    let p100 = p1.exp_power_of_2(2);\r\n    let p101 = p100.clone() * p1.clone();\r\n    let p10000 = p100.exp_power_of_2(2);\r\n    let p10101 = p10000 * p101;\r\n    let p10101000000 = p10101.clone().exp_power_of_2(6);\r\n    let p10101010101 = p10101000000.clone() * p10101.clone();\r\n    let p101010010101 = p10101000000 * p10101010101.clone();\r\n    let p101010010101000000000000 = p101010010101.exp_power_of_2(12);\r\n    let p101010010101010101010101 = p101010010101000000000000 * p10101010101;\r\n    let p101010010101010101010101000000 = p101010010101010101010101.exp_power_of_2(6);\r\n    let p101010010101010101010101010101 = p101010010101010101010101000000 * p10101;\r\n    let p1010100101010101010101010101010 = p101010010101010101010101010101.square();\r\n    p1010100101010101010101010101010 * p1.clone()\r\n}\r\n\r\n/// Compute the exponential `x -\u003e x^1725656503` using a custom addition chain.\r\n///\r\n/// This map computes the seventh root of `x` if `x` is a member of the field `BabyBear`.\r\n/// This follows from the computation: `7 * 1725656503 = 6*(2^31 - 2^27) + 1 = 1 mod (p - 1)`.\r\npub fn exp_1725656503\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n    // Note the binary expansion: 1725656503 = 1100110110110110110110110110111_2\r\n    // This uses 29 Squares + 8 Multiplications =\u003e 37 Operations total.\r\n    // Suspect it's possible to improve this with enough effort.\r\n    let p1 = val;\r\n    let p10 = p1.square();\r\n    let p11 = p10 * p1.clone();\r\n    let p110 = p11.square();\r\n    let p111 = p110.clone() * p1;\r\n    let p11000 = p110.exp_power_of_2(2);\r\n    let p11011 = p11000.clone() * p11;\r\n    let p11000000 = p11000.exp_power_of_2(3);\r\n    let p11011011 = p11000000.clone() * p11011;\r\n    let p110011011 = p11011011.clone() * p11000000;\r\n    let p110011011000000000 = p110011011.exp_power_of_2(9);\r\n    let p110011011011011011 = p110011011000000000 * p11011011.clone();\r\n    let p110011011011011011000000000 = p110011011011011011.exp_power_of_2(9);\r\n    let p110011011011011011011011011 = p110011011011011011000000000 * p11011011;\r\n    let p1100110110110110110110110110000 = p110011011011011011011011011.exp_power_of_2(4);\r\n    p1100110110110110110110110110000 * p111\r\n}\r\n\r\n/// Compute the exponential `x -\u003e x^10540996611094048183` using a custom addition chain.\r\n///\r\n/// This map computes the seventh root of `x` if `x` is a member of the field `Goldilocks`.\r\n/// This follows from the computation: `7 * 10540996611094048183 = 4*(2^64 - 2**32) + 1 = 1 mod (p - 1)`.\r\npub fn exp_10540996611094048183\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n    // Note the binary expansion: 10540996611094048183 = 1001001001001001001001001001000110110110110110110110110110110111_2.\r\n    // This uses 63 Squares + 8 Multiplications =\u003e 71 Operations total.\r\n    // Suspect it's possible to improve this a little with enough effort.\r\n    let p1 = val;\r\n    let p10 = p1.square();\r\n    let p11 = p10.clone() * p1.clone();\r\n    let p100 = p10.square();\r\n    let p111 = p100.clone() * p11.clone();\r\n    let p100000000000000000000000000000000 = p100.exp_power_of_2(30);\r\n    let p100000000000000000000000000000011 = p100000000000000000000000000000000 * p11;\r\n    let p100000000000000000000000000000011000 =\r\n        p100000000000000000000000000000011.exp_power_of_2(3);\r\n    let p100100000000000000000000000000011011 =\r\n        p100000000000000000000000000000011000 * p100000000000000000000000000000011;\r\n    let p100100000000000000000000000000011011000000 =\r\n        p100100000000000000000000000000011011.exp_power_of_2(6);\r\n    let p100100100100000000000000000000011011011011 =\r\n        p100100000000000000000000000000011011000000 * p100100000000000000000000000000011011.clone();\r\n    let p100100100100000000000000000000011011011011000000000000 =\r\n        p100100100100000000000000000000011011011011.exp_power_of_2(12);\r\n    let p100100100100100100100100000000011011011011011011011011 =\r\n        p100100100100000000000000000000011011011011000000000000\r\n            * p100100100100000000000000000000011011011011;\r\n    let p100100100100100100100100000000011011011011011011011011000000 =\r\n        p100100100100100100100100000000011011011011011011011011.exp_power_of_2(6);\r\n    let p100100100100100100100100100100011011011011011011011011011011 =\r\n        p100100100100100100100100000000011011011011011011011011000000\r\n            * p100100000000000000000000000000011011;\r\n    let p1001001001001001001001001001000110110110110110110110110110110000 =\r\n        p100100100100100100100100100100011011011011011011011011011011.exp_power_of_2(4);\r\n\r\n    p1001001001001001001001001001000110110110110110110110110110110000 * p111\r\n}\r\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":11168927075878830080}},{"line":4,"address":[],"length":0,"stats":{"Line":11168927075878830080}},{"line":11,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":15,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":16,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":17,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":18,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":19,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":20,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":21,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":22,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":23,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":24,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":25,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":26,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":27,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":28,"address":[],"length":0,"stats":{"Line":9439544818968559617}},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":39,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":47,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":48,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":49,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":51,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":52,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":63,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":73,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":77,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":78,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":85,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":89,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":90,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":91,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":92,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":93,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":95,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":96,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":97,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":99,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":100,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":105,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":106,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":107,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":108,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":109,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":110,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":111,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":112,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":113,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":114,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":117,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":78,"coverable":78},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","extension","binomial_extension.rs"],"content":"use alloc::format;\r\nuse alloc::string::ToString;\r\nuse alloc::vec::Vec;\r\nuse core::array;\r\nuse core::fmt::{self, Debug, Display, Formatter};\r\nuse core::iter::{Product, Sum};\r\nuse core::marker::PhantomData;\r\nuse core::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse itertools::Itertools;\r\nuse num_bigint::BigUint;\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse super::{HasFrobenius, HasTwoAdicBinomialExtension, PackedBinomialExtensionField};\r\nuse crate::extension::BinomiallyExtendable;\r\nuse crate::field::Field;\r\nuse crate::{\r\n    field_to_array, Algebra, ExtensionField, Packable, PrimeCharacteristicRing, Serializable,\r\n    TwoAdicField,\r\n};\r\n\r\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, PartialOrd, Ord)]\r\n#[repr(transparent)] // to make the zero_vec implementation safe\r\npub struct BinomialExtensionField\u003cF, const D: usize, A = F\u003e {\r\n    #[serde(\r\n        with = \"p3_util::array_serialization\",\r\n        bound(serialize = \"A: Serialize\", deserialize = \"A: Deserialize\u003c'de\u003e\")\r\n    )]\r\n    pub(crate) value: [A; D],\r\n    _phantom: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e BinomialExtensionField\u003cF, D, A\u003e {\r\n    pub(crate) const fn new(value: [A; D]) -\u003e Self {\r\n        Self {\r\n            value,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, A: Algebra\u003cF\u003e, const D: usize\u003e Default for BinomialExtensionField\u003cF, D, A\u003e {\r\n    fn default() -\u003e Self {\r\n        Self::new(array::from_fn(|_| A::ZERO))\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, A: Algebra\u003cF\u003e, const D: usize\u003e From\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e {\r\n    fn from(x: A) -\u003e Self {\r\n        Self::new(field_to_array(x))\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e Packable for BinomialExtensionField\u003cF, D\u003e {}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, A: Algebra\u003cF\u003e, const D: usize\u003e Serializable\u003cA\u003e\r\n    for BinomialExtensionField\u003cF, D, A\u003e\r\n{\r\n    const DIMENSION: usize = D;\r\n\r\n    #[inline]\r\n    fn serialize_as_slice(\u0026self) -\u003e \u0026[A] {\r\n        \u0026self.value\r\n    }\r\n\r\n    #[inline]\r\n    fn deserialize_fn\u003cFn: FnMut(usize) -\u003e A\u003e(f: Fn) -\u003e Self {\r\n        Self::new(array::from_fn(f))\r\n    }\r\n\r\n    #[inline]\r\n    fn deserialize_iter\u003cI: Iterator\u003cItem = A\u003e\u003e(iter: I) -\u003e Self {\r\n        let mut res = Self::default();\r\n        for (i, b) in iter.enumerate() {\r\n            res.value[i] = b;\r\n        }\r\n        res\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e ExtensionField\u003cF\u003e\r\n    for BinomialExtensionField\u003cF, D\u003e\r\n{\r\n    type ExtensionPacking = PackedBinomialExtensionField\u003cF, F::Packing, D\u003e;\r\n\r\n    fn is_in_basefield(\u0026self) -\u003e bool {\r\n        self.value[1..].iter().all(F::is_zero)\r\n    }\r\n\r\n    fn as_base(\u0026self) -\u003e Option\u003cF\u003e {\r\n        if \u003cSelf as ExtensionField\u003cF\u003e\u003e::is_in_basefield(self) {\r\n            Some(self.value[0])\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e HasFrobenius\u003cF\u003e for BinomialExtensionField\u003cF, D\u003e {\r\n    /// FrobeniusField automorphisms: x -\u003e x^n, where n is the order of BaseField.\r\n    fn frobenius(\u0026self) -\u003e Self {\r\n        self.repeated_frobenius(1)\r\n    }\r\n\r\n    /// Repeated Frobenius automorphisms: x -\u003e x^(n^count).\r\n    ///\r\n    /// Follows precomputation suggestion in Section 11.3.3 of the\r\n    /// Handbook of Elliptic and Hyperelliptic Curve Cryptography.\r\n    fn repeated_frobenius(\u0026self, count: usize) -\u003e Self {\r\n        if count == 0 {\r\n            return *self;\r\n        } else if count \u003e= D {\r\n            // x |-\u003e x^(n^D) is the identity, so x^(n^count) ==\r\n            // x^(n^(count % D))\r\n            return self.repeated_frobenius(count % D);\r\n        }\r\n        let arr: \u0026[F] = self.serialize_as_slice();\r\n\r\n        // z0 = DTH_ROOT^count = W^(k * count) where k = floor((n-1)/D)\r\n        let mut z0 = F::DTH_ROOT;\r\n        for _ in 1..count {\r\n            z0 *= F::DTH_ROOT;\r\n        }\r\n\r\n        let mut res = [F::ZERO; D];\r\n        for (i, z) in z0.powers().take(D).enumerate() {\r\n            res[i] = arr[i] * z;\r\n        }\r\n\r\n        Self::deserialize_slice(\u0026res)\r\n    }\r\n\r\n    /// Algorithm 11.3.4 in Handbook of Elliptic and Hyperelliptic Curve Cryptography.\r\n    fn frobenius_inv(\u0026self) -\u003e Self {\r\n        // Writing 'a' for self, we need to compute a^(r-1):\r\n        // r = n^D-1/n-1 = n^(D-1)+n^(D-2)+...+n\r\n        let mut f = Self::ONE;\r\n        for _ in 1..D {\r\n            f = (f * *self).frobenius();\r\n        }\r\n\r\n        // g = a^r is in the base field, so only compute that\r\n        // coefficient rather than the full product.\r\n        let a = self.value;\r\n        let b = f.value;\r\n        let mut g = F::ZERO;\r\n        for i in 1..D {\r\n            g += a[i] * b[D - i];\r\n        }\r\n        g *= F::W;\r\n        g += a[0] * b[0];\r\n        debug_assert_eq!(Self::from(g), *self * f);\r\n\r\n        f * g.inverse()\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e PrimeCharacteristicRing for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type PrimeSubfield = \u003cA as PrimeCharacteristicRing\u003e::PrimeSubfield;\r\n\r\n    const ZERO: Self = Self::new([A::ZERO; D]);\r\n\r\n    const ONE: Self = Self::new(field_to_array(A::ONE));\r\n\r\n    const TWO: Self = Self::new(field_to_array(A::TWO));\r\n\r\n    const NEG_ONE: Self = Self::new(field_to_array(A::NEG_ONE));\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        \u003cA as PrimeCharacteristicRing\u003e::from_prime_subfield(f).into()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn square(\u0026self) -\u003e Self {\r\n        match D {\r\n            2 =\u003e {\r\n                let a = self.value.clone();\r\n                let mut res = Self::default();\r\n                res.value[0] = a[0].square() + a[1].square() * F::W;\r\n                res.value[1] = a[0].clone() * a[1].double();\r\n                res\r\n            }\r\n            3 =\u003e {\r\n                let mut res = Self::default();\r\n                cubic_square(\u0026self.value, \u0026mut res.value);\r\n                res\r\n            }\r\n            _ =\u003e \u003cSelf as Mul\u003cSelf\u003e\u003e::mul(self.clone(), self.clone()),\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(F::zero_vec(len * D)) }\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e Algebra\u003cF\u003e for BinomialExtensionField\u003cF, D\u003e {}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e Field for BinomialExtensionField\u003cF, D\u003e {\r\n    type Packing = Self;\r\n\r\n    const GENERATOR: Self = Self::new(F::EXT_GENERATOR);\r\n\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\r\n        if self.is_zero() {\r\n            return None;\r\n        }\r\n\r\n        match D {\r\n            2 =\u003e Some(Self::deserialize_slice(\u0026qudratic_inv(\u0026self.value, F::W))),\r\n            3 =\u003e Some(Self::deserialize_slice(\u0026cubic_inv(\u0026self.value, F::W))),\r\n            _ =\u003e Some(self.frobenius_inv()),\r\n        }\r\n    }\r\n\r\n    fn halve(\u0026self) -\u003e Self {\r\n        Self::new(self.value.map(|x| x.halve()))\r\n    }\r\n\r\n    fn order() -\u003e BigUint {\r\n        F::order().pow(D as u32)\r\n    }\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e Display for BinomialExtensionField\u003cF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n{\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        if self.is_zero() {\r\n            write!(f, \"0\")\r\n        } else {\r\n            let str = self\r\n                .value\r\n                .iter()\r\n                .enumerate()\r\n                .filter(|(_, x)| !x.is_zero())\r\n                .map(|(i, x)| match (i, x.is_one()) {\r\n                    (0, _) =\u003e format!(\"{x}\"),\r\n                    (1, true) =\u003e \"X\".to_string(),\r\n                    (1, false) =\u003e format!(\"{x} X\"),\r\n                    (_, true) =\u003e format!(\"X^{i}\"),\r\n                    (_, false) =\u003e format!(\"{x} X^{i}\"),\r\n                })\r\n                .join(\" + \");\r\n            write!(f, \"{}\", str)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Neg for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        Self::new(self.value.map(A::neg))\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Add for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let value = vector_add(\u0026self.value, \u0026rhs.value);\r\n        Self::new(value)\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Add\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(mut self, rhs: A) -\u003e Self {\r\n        self.value[0] += rhs;\r\n        self\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e AddAssign for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        for i in 0..D {\r\n            self.value[i] += rhs.value[i].clone();\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e AddAssign\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: A) {\r\n        self.value[0] += rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Sum for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|acc, x| acc + x).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Sub for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let value = vector_sub(\u0026self.value, \u0026rhs.value);\r\n        Self::new(value)\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Sub\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: A) -\u003e Self {\r\n        let mut res = self.value;\r\n        res[0] -= rhs;\r\n        Self::new(res)\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e SubAssign for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        for i in 0..D {\r\n            self.value[i] -= rhs.value[i].clone();\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e SubAssign\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: A) {\r\n        self.value[0] -= rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Mul for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let a = self.value;\r\n        let b = rhs.value;\r\n        let mut res = Self::default();\r\n        let w = F::W;\r\n\r\n        binomial_mul(\u0026a, \u0026b, \u0026mut res.value, w);\r\n\r\n        res\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Mul\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: A) -\u003e Self {\r\n        Self::new(self.value.map(|x| x * rhs.clone()))\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e MulAssign for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = self.clone() * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e MulAssign\u003cA\u003e for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: A) {\r\n        *self = self.clone() * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, const D: usize\u003e Product for BinomialExtensionField\u003cF, D, A\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e,\r\n{\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|acc, x| acc * x).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e Div for BinomialExtensionField\u003cF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Self) -\u003e Self::Output {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e DivAssign for BinomialExtensionField\u003cF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n{\r\n    #[inline]\r\n    fn div_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self / rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, const D: usize\u003e Distribution\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for Standard\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    fn sample\u003cR: rand::Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e BinomialExtensionField\u003cF, D\u003e {\r\n        let mut res = [F::ZERO; D];\r\n        for r in res.iter_mut() {\r\n            *r = Standard.sample(rng);\r\n        }\r\n        BinomialExtensionField::deserialize_slice(\u0026res)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field + HasTwoAdicBinomialExtension\u003cD\u003e, const D: usize\u003e TwoAdicField\r\n    for BinomialExtensionField\u003cF, D\u003e\r\n{\r\n    const TWO_ADICITY: usize = F::EXT_TWO_ADICITY;\r\n\r\n    #[inline]\r\n    fn two_adic_generator(bits: usize) -\u003e Self {\r\n        Self::new(F::ext_two_adic_generator(bits))\r\n    }\r\n}\r\n\r\n/// Add two vectors element wise.\r\n#[inline]\r\npub(crate) fn vector_add\u003c\r\n    R: PrimeCharacteristicRing + Add\u003cR2, Output = R\u003e,\r\n    R2: Clone,\r\n    const D: usize,\r\n\u003e(\r\n    a: \u0026[R; D],\r\n    b: \u0026[R2; D],\r\n) -\u003e [R; D] {\r\n    array::from_fn(|i| a[i].clone() + b[i].clone())\r\n}\r\n\r\n/// Subtract two vectors element wise.\r\n#[inline]\r\npub(crate) fn vector_sub\u003c\r\n    R: PrimeCharacteristicRing + Sub\u003cR2, Output = R\u003e,\r\n    R2: Clone,\r\n    const D: usize,\r\n\u003e(\r\n    a: \u0026[R; D],\r\n    b: \u0026[R2; D],\r\n) -\u003e [R; D] {\r\n    array::from_fn(|i| a[i].clone() - b[i].clone())\r\n}\r\n\r\n/// Multiply two vectors representing elements in a binomial extension.\r\n#[inline]\r\npub(super) fn binomial_mul\u003c\r\n    F: Field,\r\n    R: Algebra\u003cF\u003e + Mul\u003cR2, Output = R\u003e,\r\n    R2: Add\u003cOutput = R2\u003e + Clone,\r\n    const D: usize,\r\n\u003e(\r\n    a: \u0026[R; D],\r\n    b: \u0026[R2; D],\r\n    res: \u0026mut [R; D],\r\n    w: F,\r\n) {\r\n    match D {\r\n        2 =\u003e {\r\n            res[0] = a[0].clone() * b[0].clone() + a[1].clone() * w * b[1].clone();\r\n            res[1] = a[0].clone() * b[1].clone() + a[1].clone() * b[0].clone();\r\n        }\r\n        3 =\u003e cubic_mul(a, b, res, w),\r\n        _ =\u003e\r\n        {\r\n            #[allow(clippy::needless_range_loop)]\r\n            for i in 0..D {\r\n                for j in 0..D {\r\n                    if i + j \u003e= D {\r\n                        res[i + j - D] += a[i].clone() * w * b[j].clone();\r\n                    } else {\r\n                        res[i + j] += a[i].clone() * b[j].clone();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n///Section 11.3.6b in Handbook of Elliptic and Hyperelliptic Curve Cryptography.\r\n#[inline]\r\nfn qudratic_inv\u003cF: Field\u003e(a: \u0026[F], w: F) -\u003e [F; 2] {\r\n    let scalar = (a[0].square() - w * a[1].square()).inverse();\r\n    [a[0] * scalar, -a[1] * scalar]\r\n}\r\n\r\n/// Section 11.3.6b in Handbook of Elliptic and Hyperelliptic Curve Cryptography.\r\n#[inline]\r\nfn cubic_inv\u003cF: Field\u003e(a: \u0026[F], w: F) -\u003e [F; 3] {\r\n    let a0_square = a[0].square();\r\n    let a1_square = a[1].square();\r\n    let a2_w = w * a[2];\r\n    let a0_a1 = a[0] * a[1];\r\n\r\n    // scalar = (a0^3+wa1^3+w^2a2^3-3wa0a1a2)^-1\r\n    let scalar = (a0_square * a[0] + w * a[1] * a1_square + a2_w.square() * a[2]\r\n        - (F::ONE + F::TWO) * a2_w * a0_a1)\r\n        .inverse();\r\n\r\n    //scalar*[a0^2-wa1a2, wa2^2-a0a1, a1^2-a0a2]\r\n    [\r\n        scalar * (a0_square - a[1] * a2_w),\r\n        scalar * (a2_w * a[2] - a0_a1),\r\n        scalar * (a1_square - a[0] * a[2]),\r\n    ]\r\n}\r\n\r\n/// karatsuba multiplication for cubic extension field\r\n#[inline]\r\npub(crate) fn cubic_mul\u003c\r\n    F: Field,\r\n    R: Algebra\u003cF\u003e + Mul\u003cR2, Output = R\u003e,\r\n    R2: Add\u003cOutput = R2\u003e + Clone,\r\n    const D: usize,\r\n\u003e(\r\n    a: \u0026[R; D],\r\n    b: \u0026[R2; D],\r\n    res: \u0026mut [R; D],\r\n    w: F,\r\n) {\r\n    assert_eq!(D, 3);\r\n\r\n    let a0_b0 = a[0].clone() * b[0].clone();\r\n    let a1_b1 = a[1].clone() * b[1].clone();\r\n    let a2_b2 = a[2].clone() * b[2].clone();\r\n\r\n    res[0] = a0_b0.clone()\r\n        + ((a[1].clone() + a[2].clone()) * (b[1].clone() + b[2].clone())\r\n            - a1_b1.clone()\r\n            - a2_b2.clone())\r\n            * w;\r\n    res[1] = (a[0].clone() + a[1].clone()) * (b[0].clone() + b[1].clone())\r\n        - a0_b0.clone()\r\n        - a1_b1.clone()\r\n        + a2_b2.clone() * w;\r\n    res[2] = (a[0].clone() + a[2].clone()) * (b[0].clone() + b[2].clone()) - a0_b0 - a2_b2 + a1_b1;\r\n}\r\n\r\n/// Section 11.3.6a in Handbook of Elliptic and Hyperelliptic Curve Cryptography.\r\n#[inline]\r\npub fn cubic_square\u003cF: BinomiallyExtendable\u003cD\u003e, A: Algebra\u003cF\u003e, const D: usize\u003e(\r\n    a: \u0026[A; D],\r\n    res: \u0026mut [A; D],\r\n) {\r\n    assert_eq!(D, 3);\r\n\r\n    let w_a2 = a[2].clone() * F::W;\r\n\r\n    res[0] = a[0].square() + (a[1].clone() * w_a2.clone()).double();\r\n    res[1] = w_a2 * a[2].clone() + (a[0].clone() * a[1].clone()).double();\r\n    res[2] = a[1].square() + (a[0].clone() * a[2].clone()).double();\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1224979098644777953}},{"line":46,"address":[],"length":0,"stats":{"Line":13042424520864958117}},{"line":47,"address":[],"length":0,"stats":{"Line":2954361355555048955}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075856173}},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075856173}},{"line":65,"address":[],"length":0,"stats":{"Line":16933534598913065314}},{"line":66,"address":[],"length":0,"stats":{"Line":16933534598913065314}},{"line":70,"address":[],"length":0,"stats":{"Line":6124895493223883089}},{"line":71,"address":[],"length":0,"stats":{"Line":6124895493223883089}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":16}},{"line":90,"address":[],"length":0,"stats":{"Line":16}},{"line":93,"address":[],"length":0,"stats":{"Line":20}},{"line":94,"address":[],"length":0,"stats":{"Line":20}},{"line":95,"address":[],"length":0,"stats":{"Line":20}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":10376293541461624875}},{"line":105,"address":[],"length":0,"stats":{"Line":10376293541461624875}},{"line":112,"address":[],"length":0,"stats":{"Line":10376293541461622970}},{"line":113,"address":[],"length":0,"stats":{"Line":10376293541461622970}},{"line":114,"address":[],"length":0,"stats":{"Line":547}},{"line":115,"address":[],"length":0,"stats":{"Line":10376293541461622449}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":10376293541461622449}},{"line":123,"address":[],"length":0,"stats":{"Line":10376293541461622449}},{"line":124,"address":[],"length":0,"stats":{"Line":10376293541461622996}},{"line":125,"address":[],"length":0,"stats":{"Line":547}},{"line":128,"address":[],"length":0,"stats":{"Line":10376293541461622783}},{"line":129,"address":[],"length":0,"stats":{"Line":1152921504606848015}},{"line":130,"address":[],"length":0,"stats":{"Line":4611686018427388424}},{"line":133,"address":[],"length":0,"stats":{"Line":10376293541461622783}},{"line":137,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":140,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":141,"address":[],"length":0,"stats":{"Line":5764607523034236029}},{"line":142,"address":[],"length":0,"stats":{"Line":10376293541461622950}},{"line":147,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":148,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":149,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":150,"address":[],"length":0,"stats":{"Line":16140901064495859993}},{"line":151,"address":[],"length":0,"stats":{"Line":10376293541461623288}},{"line":153,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":154,"address":[],"length":0,"stats":{"Line":3458764513820541744}},{"line":155,"address":[],"length":0,"stats":{"Line":6917529027641083176}},{"line":157,"address":[],"length":0,"stats":{"Line":3458764513820541406}},{"line":177,"address":[],"length":0,"stats":{"Line":17437937757178561006}},{"line":178,"address":[],"length":0,"stats":{"Line":17437937757178561006}},{"line":182,"address":[],"length":0,"stats":{"Line":16789419410837209084}},{"line":183,"address":[],"length":0,"stats":{"Line":16789419410837209084}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":11817445422220184077}},{"line":186,"address":[],"length":0,"stats":{"Line":11817445422220184077}},{"line":187,"address":[],"length":0,"stats":{"Line":11817445422220184077}},{"line":188,"address":[],"length":0,"stats":{"Line":11817445422220184077}},{"line":189,"address":[],"length":0,"stats":{"Line":11817445422220184077}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":5332261958806667349}},{"line":193,"address":[],"length":0,"stats":{"Line":5332261958806667349}},{"line":194,"address":[],"length":0,"stats":{"Line":5332261958806667349}},{"line":196,"address":[],"length":0,"stats":{"Line":15924728282382073856}},{"line":201,"address":[],"length":0,"stats":{"Line":7926335344172073019}},{"line":203,"address":[],"length":0,"stats":{"Line":7926335344172073019}},{"line":214,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":215,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":216,"address":[],"length":0,"stats":{"Line":504403158265495765}},{"line":219,"address":[],"length":0,"stats":{"Line":3819052484010180503}},{"line":220,"address":[],"length":0,"stats":{"Line":17509995351216488447}},{"line":221,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":222,"address":[],"length":0,"stats":{"Line":3458764513820540927}},{"line":226,"address":[],"length":0,"stats":{"Line":13690942867206307857}},{"line":227,"address":[],"length":0,"stats":{"Line":8502796096475497071}},{"line":230,"address":[],"length":0,"stats":{"Line":1297036692682702864}},{"line":231,"address":[],"length":0,"stats":{"Line":1297036692682702864}},{"line":239,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":240,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":241,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":243,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":244,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":247,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":248,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":249,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":250,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":10736581511651262889}},{"line":270,"address":[],"length":0,"stats":{"Line":10736581511651262889}},{"line":282,"address":[],"length":0,"stats":{"Line":11817445422220184451}},{"line":283,"address":[],"length":0,"stats":{"Line":11817445422220184451}},{"line":284,"address":[],"length":0,"stats":{"Line":11817445422220184451}},{"line":296,"address":[],"length":0,"stats":{"Line":13402712491054597783}},{"line":297,"address":[],"length":0,"stats":{"Line":13402712491054597783}},{"line":298,"address":[],"length":0,"stats":{"Line":13402712491054597783}},{"line":308,"address":[],"length":0,"stats":{"Line":15996785876420004468}},{"line":309,"address":[],"length":0,"stats":{"Line":5620492334958382324}},{"line":310,"address":[],"length":0,"stats":{"Line":5476377146882523880}},{"line":321,"address":[],"length":0,"stats":{"Line":78}},{"line":322,"address":[],"length":0,"stats":{"Line":78}},{"line":331,"address":[],"length":0,"stats":{"Line":8863084066665136210}},{"line":332,"address":[],"length":0,"stats":{"Line":7566047373982433663}},{"line":344,"address":[],"length":0,"stats":{"Line":3098476543630902298}},{"line":345,"address":[],"length":0,"stats":{"Line":3098476543630902298}},{"line":346,"address":[],"length":0,"stats":{"Line":3098476543630902298}},{"line":358,"address":[],"length":0,"stats":{"Line":14195346025471804458}},{"line":359,"address":[],"length":0,"stats":{"Line":14195346025471804458}},{"line":360,"address":[],"length":0,"stats":{"Line":14195346025471804458}},{"line":361,"address":[],"length":0,"stats":{"Line":14195346025471804458}},{"line":371,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":372,"address":[],"length":0,"stats":{"Line":342}},{"line":373,"address":[],"length":0,"stats":{"Line":9223372036854775922}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":398,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":399,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":400,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":401,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":403,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":405,"address":[],"length":0,"stats":{"Line":5764607523034235319}},{"line":417,"address":[],"length":0,"stats":{"Line":9439544818968561257}},{"line":418,"address":[],"length":0,"stats":{"Line":936748722493073035}},{"line":428,"address":[],"length":0,"stats":{"Line":14051230837395949810}},{"line":429,"address":[],"length":0,"stats":{"Line":14051230837395949810}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":450,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":462,"address":[],"length":0,"stats":{"Line":13402712491054597900}},{"line":463,"address":[],"length":0,"stats":{"Line":13402712491054597900}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":482,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":483,"address":[],"length":0,"stats":{"Line":5836665117072162816}},{"line":484,"address":[],"length":0,"stats":{"Line":8718968878589280272}},{"line":485,"address":[],"length":0,"stats":{"Line":10664523917613334536}},{"line":487,"address":[],"length":0,"stats":{"Line":5836665117072162856}},{"line":497,"address":[],"length":0,"stats":{"Line":14987979559889010697}},{"line":498,"address":[],"length":0,"stats":{"Line":14987979559889010697}},{"line":504,"address":[],"length":0,"stats":{"Line":14051230837395947753}},{"line":512,"address":[],"length":0,"stats":{"Line":10952754293765047478}},{"line":517,"address":[],"length":0,"stats":{"Line":3098476543630902107}},{"line":525,"address":[],"length":0,"stats":{"Line":16357073846609646040}},{"line":530,"address":[],"length":0,"stats":{"Line":11385099857992613934}},{"line":541,"address":[],"length":0,"stats":{"Line":11385099857992613934}},{"line":542,"address":[],"length":0,"stats":{"Line":4611686018427387975}},{"line":543,"address":[],"length":0,"stats":{"Line":4611686018427387975}},{"line":544,"address":[],"length":0,"stats":{"Line":4611686018427387975}},{"line":546,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":14123288431433876305}},{"line":551,"address":[],"length":0,"stats":{"Line":2449958197289592523}},{"line":552,"address":[],"length":0,"stats":{"Line":720575940379294477}},{"line":553,"address":[],"length":0,"stats":{"Line":720575940379294477}},{"line":555,"address":[],"length":0,"stats":{"Line":5260204364768744865}},{"line":565,"address":[],"length":0,"stats":{"Line":17509995351216488447}},{"line":566,"address":[],"length":0,"stats":{"Line":17509995351216488447}},{"line":567,"address":[],"length":0,"stats":{"Line":17509995351216488447}},{"line":572,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":573,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":574,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":575,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":576,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":579,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":580,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":585,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":586,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":587,"address":[],"length":0,"stats":{"Line":6052837899185947832}},{"line":593,"address":[],"length":0,"stats":{"Line":2954361355555047113}},{"line":604,"address":[],"length":0,"stats":{"Line":2954361355555047113}},{"line":606,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":607,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":608,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":610,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":611,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":612,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":613,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":614,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":615,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":616,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":617,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":618,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":619,"address":[],"length":0,"stats":{"Line":2954361355555047105}},{"line":624,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":628,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":630,"address":[],"length":0,"stats":{"Line":1224979098644776112}},{"line":632,"address":[],"length":0,"stats":{"Line":1224979098644776112}},{"line":633,"address":[],"length":0,"stats":{"Line":1224979098644776112}},{"line":634,"address":[],"length":0,"stats":{"Line":1224979098644776112}}],"covered":173,"coverable":192},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","extension","complex.rs"],"content":"use super::{BinomialExtensionField, BinomiallyExtendable, HasTwoAdicBinomialExtension};\r\nuse crate::{Algebra, Field, PrimeCharacteristicRing};\r\n\r\npub type Complex\u003cF\u003e = BinomialExtensionField\u003cF, 2\u003e;\r\n\r\n/// A field for which `p = 3 (mod 4)`. Equivalently, `-1` is not a square,\r\n/// so the complex extension can be defined `F[i] = F[X]/(X^2+1)`.\r\npub trait ComplexExtendable: Field {\r\n    /// The two-adicity of `p+1`, the order of the circle group.\r\n    const CIRCLE_TWO_ADICITY: usize;\r\n\r\n    const COMPLEX_GENERATOR: Complex\u003cSelf\u003e;\r\n\r\n    fn circle_two_adic_generator(bits: usize) -\u003e Complex\u003cSelf\u003e;\r\n}\r\n\r\nimpl\u003cF: ComplexExtendable\u003e BinomiallyExtendable\u003c2\u003e for F {\r\n    const W: Self = F::NEG_ONE;\r\n\r\n    // since `p = 3 (mod 4)`, `(p-1)/2` is always odd,\r\n    // so `(-1)^((p-1)/2) = -1`\r\n    const DTH_ROOT: Self = F::NEG_ONE;\r\n\r\n    const EXT_GENERATOR: [Self; 2] = F::COMPLEX_GENERATOR.value;\r\n}\r\n\r\n/// Convenience methods for complex extensions\r\nimpl\u003cR: PrimeCharacteristicRing\u003e Complex\u003cR\u003e {\r\n    #[inline(always)]\r\n    pub const fn new_complex(real: R, imag: R) -\u003e Self {\r\n        Self::new([real, imag])\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub const fn new_real(real: R) -\u003e Self {\r\n        Self::new_complex(real, R::ZERO)\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub const fn new_imag(imag: R) -\u003e Self {\r\n        Self::new_complex(R::ZERO, imag)\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub fn real(\u0026self) -\u003e R {\r\n        self.value[0].clone()\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub fn imag(\u0026self) -\u003e R {\r\n        self.value[1].clone()\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub fn conjugate(\u0026self) -\u003e Self {\r\n        Self::new_complex(self.real(), self.imag().neg())\r\n    }\r\n\r\n    #[inline]\r\n    pub fn norm(\u0026self) -\u003e R {\r\n        self.real().square() + self.imag().square()\r\n    }\r\n\r\n    #[inline(always)]\r\n    pub fn to_array(\u0026self) -\u003e [R; 2] {\r\n        self.value.clone()\r\n    }\r\n\r\n    // Sometimes we want to rotate over an extension that's not necessarily ComplexExtendable,\r\n    // but still on the circle.\r\n    pub fn rotate\u003cExt: Algebra\u003cR\u003e\u003e(\u0026self, rhs: Complex\u003cExt\u003e) -\u003e Complex\u003cExt\u003e {\r\n        Complex::\u003cExt\u003e::new_complex(\r\n            rhs.real() * self.real() - rhs.imag() * self.imag(),\r\n            rhs.imag() * self.real() + rhs.real() * self.imag(),\r\n        )\r\n    }\r\n}\r\n\r\n/// The complex extension of this field has a binomial extension.\r\n///\r\n/// This exists if the polynomial ring `F[i][X]` has an irreducible polynomial `X^d-W`\r\n/// allowing us to define the binomial extension field `F[i][X]/(X^d-W)`.\r\npub trait HasComplexBinomialExtension\u003cconst D: usize\u003e: ComplexExtendable {\r\n    const W: Complex\u003cSelf\u003e;\r\n\r\n    // DTH_ROOT = W^((n - 1)/D).\r\n    // n is the order of base field.\r\n    // Only works when exists k such that n = kD + 1.\r\n    const DTH_ROOT: Complex\u003cSelf\u003e;\r\n\r\n    const EXT_GENERATOR: [Complex\u003cSelf\u003e; D];\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e BinomiallyExtendable\u003cD\u003e for Complex\u003cF\u003e\r\nwhere\r\n    F: HasComplexBinomialExtension\u003cD\u003e,\r\n{\r\n    const W: Self = \u003cF as HasComplexBinomialExtension\u003cD\u003e\u003e::W;\r\n\r\n    const DTH_ROOT: Self = \u003cF as HasComplexBinomialExtension\u003cD\u003e\u003e::DTH_ROOT;\r\n\r\n    const EXT_GENERATOR: [Self; D] = F::EXT_GENERATOR;\r\n}\r\n\r\n/// The complex extension of this field has a two-adic binomial extension.\r\npub trait HasTwoAdicComplexBinomialExtension\u003cconst D: usize\u003e:\r\n    HasComplexBinomialExtension\u003cD\u003e\r\n{\r\n    const COMPLEX_EXT_TWO_ADICITY: usize;\r\n\r\n    fn complex_ext_two_adic_generator(bits: usize) -\u003e [Complex\u003cSelf\u003e; D];\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e HasTwoAdicBinomialExtension\u003cD\u003e for Complex\u003cF\u003e\r\nwhere\r\n    F: HasTwoAdicComplexBinomialExtension\u003cD\u003e,\r\n{\r\n    const EXT_TWO_ADICITY: usize = F::COMPLEX_EXT_TWO_ADICITY;\r\n\r\n    #[inline(always)]\r\n    fn ext_two_adic_generator(bits: usize) -\u003e [Self; D] {\r\n        F::complex_ext_two_adic_generator(bits)\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":31,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567665}},{"line":36,"address":[],"length":0,"stats":{"Line":432345564227567665}},{"line":40,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":41,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":45,"address":[],"length":0,"stats":{"Line":1224979098644775022}},{"line":46,"address":[],"length":0,"stats":{"Line":1224979098644775022}},{"line":50,"address":[],"length":0,"stats":{"Line":1224979098644774986}},{"line":51,"address":[],"length":0,"stats":{"Line":1224979098644774986}},{"line":55,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":56,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":9079256848778920038}},{"line":66,"address":[],"length":0,"stats":{"Line":9079256848778920038}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":122,"address":[],"length":0,"stats":{"Line":6557241057451442176}}],"covered":16,"coverable":21},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","extension","mod.rs"],"content":"use core::{debug_assert, debug_assert_eq, iter};\r\n\r\nuse crate::field::Field;\r\nuse crate::{naive_poly_mul, ExtensionField};\r\n\r\nmod binomial_extension;\r\nmod complex;\r\nmod packed_binomial_extension;\r\n\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\npub use binomial_extension::*;\r\npub use complex::*;\r\npub use packed_binomial_extension::*;\r\n\r\n/// Binomial extension field trait.\r\n///\r\n/// This exists if the polynomial ring `F[X]` has an irreducible polynomial `X^d-W`\r\n/// allowing us to define the binomial extension field `F[X]/(X^d-W)`.\r\npub trait BinomiallyExtendable\u003cconst D: usize\u003e: Field {\r\n    const W: Self;\r\n\r\n    // DTH_ROOT = W^((n - 1)/D).\r\n    // n is the order of base field.\r\n    // Only works when exists k such that n = kD + 1.\r\n    const DTH_ROOT: Self;\r\n\r\n    const EXT_GENERATOR: [Self; D];\r\n}\r\n\r\npub trait HasFrobenius\u003cF: Field\u003e: ExtensionField\u003cF\u003e {\r\n    fn frobenius(\u0026self) -\u003e Self;\r\n    fn repeated_frobenius(\u0026self, count: usize) -\u003e Self;\r\n    fn frobenius_inv(\u0026self) -\u003e Self;\r\n\r\n    fn minimal_poly(mut self) -\u003e Vec\u003cF\u003e {\r\n        let mut m = vec![Self::ONE];\r\n        for _ in 0..Self::DIMENSION {\r\n            m = naive_poly_mul(\u0026m, \u0026[-self, Self::ONE]);\r\n            self = self.frobenius();\r\n        }\r\n        let mut m_iter = m\r\n            .into_iter()\r\n            .map(|c| c.as_base().expect(\"Extension is not algebraic?\"));\r\n        let m: Vec\u003cF\u003e = m_iter.by_ref().take(Self::DIMENSION + 1).collect();\r\n        debug_assert_eq!(m.len(), Self::DIMENSION + 1);\r\n        debug_assert_eq!(m.last(), Some(\u0026F::ONE));\r\n        debug_assert!(m_iter.all(|c| c.is_zero()));\r\n        m\r\n    }\r\n\r\n    fn galois_group(self) -\u003e Vec\u003cSelf\u003e {\r\n        iter::successors(Some(self), |x| Some(x.frobenius()))\r\n            .take(Self::DIMENSION)\r\n            .collect()\r\n    }\r\n}\r\n\r\n/// Optional trait for implementing Two Adic Binomial Extension Field.\r\npub trait HasTwoAdicBinomialExtension\u003cconst D: usize\u003e: BinomiallyExtendable\u003cD\u003e {\r\n    const EXT_TWO_ADICITY: usize;\r\n\r\n    /// Assumes the multiplicative group size has at least `bits` powers of two, otherwise the\r\n    /// behavior is undefined.\r\n    fn ext_two_adic_generator(bits: usize) -\u003e [Self; D];\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":20}},{"line":38,"address":[],"length":0,"stats":{"Line":20}},{"line":39,"address":[],"length":0,"stats":{"Line":28}},{"line":40,"address":[],"length":0,"stats":{"Line":4}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":20}},{"line":45,"address":[],"length":0,"stats":{"Line":44}},{"line":46,"address":[],"length":0,"stats":{"Line":20}},{"line":47,"address":[],"length":0,"stats":{"Line":36}},{"line":48,"address":[],"length":0,"stats":{"Line":12}},{"line":49,"address":[],"length":0,"stats":{"Line":36}},{"line":50,"address":[],"length":0,"stats":{"Line":8}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}}],"covered":12,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","extension","packed_binomial_extension.rs"],"content":"use alloc::vec::Vec;\r\nuse core::array;\r\nuse core::fmt::Debug;\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse itertools::Itertools;\r\nuse p3_util::convert_vec;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse super::{binomial_mul, cubic_square, vector_add, vector_sub, BinomialExtensionField};\r\nuse crate::extension::BinomiallyExtendable;\r\nuse crate::{\r\n    field_to_array, Algebra, Field, PackedField, PackedFieldExtension, PackedValue, Powers,\r\n    PrimeCharacteristicRing, Serializable,\r\n};\r\n\r\n#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, PartialOrd, Ord)]\r\n#[repr(transparent)] // to make the zero_vec implementation safe\r\npub struct PackedBinomialExtensionField\u003cF: Field, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e {\r\n    #[serde(\r\n        with = \"p3_util::array_serialization\",\r\n        bound(serialize = \"PF: Serialize\", deserialize = \"PF: Deserialize\u003c'de\u003e\")\r\n    )]\r\n    pub(crate) value: [PF; D],\r\n}\r\n\r\nimpl\u003cF: Field, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e PackedBinomialExtensionField\u003cF, PF, D\u003e {\r\n    fn new(value: [PF; D]) -\u003e Self {\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e Default\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\n{\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            value: array::from_fn(|_| PF::ZERO),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e From\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\n{\r\n    fn from(x: BinomialExtensionField\u003cF, D\u003e) -\u003e Self {\r\n        Self {\r\n            value: x.value.map(Into::\u003cPF\u003e::into),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e From\u003cPF\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\n{\r\n    fn from(x: PF) -\u003e Self {\r\n        Self {\r\n            value: field_to_array::\u003cPF, D\u003e(x),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e\r\n    Algebra\u003cBinomialExtensionField\u003cF, D\u003e\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\n{\r\n}\r\n\r\nimpl\u003cF: BinomiallyExtendable\u003cD\u003e, PF: PackedField\u003cScalar = F\u003e, const D: usize\u003e Algebra\u003cPF\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\n{\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e PrimeCharacteristicRing for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type PrimeSubfield = PF::PrimeSubfield;\r\n\r\n    const ZERO: Self = Self {\r\n        value: [PF::ZERO; D],\r\n    };\r\n\r\n    const ONE: Self = Self {\r\n        value: field_to_array::\u003cPF, D\u003e(PF::ONE),\r\n    };\r\n\r\n    const TWO: Self = Self {\r\n        value: field_to_array::\u003cPF, D\u003e(PF::TWO),\r\n    };\r\n\r\n    const NEG_ONE: Self = Self {\r\n        value: field_to_array::\u003cPF, D\u003e(PF::NEG_ONE),\r\n    };\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(val: Self::PrimeSubfield) -\u003e Self {\r\n        PF::from_prime_subfield(val).into()\r\n    }\r\n\r\n    #[inline]\r\n    fn from_bool(b: bool) -\u003e Self {\r\n        PF::from_bool(b).into()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn square(\u0026self) -\u003e Self {\r\n        match D {\r\n            2 =\u003e {\r\n                let a = self.value;\r\n                let mut res = Self::default();\r\n                res.value[0] = a[0].square() + a[1].square() * F::W;\r\n                res.value[1] = a[0] * a[1].double();\r\n                res\r\n            }\r\n            3 =\u003e {\r\n                let mut res = Self::default();\r\n                cubic_square(\u0026self.value, \u0026mut res.value);\r\n                res\r\n            }\r\n            _ =\u003e \u003cSelf as Mul\u003cSelf\u003e\u003e::mul(*self, *self),\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(PF::zero_vec(len * D)) }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Serializable\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    const DIMENSION: usize = D;\r\n\r\n    fn serialize_as_slice(\u0026self) -\u003e \u0026[PF] {\r\n        \u0026self.value\r\n    }\r\n\r\n    fn deserialize_fn\u003cFn: FnMut(usize) -\u003e PF\u003e(f: Fn) -\u003e Self {\r\n        Self {\r\n            value: array::from_fn(f),\r\n        }\r\n    }\r\n\r\n    fn deserialize_iter\u003cI: Iterator\u003cItem = PF\u003e\u003e(iter: I) -\u003e Self {\r\n        let mut res = Self::default();\r\n        for (i, b) in iter.enumerate() {\r\n            res.value[i] = b;\r\n        }\r\n        res\r\n    }\r\n}\r\n\r\nimpl\u003cF, const D: usize\u003e PackedFieldExtension\u003cF, BinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, F::Packing, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n{\r\n    fn from_ext_slice(ext_slice: \u0026[BinomialExtensionField\u003cF, D\u003e]) -\u003e Self {\r\n        let width = F::Packing::WIDTH;\r\n        assert_eq!(ext_slice.len(), width);\r\n\r\n        let mut res = [F::Packing::ZERO; D];\r\n\r\n        res.iter_mut().enumerate().for_each(|(i, row_i)| {\r\n            let row_i = row_i.as_slice_mut();\r\n            ext_slice\r\n                .iter()\r\n                .enumerate()\r\n                .for_each(|(j, vec_j)| row_i[j] = vec_j.value[i])\r\n        });\r\n\r\n        Self::new(res)\r\n    }\r\n\r\n    fn packed_ext_powers(base: BinomialExtensionField\u003cF, D\u003e) -\u003e crate::Powers\u003cSelf\u003e {\r\n        let width = F::Packing::WIDTH;\r\n        let powers = base.powers().take(width + 1).collect_vec();\r\n        // Transpose first WIDTH powers\r\n        let current = Self::from_ext_slice(\u0026powers[..width]);\r\n\r\n        // Broadcast self^WIDTH\r\n        let multiplier = powers[width].into();\r\n\r\n        Powers {\r\n            base: multiplier,\r\n            current,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Neg for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        Self {\r\n            value: self.value.map(PF::neg),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Add for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let value = vector_add(\u0026self.value, \u0026rhs.value);\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Add\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: BinomialExtensionField\u003cF, D\u003e) -\u003e Self {\r\n        let value = vector_add(\u0026self.value, \u0026rhs.value);\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Add\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(mut self, rhs: PF) -\u003e Self {\r\n        self.value[0] += rhs;\r\n        self\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e AddAssign for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        for i in 0..D {\r\n            self.value[i] += rhs.value[i];\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e AddAssign\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: BinomialExtensionField\u003cF, D\u003e) {\r\n        for i in 0..D {\r\n            self.value[i] += rhs.value[i];\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e AddAssign\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: PF) {\r\n        self.value[0] += rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Sum for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|acc, x| acc + x).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Sub for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let value = vector_sub(\u0026self.value, \u0026rhs.value);\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Sub\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: BinomialExtensionField\u003cF, D\u003e) -\u003e Self {\r\n        let value = vector_sub(\u0026self.value, \u0026rhs.value);\r\n        Self { value }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Sub\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: PF) -\u003e Self {\r\n        let mut res = self.value;\r\n        res[0] -= rhs;\r\n        Self { value: res }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e SubAssign for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e SubAssign\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: BinomialExtensionField\u003cF, D\u003e) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e SubAssign\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: PF) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Mul for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let a = self.value;\r\n        let b = rhs.value;\r\n        let mut res = Self::default();\r\n        let w = F::W;\r\n\r\n        binomial_mul(\u0026a, \u0026b, \u0026mut res.value, w);\r\n\r\n        res\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Mul\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: BinomialExtensionField\u003cF, D\u003e) -\u003e Self {\r\n        let a = self.value;\r\n        let b = rhs.value;\r\n        let mut res = Self::default();\r\n        let w = F::W;\r\n\r\n        binomial_mul(\u0026a, \u0026b, \u0026mut res.value, w);\r\n\r\n        res\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Mul\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: PF) -\u003e Self {\r\n        Self {\r\n            value: self.value.map(|x| x * rhs),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e Product for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|acc, x| acc * x).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e MulAssign for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e MulAssign\u003cBinomialExtensionField\u003cF, D\u003e\u003e\r\n    for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: BinomialExtensionField\u003cF, D\u003e) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, const D: usize\u003e MulAssign\u003cPF\u003e for PackedBinomialExtensionField\u003cF, PF, D\u003e\r\nwhere\r\n    F: BinomiallyExtendable\u003cD\u003e,\r\n    PF: PackedField\u003cScalar = F\u003e,\r\n{\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: PF) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":2594073385365406845}},{"line":37,"address":[],"length":0,"stats":{"Line":16140901064495857752}},{"line":39,"address":[],"length":0,"stats":{"Line":9223372036854776026}},{"line":47,"address":[],"length":0,"stats":{"Line":3314649325744685145}},{"line":49,"address":[],"length":0,"stats":{"Line":3314649325744685145}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":1513209474796486708}},{"line":129,"address":[],"length":0,"stats":{"Line":1513209474796486708}},{"line":140,"address":[],"length":0,"stats":{"Line":3530822107858469384}},{"line":141,"address":[],"length":0,"stats":{"Line":3530822107858469384}},{"line":144,"address":[],"length":0,"stats":{"Line":2522015791327477880}},{"line":146,"address":[],"length":0,"stats":{"Line":2522015791327477880}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":2594073385365405840}},{"line":165,"address":[],"length":0,"stats":{"Line":2594073385365405840}},{"line":166,"address":[],"length":0,"stats":{"Line":2594073385365405840}},{"line":168,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":170,"address":[],"length":0,"stats":{"Line":11817445422220181502}},{"line":171,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":172,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":173,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":174,"address":[],"length":0,"stats":{"Line":9223372036854775807}},{"line":175,"address":[],"length":0,"stats":{"Line":87}},{"line":178,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":181,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":182,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":183,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":185,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":188,"address":[],"length":0,"stats":{"Line":2594073385365405695}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":11529215046068469787}},{"line":221,"address":[],"length":0,"stats":{"Line":11529215046068469787}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":7277816997830722007}},{"line":262,"address":[],"length":0,"stats":{"Line":9295429630892705843}},{"line":263,"address":[],"length":0,"stats":{"Line":6052837899185947000}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":12970366926827028774}},{"line":299,"address":[],"length":0,"stats":{"Line":576460752303424139}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":390,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":391,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":392,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":393,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":395,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":397,"address":[],"length":0,"stats":{"Line":16140901064495858435}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":4251398048237748507}},{"line":432,"address":[],"length":0,"stats":{"Line":12826251738751174929}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":16140901064495858046}},{"line":454,"address":[],"length":0,"stats":{"Line":16140901064495858046}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}}],"covered":45,"coverable":107},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","field.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt::{Debug, Display};\r\nuse core::hash::Hash;\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\nuse core::slice;\r\n\r\nuse num_bigint::BigUint;\r\nuse num_traits::One;\r\nuse nums::{Factorizer, FactorizerFromSplitter, MillerRabin, PollardRho};\r\nuse serde::de::DeserializeOwned;\r\nuse serde::Serialize;\r\n\r\nuse crate::exponentiation::bits_u64;\r\nuse crate::integers::{from_integer_types, QuotientMap};\r\nuse crate::packed::PackedField;\r\nuse crate::{Packable, PackedFieldExtension};\r\n\r\n/// A commutative ring, `R`, with prime characteristic, `p`.\r\n///\r\n/// This permits elements like:\r\n/// - A single finite field element.\r\n/// - A symbolic expression which would evaluate to a field element.\r\n/// - An array of finite field elements.\r\n/// - A polynomial with coefficients in a finite field.\r\n///\r\n/// ### Mathematical Description\r\n///\r\n/// Mathematically, a commutative ring is a set of objects which supports an addition-like\r\n/// like operation, `+`, and a multiplication-like operation `*`.\r\n///\r\n/// Let `x, y, z` denote arbitrary elements of the set.\r\n///\r\n/// Then, an operation is addition-like if it satisfies the following properties:\r\n/// - Commutativity =\u003e `x + y = y + x`\r\n/// - Associativity =\u003e `x + (y + z) = (x + y) + z`\r\n/// - Unit =\u003e There exists an identity element `ZERO` satisfying `x + ZERO = x`.\r\n/// - Inverses =\u003e For every `x` there exists a unique inverse `(-x)` satisfying `x + (-x) = ZERO`\r\n///\r\n/// Similarly, an operation is multiplication-like if it satisfies the following properties:\r\n/// - Commutativity =\u003e `x * y = y * x`\r\n/// - Associativity =\u003e `x * (y * z) = (x * y) * z`\r\n/// - Unit =\u003e There exists an identity element `ONE` satisfying `x * ONE = x`.\r\n/// - Distributivity =\u003e The two operations `+` and `*` must together satisfy `x * (y + z) = (x * y) + (x * z)`\r\n///\r\n/// Unlike in the addition case, we do not require inverses to exist with respect to `*`.\r\n///\r\n/// The simplest examples of commutative rings are the integers (``), and the integers mod `N` (`/N`).\r\n///\r\n/// The characteristic of a ring is the smallest positive integer `r` such that `0 = r . 1 = 1 + 1 + ... + 1 (r times)`.\r\n/// For example, the characteristic of the modulo ring `/N` is `N`.\r\n///\r\n/// Rings with prime characteristic are particularly special due to their close relationship with finite fields.\r\npub trait PrimeCharacteristicRing:\r\n    Sized\r\n    + Default\r\n    + Clone\r\n    + Add\u003cOutput = Self\u003e\r\n    + AddAssign\r\n    + Sub\u003cOutput = Self\u003e\r\n    + SubAssign\r\n    + Neg\u003cOutput = Self\u003e\r\n    + Mul\u003cOutput = Self\u003e\r\n    + MulAssign\r\n    + Sum\r\n    + Product\r\n    + Debug\r\n{\r\n    /// The field `/p` where the characteristic of this ring is p.\r\n    type PrimeSubfield: PrimeField;\r\n\r\n    /// The additive identity of the ring.\r\n    ///\r\n    /// For every element `a` in the ring we require the following properties:\r\n    ///\r\n    /// `a + ZERO = ZERO + a = a,`\r\n    ///\r\n    /// `a + (-a) = (-a) + a = ZERO.`\r\n    const ZERO: Self;\r\n\r\n    /// The multiplicative identity of the ring.\r\n    ///\r\n    /// For every element `a` in the ring we require the following property:\r\n    ///\r\n    /// `a*ONE = ONE*a = a.`\r\n    const ONE: Self;\r\n\r\n    /// The element in the ring given by `ONE + ONE`.\r\n    ///\r\n    /// This is provided as a convenience as `TWO` occurs regularly in\r\n    /// the proving system. This also is slightly faster than computing\r\n    /// it via addition. Note that multiplication by `TWO` is discouraged.\r\n    /// Instead of `a * TWO` use `a.double()` which will be faster.\r\n    ///\r\n    /// If the field has characteristic 2 this is equal to ZERO.\r\n    const TWO: Self;\r\n\r\n    /// The element in the ring given by `-ONE`.\r\n    ///\r\n    /// This is provided as a convenience as `NEG_ONE` occurs regularly in\r\n    /// the proving system. This also is slightly faster than computing\r\n    /// it via negation. Note that where possible `NEG_ONE` should be absorbed\r\n    /// into mathematical operations. For example `a - b` will be faster\r\n    /// than `a + NEG_ONE * b` and similarly `(-b)` is faster than `NEG_ONE * b`.\r\n    ///\r\n    /// If the field has characteristic 2 this is equal to ONE.\r\n    const NEG_ONE: Self;\r\n\r\n    /// Embed an element of the prime field `/p` into the ring `R`.\r\n    ///\r\n    /// Given any element `[r]  /p`, represented by an integer `r` between `0` and `p - 1`\r\n    /// `from_prime_subfield([r])` will be equal to:\r\n    ///\r\n    /// `Self::ONE + ... + Self::ONE (r times)`\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self;\r\n\r\n    /// Return `Self::ONE` if `b` is `true` and `Self::ZERO` if `b` is `false`.\r\n    fn from_bool(b: bool) -\u003e Self {\r\n        // Some rings might reimplement this to avoid the branch.\r\n        if b {\r\n            Self::ONE\r\n        } else {\r\n            Self::ZERO\r\n        }\r\n    }\r\n\r\n    from_integer_types!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\r\n\r\n    /// The elementary function `double(a) = 2*a`.\r\n    ///\r\n    /// This function should be preferred over calling `a + a` or `TWO * a` as a faster implementation may be available for some rings.\r\n    /// If the field has characteristic 2 then this returns 0.\r\n    #[must_use]\r\n    fn double(\u0026self) -\u003e Self {\r\n        self.clone() + self.clone()\r\n    }\r\n\r\n    /// The elementary function `square(a) = a^2`.\r\n    ///\r\n    /// This function should be preferred over calling `a * a`, as a faster implementation may be available for some rings.\r\n    #[must_use]\r\n    fn square(\u0026self) -\u003e Self {\r\n        self.clone() * self.clone()\r\n    }\r\n\r\n    /// The elementary function `cube(a) = a^3`.\r\n    ///\r\n    /// This function should be preferred over calling `a * a * a`, as a faster implementation may be available for some rings.\r\n    #[must_use]\r\n    fn cube(\u0026self) -\u003e Self {\r\n        self.square() * self.clone()\r\n    }\r\n\r\n    /// Exponentiation by a `u64` power.\r\n    ///\r\n    /// This uses the standard square and multiply approach.\r\n    /// For specific powers regularly used and known in advance,\r\n    /// this will be slower than custom addition chain exponentiation.\r\n    #[must_use]\r\n    #[inline]\r\n    fn exp_u64(\u0026self, power: u64) -\u003e Self {\r\n        let mut current = self.clone();\r\n        let mut product = Self::ONE;\r\n\r\n        for j in 0..bits_u64(power) {\r\n            if (power \u003e\u003e j \u0026 1) != 0 {\r\n                product *= current.clone();\r\n            }\r\n            current = current.square();\r\n        }\r\n        product\r\n    }\r\n\r\n    /// Exponentiation by a small constant power.\r\n    ///\r\n    /// For a collection of small values we implement custom multiplication chain circuits which can be faster than the\r\n    /// simpler square and multiply approach.\r\n    ///\r\n    /// For large values this defaults back to `self.exp_u64`.\r\n    #[must_use]\r\n    #[inline(always)]\r\n    fn exp_const_u64\u003cconst POWER: u64\u003e(\u0026self) -\u003e Self {\r\n        match POWER {\r\n            0 =\u003e Self::ONE,\r\n            1 =\u003e self.clone(),\r\n            2 =\u003e self.square(),\r\n            3 =\u003e self.cube(),\r\n            4 =\u003e self.square().square(),\r\n            5 =\u003e self.square().square() * self.clone(),\r\n            6 =\u003e self.square().cube(),\r\n            7 =\u003e {\r\n                let x2 = self.square();\r\n                let x3 = x2.clone() * self.clone();\r\n                let x4 = x2.square();\r\n                x3 * x4\r\n            }\r\n            _ =\u003e self.exp_u64(POWER),\r\n        }\r\n    }\r\n\r\n    /// The elementary function `exp_power_of_2(a, power_log) = a^{2^power_log}`.\r\n    ///\r\n    /// Computed via repeated squaring.\r\n    #[must_use]\r\n    fn exp_power_of_2(\u0026self, power_log: usize) -\u003e Self {\r\n        let mut res = self.clone();\r\n        for _ in 0..power_log {\r\n            res = res.square();\r\n        }\r\n        res\r\n    }\r\n\r\n    /// The elementary function `mul_2exp_u64(a, exp) = a * 2^{exp}`.\r\n    ///\r\n    /// Here `2^{exp}` is computed using the square and multiply approach.\r\n    #[must_use]\r\n    #[inline]\r\n    fn mul_2exp_u64(\u0026self, exp: u64) -\u003e Self {\r\n        self.clone() * Self::TWO.exp_u64(exp)\r\n    }\r\n\r\n    /// Construct an iterator which returns powers of `self`: `self^0, self^1, self^2, ...`.\r\n    #[must_use]\r\n    fn powers(\u0026self) -\u003e Powers\u003cSelf\u003e {\r\n        self.shifted_powers(Self::ONE)\r\n    }\r\n\r\n    /// Construct an iterator which returns powers of `self` shifted by `start`: `start, start*self^1, start*self^2, ...`.\r\n    fn shifted_powers(\u0026self, start: Self) -\u003e Powers\u003cSelf\u003e {\r\n        Powers {\r\n            base: self.clone(),\r\n            current: start,\r\n        }\r\n    }\r\n\r\n    /// Compute the dot product of two vectors.\r\n    fn dot_product\u003cconst N: usize\u003e(u: \u0026[Self; N], v: \u0026[Self; N]) -\u003e Self {\r\n        u.iter().zip(v).map(|(x, y)| x.clone() * y.clone()).sum()\r\n    }\r\n\r\n    /// Allocates a vector of zero elements of length `len`. Many operating systems zero pages\r\n    /// before assigning them to a userspace process. In that case, our process should not need to\r\n    /// write zeros, which would be redundant. However, the compiler may not always recognize this.\r\n    ///\r\n    /// In particular, `vec![Self::ZERO; len]` appears to result in redundant userspace zeroing.\r\n    /// This is the default implementation, but implementors may wish to provide their own\r\n    /// implementation which transmutes something like `vec![0u32; len]`.\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        vec![Self::ZERO; len]\r\n    }\r\n}\r\n\r\n/// A vector space over `F` which can be serialized into and out of a collection of `F` elements.\r\n///\r\n/// We usually expect `F` to be a field but there are a few cases where it\r\n/// is handy to allow it to be just a ring. In particular, every ring implements `Serializable\u003cSelf\u003e`.\r\n///\r\n/// We make no guarantees about consistency of this Serialization/Deserialization\r\n/// across different versions of Plonky3.\r\n///\r\n/// ### Mathematical Description\r\n///\r\n/// Mathematically a more accurate name for this trait would be `BasedVectorSpace` or\r\n/// even more generally `BasedFreeModule` if you want to account for cases where `F` is\r\n/// not a field.\r\n///\r\n/// Given a vector space, `A` over `F`, we can pick a basis of elements `B = {b_0, ..., b_{n-1}}`\r\n/// in `A` such that, given any element `a`, we can find a unique set of `n` elements of `F`,\r\n/// `f_0, ..., f_{n - 1}` satisfying `a = f_0 b_0 + ... + f_{n - 1} b_{n - 1}`.\r\n///\r\n/// Thus choosing this basis `B` allows us to map between elements of `A` and\r\n/// arrays of `n` elements of `F`. Clearly this map depends entirely on the\r\n/// choice of basis `B` which may change across versions of Plonky3.\r\npub trait Serializable\u003cF: PrimeCharacteristicRing\u003e: Sized {\r\n    /// The dimension of the vector space, i.e. the number of elements in\r\n    /// its basis.\r\n    const DIMENSION: usize;\r\n\r\n    /// Fixes a basis for the algebra `A` and uses this to\r\n    /// map an element of `A` to a vector of `DIMENSION` `F` elements.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// The value produced by this function fundamentally depends\r\n    /// on the choice of basis. Care must be taken\r\n    /// to ensure portability if these values might ever be passed to\r\n    /// (or rederived within) another compilation environment where a\r\n    /// different basis might have been used.\r\n    fn serialize_as_slice(\u0026self) -\u003e \u0026[F];\r\n\r\n    /// Fixes a basis for the algebra `A` and uses this to\r\n    /// map `DIMENSION` `F` elements to an element of `A`.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// The value produced by this function fundamentally depends\r\n    /// on the choice of basis. Care must be taken\r\n    /// to ensure portability if these values might ever be passed to\r\n    /// (or rederived within) another compilation environment where a\r\n    /// different basis might have been used.\r\n    ///\r\n    /// The user should ensure that the slice has length `DIMENSION`. If\r\n    /// it is shorter than this, the function will panic, if it is longer the\r\n    /// extra elements will be ignored.\r\n    #[inline]\r\n    fn deserialize_slice(slice: \u0026[F]) -\u003e Self {\r\n        Self::deserialize_fn(|i| slice[i].clone())\r\n    }\r\n\r\n    /// Fixes a basis for the algebra `A` and uses this to\r\n    /// map `DIMENSION` `F` elements to an element of `A`. Similar\r\n    /// to `core:array::from_fn`, the `DIMENSION` `F` elements are\r\n    /// given by `Fn(0), ..., Fn(DIMENSION - 1)`.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// The value produced by this function fundamentally depends\r\n    /// on the choice of basis. Care must be taken\r\n    /// to ensure portability if these values might ever be passed to\r\n    /// (or rederived within) another compilation environment where a\r\n    /// different basis might have been used.\r\n    fn deserialize_fn\u003cFn: FnMut(usize) -\u003e F\u003e(f: Fn) -\u003e Self;\r\n\r\n    /// Fixes a basis for the algebra `A` and uses this to\r\n    /// map `DIMENSION` `F` elements to an element of `A`.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// The value produced by this function fundamentally depends\r\n    /// on the choice of basis. Care must be taken\r\n    /// to ensure portability if these values might ever be passed to\r\n    /// (or rederived within) another compilation environment where a\r\n    /// different basis might have been used.\r\n    ///\r\n    /// If the iterator contains more than `DIMENSION` many elements,\r\n    /// the rest will be ignored.\r\n    fn deserialize_iter\u003cI: Iterator\u003cItem = F\u003e\u003e(iter: I) -\u003e Self;\r\n\r\n    /// Given a basis for the Algebra `A`, return the i'th basis element.\r\n    ///\r\n    /// # Safety\r\n    ///\r\n    /// The value produced by this function fundamentally depends\r\n    /// on the choice of basis. Care must be taken\r\n    /// to ensure portability if these values might ever be passed to\r\n    /// (or rederived within) another compilation environment where a\r\n    /// different basis might have been used.\r\n    fn ith_basis_element(i: usize) -\u003e Self {\r\n        Self::deserialize_fn(|j| F::from_bool(i == j))\r\n    }\r\n}\r\n\r\nimpl\u003cF: PrimeCharacteristicRing\u003e Serializable\u003cF\u003e for F {\r\n    const DIMENSION: usize = 1;\r\n\r\n    #[inline]\r\n    fn serialize_as_slice(\u0026self) -\u003e \u0026[F] {\r\n        slice::from_ref(self)\r\n    }\r\n\r\n    #[inline]\r\n    fn deserialize_fn\u003cFn: FnMut(usize) -\u003e F\u003e(mut f: Fn) -\u003e Self {\r\n        f(0)\r\n    }\r\n\r\n    #[inline]\r\n    fn deserialize_iter\u003cI: Iterator\u003cItem = F\u003e\u003e(mut iter: I) -\u003e Self {\r\n        iter.next().unwrap()\r\n    }\r\n}\r\n\r\n/// A ring implements `InjectiveMonomial\u003cN\u003e` if the algebraic function\r\n/// `f(x) = x^N` is an injective map on elements of the ring.\r\n///\r\n/// We do not enforce that this map be invertible as there are useful\r\n/// cases such as polynomials or symbolic expressions where no inverse exists.\r\n///\r\n/// However, if the ring is a field with order `q` or an array of such field elements,\r\n/// then `f(x) = x^N` will be injective if and only if it is invertible and so in\r\n/// such cases this monomial acts as a permutation. Moreover, this will occur\r\n/// exactly when `N` and `q - 1` are relatively prime i.e. `gcd(N, q - 1) = 1`.\r\npub trait InjectiveMonomial\u003cconst N: u64\u003e: PrimeCharacteristicRing {\r\n    /// Compute `x -\u003e x^n` for a given `n \u003e 1` such that this\r\n    /// map is injective.\r\n    fn injective_exp_n(\u0026self) -\u003e Self {\r\n        self.exp_const_u64::\u003cN\u003e()\r\n    }\r\n}\r\n\r\n/// A ring implements `PermutationMonomial\u003cN\u003e` if the algebraic function\r\n/// `f(x) = x^N` is invertible and thus acts as a permutation on elements of the ring.\r\n///\r\n/// In all cases we care about, this means that we can find another integer `K` such\r\n/// that `x = x^{NK}` for all elements of our ring.\r\npub trait PermutationMonomial\u003cconst N: u64\u003e: InjectiveMonomial\u003cN\u003e {\r\n    /// Compute `x -\u003e x^K` for a given `K \u003e 1` such that\r\n    /// `x^{NK} = x` for all elements `x`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self;\r\n}\r\n\r\n/// A ring `R` implements `Algebra\u003cF\u003e` if there is an injective homomorphism\r\n///  from `F` into `R`; in particular only `F::ZERO` maps to `R::ZERO`.\r\n///\r\n/// For the most part, we will usually expect `F` to be a field but there\r\n/// are a few cases where it is handy to allow it to just be a ring. In\r\n/// particular, every ring naturally implements `Algebra\u003cSelf\u003e`.\r\n///\r\n/// ### Mathematical Description\r\n///\r\n/// Let `x` and `y` denote arbitrary elements of `F`. Then\r\n/// we require that our map `from` has the properties:\r\n/// - Preserves Identity: `from(F::ONE) = R::ONE`\r\n/// - Commutes with Addition: `from(x + y) = from(x) + from(y)`\r\n/// - Commutes with Multiplication: `from(x * y) = from(x) * from(y)`\r\n///\r\n/// Such maps are known as ring homomorphisms and are injective if the\r\n/// only element which maps to `R::ZERO` is `F::ZERO`.\r\n///\r\n/// The existence of this map makes `R` into an `F`-module and hence an `F`-algebra.\r\n/// If, additionally, `R` is a field, then this makes `R` a field extension of `F`.\r\npub trait Algebra\u003cF\u003e:\r\n    PrimeCharacteristicRing\r\n    + From\u003cF\u003e\r\n    + Add\u003cF, Output = Self\u003e\r\n    + AddAssign\u003cF\u003e\r\n    + Sub\u003cF, Output = Self\u003e\r\n    + SubAssign\u003cF\u003e\r\n    + Mul\u003cF, Output = Self\u003e\r\n    + MulAssign\u003cF\u003e\r\n{\r\n}\r\n\r\n// Every ring is an algebra over itself.\r\nimpl\u003cR: PrimeCharacteristicRing\u003e Algebra\u003cR\u003e for R {}\r\n\r\n/// A field `F`. This permits both modular fields `/p` along with their field extensions.\r\n///\r\n/// A ring is a field if every element `x` has a unique multiplicative inverse `x^{-1}`\r\n/// which satisfies `x * x^{-1} = F::ONE`.\r\npub trait Field:\r\n    Algebra\u003cSelf\u003e\r\n    + Packable\r\n    + 'static\r\n    + Copy\r\n    + Div\u003cSelf, Output = Self\u003e\r\n    + Eq\r\n    + Hash\r\n    + Send\r\n    + Sync\r\n    + Display\r\n    + Serialize\r\n    + DeserializeOwned\r\n{\r\n    type Packing: PackedField\u003cScalar = Self\u003e;\r\n\r\n    /// A generator of this field's multiplicative group.\r\n    const GENERATOR: Self;\r\n\r\n    /// Check if the given field element is equal to the unique additive identity (ZERO).\r\n    fn is_zero(\u0026self) -\u003e bool {\r\n        *self == Self::ZERO\r\n    }\r\n\r\n    /// Check if the given field element is equal to the unique multiplicative identity (ONE).\r\n    fn is_one(\u0026self) -\u003e bool {\r\n        *self == Self::ONE\r\n    }\r\n\r\n    /// The multiplicative inverse of this field element, if it exists.\r\n    ///\r\n    /// NOTE: The inverse of `0` is undefined and will return `None`.\r\n    #[must_use]\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e;\r\n\r\n    /// The multiplicative inverse of this field element.\r\n    ///\r\n    /// NOTE: The inverse of `0` is undefined and will error.\r\n    #[must_use]\r\n    fn inverse(\u0026self) -\u003e Self {\r\n        self.try_inverse().expect(\"Tried to invert zero\")\r\n    }\r\n\r\n    /// The elementary function `halve(a) = a/2`.\r\n    ///\r\n    /// Will error if the field characteristic is 2.\r\n    #[must_use]\r\n    fn halve(\u0026self) -\u003e Self {\r\n        // This should be overwritten by most field implementations.\r\n        let half = Self::from_prime_subfield(\r\n            Self::PrimeSubfield::TWO\r\n                .try_inverse()\r\n                .expect(\"Cannot divide by 2 in fields with characteristic 2\"),\r\n        );\r\n        *self * half\r\n    }\r\n\r\n    /// Divide by a given power of two. `div_2exp_u64(a, exp) = a/2^exp`\r\n    ///\r\n    /// Will error if the field characteristic is 2.\r\n    #[must_use]\r\n    #[inline]\r\n    fn div_2exp_u64(\u0026self, exp: u64) -\u003e Self {\r\n        // This should be overwritten by most field implementations.\r\n        *self\r\n            * Self::from_prime_subfield(\r\n                Self::PrimeSubfield::TWO\r\n                    .try_inverse()\r\n                    .expect(\"Cannot divide by 2 in fields with characteristic 2\")\r\n                    .exp_u64(exp),\r\n            )\r\n    }\r\n\r\n    /// The number of elements in the field.\r\n    ///\r\n    /// This will either be prime if the field is a PrimeField or a power of a\r\n    /// prime if the field is an extension field.\r\n    fn order() -\u003e BigUint;\r\n\r\n    /// A list of (factor, exponent) pairs.\r\n    fn multiplicative_group_factors() -\u003e Vec\u003c(BigUint, usize)\u003e {\r\n        let primality_test = MillerRabin { error_bits: 128 };\r\n        let composite_splitter = PollardRho;\r\n        let factorizer = FactorizerFromSplitter {\r\n            primality_test,\r\n            composite_splitter,\r\n        };\r\n        let n = Self::order() - BigUint::one();\r\n        factorizer.factor_counts(\u0026n)\r\n    }\r\n\r\n    /// The number of bits required to define an element of this field.\r\n    ///\r\n    /// Usually due to storage and practical reasons the memory size of\r\n    /// a field element will be a little larger than bits().\r\n    #[inline]\r\n    fn bits() -\u003e usize {\r\n        Self::order().bits() as usize\r\n    }\r\n}\r\n\r\n/// A field isomorphic to `/p` for some prime `p`.\r\n///\r\n/// There is a natural map from `` to `/p` which sends an integer `r` to its conjugacy class `[r]`.\r\n/// Canonically, each conjugacy class `[r]` can be represented by the unique integer `s` in `[0, p - 1)`\r\n/// satisfying `s = r mod p`. This however is often not the most convenient computational representation\r\n/// and so internal representations of field elements might differ from this and may change over time.\r\npub trait PrimeField:\r\n    Field\r\n    + Ord\r\n    + QuotientMap\u003cu8\u003e\r\n    + QuotientMap\u003cu16\u003e\r\n    + QuotientMap\u003cu32\u003e\r\n    + QuotientMap\u003cu64\u003e\r\n    + QuotientMap\u003cu128\u003e\r\n    + QuotientMap\u003cusize\u003e\r\n    + QuotientMap\u003ci8\u003e\r\n    + QuotientMap\u003ci16\u003e\r\n    + QuotientMap\u003ci32\u003e\r\n    + QuotientMap\u003ci64\u003e\r\n    + QuotientMap\u003ci128\u003e\r\n    + QuotientMap\u003cisize\u003e\r\n{\r\n    /// Return the representative of `value` in canonical form\r\n    /// which lies in the range `0 \u003c= x \u003c self.order()`.\r\n    fn as_canonical_biguint(\u0026self) -\u003e BigUint;\r\n}\r\n\r\n/// A prime field `/p` with order, `p \u003c 2^64`.\r\npub trait PrimeField64: PrimeField {\r\n    const ORDER_U64: u64;\r\n\r\n    /// Return the representative of `value` in canonical form\r\n    /// which lies in the range `0 \u003c= x \u003c ORDER_U64`.\r\n    fn as_canonical_u64(\u0026self) -\u003e u64;\r\n\r\n    /// Convert a field element to a `u64` such that any two field elements\r\n    /// are converted to the same `u64` if and only if they represent the same value.\r\n    ///\r\n    /// This will be the fastest way to convert a field element to a `u64` and\r\n    /// is intended for use in hashing. It will also be consistent across different targets.\r\n    fn to_unique_u64(\u0026self) -\u003e u64 {\r\n        // A simple default which is optimal for some fields.\r\n        self.as_canonical_u64()\r\n    }\r\n}\r\n\r\n/// A prime field `/p` with order `p \u003c 2^32`.\r\npub trait PrimeField32: PrimeField64 {\r\n    const ORDER_U32: u32;\r\n\r\n    /// Return the representative of `value` in canonical form\r\n    /// which lies in the range `0 \u003c= x \u003c ORDER_U64`.\r\n    fn as_canonical_u32(\u0026self) -\u003e u32;\r\n\r\n    /// Convert a field element to a `u32` such that any two field elements\r\n    /// are converted to the same `u32` if and only if they represent the same value.\r\n    ///\r\n    /// This will be the fastest way to convert a field element to a `u32` and\r\n    /// is intended for use in hashing. It will also be consistent across different targets.\r\n    fn to_unique_u32(\u0026self) -\u003e u32 {\r\n        // A simple default which is optimal for some fields.\r\n        self.as_canonical_u32()\r\n    }\r\n}\r\n\r\n/// A field `EF` which is also an algebra over a field `F`.\r\n///\r\n/// This provides a couple of convenience methods on top of the\r\n/// standard methods provided by `Field`, `Algebra\u003cF\u003e` and `Serializable\u003cF\u003e`.\r\n///\r\n/// It also provides a type which handles packed vectors of extension field elements.\r\npub trait ExtensionField\u003cBase: Field\u003e: Field + Algebra\u003cBase\u003e + Serializable\u003cBase\u003e {\r\n    type ExtensionPacking: PackedFieldExtension\u003cBase, Self\u003e + 'static + Copy + Send + Sync;\r\n\r\n    /// Determine if the given element lies in the base field.\r\n    fn is_in_basefield(\u0026self) -\u003e bool;\r\n\r\n    /// If the element lies in the base field project it down.\r\n    /// Otherwise return None.\r\n    fn as_base(\u0026self) -\u003e Option\u003cBase\u003e;\r\n}\r\n\r\n// Every field is trivially a one dimensional extension over itself.\r\nimpl\u003cF: Field\u003e ExtensionField\u003cF\u003e for F {\r\n    type ExtensionPacking = F::Packing;\r\n\r\n    fn is_in_basefield(\u0026self) -\u003e bool {\r\n        true\r\n    }\r\n\r\n    fn as_base(\u0026self) -\u003e Option\u003cF\u003e {\r\n        Some(*self)\r\n    }\r\n}\r\n\r\n/// A field which supplies information like the two-adicity of its multiplicative group, and methods\r\n/// for obtaining two-adic generators.\r\npub trait TwoAdicField: Field {\r\n    /// The number of factors of two in this field's multiplicative group.\r\n    const TWO_ADICITY: usize;\r\n\r\n    /// Returns a generator of the multiplicative group of order `2^bits`.\r\n    /// Assumes `bits \u003c= TWO_ADICITY`, otherwise the result is undefined.\r\n    #[must_use]\r\n    fn two_adic_generator(bits: usize) -\u003e Self;\r\n}\r\n\r\n/// An iterator which returns the powers of a base element `b` shifted by current `c`: `c, c * b, c * b^2, ...`.\r\n#[derive(Clone, Debug)]\r\npub struct Powers\u003cF\u003e {\r\n    pub base: F,\r\n    pub current: F,\r\n}\r\n\r\nimpl\u003cR: PrimeCharacteristicRing\u003e Iterator for Powers\u003cR\u003e {\r\n    type Item = R;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cR\u003e {\r\n        let result = self.current.clone();\r\n        self.current *= self.base.clone();\r\n        Some(result)\r\n    }\r\n}\r\n","traces":[{"line":119,"address":[],"length":0,"stats":{"Line":1369094286720630874}},{"line":121,"address":[],"length":0,"stats":{"Line":1369094286720630874}},{"line":122,"address":[],"length":0,"stats":{"Line":17509995351216488462}},{"line":124,"address":[],"length":0,"stats":{"Line":2305843009213694028}},{"line":135,"address":[],"length":0,"stats":{"Line":17221764975064778054}},{"line":136,"address":[],"length":0,"stats":{"Line":17221764975064778054}},{"line":143,"address":[],"length":0,"stats":{"Line":10016005571271991253}},{"line":144,"address":[],"length":0,"stats":{"Line":10016005571271991253}},{"line":151,"address":[],"length":0,"stats":{"Line":1657324662872343031}},{"line":152,"address":[],"length":0,"stats":{"Line":1657324662872343031}},{"line":162,"address":[],"length":0,"stats":{"Line":11745387828182258462}},{"line":163,"address":[],"length":0,"stats":{"Line":11745387828182258462}},{"line":164,"address":[],"length":0,"stats":{"Line":11745387828182258462}},{"line":166,"address":[],"length":0,"stats":{"Line":8430738502437573405}},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855875}},{"line":168,"address":[],"length":0,"stats":{"Line":3458764513820540932}},{"line":170,"address":[],"length":0,"stats":{"Line":15132094747964866559}},{"line":172,"address":[],"length":0,"stats":{"Line":11745387828182253567}},{"line":183,"address":[],"length":0,"stats":{"Line":7854277750134145679}},{"line":184,"address":[],"length":0,"stats":{"Line":7854277750134145679}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":194,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":195,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":196,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":17149707381026850332}},{"line":207,"address":[],"length":0,"stats":{"Line":17149707381026850332}},{"line":208,"address":[],"length":0,"stats":{"Line":72057594037929555}},{"line":209,"address":[],"length":0,"stats":{"Line":1369094286720630839}},{"line":211,"address":[],"length":0,"stats":{"Line":17149707381026851979}},{"line":219,"address":[],"length":0,"stats":{"Line":432345564227567651}},{"line":220,"address":[],"length":0,"stats":{"Line":432345564227567651}},{"line":225,"address":[],"length":0,"stats":{"Line":11817445422220181544}},{"line":226,"address":[],"length":0,"stats":{"Line":11817445422220181544}},{"line":230,"address":[],"length":0,"stats":{"Line":17077649786988921086}},{"line":232,"address":[],"length":0,"stats":{"Line":17077649786988921086}},{"line":238,"address":[],"length":0,"stats":{"Line":8070450532247928831}},{"line":239,"address":[],"length":0,"stats":{"Line":16140901064495857661}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":10304235947423694882}},{"line":309,"address":[],"length":0,"stats":{"Line":17437937757178561735}},{"line":350,"address":[],"length":0,"stats":{"Line":7205759403792793860}},{"line":351,"address":[],"length":0,"stats":{"Line":5476377146882524692}},{"line":359,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":360,"address":[],"length":0,"stats":{"Line":1945555039024054272}},{"line":364,"address":[],"length":0,"stats":{"Line":17654110539292344440}},{"line":365,"address":[],"length":0,"stats":{"Line":17654110539292344440}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":7421932185906578970}},{"line":388,"address":[],"length":0,"stats":{"Line":7421932185906578970}},{"line":462,"address":[],"length":0,"stats":{"Line":16717361816799281172}},{"line":463,"address":[],"length":0,"stats":{"Line":16717361816799281172}},{"line":467,"address":[],"length":0,"stats":{"Line":16717361816799281148}},{"line":468,"address":[],"length":0,"stats":{"Line":16717361816799281148}},{"line":481,"address":[],"length":0,"stats":{"Line":14915921965851085878}},{"line":482,"address":[],"length":0,"stats":{"Line":14915921965851085878}},{"line":489,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":492,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":493,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":494,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":496,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":792633534417207589}},{"line":523,"address":[],"length":0,"stats":{"Line":792633534417207589}},{"line":524,"address":[],"length":0,"stats":{"Line":792633534417207589}},{"line":529,"address":[],"length":0,"stats":{"Line":792633534417207589}},{"line":530,"address":[],"length":0,"stats":{"Line":792633534417207589}},{"line":538,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":539,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":583,"address":[],"length":0,"stats":{"Line":864691128455135235}},{"line":585,"address":[],"length":0,"stats":{"Line":864691128455135235}},{"line":602,"address":[],"length":0,"stats":{"Line":12321848580485677099}},{"line":604,"address":[],"length":0,"stats":{"Line":12321848580485677099}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":13258597302979090893}},{"line":661,"address":[],"length":0,"stats":{"Line":13258597302979090893}},{"line":662,"address":[],"length":0,"stats":{"Line":13258597302979090893}},{"line":663,"address":[],"length":0,"stats":{"Line":13258597302979090893}}],"covered":75,"coverable":97},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","helpers.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::iter::Sum;\r\nuse core::mem::{ManuallyDrop, MaybeUninit};\r\nuse core::ops::Mul;\r\n\r\nuse num_bigint::BigUint;\r\nuse p3_maybe_rayon::prelude::{IntoParallelRefMutIterator, ParallelIterator};\r\n\r\nuse crate::field::Field;\r\nuse crate::{PackedValue, PrimeCharacteristicRing, PrimeField, PrimeField32, TwoAdicField};\r\n\r\n/// Computes `Z_H(x)`, where `Z_H` is the zerofier of a multiplicative subgroup of order `2^log_n`.\r\npub fn two_adic_subgroup_zerofier\u003cF: TwoAdicField\u003e(log_n: usize, x: F) -\u003e F {\r\n    x.exp_power_of_2(log_n) - F::ONE\r\n}\r\n\r\n/// Computes `Z_{sH}(x)`, where `Z_{sH}` is the zerofier of the given coset of a multiplicative\r\n/// subgroup of order `2^log_n`.\r\npub fn two_adic_coset_zerofier\u003cF: TwoAdicField\u003e(log_n: usize, shift: F, x: F) -\u003e F {\r\n    x.exp_power_of_2(log_n) - shift.exp_power_of_2(log_n)\r\n}\r\n\r\n/// Computes a multiplicative subgroup whose order is known in advance.\r\npub fn cyclic_subgroup_known_order\u003cF: Field\u003e(\r\n    generator: F,\r\n    order: usize,\r\n) -\u003e impl Iterator\u003cItem = F\u003e + Clone {\r\n    generator.powers().take(order)\r\n}\r\n\r\n/// Computes a coset of a multiplicative subgroup whose order is known in advance.\r\npub fn cyclic_subgroup_coset_known_order\u003cF: Field\u003e(\r\n    generator: F,\r\n    shift: F,\r\n    order: usize,\r\n) -\u003e impl Iterator\u003cItem = F\u003e + Clone {\r\n    generator.shifted_powers(shift).take(order)\r\n}\r\n\r\n#[must_use]\r\npub fn add_vecs\u003cF: Field\u003e(v: Vec\u003cF\u003e, w: Vec\u003cF\u003e) -\u003e Vec\u003cF\u003e {\r\n    assert_eq!(v.len(), w.len());\r\n    v.into_iter().zip(w).map(|(x, y)| x + y).collect()\r\n}\r\n\r\npub fn sum_vecs\u003cF: Field, I: Iterator\u003cItem = Vec\u003cF\u003e\u003e\u003e(iter: I) -\u003e Vec\u003cF\u003e {\r\n    iter.reduce(|v, w| add_vecs(v, w))\r\n        .expect(\"sum_vecs: empty iterator\")\r\n}\r\n\r\npub fn scale_vec\u003cF: Field\u003e(s: F, vec: Vec\u003cF\u003e) -\u003e Vec\u003cF\u003e {\r\n    vec.into_iter().map(|x| s * x).collect()\r\n}\r\n\r\npub fn scale_slice_in_place\u003cF: Field\u003e(s: F, slice: \u0026mut [F]) {\r\n    let (packed, sfx) = F::Packing::pack_slice_with_suffix_mut(slice);\r\n    let packed_s: F::Packing = s.into();\r\n    packed.par_iter_mut().for_each(|x| *x *= packed_s);\r\n    sfx.iter_mut().for_each(|x| *x *= s);\r\n}\r\n\r\n/// `x += y * s`, where `s` is a scalar.\r\npub fn add_scaled_slice_in_place\u003cF, Y\u003e(x: \u0026mut [F], y: Y, s: F)\r\nwhere\r\n    F: Field,\r\n    Y: Iterator\u003cItem = F\u003e,\r\n{\r\n    // TODO: Use PackedField\r\n    x.iter_mut().zip(y).for_each(|(x_i, y_i)| *x_i += y_i * s);\r\n}\r\n\r\n// The ideas for the following work around come from the construe crate along with\r\n// the playground example linked in the following comment:\r\n// https://github.com/rust-lang/rust/issues/115403#issuecomment-1701000117\r\n\r\n// The goal is to want to make field_to_array a const function in order\r\n// to allow us to convert R constants to BinomialExtensionField\u003cR, D\u003e constants.\r\n//\r\n// The natural approach would be:\r\n// fn field_to_array\u003cR: PrimeCharacteristicRing, const D: usize\u003e(x: R) -\u003e [R; D]\r\n//      let mut arr: [R; D] = [R::ZERO; D];\r\n//      arr[0] = x\r\n//      arr\r\n//\r\n// Unfortunately this doesn't compile as R does not implement Copy and so instead\r\n// implements Drop which cannot be run in constant contexts. Clearly nothing should\r\n// actually be dropped by the above function but the compiler is unable to determine this.\r\n// There is a rust issue for this: https://github.com/rust-lang/rust/issues/73255\r\n// but it seems unlikely to be stabilized anytime soon.\r\n//\r\n// The natural workaround for this is to use MaybeUninit and set each element of the list\r\n// separately. This mostly works but we end up with an array of the form [MaybeUninit\u003cT\u003e; N]\r\n// and there is not currently a way in the standard library to convert this to [T; N].\r\n// There is a method on nightly: array_assume_init so this function should be reworked after\r\n// that has stabilized (More details in Rust issue: https://github.com/rust-lang/rust/issues/96097).\r\n//\r\n// Annoyingly, both transmute and transmute_copy fail here. The first because it cannot handle\r\n// const generics and the second due to interior mutability and the unability to use \u0026mut in const\r\n// functions.\r\n//\r\n// The solution is to implement the map [MaybeUninit\u003cT\u003e; D]) -\u003e MaybeUninit\u003c[T; D]\u003e\r\n// using Union types and ManuallyDrop to essentially do a manual transmute.\r\n\r\nunion HackyWorkAround\u003cT, const D: usize\u003e {\r\n    complete: ManuallyDrop\u003cMaybeUninit\u003c[T; D]\u003e\u003e,\r\n    elements: ManuallyDrop\u003c[MaybeUninit\u003cT\u003e; D]\u003e,\r\n}\r\n\r\nimpl\u003cT, const D: usize\u003e HackyWorkAround\u003cT, D\u003e {\r\n    const fn transpose(arr: [MaybeUninit\u003cT\u003e; D]) -\u003e MaybeUninit\u003c[T; D]\u003e {\r\n        // This is safe as [MaybeUninit\u003cT\u003e; D]\u003e and MaybeUninit\u003c[T; D]\u003e are\r\n        // the same type regardless of T. Both are an array or size equal to [T; D]\r\n        // with some data potentially not initialized.\r\n        let transpose = Self {\r\n            elements: ManuallyDrop::new(arr),\r\n        };\r\n        unsafe { ManuallyDrop::into_inner(transpose.complete) }\r\n    }\r\n}\r\n\r\n/// Extend a ring `R` element `x` to an array of length `D`\r\n/// by filling zeros.\r\n#[inline]\r\npub const fn field_to_array\u003cR: PrimeCharacteristicRing, const D: usize\u003e(x: R) -\u003e [R; D] {\r\n    let mut arr: [MaybeUninit\u003cR\u003e; D] = unsafe { MaybeUninit::uninit().assume_init() };\r\n\r\n    arr[0] = MaybeUninit::new(x);\r\n    let mut acc = 1;\r\n    loop {\r\n        if acc == D {\r\n            break;\r\n        }\r\n        arr[acc] = MaybeUninit::new(R::ZERO);\r\n        acc += 1;\r\n    }\r\n    // If the code has reached this point every element of arr is correctly initialized.\r\n    // Hence we are safe to reinterpret the array as [R; D].\r\n\r\n    unsafe { HackyWorkAround::transpose(arr).assume_init() }\r\n}\r\n\r\n/// Naive polynomial multiplication.\r\npub fn naive_poly_mul\u003cR: PrimeCharacteristicRing\u003e(a: \u0026[R], b: \u0026[R]) -\u003e Vec\u003cR\u003e {\r\n    // Grade school algorithm\r\n    let mut product = vec![R::ZERO; a.len() + b.len() - 1];\r\n    for (i, c1) in a.iter().enumerate() {\r\n        for (j, c2) in b.iter().enumerate() {\r\n            product[i + j] += c1.clone() * c2.clone();\r\n        }\r\n    }\r\n    product\r\n}\r\n\r\n/// Expand a product of binomials `(x - roots[0])(x - roots[1])..` into polynomial coefficients.\r\npub fn binomial_expand\u003cR: PrimeCharacteristicRing\u003e(roots: \u0026[R]) -\u003e Vec\u003cR\u003e {\r\n    let mut coeffs = vec![R::ZERO; roots.len() + 1];\r\n    coeffs[0] = R::ONE;\r\n    for (i, x) in roots.iter().enumerate() {\r\n        for j in (1..i + 2).rev() {\r\n            coeffs[j] = coeffs[j - 1].clone() - x.clone() * coeffs[j].clone();\r\n        }\r\n        coeffs[0] *= -x.clone();\r\n    }\r\n    coeffs\r\n}\r\n\r\npub fn eval_poly\u003cR: PrimeCharacteristicRing\u003e(poly: \u0026[R], x: R) -\u003e R {\r\n    let mut acc = R::ZERO;\r\n    for coeff in poly.iter().rev() {\r\n        acc *= x.clone();\r\n        acc += coeff.clone();\r\n    }\r\n    acc\r\n}\r\n\r\n/// Given an element x from a 32 bit field F_P compute x/2.\r\n#[inline]\r\npub fn halve_u32\u003cconst P: u32\u003e(input: u32) -\u003e u32 {\r\n    let shift = (P + 1) \u003e\u003e 1;\r\n    let shr = input \u003e\u003e 1;\r\n    let lo_bit = input \u0026 1;\r\n    let shr_corr = shr + shift;\r\n    if lo_bit == 0 {\r\n        shr\r\n    } else {\r\n        shr_corr\r\n    }\r\n}\r\n\r\n/// Given an element x from a 64 bit field F_P compute x/2.\r\n#[inline]\r\npub fn halve_u64\u003cconst P: u64\u003e(input: u64) -\u003e u64 {\r\n    let shift = (P + 1) \u003e\u003e 1;\r\n    let shr = input \u003e\u003e 1;\r\n    let lo_bit = input \u0026 1;\r\n    let shr_corr = shr + shift;\r\n    if lo_bit == 0 {\r\n        shr\r\n    } else {\r\n        shr_corr\r\n    }\r\n}\r\n\r\n/// Given a slice of SF elements, reduce them to a TF element using a 2^32-base decomposition.\r\n///\r\n/// This is optimised assuming that the characteristic of TF is greater than 2^64.\r\npub fn reduce_32\u003cSF: PrimeField32, TF: PrimeField\u003e(vals: \u0026[SF]) -\u003e TF {\r\n    // If the characteristic of TF is \u003e 2^64, from_int and from_canonical_unchecked act identically\r\n    // on u64 and u32 inputs so we use the safer option.\r\n    let po2 = TF::from_int(1u64 \u003c\u003c 32);\r\n    let mut result = TF::ZERO;\r\n    for val in vals.iter().rev() {\r\n        result = result * po2 + TF::from_int(val.as_canonical_u32());\r\n    }\r\n    result\r\n}\r\n\r\n/// Given an SF element, split it to a vector of TF elements using a 2^64-base decomposition.\r\n///\r\n/// We use a 2^64-base decomposition for a field of size ~2^32 because then the bias will be\r\n/// at most ~1/2^32 for each element after the reduction.\r\npub fn split_32\u003cSF: PrimeField, TF: PrimeField32\u003e(val: SF, n: usize) -\u003e Vec\u003cTF\u003e {\r\n    let po2 = BigUint::from(1u128 \u003c\u003c 64);\r\n    let mut val = val.as_canonical_biguint();\r\n    let mut result = Vec::new();\r\n    for _ in 0..n {\r\n        let mask: BigUint = po2.clone() - BigUint::from(1u128);\r\n        let digit: BigUint = val.clone() \u0026 mask;\r\n        let digit_u64s = digit.to_u64_digits();\r\n        if !digit_u64s.is_empty() {\r\n            result.push(TF::from_int(digit_u64s[0]));\r\n        } else {\r\n            result.push(TF::ZERO)\r\n        }\r\n        val /= po2.clone();\r\n    }\r\n    result\r\n}\r\n\r\n/// Maximally generic dot product.\r\npub fn dot_product\u003cS, LI, RI\u003e(li: LI, ri: RI) -\u003e S\r\nwhere\r\n    LI: Iterator,\r\n    RI: Iterator,\r\n    LI::Item: Mul\u003cRI::Item\u003e,\r\n    S: Sum\u003c\u003cLI::Item as Mul\u003cRI::Item\u003e\u003e::Output\u003e,\r\n{\r\n    li.zip(ri).map(|(l, r)| l * r).sum()\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":15,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":20,"address":[],"length":0,"stats":{"Line":1080863910568919042}},{"line":21,"address":[],"length":0,"stats":{"Line":1080863910568919042}},{"line":25,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":29,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":33,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":38,"address":[],"length":0,"stats":{"Line":8286623314361712640}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":15636497906230362112}},{"line":53,"address":[],"length":0,"stats":{"Line":13618885273168379904}},{"line":56,"address":[],"length":0,"stats":{"Line":17437937757178560549}},{"line":57,"address":[],"length":0,"stats":{"Line":17437937757178560549}},{"line":58,"address":[],"length":0,"stats":{"Line":17437937757178560549}},{"line":59,"address":[],"length":0,"stats":{"Line":11889503016258109529}},{"line":60,"address":[],"length":0,"stats":{"Line":16501189034685497901}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":14339461213547659532}},{"line":116,"address":[],"length":0,"stats":{"Line":14339461213547659532}},{"line":118,"address":[],"length":0,"stats":{"Line":14339461213547659532}},{"line":125,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":126,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":128,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":129,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":15708555500268290726}},{"line":132,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":134,"address":[],"length":0,"stats":{"Line":1369094286720631009}},{"line":135,"address":[],"length":0,"stats":{"Line":1369094286720631009}},{"line":140,"address":[],"length":0,"stats":{"Line":14339461213547659717}},{"line":144,"address":[],"length":0,"stats":{"Line":60}},{"line":146,"address":[],"length":0,"stats":{"Line":60}},{"line":147,"address":[],"length":0,"stats":{"Line":76}},{"line":148,"address":[],"length":0,"stats":{"Line":48}},{"line":149,"address":[],"length":0,"stats":{"Line":16}},{"line":152,"address":[],"length":0,"stats":{"Line":40}},{"line":156,"address":[],"length":0,"stats":{"Line":72057594037928016}},{"line":157,"address":[],"length":0,"stats":{"Line":72057594037928016}},{"line":158,"address":[],"length":0,"stats":{"Line":72057594037928016}},{"line":159,"address":[],"length":0,"stats":{"Line":216172782113783888}},{"line":160,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":165,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":8}},{"line":171,"address":[],"length":0,"stats":{"Line":4}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":20}},{"line":179,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":180,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":181,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":182,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":183,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":184,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":185,"address":[],"length":0,"stats":{"Line":13114482114902884709}},{"line":187,"address":[],"length":0,"stats":{"Line":9727775195120271003}},{"line":193,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":194,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":195,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":196,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":197,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":198,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":201,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":6196953087261802534}},{"line":249,"address":[],"length":0,"stats":{"Line":16140901064495857737}}],"covered":63,"coverable":92},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","integers.rs"],"content":"//! A collection of traits and macros which convert primitive integer types into field elements.\r\n\r\n/// A macro which lets us define the function `from_Int`\r\n/// where `Int` can be replaced by any integer type.\r\n///\r\n/// Running, `from_integer_types!(Int)` adds the following code to a trait:\r\n///\r\n/// ```rust,ignore\r\n/// /// Given an integer `r`, return the sum of `r` copies of `ONE`:\r\n/// ///\r\n/// /// `r * Self::ONE =  Self::ONE + ... + Self::ONE (r times)`.\r\n/// ///\r\n/// /// Note that the output only depends on `r mod p`.\r\n/// ///\r\n/// /// This should be avoided in performance critical locations.\r\n/// fn from_Int(int: Int) -\u003e Self {\r\n///     Self::from_prime_subfield(Self::PrimeSubfield::from_int(int))\r\n/// }\r\n/// ```\r\n///\r\n/// This macro can be run for any `Int` where `Self::PrimeSubfield` implements `QuotientMap\u003cInt\u003e`.\r\n/// It considerably cuts down on the amount of copy/pasted code.\r\nmacro_rules! from_integer_types {\r\n    ($($type:ty),* $(,)? ) =\u003e {\r\n        $( paste::paste!{\r\n            /// Given an integer `r`, return the sum of `r` copies of `ONE`:\r\n            ///\r\n            /// `r * Self::ONE =  Self::ONE + ... + Self::ONE (r times)`.\r\n            ///\r\n            /// Note that the output only depends on `r mod p`.\r\n            ///\r\n            /// This should be avoided in performance critical locations.\r\n            fn [\u003cfrom_ $type\u003e](int: $type) -\u003e Self {\r\n                Self::from_prime_subfield(Self::PrimeSubfield::from_int(int))\r\n            }\r\n        }\r\n        )*\r\n    };\r\n}\r\n\r\n/// Implementation of the quotient map ` -\u003e /p` which sends an integer `r` to its conjugacy class `[r]`.\r\n///\r\n/// This is the key trait allowing us to convert integers into field elements. Each prime field\r\n/// should implement this for all primitive integer types.\r\npub trait QuotientMap\u003cInt\u003e: Sized {\r\n    /// Convert a given integer into an element of the field `/p`.\r\n    ///   \r\n    /// This is the most generic method which makes no assumptions on the size of the input.\r\n    /// Where possible, this method should be used with the smallest possible integer type.\r\n    /// For example, if a 32-bit integer `x` is known to be less than `2^16`, then\r\n    /// `from_int(x as u16)` will often be faster than `from_int(x)`.\r\n    ///\r\n    /// This method is also strongly preferred over `from_canonical_checked/from_canonical_unchecked`.\r\n    /// It will usually be identical when `Int` is a small type, e.g. `u8/u16` and is safer for\r\n    /// larger types.\r\n    fn from_int(int: Int) -\u003e Self;\r\n\r\n    /// Convert a given integer into an element of the field `/p`. The input is checked to\r\n    /// ensure it lies within a given range.\r\n    /// - If `Int` is an unsigned integer type the input must lie in `[0, p - 1]`.\r\n    /// - If `Int` is a signed integer type the input must lie in `[-(p - 1)/2, (p - 1)/2]`.\r\n    ///\r\n    /// Return `None` if the input lies outside this range and `Some(val)` otherwise.\r\n    fn from_canonical_checked(int: Int) -\u003e Option\u003cSelf\u003e;\r\n\r\n    /// Convert a given integer into an element of the field `/p`. The input is guaranteed\r\n    /// to lie within a specific range depending on `p`. If the input lies outside of this\r\n    /// range, the output is undefined.\r\n    ///\r\n    /// In general `from_canonical_unchecked` will be faster for either `signed` or `unsigned`\r\n    /// types but the specifics will depend on the field.\r\n    ///\r\n    /// # Safety\r\n    /// - If `Int` is an unsigned integer type then the allowed range will include `[0, p - 1]`.\r\n    /// - If `Int` is a signed integer type then the allowed range will include `[-(p - 1)/2, (p - 1)/2]`.\r\n    unsafe fn from_canonical_unchecked(int: Int) -\u003e Self;\r\n}\r\n\r\n/// This allows us to avoid some duplication which arises when working with fields which contain a generic parameter.\r\n/// See `quotient_map_small_int` to see what this will expand to/how to call it. This is not intended for use outside of\r\n/// that macro.\r\n#[macro_export]\r\nmacro_rules! quotient_map_small_internals {\r\n    ($field:ty, $field_size:ty, $small_int:ty) =\u003e {\r\n        #[doc = concat!(\"Convert a given `\", stringify!($small_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n        \\n Due to the integer type, the input value is always canonical.\")]\r\n        #[inline]\r\n        fn from_int(int: $small_int) -\u003e Self {\r\n            // Should be removed by the compiler.\r\n            assert!(size_of::\u003c$small_int\u003e() \u003c size_of::\u003c$field_size\u003e());\r\n            unsafe {\r\n                Self::from_canonical_unchecked(int as $field_size)\r\n            }\r\n        }\r\n\r\n        #[doc = concat!(\"Convert a given `\", stringify!($small_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n        \\n Due to the integer type, the input value is always canonical.\")]\r\n        #[inline]\r\n        fn from_canonical_checked(int: $small_int) -\u003e Option\u003cSelf\u003e {\r\n            // Should be removed by the compiler.\r\n            assert!(size_of::\u003c$small_int\u003e() \u003c size_of::\u003c$field_size\u003e());\r\n            Some(unsafe {\r\n                Self::from_canonical_unchecked(int as $field_size)\r\n            })\r\n        }\r\n\r\n        #[doc = concat!(\"Convert a given `\", stringify!($small_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n        \\n Due to the integer type, the input value is always canonical.\")]\r\n        #[inline]\r\n        unsafe fn from_canonical_unchecked(int: $small_int) -\u003e Self {\r\n            // We use debug_assert to ensure this is removed by the compiler in release mode.\r\n            debug_assert!(size_of::\u003c$small_int\u003e() \u003c size_of::\u003c$field_size\u003e());\r\n            Self::from_canonical_unchecked(int as $field_size)\r\n        }\r\n    };\r\n}\r\n\r\n/// If the integer type is smaller than the field order all possible inputs are canonical.\r\n/// In such a case we can easily implement `QuotientMap\u003cSmallInt\u003e` as all three methods will coincide.\r\n///\r\n/// The range of acceptable integer types depends on the size of the field:\r\n/// - For 31 bit fields, `SmallInt = u8, u16, i8, i16`.\r\n/// - For 64 bit fields, `SmallInt = u8, u16, u32, i8, i16, i32`.\r\n/// - For large fields (E.g. `Bn254`), `SmallInt` can be anything except for the largest primitive integer type `u128/i128`\r\n///\r\n/// This macro accepts 3 inputs.\r\n/// - The name of the prime field `P`\r\n/// - The larger integer type `Int` which inputs should be cast to.\r\n/// - A list of smaller integer types to auto implement `QuotientMap\u003cSmallInt\u003e`.\r\n///\r\n/// Then `from_int`, `from_canonical_checked`, `from_canonical_unchecked` are all\r\n/// implemented by casting the input to an `Int` and using the `from_canonical_unchecked`\r\n/// method from `QuotientMap\u003cInt\u003e`.\r\n///\r\n/// For a concrete example, `quotient_map_small_int!(Mersenne31, u32, [u8])` produces the following code:\r\n///\r\n/// ```rust,ignore\r\n/// impl QuotientMap\u003cu8\u003e for Mersenne31 {\r\n///     /// Convert a given `u8` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Due to the integer type, the input value is always canonical.\r\n///     #[inline]\r\n///     fn from_int(int: u8) -\u003e Mersenne31 {\r\n///         // Should be removed by the compiler.\r\n///         assert!(size_of::\u003cu8\u003e() \u003c size_of::\u003cu32\u003e());\r\n///         unsafe {\r\n///             Self::from_canonical_unchecked(int as u32)\r\n///         }\r\n///     }\r\n///\r\n///     /// Convert a given `u8` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Due to the integer type, the input value is always canonical.\r\n///     #[inline]\r\n///     fn from_canonical_checked(int: u8) -\u003e Option\u003cMersenne31\u003e {\r\n///         // Should be removed by the compiler.\r\n///         assert!(size_of::\u003cu8\u003e() \u003c size_of::\u003cu32\u003e());\r\n///         Some(unsafe {\r\n///             Self::from_canonical_unchecked(int as u32)\r\n///         })\r\n///     }\r\n///\r\n///     /// Convert a given `u8` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Due to the integer type, the input value is always canonical.\r\n///     #[inline]\r\n///     unsafe fn from_canonical_unchecked(int: u8) -\u003e Mersenne31 {\r\n///         // We use debug_assert to ensure this is removed by the compiler in release mode.\r\n///         debug_assert!(size_of::\u003cu8\u003e() \u003c size_of::\u003cu32\u003e());\r\n///         Self::from_canonical_unchecked(int as u32)\r\n///     }\r\n/// }\r\n///```\r\n///\r\n/// Fields will often use this method twice. Once for unsigned ints and once for signed ints.\r\n///\r\n/// We need two slightly different versions for this macro as MontyField31 uses generic parameters.\r\n#[macro_export]\r\nmacro_rules! quotient_map_small_int {\r\n    ($field:ty, $field_size:ty, [$($small_int:ty),*] ) =\u003e {\r\n        $(\r\n        paste::paste!{\r\n            impl QuotientMap\u003c$small_int\u003e for $field {\r\n                $crate::quotient_map_small_internals!($field, $field_size, $small_int);\r\n            }\r\n        }\r\n        )*\r\n    };\r\n\r\n    ($field:ty, $field_size:ty, $field_param:ty, [$($small_int:ty),*] ) =\u003e {\r\n        $(\r\n        paste::paste!{\r\n            impl\u003cFP: $field_param\u003e QuotientMap\u003c$small_int\u003e for $field\u003cFP\u003e {\r\n                $crate::quotient_map_small_internals!($field, $field_size, $small_int);\r\n            }\r\n        }\r\n        )*\r\n    };\r\n}\r\n\r\n/// If the unsigned integer type is large enough, there is often no method better for `from_int` than\r\n/// just doing a modular reduction to a smaller type.\r\n///\r\n/// This macro accepts 6 inputs.\r\n/// - The name of the prime field `P`\r\n/// - The smallest natural integer type large enough to contain the field characteristic.\r\n/// - The characteristic of the field.\r\n/// - A string giving the range for which from_canonical_checked produces the correct result.\r\n/// - A string giving the range for which from_canonical_unchecked produces the correct result.\r\n/// - A list of large integer types to auto implement `QuotientMap\u003cLargeInt\u003e`.\r\n///\r\n/// For a concrete example, `quotient_map_large_uint!(Mersenne31, u32, Mersenne31::ORDER_U32, \"`\\[0, 2^31 - 2\\]`\", \"`\\[0, 2^31 - 1\\]`\", [u128])` would produce the following code:\r\n///\r\n/// ```rust,ignore\r\n/// impl QuotientMap\u003cu128\u003e for Mersenne31 {\r\n///     /// Convert a given `u128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Uses a modular reduction to reduce to canonical form.\r\n///     /// This should be avoided in performance critical locations.\r\n///     #[inline]\r\n///     fn from_int(int: u128) -\u003e Mersenne31 {\r\n///         // Should be removed by the compiler.\r\n///         assert!(size_of::\u003cu128\u003e() \u003e size_of::\u003cu32\u003e());\r\n///         let red = (int % (Mersenne31::ORDER_U32 as u128)) as u32;\r\n///            unsafe {\r\n///                // This is safe as red is less than the field order by assumption.\r\n///                Self::from_canonical_unchecked(red)\r\n///            }\r\n///     }\r\n///\r\n///     /// Convert a given `u128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Returns `None` if the input does not lie in the range: [0, 2^31 - 2].\r\n///     #[inline]\r\n///     fn from_canonical_checked(int: u128) -\u003e Option\u003cMersenne31\u003e {\r\n///         if int \u003c Mersenne31::ORDER_U32 as u128 {\r\n///             unsafe {\r\n///                 // This is safe as we just checked that int is less than the field order.\r\n///                 Some(Self::from_canonical_unchecked(int as u32))\r\n///             }\r\n///         } else {\r\n///             None\r\n///         }\r\n///     }\r\n///\r\n///     /// Convert a given `u128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// # Safety\r\n///     /// The input mut lie in the range:\", [0, 2^31 - 1].\r\n///     #[inline]\r\n///     unsafe fn from_canonical_unchecked(int: u128) -\u003e Mersenne31 {\r\n///         Self::from_canonical_unchecked(int as u32)\r\n///     }\r\n/// }\r\n///```\r\n#[macro_export]\r\nmacro_rules! quotient_map_large_uint {\r\n    ($field:ty, $field_size:ty, $field_order:expr, $checked_bounds:literal, $unchecked_bounds:literal, [$($large_int:ty),*] ) =\u003e {\r\n        $(\r\n        impl QuotientMap\u003c$large_int\u003e for $field {\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n                \\n Uses a modular reduction to reduce to canonical form. \\n This should be avoided in performance critical locations.\")]\r\n            #[inline]\r\n            fn from_int(int: $large_int) -\u003e $field {\r\n                assert!(size_of::\u003c$large_int\u003e() \u003e size_of::\u003c$field_size\u003e());\r\n                let red = (int % ($field_order as $large_int)) as $field_size;\r\n                unsafe {\r\n                    // This is safe as red is less than the field order by assumption.\r\n                    Self::from_canonical_unchecked(red)\r\n                }\r\n            }\r\n\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n                \\n Returns `None` if the input does not lie in the range:\", $checked_bounds, \".\")]\r\n            #[inline]\r\n            fn from_canonical_checked(int: $large_int) -\u003e Option\u003c$field\u003e {\r\n                if int \u003c $field_order as $large_int {\r\n                    unsafe {\r\n                        // This is safe as we just checked that int is less than the field order.\r\n                        Some(Self::from_canonical_unchecked(int as $field_size))\r\n                    }\r\n                } else {\r\n                    None\r\n                }\r\n            }\r\n\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_int), \"` integer into an element of the `\", stringify!($field), \"` field.\")]\r\n            ///\r\n            /// # Safety\r\n            #[doc = concat!(\"The input mut lie in the range:\", $unchecked_bounds, \".\")]\r\n            #[inline]\r\n            unsafe fn from_canonical_unchecked(int: $large_int) -\u003e $field {\r\n                Self::from_canonical_unchecked(int as $field_size)\r\n            }\r\n        }\r\n        )*\r\n    };\r\n}\r\n\r\n/// For large signed integer types, a simple method which is usually good enough is to simply check the sign and use this to\r\n/// pass to the equivalent unsigned method. This will often not be the fastest implementation but should be good enough for most cases.\r\n///\r\n/// This macro accepts 4 inputs.\r\n/// - The name of the prime field `P`.\r\n/// - The smallest natural integer type large enough to contain the field characteristic.\r\n/// - A string giving the range for which from_canonical_checked produces the correct result.\r\n/// - A string giving the range for which from_canonical_unchecked produces the correct result.\r\n/// - A list of pairs of large sign and unsigned integer types to auto implement `QuotientMap\u003cLargeSignInt\u003e`.\r\n///\r\n/// For a concrete example, `quotient_map_large_iint!(Mersenne31, i32, \"`\\[-2^30, 2^30\\]`\", \"`\\[1 - 2^31, 2^31 - 1\\]`\", [(i128, u128)])` would produce the following code:\r\n///\r\n/// ```rust,ignore\r\n/// impl QuotientMap\u003ci128\u003e for Mersenne31 {\r\n///     /// Convert a given `i128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// This checks the sign and then makes use of the equivalent method for unsigned integers.\r\n///     /// This should be avoided in performance critical locations.\r\n///     #[inline]\r\n///     fn from_int(int: i128) -\u003e Mersenne31 {\r\n///         if int \u003e= 0 {\r\n///             Self::from_int(int as u128)\r\n///         } else {\r\n///            -Self::from_int(-int as u128)\r\n///         }\r\n///     }\r\n///\r\n///     /// Convert a given `i128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// Returns `None` if the input does not lie in the range: `[-2^30, 2^30]`.\r\n///     #[inline]\r\n///     fn from_canonical_checked(int: i128) -\u003e Option\u003cMersenne31\u003e {\r\n///         // We just check that int fits into an i32 now and then use the i32 method.\r\n///         let int_small = TryInto::\u003ci32\u003e::try_into(int);\r\n///         if int_small.is_ok() {\r\n///             Self::from_canonical_checked(int_small.unwrap())\r\n///         } else {\r\n///             None\r\n///         }\r\n///     }\r\n///\r\n///     /// Convert a given `i128` integer into an element of the `Mersenne31` field.\r\n///     ///\r\n///     /// # Safety\r\n///     /// The input mut lie in the range:\", `[1 - 2^31, 2^31 - 1]`.\r\n///     #[inline]\r\n///     unsafe fn from_canonical_unchecked(int: i128) -\u003e Mersenne31 {\r\n///         Self::from_canonical_unchecked(int as i32)\r\n///     }\r\n/// }\r\n///```\r\n#[macro_export]\r\nmacro_rules! quotient_map_large_iint {\r\n    ($field:ty, $field_size:ty, $checked_bounds:literal, $unchecked_bounds:literal, [$(($large_signed_int:ty, $large_int:ty)),*] ) =\u003e {\r\n        $(\r\n        impl QuotientMap\u003c$large_signed_int\u003e for $field {\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_signed_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n                \\n This checks the sign and then makes use of the equivalent method for unsigned integers. \\n This should be avoided in performance critical locations.\")]\r\n            #[inline]\r\n            fn from_int(int: $large_signed_int) -\u003e $field {\r\n                if int \u003e= 0 {\r\n                    Self::from_int(int as $large_int)\r\n                } else {\r\n                    -Self::from_int(-int as $large_int)\r\n                }\r\n            }\r\n\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_int), \"` integer into an element of the `\", stringify!($field), \"` field.\r\n                \\n Returns `None` if the input does not lie in the range:\", $checked_bounds, \".\")]\r\n            #[inline]\r\n            fn from_canonical_checked(int: $large_signed_int) -\u003e Option\u003c$field\u003e {\r\n                let int_small = TryInto::\u003c$field_size\u003e::try_into(int).ok();\r\n\r\n                // The type of the following is Option\u003cOption\u003c$field\u003e\u003e.\r\n                // We use the ? operator to convert it to Option\u003c$field\u003e, with\r\n                // None and Some(None) both becoming None.\r\n                int_small.map(Self::from_canonical_checked)?\r\n            }\r\n\r\n            #[doc = concat!(\"Convert a given `\", stringify!($large_int), \"` integer into an element of the `\", stringify!($field), \"` field.\")]\r\n            ///\r\n            /// # Safety\r\n            #[doc = concat!(\"The input mut lie in the range:\", $unchecked_bounds, \".\")]\r\n            #[inline]\r\n            unsafe fn from_canonical_unchecked(int: $large_signed_int) -\u003e $field {\r\n                Self::from_canonical_unchecked(int as $field_size)\r\n            }\r\n        }\r\n        )*\r\n    };\r\n}\r\n\r\n/// We implement `QuotientMap\u003cusize\u003e` (`QuotientMap\u003cisize\u003e`) by matching against the size of `usize` (`isize`)\r\n/// and then converting `usize` (`isize`) into the equivalent matching integer type.\r\n///\r\n/// The code is identical for both `usize` and `isize` outside of replacing some u's by i's so we use a macro\r\n/// to avoid the copy and paste.\r\nmacro_rules! impl_u_i_size {\r\n    ($intsize:ty, $int8:ty, $int16:ty, $int32:ty, $int64:ty, $int128:ty) =\u003e {\r\n        impl\u003c\r\n                F: QuotientMap\u003c$int8\u003e\r\n                    + QuotientMap\u003c$int16\u003e\r\n                    + QuotientMap\u003c$int32\u003e\r\n                    + QuotientMap\u003c$int64\u003e\r\n                    + QuotientMap\u003c$int128\u003e,\r\n            \u003e QuotientMap\u003c$intsize\u003e for F\r\n        {\r\n            #[doc = concat!(\"We use the `from_int` method of the primitive integer type identical to `\", stringify!($intsize), \"` on this machine\")]\r\n            fn from_int(int: $intsize) -\u003e Self {\r\n                match size_of::\u003c$intsize\u003e() {\r\n                    1 =\u003e Self::from_int(int as $int8),\r\n                    2 =\u003e Self::from_int(int as $int16),\r\n                    4 =\u003e Self::from_int(int as $int32),\r\n                    8 =\u003e Self::from_int(int as $int64),\r\n                    16 =\u003e Self::from_int(int as $int128),\r\n                    _ =\u003e panic!(concat!(stringify!($intsize), \"is not equivalent to any primitive integer types.\")),\r\n                }\r\n            }\r\n\r\n            #[doc = concat!(\"We use the `from_canonical_checked` method of the primitive integer type identical to `\", stringify!($intsize), \"` on this machine\")]\r\n            fn from_canonical_checked(int: $intsize) -\u003e Option\u003cSelf\u003e {\r\n                match size_of::\u003c$intsize\u003e() {\r\n                    1 =\u003e Self::from_canonical_checked(int as $int8),\r\n                    2 =\u003e Self::from_canonical_checked(int as $int16),\r\n                    4 =\u003e Self::from_canonical_checked(int as $int32),\r\n                    8 =\u003e Self::from_canonical_checked(int as $int64),\r\n                    16 =\u003e Self::from_canonical_checked(int as $int128),\r\n                    _ =\u003e panic!(concat!(stringify!($intsize), \"is not equivalent to any primitive integer types.\")),\r\n                }\r\n            }\r\n\r\n            #[doc = concat!(\"We use the `from_canonical_unchecked` method of the primitive integer type identical to `\", stringify!($intsize), \"` on this machine\")]\r\n            unsafe fn from_canonical_unchecked(int: $intsize) -\u003e Self {\r\n                match size_of::\u003c$intsize\u003e() {\r\n                    1 =\u003e Self::from_canonical_unchecked(int as $int8),\r\n                    2 =\u003e Self::from_canonical_unchecked(int as $int16),\r\n                    4 =\u003e Self::from_canonical_unchecked(int as $int32),\r\n                    8 =\u003e Self::from_canonical_unchecked(int as $int64),\r\n                    16 =\u003e Self::from_canonical_unchecked(int as $int128),\r\n                    _ =\u003e panic!(concat!(stringify!($intsize), \"is not equivalent to any primitive integer types.\")),\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nimpl_u_i_size!(usize, u8, u16, u32, u64, u128);\r\nimpl_u_i_size!(isize, i8, i16, i32, i64, i128);\r\n\r\n// The only general type for which we do not provide a macro is for large signed integers.\r\n// This is because different field will usually want to handle large signed integers in\r\n// their own way.\r\npub(crate) use from_integer_types;\r\npub use {quotient_map_large_iint, quotient_map_large_uint, quotient_map_small_int};\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":13042424520864971414}},{"line":34,"address":[],"length":0,"stats":{"Line":13042424520864971414}},{"line":88,"address":[],"length":0,"stats":{"Line":13402712491054599165}},{"line":90,"address":[],"length":0,"stats":{"Line":13402712491054599165}},{"line":92,"address":[],"length":0,"stats":{"Line":13402712491054596095}},{"line":99,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":101,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":102,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":103,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":110,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":112,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":113,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":264,"address":[],"length":0,"stats":{"Line":15348267530078714205}},{"line":265,"address":[],"length":0,"stats":{"Line":15348267530078714205}},{"line":266,"address":[],"length":0,"stats":{"Line":15348267530078650722}},{"line":267,"address":[],"length":0,"stats":{"Line":15348267530078650722}},{"line":269,"address":[],"length":0,"stats":{"Line":15348267530078650722}},{"line":276,"address":[],"length":0,"stats":{"Line":3819052484010180898}},{"line":277,"address":[],"length":0,"stats":{"Line":3819052484010180898}},{"line":280,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":283,"address":[],"length":0,"stats":{"Line":1080863910568919330}},{"line":292,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":293,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":359,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":360,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":361,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":363,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":370,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":371,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":376,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":384,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":385,"address":[],"length":0,"stats":{"Line":4179340454199820288}},{"line":408,"address":[],"length":0,"stats":{"Line":7998392938210123405}},{"line":409,"address":[],"length":0,"stats":{"Line":7998392938210123405}},{"line":410,"address":[],"length":0,"stats":{"Line":153527}},{"line":411,"address":[],"length":0,"stats":{"Line":152}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":7998392938210000895}},{"line":414,"address":[],"length":0,"stats":{"Line":152}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":6845471433603154184}},{"line":421,"address":[],"length":0,"stats":{"Line":6845471433603154184}},{"line":422,"address":[],"length":0,"stats":{"Line":264}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":433,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":6845471433603153920}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}}],"covered":45,"coverable":56},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","lib.rs"],"content":"//! A framework for finite fields.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod array;\r\nmod batch_inverse;\r\npub mod exponentiation;\r\npub mod extension;\r\nmod field;\r\nmod helpers;\r\npub mod integers;\r\nmod packed;\r\n\r\npub use array::*;\r\npub use batch_inverse::*;\r\npub use field::*;\r\npub use helpers::*;\r\npub use packed::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field","src","packed.rs"],"content":"use core::mem::MaybeUninit;\r\nuse core::ops::Div;\r\nuse core::slice;\r\n\r\nuse crate::field::Field;\r\nuse crate::{Algebra, ExtensionField, Powers, PrimeCharacteristicRing, Serializable};\r\n\r\n/// A trait to constrain types that can be packed into a packed value.\r\n///\r\n/// The `Packable` trait allows us to specify implementations for potentially conflicting types.\r\npub trait Packable: 'static + Default + Copy + Send + Sync + PartialEq + Eq {}\r\n\r\n/// # Safety\r\n/// - If `P` implements `PackedField` then `P` must be castable to/from `[P::Value; P::WIDTH]`\r\n///   without UB.\r\npub unsafe trait PackedValue: 'static + Copy + Send + Sync {\r\n    type Value: Packable;\r\n\r\n    const WIDTH: usize;\r\n\r\n    fn from_slice(slice: \u0026[Self::Value]) -\u003e \u0026Self;\r\n    fn from_slice_mut(slice: \u0026mut [Self::Value]) -\u003e \u0026mut Self;\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    fn from_fn\u003cF\u003e(f: F) -\u003e Self\r\n    where\r\n        F: FnMut(usize) -\u003e Self::Value;\r\n\r\n    fn as_slice(\u0026self) -\u003e \u0026[Self::Value];\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Self::Value];\r\n\r\n    fn pack_slice(buf: \u0026[Self::Value]) -\u003e \u0026[Self] {\r\n        // Sources vary, but this should be true on all platforms we care about.\r\n        // This should be a const assert, but trait methods can't access `Self` in a const context,\r\n        // even with inner struct instantiation. So we will trust LLVM to optimize this out.\r\n        assert!(align_of::\u003cSelf\u003e() \u003c= align_of::\u003cSelf::Value\u003e());\r\n        assert!(\r\n            buf.len() % Self::WIDTH == 0,\r\n            \"Slice length (got {}) must be a multiple of packed field width ({}).\",\r\n            buf.len(),\r\n            Self::WIDTH\r\n        );\r\n        let buf_ptr = buf.as_ptr().cast::\u003cSelf\u003e();\r\n        let n = buf.len() / Self::WIDTH;\r\n        unsafe { slice::from_raw_parts(buf_ptr, n) }\r\n    }\r\n\r\n    fn pack_slice_with_suffix(buf: \u0026[Self::Value]) -\u003e (\u0026[Self], \u0026[Self::Value]) {\r\n        let (packed, suffix) = buf.split_at(buf.len() - buf.len() % Self::WIDTH);\r\n        (Self::pack_slice(packed), suffix)\r\n    }\r\n\r\n    fn pack_slice_mut(buf: \u0026mut [Self::Value]) -\u003e \u0026mut [Self] {\r\n        assert!(align_of::\u003cSelf\u003e() \u003c= align_of::\u003cSelf::Value\u003e());\r\n        assert!(\r\n            buf.len() % Self::WIDTH == 0,\r\n            \"Slice length (got {}) must be a multiple of packed field width ({}).\",\r\n            buf.len(),\r\n            Self::WIDTH\r\n        );\r\n        let buf_ptr = buf.as_mut_ptr().cast::\u003cSelf\u003e();\r\n        let n = buf.len() / Self::WIDTH;\r\n        unsafe { slice::from_raw_parts_mut(buf_ptr, n) }\r\n    }\r\n\r\n    fn pack_maybe_uninit_slice_mut(\r\n        buf: \u0026mut [MaybeUninit\u003cSelf::Value\u003e],\r\n    ) -\u003e \u0026mut [MaybeUninit\u003cSelf\u003e] {\r\n        assert!(align_of::\u003cSelf\u003e() \u003c= align_of::\u003cSelf::Value\u003e());\r\n        assert!(\r\n            buf.len() % Self::WIDTH == 0,\r\n            \"Slice length (got {}) must be a multiple of packed field width ({}).\",\r\n            buf.len(),\r\n            Self::WIDTH\r\n        );\r\n        let buf_ptr = buf.as_mut_ptr().cast::\u003cMaybeUninit\u003cSelf\u003e\u003e();\r\n        let n = buf.len() / Self::WIDTH;\r\n        unsafe { slice::from_raw_parts_mut(buf_ptr, n) }\r\n    }\r\n\r\n    fn pack_slice_with_suffix_mut(buf: \u0026mut [Self::Value]) -\u003e (\u0026mut [Self], \u0026mut [Self::Value]) {\r\n        let (packed, suffix) = buf.split_at_mut(buf.len() - buf.len() % Self::WIDTH);\r\n        (Self::pack_slice_mut(packed), suffix)\r\n    }\r\n\r\n    fn pack_maybe_uninit_slice_with_suffix_mut(\r\n        buf: \u0026mut [MaybeUninit\u003cSelf::Value\u003e],\r\n    ) -\u003e (\u0026mut [MaybeUninit\u003cSelf\u003e], \u0026mut [MaybeUninit\u003cSelf::Value\u003e]) {\r\n        let (packed, suffix) = buf.split_at_mut(buf.len() - buf.len() % Self::WIDTH);\r\n        (Self::pack_maybe_uninit_slice_mut(packed), suffix)\r\n    }\r\n\r\n    fn unpack_slice(buf: \u0026[Self]) -\u003e \u0026[Self::Value] {\r\n        assert!(align_of::\u003cSelf\u003e() \u003e= align_of::\u003cSelf::Value\u003e());\r\n        let buf_ptr = buf.as_ptr().cast::\u003cSelf::Value\u003e();\r\n        let n = buf.len() * Self::WIDTH;\r\n        unsafe { slice::from_raw_parts(buf_ptr, n) }\r\n    }\r\n}\r\n\r\nunsafe impl\u003cT: Packable, const WIDTH: usize\u003e PackedValue for [T; WIDTH] {\r\n    type Value = T;\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    fn from_slice(slice: \u0026[Self::Value]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        slice.try_into().unwrap()\r\n    }\r\n\r\n    fn from_slice_mut(slice: \u0026mut [Self::Value]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        slice.try_into().unwrap()\r\n    }\r\n\r\n    fn from_fn\u003cF\u003e(f: F) -\u003e Self\r\n    where\r\n        F: FnMut(usize) -\u003e Self::Value,\r\n    {\r\n        core::array::from_fn(f)\r\n    }\r\n\r\n    fn as_slice(\u0026self) -\u003e \u0026[Self::Value] {\r\n        self\r\n    }\r\n\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Self::Value] {\r\n        self\r\n    }\r\n}\r\n\r\n/// An array of field elements which can be packed into a vector for SIMD operations.\r\n///\r\n/// # Safety\r\n/// - See `PackedValue` above.\r\npub unsafe trait PackedField: Algebra\u003cSelf::Scalar\u003e\r\n    + PackedValue\u003cValue = Self::Scalar\u003e\r\n    // TODO: Implement packed / packed division\r\n    + Div\u003cSelf::Scalar, Output = Self\u003e\r\n{\r\n    type Scalar: Field;\r\n\r\n    /// Construct an iterator which returns powers of `base` packed into packed field elements.\r\n    /// \r\n    /// E.g. if `Self::WIDTH = 4`, returns: `[base^0, base^1, base^2, base^3], [base^4, base^5, base^6, base^7], ...`.\r\n    #[must_use]\r\n    fn packed_powers(base: Self::Scalar) -\u003e Powers\u003cSelf\u003e {\r\n        Self::packed_shifted_powers(base, Self::Scalar::ONE)\r\n    }\r\n\r\n    /// Construct an iterator which returns powers of `base` multiplied by `start` and packed into packed field elements.\r\n    /// \r\n    /// E.g. if `Self::WIDTH = 4`, returns: `[start, start*base, start*base^2, start*base^3], [start*base^4, start*base^5, start*base^6, start*base^7], ...`.\r\n    #[must_use]\r\n    fn packed_shifted_powers(base: Self::Scalar, start: Self::Scalar) -\u003e Powers\u003cSelf\u003e {\r\n        let mut current: Self = start.into();\r\n        let slice = current.as_slice_mut();\r\n        for i in 1..Self::WIDTH {\r\n            slice[i] = slice[i - 1] * base;\r\n        }\r\n\r\n        Powers {\r\n            base: base.exp_u64(Self::WIDTH as u64).into(),\r\n            current,\r\n        }\r\n    }\r\n}\r\n\r\n/// # Safety\r\n/// - `WIDTH` is assumed to be a power of 2.\r\npub unsafe trait PackedFieldPow2: PackedField {\r\n    /// Take interpret two vectors as chunks of `block_len` elements. Unpack and interleave those\r\n    /// chunks. This is best seen with an example. If we have:\r\n    /// ```text\r\n    /// A = [x0, y0, x1, y1]\r\n    /// B = [x2, y2, x3, y3]\r\n    /// ```\r\n    ///\r\n    /// then\r\n    ///\r\n    /// ```text\r\n    /// interleave(A, B, 1) = ([x0, x2, x1, x3], [y0, y2, y1, y3])\r\n    /// ```\r\n    ///\r\n    /// Pairs that were adjacent in the input are at corresponding positions in the output.\r\n    ///\r\n    /// `r` lets us set the size of chunks we're interleaving. If we set `block_len = 2`, then for\r\n    ///\r\n    /// ```text\r\n    /// A = [x0, x1, y0, y1]\r\n    /// B = [x2, x3, y2, y3]\r\n    /// ```\r\n    ///\r\n    /// we obtain\r\n    ///\r\n    /// ```text\r\n    /// interleave(A, B, block_len) = ([x0, x1, x2, x3], [y0, y1, y2, y3])\r\n    /// ```\r\n    ///\r\n    /// We can also think about this as stacking the vectors, dividing them into 2x2 matrices, and\r\n    /// transposing those matrices.\r\n    ///\r\n    /// When `block_len = WIDTH`, this operation is a no-op. `block_len` must divide `WIDTH`. Since\r\n    /// `WIDTH` is specified to be a power of 2, `block_len` must also be a power of 2. It cannot be\r\n    /// 0 and it cannot exceed `WIDTH`.\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self);\r\n}\r\n\r\n/// Fix a field `F` a packing width `W` and an extension field `EF` of `F`.\r\n///\r\n/// By choosing a basis `B`, `EF` can be transformed into an array `[F; D]`.\r\n///\r\n/// A type should implement PackedFieldExtension if it can be transformed into `[F::Packing; D] ~ [[F; W]; D]`\r\n///\r\n/// This is interpreted by taking a transpose to get `[[F; D]; W]` which can then be reinterpreted\r\n/// as `[EF; W]` by making use of the chosen basis `B` again.\r\npub trait PackedFieldExtension\u003c\r\n    BaseField: Field,\r\n    ExtField: ExtensionField\u003cBaseField, ExtensionPacking = Self\u003e,\r\n\u003e: Algebra\u003cExtField\u003e + Algebra\u003cBaseField::Packing\u003e + Serializable\u003cBaseField::Packing\u003e\r\n{\r\n    /// Given a slice of extension field `EF` elements of length `W`,\r\n    /// convert into the array `[[F; D]; W]` transpose to\r\n    /// `[[F; W]; D]` and then pack to get `[PF; D]`.\r\n    fn from_ext_slice(ext_slice: \u0026[ExtField]) -\u003e Self;\r\n\r\n    /// Similar to packed_powers, construct an iterator which returns\r\n    /// powers of `base` packed into `PackedFieldExtension` elements.\r\n    fn packed_ext_powers(base: ExtField) -\u003e Powers\u003cSelf\u003e;\r\n}\r\n\r\nunsafe impl\u003cT: Packable\u003e PackedValue for T {\r\n    type Value = Self;\r\n\r\n    const WIDTH: usize = 1;\r\n\r\n    fn from_slice(slice: \u0026[Self::Value]) -\u003e \u0026Self {\r\n        \u0026slice[0]\r\n    }\r\n\r\n    fn from_slice_mut(slice: \u0026mut [Self::Value]) -\u003e \u0026mut Self {\r\n        \u0026mut slice[0]\r\n    }\r\n\r\n    fn from_fn\u003cFn\u003e(mut f: Fn) -\u003e Self\r\n    where\r\n        Fn: FnMut(usize) -\u003e Self::Value,\r\n    {\r\n        f(0)\r\n    }\r\n\r\n    fn as_slice(\u0026self) -\u003e \u0026[Self::Value] {\r\n        slice::from_ref(self)\r\n    }\r\n\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Self::Value] {\r\n        slice::from_mut(self)\r\n    }\r\n}\r\n\r\nunsafe impl\u003cF: Field\u003e PackedField for F {\r\n    type Scalar = Self;\r\n}\r\n\r\nunsafe impl\u003cF: Field\u003e PackedFieldPow2 for F {\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        match block_len {\r\n            1 =\u003e (*self, other),\r\n            _ =\u003e panic!(\"unsupported block length\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e PackedFieldExtension\u003cF, F\u003e for F::Packing {\r\n    fn from_ext_slice(ext_slice: \u0026[F]) -\u003e Self {\r\n        ext_slice[0].into()\r\n    }\r\n\r\n    fn packed_ext_powers(base: F) -\u003e Powers\u003cSelf\u003e {\r\n        F::Packing::packed_powers(base)\r\n    }\r\n}\r\n\r\nimpl Packable for u8 {}\r\n\r\nimpl Packable for u16 {}\r\n\r\nimpl Packable for u32 {}\r\n\r\nimpl Packable for u64 {}\r\n\r\nimpl Packable for u128 {}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":7421932185906577466}},{"line":36,"address":[],"length":0,"stats":{"Line":7421932185906577466}},{"line":37,"address":[],"length":0,"stats":{"Line":7421932185906577490}},{"line":38,"address":[],"length":0,"stats":{"Line":7421932185906577490}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":7421932185906577490}},{"line":44,"address":[],"length":0,"stats":{"Line":7421932185906577490}},{"line":45,"address":[],"length":0,"stats":{"Line":7421932185906577490}},{"line":48,"address":[],"length":0,"stats":{"Line":4107282860161898388}},{"line":49,"address":[],"length":0,"stats":{"Line":4107282860161898388}},{"line":50,"address":[],"length":0,"stats":{"Line":4107282860161898388}},{"line":53,"address":[],"length":0,"stats":{"Line":2449958197289550281}},{"line":54,"address":[],"length":0,"stats":{"Line":2449958197289550281}},{"line":55,"address":[],"length":0,"stats":{"Line":2449958197289556162}},{"line":56,"address":[],"length":0,"stats":{"Line":2449958197289556162}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":2449958197289556162}},{"line":62,"address":[],"length":0,"stats":{"Line":2449958197289556162}},{"line":63,"address":[],"length":0,"stats":{"Line":2449958197289556162}},{"line":66,"address":[],"length":0,"stats":{"Line":4179340454199826603}},{"line":69,"address":[],"length":0,"stats":{"Line":4179340454199826603}},{"line":70,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":71,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":77,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":78,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":81,"address":[],"length":0,"stats":{"Line":12105675798371894695}},{"line":82,"address":[],"length":0,"stats":{"Line":12105675798371894695}},{"line":83,"address":[],"length":0,"stats":{"Line":12105675798371894695}},{"line":86,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":89,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":90,"address":[],"length":0,"stats":{"Line":4179340454199820380}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":576460752303423487}},{"line":248,"address":[],"length":0,"stats":{"Line":576460752303423487}},{"line":251,"address":[],"length":0,"stats":{"Line":9223372036854778231}},{"line":252,"address":[],"length":0,"stats":{"Line":9223372036854778231}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}}],"covered":34,"coverable":82},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field-testing","src","bench_func.rs"],"content":"use alloc::format;\r\nuse alloc::vec::Vec;\r\n\r\nuse criterion::{black_box, BatchSize, Criterion};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\nuse rand::Rng;\r\n\r\npub fn benchmark_square\u003cF: Field\u003e(c: \u0026mut Criterion, name: \u0026str)\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut rng = rand::thread_rng();\r\n    let x = rng.gen::\u003cF\u003e();\r\n    c.bench_function(\u0026format!(\"{} square\", name), |b| {\r\n        b.iter(|| black_box(black_box(x).square()))\r\n    });\r\n}\r\n\r\npub fn benchmark_inv\u003cF: Field\u003e(c: \u0026mut Criterion, name: \u0026str)\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut rng = rand::thread_rng();\r\n    let x = rng.gen::\u003cF\u003e();\r\n    c.bench_function(\u0026format!(\"{} inv\", name), |b| {\r\n        b.iter(|| black_box(black_box(x)).inverse())\r\n    });\r\n}\r\n\r\n/// Benchmark the time taken to sum an array [F; N] using .sum() method.\r\n/// Repeat the summation REPS times.\r\npub fn benchmark_iter_sum\u003cF: Field, const N: usize, const REPS: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut rng = rand::thread_rng();\r\n    let mut input = Vec::new();\r\n    for _ in 0..REPS {\r\n        input.push(rng.gen::\u003c[F; N]\u003e())\r\n    }\r\n    let mut output = [F::ZERO; REPS];\r\n    c.bench_function(\u0026format!(\"{} sum/{}, {}\", name, REPS, N), |b| {\r\n        b.iter(|| {\r\n            for i in 0..REPS {\r\n                output[i] = input[i].iter().cloned().sum()\r\n            }\r\n            output\r\n        })\r\n    });\r\n}\r\n\r\npub fn benchmark_add_latency\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"add-latency/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                let mut vec = Vec::new();\r\n                for _ in 0..N {\r\n                    vec.push(rng.gen::\u003cR\u003e())\r\n                }\r\n                vec\r\n            },\r\n            |x| x.iter().fold(R::ZERO, |x, y| x + *y),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\npub fn benchmark_add_throughput\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"add-throughput/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                (\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                )\r\n            },\r\n            |(mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h, mut i, mut j)| {\r\n                for _ in 0..N {\r\n                    (a, b, c, d, e, f, g, h, i, j) = (\r\n                        a + b,\r\n                        b + c,\r\n                        c + d,\r\n                        d + e,\r\n                        e + f,\r\n                        f + g,\r\n                        g + h,\r\n                        h + i,\r\n                        i + j,\r\n                        j + a,\r\n                    );\r\n                }\r\n                (a, b, c, d, e, f, g, h, i, j)\r\n            },\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\npub fn benchmark_sub_latency\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"sub-latency/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                let mut vec = Vec::new();\r\n                for _ in 0..N {\r\n                    vec.push(rng.gen::\u003cR\u003e())\r\n                }\r\n                vec\r\n            },\r\n            |x| x.iter().fold(R::ZERO, |x, y| x - *y),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\npub fn benchmark_sub_throughput\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"sub-throughput/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                (\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                )\r\n            },\r\n            |(mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h, mut i, mut j)| {\r\n                for _ in 0..N {\r\n                    (a, b, c, d, e, f, g, h, i, j) = (\r\n                        a - b,\r\n                        b - c,\r\n                        c - d,\r\n                        d - e,\r\n                        e - f,\r\n                        f - g,\r\n                        g - h,\r\n                        h - i,\r\n                        i - j,\r\n                        j - a,\r\n                    );\r\n                }\r\n                (a, b, c, d, e, f, g, h, i, j)\r\n            },\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\npub fn benchmark_mul_latency\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"mul-latency/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                let mut vec = Vec::new();\r\n                for _ in 0..N {\r\n                    vec.push(rng.gen::\u003cR\u003e())\r\n                }\r\n                vec\r\n            },\r\n            |x| x.iter().fold(R::ZERO, |x, y| x * *y),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\npub fn benchmark_mul_throughput\u003cR: PrimeCharacteristicRing + Copy, const N: usize\u003e(\r\n    c: \u0026mut Criterion,\r\n    name: \u0026str,\r\n) where\r\n    Standard: Distribution\u003cR\u003e,\r\n{\r\n    c.bench_function(\u0026format!(\"mul-throughput/{} {}\", N, name), |b| {\r\n        b.iter_batched(\r\n            || {\r\n                let mut rng = rand::thread_rng();\r\n                (\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                    rng.gen::\u003cR\u003e(),\r\n                )\r\n            },\r\n            |(mut a, mut b, mut c, mut d, mut e, mut f, mut g, mut h, mut i, mut j)| {\r\n                for _ in 0..N {\r\n                    (a, b, c, d, e, f, g, h, i, j) = (\r\n                        a * b,\r\n                        b * c,\r\n                        c * d,\r\n                        d * e,\r\n                        e * f,\r\n                        f * g,\r\n                        g * h,\r\n                        h * i,\r\n                        i * j,\r\n                        j * a,\r\n                    );\r\n                }\r\n                (a, b, c, d, e, f, g, h, i, j)\r\n            },\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":144},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field-testing","src","dft_testing.rs"],"content":"use p3_dft::{NaiveDft, TwoAdicSubgroupDft};\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::thread_rng;\r\n\r\npub fn test_dft_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..12 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let dft_naive = NaiveDft.dft_batch(mat.clone());\r\n        let dft_result = dft.dft_batch(mat);\r\n        assert_eq!(dft_naive, dft_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_coset_dft_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..5 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let shift = F::GENERATOR;\r\n        let coset_dft_naive = NaiveDft.coset_dft_batch(mat.clone(), shift);\r\n        let coset_dft_result = dft.coset_dft_batch(mat, shift);\r\n        assert_eq!(coset_dft_naive, coset_dft_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_idft_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..12 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let idft_naive = NaiveDft.idft_batch(mat.clone());\r\n        let idft_result = dft.idft_batch(mat.clone());\r\n        assert_eq!(idft_naive, idft_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_coset_idft_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..5 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let shift = F::GENERATOR;\r\n        let idft_naive = NaiveDft.coset_idft_batch(mat.clone(), shift);\r\n        let idft_result = dft.coset_idft_batch(mat, shift);\r\n        assert_eq!(idft_naive, idft_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_lde_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..5 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let lde_naive = NaiveDft.lde_batch(mat.clone(), 1);\r\n        let lde_result = dft.lde_batch(mat, 1);\r\n        assert_eq!(lde_naive, lde_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_coset_lde_matches_naive\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..5 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let shift = F::GENERATOR;\r\n        let coset_lde_naive = NaiveDft.coset_lde_batch(mat.clone(), 1, shift);\r\n        let coset_lde_result = dft.coset_lde_batch(mat, 1, shift);\r\n        assert_eq!(coset_lde_naive, coset_lde_result.to_row_major_matrix());\r\n    }\r\n}\r\n\r\npub fn test_dft_idft_consistency\u003cF, Dft\u003e()\r\nwhere\r\n    F: TwoAdicField,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cF\u003e,\r\n{\r\n    let dft = Dft::default();\r\n    let mut rng = thread_rng();\r\n    for log_h in 0..12 {\r\n        let h = 1 \u003c\u003c log_h;\r\n        let original = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, h, 3);\r\n        let dft_output = dft.dft_batch(original.clone());\r\n        let idft_output = dft.idft_batch(dft_output.to_row_major_matrix());\r\n        assert_eq!(original, idft_output.to_row_major_matrix());\r\n    }\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_field_dft {\r\n    ($mod:ident, $field:ty, $dft:ty) =\u003e {\r\n        mod $mod {\r\n            #[test]\r\n            fn dft_matches_naive() {\r\n                $crate::test_dft_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn coset_dft_matches_naive() {\r\n                $crate::test_coset_dft_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn idft_matches_naive() {\r\n                $crate::test_idft_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn coset_idft_matches_naive() {\r\n                $crate::test_coset_idft_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn lde_matches_naive() {\r\n                $crate::test_lde_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn coset_lde_matches_naive() {\r\n                $crate::test_coset_lde_matches_naive::\u003c$field, $dft\u003e();\r\n            }\r\n\r\n            #[test]\r\n            fn dft_idft_consistency() {\r\n                $crate::test_dft_idft_consistency::\u003c$field, $dft\u003e();\r\n            }\r\n        }\r\n    };\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":792633534417207877}},{"line":14,"address":[],"length":0,"stats":{"Line":792633534417207877}},{"line":15,"address":[],"length":0,"stats":{"Line":792633534417207877}},{"line":16,"address":[],"length":0,"stats":{"Line":1369094286720631946}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":31,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":32,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":33,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":49,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":50,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":51,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":66,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":67,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":68,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":84,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":85,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":86,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":101,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":102,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":103,"address":[],"length":0,"stats":{"Line":8718968878589280256}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":119,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":120,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":121,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":136,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":140,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":141,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":145,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":146,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":150,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":151,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":155,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":156,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":160,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":161,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":165,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":166,"address":[],"length":0,"stats":{"Line":792633534417207296}}],"covered":42,"coverable":80},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field-testing","src","from_integer_tests.rs"],"content":"//! Macros for testing the implementations of converting integers into field elements.\r\n#[macro_export]\r\nmacro_rules! generate_from_int_tests {\r\n    ($field:ty, $val:expr, $field_val:expr) =\u003e {\r\n        assert_eq!(\u003c$field\u003e::from_int($val), $field_val);\r\n        let poss_val = \u003c$field\u003e::from_canonical_checked($val);\r\n        assert!(poss_val.is_some());\r\n        assert_eq!(poss_val.unwrap(), $field_val);\r\n        assert_eq!(\r\n            unsafe { \u003c$field\u003e::from_canonical_unchecked($val) },\r\n            $field_val\r\n        );\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! generate_from_small_int_tests {\r\n    ($field:ty, [$($int_type:ty), *]) =\u003e {\r\n        $(\r\n            // We check 0, 1 and a couple of other small values.\r\n            $crate::generate_from_int_tests!($field, 0 as $int_type, \u003c$field\u003e::ZERO);\r\n            $crate::generate_from_int_tests!($field, 1 as $int_type, \u003c$field\u003e::ONE);\r\n            let field_two = \u003c$field\u003e::ONE + \u003c$field\u003e::ONE;\r\n            $crate::generate_from_int_tests!($field, 2 as $int_type, field_two);\r\n            let field_three = field_two + \u003c$field\u003e::ONE;\r\n            $crate::generate_from_int_tests!($field, 3 as $int_type, field_three);\r\n            let field_six = field_two * field_three;\r\n            $crate::generate_from_int_tests!($field, 6 as $int_type, field_six);\r\n            let field_36 = field_six * field_six;\r\n            $crate::generate_from_int_tests!($field, 36 as $int_type, field_36);\r\n            let field_108 = field_36 * field_three;\r\n            $crate::generate_from_int_tests!($field, 108 as $int_type, field_108);\r\n        )*\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! generate_from_small_neg_int_tests {\r\n    ($field:ty, [$($int_type:ty), *]) =\u003e {\r\n        $(\r\n            // We check -1 and a couple of other small negative values.\r\n            let field_neg_one = -\u003c$field\u003e::ONE;\r\n            $crate::generate_from_int_tests!($field, -1 as $int_type, field_neg_one);\r\n            let field_neg_two = field_neg_one + field_neg_one;\r\n            $crate::generate_from_int_tests!($field, -2 as $int_type, field_neg_two);\r\n            let field_neg_four = field_neg_two + field_neg_two;\r\n            $crate::generate_from_int_tests!($field, -4 as $int_type, field_neg_four);\r\n            let field_neg_six = field_neg_two + field_neg_four;\r\n            $crate::generate_from_int_tests!($field, -6 as $int_type, field_neg_six);\r\n            let field_neg_24 = -field_neg_six * field_neg_four;\r\n            $crate::generate_from_int_tests!($field, -24 as $int_type, field_neg_24);\r\n        )*\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! generate_from_large_u_int_tests {\r\n    ($field:ty, $field_order:expr, [$($int_type:ty), *]) =\u003e {\r\n        $(\r\n            // Check some wraparound cases:\r\n            // Note that for unsigned integers, from_canonical_checked returns\r\n            // None when the input is bigger or equal to the field order.\r\n            // Similarly, from_canonical_unchecked may also return invalid results in these cases.\r\n            let field_order = $field_order as $int_type;\r\n\r\n            // On the other hand, everything should work fine for field_order - 1 and (field_order + 1)/2.\r\n            $crate::generate_from_int_tests!($field, field_order - 1, -\u003c$field\u003e::ONE);\r\n\r\n            let half = (field_order + 1) \u003e\u003e 1;\r\n            let field_half = (\u003c$field\u003e::ONE + \u003c$field\u003e::ONE).inverse();\r\n            $crate::generate_from_int_tests!($field, half, field_half);\r\n\r\n            // We check that from_canonical_checked returns None for large enough values\r\n            // but from_int is still correct.\r\n            assert_eq!(\u003c$field\u003e::from_int(field_order), \u003c$field\u003e::ZERO);\r\n            assert_eq!(\u003c$field\u003e::from_canonical_checked(field_order), None);\r\n            assert_eq!(\u003c$field\u003e::from_int(field_order + 1), \u003c$field\u003e::ONE);\r\n            assert_eq!(\u003c$field\u003e::from_canonical_checked(field_order + 1), None);\r\n            assert_eq!(\u003c$field\u003e::from_canonical_checked(\u003c$int_type\u003e::MAX), None);\r\n    )*\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! generate_from_large_i_int_tests {\r\n    ($field:ty, $field_order:expr, [$($int_type:ty), *]) =\u003e {\r\n        $(\r\n        // Check some wraparound cases:\r\n        // Note that for unsigned integers, from_canonical_checked returns\r\n        // None when |input| is bigger than (field order - 1)/2 and from_canonical_unchecked\r\n        // may also return invalid results in these cases.\r\n        let neg_half = ($field_order \u003e\u003e 1) as $int_type;\r\n        let half_as_neg_rep = -neg_half;\r\n\r\n        let field_half = (\u003c$field\u003e::ONE + \u003c$field\u003e::ONE).inverse();\r\n        let field_neg_half = field_half - \u003c$field\u003e::ONE;\r\n\r\n        $crate::generate_from_int_tests!($field, half_as_neg_rep, field_half);\r\n        $crate::generate_from_int_tests!($field, neg_half, field_neg_half);\r\n\r\n        // We check that from_canonical_checked returns None for large enough values but\r\n        // from_int is still correct.\r\n        let half = neg_half + 1;\r\n        assert_eq!(\u003c$field\u003e::from_int(half), field_half);\r\n        assert_eq!(\u003c$field\u003e::from_canonical_checked(half), None);\r\n        assert_eq!(\u003c$field\u003e::from_int(-half), field_neg_half);\r\n        assert_eq!(\u003c$field\u003e::from_canonical_checked(-half), None);\r\n        assert_eq!(\u003c$field\u003e::from_canonical_checked(\u003c$int_type\u003e::MAX), None);\r\n        assert_eq!(\u003c$field\u003e::from_canonical_checked(\u003c$int_type\u003e::MIN), None);\r\n        )*\r\n    };\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field-testing","src","lib.rs"],"content":"//! Utilities for testing field implementations.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\npub mod bench_func;\r\npub mod dft_testing;\r\npub mod from_integer_tests;\r\npub mod packedfield_testing;\r\n\r\npub use bench_func::*;\r\npub use dft_testing::*;\r\nuse num_bigint::BigUint;\r\nuse num_traits::identities::One;\r\nuse p3_field::{\r\n    cyclic_subgroup_coset_known_order, cyclic_subgroup_known_order, two_adic_coset_zerofier,\r\n    two_adic_subgroup_zerofier, ExtensionField, Field, TwoAdicField,\r\n};\r\npub use packedfield_testing::*;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\n#[allow(clippy::eq_op)]\r\npub fn test_add_neg_sub_mul\u003cF: Field\u003e()\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut rng = rand::thread_rng();\r\n    let x = rng.gen::\u003cF\u003e();\r\n    let y = rng.gen::\u003cF\u003e();\r\n    let z = rng.gen::\u003cF\u003e();\r\n    assert_eq!(F::ONE + F::NEG_ONE, F::ZERO);\r\n    assert_eq!(x + (-x), F::ZERO);\r\n    assert_eq!(F::ONE + F::ONE, F::TWO);\r\n    assert_eq!(-x, F::ZERO - x);\r\n    assert_eq!(x + x, x * F::TWO);\r\n    assert_eq!(x * F::TWO, x.double());\r\n    assert_eq!(x, x.halve() * F::TWO);\r\n    assert_eq!(x * (-x), -x.square());\r\n    assert_eq!(x + y, y + x);\r\n    assert_eq!(x * F::ZERO, F::ZERO);\r\n    assert_eq!(x * F::ONE, x);\r\n    assert_eq!(x * y, y * x);\r\n    assert_eq!(x * (y * z), (x * y) * z);\r\n    assert_eq!(x - (y + z), (x - y) - z);\r\n    assert_eq!((x + y) - z, x + (y - z));\r\n    assert_eq!(x * (y + z), x * y + x * z);\r\n    assert_eq!(\r\n        x + y + z + x + y + z,\r\n        [x, x, y, y, z, z].iter().cloned().sum()\r\n    );\r\n}\r\n\r\npub fn test_inv_div\u003cF: Field\u003e()\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let mut rng = rand::thread_rng();\r\n    let x = rng.gen::\u003cF\u003e();\r\n    let y = rng.gen::\u003cF\u003e();\r\n    let z = rng.gen::\u003cF\u003e();\r\n    assert_eq!(x * x.inverse(), F::ONE);\r\n    assert_eq!(x.inverse() * x, F::ONE);\r\n    assert_eq!(x.square().inverse(), x.inverse().square());\r\n    assert_eq!((x / y) * y, x);\r\n    assert_eq!(x / (y * z), (x / y) / z);\r\n    assert_eq!((x * y) / z, x * (y / z));\r\n}\r\n\r\npub fn test_inverse\u003cF: Field\u003e()\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    assert_eq!(None, F::ZERO.try_inverse());\r\n\r\n    assert_eq!(Some(F::ONE), F::ONE.try_inverse());\r\n\r\n    let mut rng = rand::thread_rng();\r\n    for _ in 0..1000 {\r\n        let x = rng.gen::\u003cF\u003e();\r\n        if !x.is_zero() \u0026\u0026 !x.is_one() {\r\n            let z = x.inverse();\r\n            assert_ne!(x, z);\r\n            assert_eq!(x * z, F::ONE);\r\n        }\r\n    }\r\n}\r\n\r\npub fn test_multiplicative_group_factors\u003cF: Field\u003e() {\r\n    let product: BigUint = F::multiplicative_group_factors()\r\n        .into_iter()\r\n        .map(|(factor, exponent)| factor.pow(exponent as u32))\r\n        .product();\r\n    assert_eq!(product + BigUint::one(), F::order());\r\n}\r\n\r\npub fn test_two_adic_subgroup_zerofier\u003cF: TwoAdicField\u003e() {\r\n    for log_n in 0..5 {\r\n        let g = F::two_adic_generator(log_n);\r\n        for x in cyclic_subgroup_known_order(g, 1 \u003c\u003c log_n) {\r\n            let zerofier_eval = two_adic_subgroup_zerofier(log_n, x);\r\n            assert_eq!(zerofier_eval, F::ZERO);\r\n        }\r\n    }\r\n}\r\n\r\npub fn test_two_adic_coset_zerofier\u003cF: TwoAdicField\u003e() {\r\n    for log_n in 0..5 {\r\n        let g = F::two_adic_generator(log_n);\r\n        let shift = F::GENERATOR;\r\n        for x in cyclic_subgroup_coset_known_order(g, shift, 1 \u003c\u003c log_n) {\r\n            let zerofier_eval = two_adic_coset_zerofier(log_n, shift, x);\r\n            assert_eq!(zerofier_eval, F::ZERO);\r\n        }\r\n    }\r\n}\r\n\r\npub fn test_two_adic_generator_consistency\u003cF: TwoAdicField\u003e() {\r\n    let log_n = F::TWO_ADICITY;\r\n    let g = F::two_adic_generator(log_n);\r\n    for bits in 0..=log_n {\r\n        assert_eq!(g.exp_power_of_2(bits), F::two_adic_generator(log_n - bits));\r\n    }\r\n}\r\n\r\npub fn test_ef_two_adic_generator_consistency\u003c\r\n    F: TwoAdicField,\r\n    EF: TwoAdicField + ExtensionField\u003cF\u003e,\r\n\u003e() {\r\n    assert_eq!(\r\n        Into::\u003cEF\u003e::into(F::two_adic_generator(F::TWO_ADICITY)),\r\n        EF::two_adic_generator(F::TWO_ADICITY)\r\n    );\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_field {\r\n    ($field:ty) =\u003e {\r\n        mod field_tests {\r\n            #[test]\r\n            fn test_add_neg_sub_mul() {\r\n                $crate::test_add_neg_sub_mul::\u003c$field\u003e();\r\n            }\r\n            #[test]\r\n            fn test_inv_div() {\r\n                $crate::test_inv_div::\u003c$field\u003e();\r\n            }\r\n            #[test]\r\n            fn test_inverse() {\r\n                $crate::test_inverse::\u003c$field\u003e();\r\n            }\r\n            #[test]\r\n            fn test_multiplicative_group_factors() {\r\n                $crate::test_multiplicative_group_factors::\u003c$field\u003e();\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_prime_field {\r\n    ($field:ty) =\u003e {\r\n        mod from_integer_small_tests {\r\n            use p3_field::integers::QuotientMap;\r\n            use p3_field::{Field, PrimeCharacteristicRing};\r\n\r\n            #[test]\r\n            fn test_small_integer_conversions() {\r\n                $crate::generate_from_small_int_tests!(\r\n                    $field,\r\n                    [u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize]\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_small_signed_integer_conversions() {\r\n                $crate::generate_from_small_neg_int_tests!(\r\n                    $field,\r\n                    [i8, i16, i32, i64, i128, isize]\r\n                );\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_prime_field_64 {\r\n    ($field:ty) =\u003e {\r\n        mod from_integer_tests_prime_field_64 {\r\n            use p3_field::integers::QuotientMap;\r\n            use p3_field::{Field, PrimeCharacteristicRing, PrimeField64};\r\n            use rand::Rng;\r\n\r\n            #[test]\r\n            fn test_as_canonical_u64() {\r\n                let mut rng = rand::thread_rng();\r\n                let x: u64 = rng.gen();\r\n                let x_mod_order = x % \u003c$field\u003e::ORDER_U64;\r\n\r\n                assert_eq!(\u003c$field\u003e::ZERO.as_canonical_u64(), 0);\r\n                assert_eq!(\u003c$field\u003e::ONE.as_canonical_u64(), 1);\r\n                assert_eq!(\u003c$field\u003e::TWO.as_canonical_u64(), 2 % \u003c$field\u003e::ORDER_U64);\r\n                assert_eq!(\r\n                    \u003c$field\u003e::NEG_ONE.as_canonical_u64(),\r\n                    \u003c$field\u003e::ORDER_U64 - 1\r\n                );\r\n\r\n                assert_eq!(\r\n                    \u003c$field\u003e::from_int(\u003c$field\u003e::ORDER_U64).as_canonical_u64(),\r\n                    0\r\n                );\r\n                assert_eq!(\u003c$field\u003e::from_int(x).as_canonical_u64(), x_mod_order);\r\n                assert_eq!(\r\n                    unsafe { \u003c$field\u003e::from_canonical_unchecked(x_mod_order).as_canonical_u64() },\r\n                    x_mod_order\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_as_unique_u64() {\r\n                assert_ne!(\r\n                    \u003c$field\u003e::ZERO.to_unique_u64(),\r\n                    \u003c$field\u003e::ONE.to_unique_u64()\r\n                );\r\n                assert_ne!(\r\n                    \u003c$field\u003e::ZERO.to_unique_u64(),\r\n                    \u003c$field\u003e::NEG_ONE.to_unique_u64()\r\n                );\r\n                assert_eq!(\r\n                    \u003c$field\u003e::from_int(\u003c$field\u003e::ORDER_U64).to_unique_u64(),\r\n                    \u003c$field\u003e::ZERO.to_unique_u64()\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_large_unsigned_integer_conversions() {\r\n                $crate::generate_from_large_u_int_tests!($field, \u003c$field\u003e::ORDER_U64, [u64, u128]);\r\n            }\r\n\r\n            #[test]\r\n            fn test_large_signed_integer_conversions() {\r\n                $crate::generate_from_large_i_int_tests!($field, \u003c$field\u003e::ORDER_U64, [i64, i128]);\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_prime_field_32 {\r\n    ($field:ty) =\u003e {\r\n        mod from_integer_tests_prime_field_32 {\r\n            use p3_field::integers::QuotientMap;\r\n            use p3_field::{Field, PrimeCharacteristicRing, PrimeField32};\r\n            use rand::Rng;\r\n\r\n            #[test]\r\n            fn test_as_canonical_u32() {\r\n                let mut rng = rand::thread_rng();\r\n                let x: u32 = rng.gen();\r\n                let x_mod_order = x % \u003c$field\u003e::ORDER_U32;\r\n\r\n                assert_eq!(\u003c$field\u003e::ZERO.as_canonical_u32(), 0);\r\n                assert_eq!(\u003c$field\u003e::ONE.as_canonical_u32(), 1);\r\n                assert_eq!(\u003c$field\u003e::TWO.as_canonical_u32(), 2 % \u003c$field\u003e::ORDER_U32);\r\n                assert_eq!(\r\n                    \u003c$field\u003e::NEG_ONE.as_canonical_u32(),\r\n                    \u003c$field\u003e::ORDER_U32 - 1\r\n                );\r\n                assert_eq!(\r\n                    \u003c$field\u003e::from_int(\u003c$field\u003e::ORDER_U32).as_canonical_u32(),\r\n                    0\r\n                );\r\n                assert_eq!(\u003c$field\u003e::from_int(x).as_canonical_u32(), x_mod_order);\r\n                assert_eq!(\r\n                    unsafe { \u003c$field\u003e::from_canonical_unchecked(x_mod_order).as_canonical_u32() },\r\n                    x_mod_order\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_as_unique_u32() {\r\n                assert_ne!(\r\n                    \u003c$field\u003e::ZERO.to_unique_u32(),\r\n                    \u003c$field\u003e::ONE.to_unique_u32()\r\n                );\r\n                assert_ne!(\r\n                    \u003c$field\u003e::ZERO.to_unique_u32(),\r\n                    \u003c$field\u003e::NEG_ONE.to_unique_u32()\r\n                );\r\n                assert_eq!(\r\n                    \u003c$field\u003e::from_int(\u003c$field\u003e::ORDER_U32).to_unique_u32(),\r\n                    \u003c$field\u003e::ZERO.to_unique_u32()\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_large_unsigned_integer_conversions() {\r\n                $crate::generate_from_large_u_int_tests!(\r\n                    $field,\r\n                    \u003c$field\u003e::ORDER_U32,\r\n                    [u32, u64, u128]\r\n                );\r\n            }\r\n\r\n            #[test]\r\n            fn test_large_signed_integer_conversions() {\r\n                $crate::generate_from_large_i_int_tests!(\r\n                    $field,\r\n                    \u003c$field\u003e::ORDER_U32,\r\n                    [i32, i64, i128]\r\n                );\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_two_adic_field {\r\n    ($field:ty) =\u003e {\r\n        mod two_adic_field_tests {\r\n            #[test]\r\n            fn test_two_adic_field_subgroup_zerofier() {\r\n                $crate::test_two_adic_subgroup_zerofier::\u003c$field\u003e();\r\n            }\r\n            #[test]\r\n            fn test_two_adic_coset_zerofier() {\r\n                $crate::test_two_adic_coset_zerofier::\u003c$field\u003e();\r\n            }\r\n            #[test]\r\n            fn test_two_adic_consisitency() {\r\n                $crate::test_two_adic_generator_consistency::\u003c$field\u003e();\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_two_adic_extension_field {\r\n    ($field:ty, $ef:ty) =\u003e {\r\n        use $crate::test_two_adic_field;\r\n\r\n        test_two_adic_field!($ef);\r\n\r\n        mod two_adic_extension_field_tests {\r\n\r\n            #[test]\r\n            fn test_ef_two_adic_generator_consistency() {\r\n                $crate::test_ef_two_adic_generator_consistency::\u003c$field, $ef\u003e();\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n    use alloc::vec::Vec;\r\n\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_field::extension::{BinomialExtensionField, HasFrobenius};\r\n    use p3_field::{binomial_expand, eval_poly, PrimeCharacteristicRing};\r\n    use rand::random;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_minimal_poly() {\r\n        type F = BabyBear;\r\n        type EF = BinomialExtensionField\u003cF, 4\u003e;\r\n        for _ in 0..1024 {\r\n            let x: EF = random();\r\n            let m: Vec\u003cEF\u003e = x.minimal_poly().into_iter().map(Into::\u003cEF\u003e::into).collect();\r\n            assert!(eval_poly(\u0026m, x).is_zero());\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_binomial_expand() {\r\n        type F = BabyBear;\r\n        // (x - 1)(x - 2) = x^2 - 3x + 2\r\n        assert_eq!(\r\n            binomial_expand(\u0026[F::ONE, F::TWO]),\r\n            vec![F::TWO, -F::from_u8(3), F::ONE]\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":29,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":30,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":31,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":32,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":33,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":34,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":35,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":36,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":38,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":40,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":41,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":42,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":43,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":44,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":45,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":46,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":47,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":48,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":49,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":50,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":51,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":55,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":59,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":60,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":61,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":62,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":63,"address":[],"length":0,"stats":{"Line":864691128455135410}},{"line":64,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":65,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":66,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":68,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":71,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":75,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":77,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":80,"address":[],"length":0,"stats":{"Line":16789419410837209084}},{"line":81,"address":[],"length":0,"stats":{"Line":16717361816799281145}},{"line":82,"address":[],"length":0,"stats":{"Line":14987979559889010674}},{"line":83,"address":[],"length":0,"stats":{"Line":16717361816799281145}},{"line":84,"address":[],"length":0,"stats":{"Line":16717361816799281145}},{"line":85,"address":[],"length":0,"stats":{"Line":16717361816799281145}},{"line":90,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":91,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":93,"address":[],"length":0,"stats":{"Line":8214565720323784704}},{"line":95,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":98,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":99,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":102,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":103,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":108,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":109,"address":[],"length":0,"stats":{"Line":7926335344172072960}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":113,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":114,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":119,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":120,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":121,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":122,"address":[],"length":0,"stats":{"Line":4251398048237748224}},{"line":123,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":127,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":131,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":132,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":133,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":142,"address":[],"length":0,"stats":{"Line":864691128455135233}},{"line":143,"address":[],"length":0,"stats":{"Line":864691128455135233}},{"line":146,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":147,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":150,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":151,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":154,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":155,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":169,"address":[],"length":0,"stats":{"Line":360287970189639683}},{"line":170,"address":[],"length":0,"stats":{"Line":360287970189639683}},{"line":171,"address":[],"length":0,"stats":{"Line":360287970189639683}},{"line":172,"address":[],"length":0,"stats":{"Line":360287970189639683}},{"line":177,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":178,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":179,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":180,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":196,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":197,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":198,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":199,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":201,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":202,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":203,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":204,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":205,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":206,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":209,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":210,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":211,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":213,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":214,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":215,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":216,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":221,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":222,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":223,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":224,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":226,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":227,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":228,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":230,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":231,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":232,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":237,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":238,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":242,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":243,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":258,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":259,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":260,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":261,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":263,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":264,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":266,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":267,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":268,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":270,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":271,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":272,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":274,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":275,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":276,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":277,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":282,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":283,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":284,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":285,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":287,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":288,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":289,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":291,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":292,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":293,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":298,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":299,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":300,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":301,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":302,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":307,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":308,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":309,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":310,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":311,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":323,"address":[],"length":0,"stats":{"Line":720575940379279375}},{"line":324,"address":[],"length":0,"stats":{"Line":720575940379279375}},{"line":327,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":328,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":331,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":332,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":348,"address":[],"length":0,"stats":{"Line":432345564227567842}},{"line":349,"address":[],"length":0,"stats":{"Line":432345564227567842}}],"covered":160,"coverable":163},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","field-testing","src","packedfield_testing.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{Field, PackedField, PackedFieldPow2, PackedValue, PrimeCharacteristicRing};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{Rng, SeedableRng};\r\nuse rand_chacha::ChaCha20Rng;\r\n\r\nfn packed_from_random\u003cPV\u003e(seed: u64) -\u003e PV\r\nwhere\r\n    PV: PackedValue,\r\n    Standard: Distribution\u003cPV::Value\u003e,\r\n{\r\n    let mut rng = ChaCha20Rng::seed_from_u64(seed);\r\n    PV::from_fn(|_| rng.gen())\r\n}\r\n\r\n/// Interleave arr1 and arr2 using chunks of size i.\r\nfn interleave\u003cT: Copy + Default\u003e(arr1: \u0026[T], arr2: \u0026[T], i: usize) -\u003e (Vec\u003cT\u003e, Vec\u003cT\u003e) {\r\n    let width = arr1.len();\r\n    assert_eq!(width, arr2.len());\r\n    assert_eq!(width % i, 0);\r\n\r\n    if i == width {\r\n        return (arr1.to_vec(), arr2.to_vec());\r\n    }\r\n\r\n    let mut outleft = vec![T::default(); width];\r\n    let mut outright = vec![T::default(); width];\r\n\r\n    let mut flag = false;\r\n\r\n    for j in 0..width {\r\n        if j % i == 0 {\r\n            flag = !flag;\r\n        }\r\n        if flag {\r\n            outleft[j] = arr1[j];\r\n            outleft[j + i] = arr2[j];\r\n        } else {\r\n            outright[j - i] = arr1[j];\r\n            outright[j] = arr2[j];\r\n        }\r\n    }\r\n\r\n    (outleft, outright)\r\n}\r\n\r\nfn test_interleave\u003cPF\u003e(i: usize)\r\nwhere\r\n    PF: PackedFieldPow2 + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    assert!(PF::WIDTH % i == 0);\r\n\r\n    let vec1 = packed_from_random::\u003cPF\u003e(0x4ff5dec04791e481);\r\n    let vec2 = packed_from_random::\u003cPF\u003e(0x5806c495e9451f8e);\r\n\r\n    let arr1 = vec1.as_slice();\r\n    let arr2 = vec2.as_slice();\r\n\r\n    let (res1, res2) = vec1.interleave(vec2, i);\r\n    let (out1, out2) = interleave(arr1, arr2, i);\r\n\r\n    assert_eq!(\r\n        res1.as_slice(),\r\n        \u0026out1,\r\n        \"Error in left output when testing interleave {}.\",\r\n        i\r\n    );\r\n    assert_eq!(\r\n        res2.as_slice(),\r\n        \u0026out2,\r\n        \"Error in right output when testing interleave {}.\",\r\n        i\r\n    );\r\n}\r\n\r\npub fn test_interleaves\u003cPF\u003e()\r\nwhere\r\n    PF: PackedFieldPow2 + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let mut i = 1;\r\n    while i \u003c= PF::WIDTH {\r\n        test_interleave::\u003cPF\u003e(i);\r\n        i *= 2;\r\n    }\r\n}\r\n\r\n#[allow(clippy::eq_op)]\r\npub fn test_add_neg\u003cPF\u003e(zeros: PF)\r\nwhere\r\n    PF: PackedField + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let vec0 = packed_from_random::\u003cPF\u003e(0x8b078c2b693c893f);\r\n    let vec1 = packed_from_random::\u003cPF\u003e(0x4ff5dec04791e481);\r\n    let vec2 = packed_from_random::\u003cPF\u003e(0x5806c495e9451f8e);\r\n\r\n    assert_eq!(\r\n        (vec0 + vec1) + vec2,\r\n        vec0 + (vec1 + vec2),\r\n        \"Error when testing associativity of add.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 + vec1,\r\n        vec1 + vec0,\r\n        \"Error when testing commutativity of add.\"\r\n    );\r\n    assert_eq!(\r\n        vec0,\r\n        vec0 + zeros,\r\n        \"Error when testing additive identity right.\"\r\n    );\r\n    assert_eq!(\r\n        vec0,\r\n        zeros + vec0,\r\n        \"Error when testing additive identity left.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 + (-vec0),\r\n        PF::ZERO,\r\n        \"Error when testing additive inverse.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 - vec0,\r\n        PF::ZERO,\r\n        \"Error when testing subtracting of self.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 - vec1,\r\n        -(vec1 - vec0),\r\n        \"Error when testing anticommutativity of sub.\"\r\n    );\r\n    assert_eq!(vec0, vec0 - zeros, \"Error when testing subtracting zero.\");\r\n    assert_eq!(\r\n        -vec0,\r\n        zeros - vec0,\r\n        \"Error when testing subtracting from zero\"\r\n    );\r\n    assert_eq!(vec0, -(-vec0), \"Error when testing double negation\");\r\n    assert_eq!(\r\n        vec0 - vec1,\r\n        vec0 + (-vec1),\r\n        \"Error when testing addition of negation\"\r\n    );\r\n    assert_eq!(PF::ONE + PF::ONE, PF::TWO, \"Error 1 + 1 =/= 2\");\r\n    assert_eq!(PF::NEG_ONE + PF::TWO, PF::ONE, \"Error -1 + 2 =/= 1\");\r\n    assert_eq!(\r\n        vec0.double(),\r\n        vec0 + vec0,\r\n        \"Error when comparing x.double() to x + x\"\r\n    );\r\n}\r\n\r\npub fn test_mul\u003cPF\u003e(zeros: PF)\r\nwhere\r\n    PF: PackedField + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let vec0 = packed_from_random::\u003cPF\u003e(0x0b1ee4d7c979d50c);\r\n    let vec1 = packed_from_random::\u003cPF\u003e(0x39faa0844a36e45a);\r\n    let vec2 = packed_from_random::\u003cPF\u003e(0x08fac4ee76260e44);\r\n\r\n    assert_eq!(\r\n        (vec0 * vec1) * vec2,\r\n        vec0 * (vec1 * vec2),\r\n        \"Error when testing associativity of mul.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 * vec1,\r\n        vec1 * vec0,\r\n        \"Error when testing commutativity of mul.\"\r\n    );\r\n    assert_eq!(\r\n        vec0,\r\n        vec0 * PF::ONE,\r\n        \"Error when testing multiplicative identity right.\"\r\n    );\r\n    assert_eq!(\r\n        vec0,\r\n        PF::ONE * vec0,\r\n        \"Error when testing multiplicative identity left.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 * zeros,\r\n        PF::ZERO,\r\n        \"Error when testing right multiplication by 0.\"\r\n    );\r\n    assert_eq!(\r\n        zeros * vec0,\r\n        PF::ZERO,\r\n        \"Error when testing left multiplication by 0.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 * PF::NEG_ONE,\r\n        -(vec0),\r\n        \"Error when testing right multiplication by -1.\"\r\n    );\r\n    assert_eq!(\r\n        PF::NEG_ONE * vec0,\r\n        -(vec0),\r\n        \"Error when testing left multiplication by -1.\"\r\n    );\r\n    assert_eq!(\r\n        vec0.double(),\r\n        PF::TWO * vec0,\r\n        \"Error when comparing x.double() to 2 * x.\"\r\n    );\r\n    assert_eq!(\r\n        vec0.exp_const_u64::\u003c3\u003e(),\r\n        vec0 * vec0 * vec0,\r\n        \"Error when comparing x.exp_const_u64::\u003c3\u003e to x*x*x.\"\r\n    );\r\n    assert_eq!(\r\n        vec0.exp_const_u64::\u003c5\u003e(),\r\n        vec0 * vec0 * vec0 * vec0 * vec0,\r\n        \"Error when comparing x.exp_const_u64::\u003c5\u003e to x*x*x*x*x.\"\r\n    );\r\n    assert_eq!(\r\n        vec0.exp_const_u64::\u003c7\u003e(),\r\n        vec0 * vec0 * vec0 * vec0 * vec0 * vec0 * vec0,\r\n        \"Error when comparing x.exp_const_u64::\u003c7\u003e to x*x*x*x*x*x*x.\"\r\n    );\r\n}\r\n\r\npub fn test_distributivity\u003cPF\u003e()\r\nwhere\r\n    PF: PackedField + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let vec0 = packed_from_random::\u003cPF\u003e(0x278d9e202925a1d1);\r\n    let vec1 = packed_from_random::\u003cPF\u003e(0xf04cbac0cbad419f);\r\n    let vec2 = packed_from_random::\u003cPF\u003e(0x76976e2abdc5a056);\r\n\r\n    assert_eq!(\r\n        vec0 * (-vec1),\r\n        -(vec0 * vec1),\r\n        \"Error when testing distributivity of mul and right neg.\"\r\n    );\r\n    assert_eq!(\r\n        (-vec0) * vec1,\r\n        -(vec0 * vec1),\r\n        \"Error when testing distributivity of mul and left neg.\"\r\n    );\r\n\r\n    assert_eq!(\r\n        vec0 * (vec1 + vec2),\r\n        vec0 * vec1 + vec0 * vec2,\r\n        \"Error when testing distributivity of add and left mul.\"\r\n    );\r\n    assert_eq!(\r\n        (vec0 + vec1) * vec2,\r\n        vec0 * vec2 + vec1 * vec2,\r\n        \"Error when testing distributivity of add and right mul.\"\r\n    );\r\n    assert_eq!(\r\n        vec0 * (vec1 - vec2),\r\n        vec0 * vec1 - vec0 * vec2,\r\n        \"Error when testing distributivity of sub and left mul.\"\r\n    );\r\n    assert_eq!(\r\n        (vec0 - vec1) * vec2,\r\n        vec0 * vec2 - vec1 * vec2,\r\n        \"Error when testing distributivity of sub and right mul.\"\r\n    );\r\n}\r\n\r\npub fn test_vs_scalar\u003cPF\u003e(special_vals: PF)\r\nwhere\r\n    PF: PackedField + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let vec0: PF = packed_from_random(0x278d9e202925a1d1);\r\n    let vec1: PF = packed_from_random(0xf04cbac0cbad419f);\r\n    let vec_special = special_vals;\r\n\r\n    let arr0 = vec0.as_slice();\r\n    let arr1 = vec1.as_slice();\r\n\r\n    let vec_sum = vec0 + vec1;\r\n    let arr_sum = vec_sum.as_slice();\r\n    let vec_special_sum_left = vec_special + vec0;\r\n    let arr_special_sum_left = vec_special_sum_left.as_slice();\r\n    let vec_special_sum_right = vec1 + vec_special;\r\n    let arr_special_sum_right = vec_special_sum_right.as_slice();\r\n\r\n    let vec_sub = vec0 - vec1;\r\n    let arr_sub = vec_sub.as_slice();\r\n    let vec_special_sub_left = vec_special - vec0;\r\n    let arr_special_sub_left = vec_special_sub_left.as_slice();\r\n    let vec_special_sub_right = vec1 - vec_special;\r\n    let arr_special_sub_right = vec_special_sub_right.as_slice();\r\n\r\n    let vec_mul = vec0 * vec1;\r\n    let arr_mul = vec_mul.as_slice();\r\n    let vec_special_mul_left = vec_special * vec0;\r\n    let arr_special_mul_left = vec_special_mul_left.as_slice();\r\n    let vec_special_mul_right = vec1 * vec_special;\r\n    let arr_special_mul_right = vec_special_mul_right.as_slice();\r\n\r\n    let vec_neg = -vec0;\r\n    let arr_neg = vec_neg.as_slice();\r\n    let vec_special_neg = -vec_special;\r\n    let arr_special_neg = vec_special_neg.as_slice();\r\n\r\n    let vec_exp_3 = vec0.exp_const_u64::\u003c3\u003e();\r\n    let arr_exp_3 = vec_exp_3.as_slice();\r\n    let vec_special_exp_3 = vec_special.exp_const_u64::\u003c3\u003e();\r\n    let arr_special_exp_3 = vec_special_exp_3.as_slice();\r\n\r\n    let vec_exp_5 = vec0.exp_const_u64::\u003c5\u003e();\r\n    let arr_exp_5 = vec_exp_5.as_slice();\r\n    let vec_special_exp_5 = vec_special.exp_const_u64::\u003c5\u003e();\r\n    let arr_special_exp_5 = vec_special_exp_5.as_slice();\r\n\r\n    let vec_exp_7 = vec0.exp_const_u64::\u003c7\u003e();\r\n    let arr_exp_7 = vec_exp_7.as_slice();\r\n    let vec_special_exp_7 = vec_special.exp_const_u64::\u003c7\u003e();\r\n    let arr_special_exp_7 = vec_special_exp_7.as_slice();\r\n\r\n    let special_vals = special_vals.as_slice();\r\n    for i in 0..PF::WIDTH {\r\n        assert_eq!(\r\n            arr_sum[i],\r\n            arr0[i] + arr1[i],\r\n            \"Error when testing add consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(\r\n            arr_special_sum_left[i],\r\n            special_vals[i] + arr0[i],\r\n            \"Error when testing consistency of left add for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(\r\n            arr_special_sum_right[i],\r\n            arr1[i] + special_vals[i],\r\n            \"Error when testing consistency of right add for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n\r\n        assert_eq!(\r\n            arr_sub[i],\r\n            arr0[i] - arr1[i],\r\n            \"Error when testing sub consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_sub_left[i],\r\n            special_vals[i] - arr0[i],\r\n            \"Error when testing consistency of left sub for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_sub_right[i],\r\n            arr1[i] - special_vals[i],\r\n            \"Error when testing consistency of right sub for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n\r\n        assert_eq!(\r\n            arr_mul[i],\r\n            arr0[i] * arr1[i],\r\n            \"Error when testing mul consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_mul_left[i],\r\n            special_vals[i] * arr0[i],\r\n            \"Error when testing consistency of left mul for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_mul_right[i],\r\n            arr1[i] * special_vals[i],\r\n            \"Error when testing consistency of right mul for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n\r\n        assert_eq!(\r\n            arr_neg[i], -arr0[i],\r\n            \"Error when testing neg consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_neg[i],\r\n            -special_vals[i],\r\n            \"Error when testing consistency of neg for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_exp_3[i],\r\n            arr0[i].exp_const_u64::\u003c3\u003e(),\r\n            \"Error when testing exp_const_u64::\u003c3\u003e consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_exp_3[i],\r\n            special_vals[i].exp_const_u64::\u003c3\u003e(),\r\n            \"Error when testing consistency of exp_const_u64::\u003c3\u003e for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_exp_5[i],\r\n            arr0[i].exp_const_u64::\u003c5\u003e(),\r\n            \"Error when testing exp_const_u64::\u003c5\u003e consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_exp_5[i],\r\n            special_vals[i].exp_const_u64::\u003c5\u003e(),\r\n            \"Error when testing consistency of exp_const_u64::\u003c5\u003e for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_exp_7[i],\r\n            arr0[i].exp_const_u64::\u003c7\u003e(),\r\n            \"Error when testing exp_const_u64::\u003c7\u003e consistency of packed and scalar at location {}.\",\r\n            i\r\n        );\r\n        assert_eq!(arr_special_exp_7[i],\r\n            special_vals[i].exp_const_u64::\u003c7\u003e(),\r\n            \"Error when testing consistency of exp_const_u64::\u003c7\u003e for special values for packed and scalar at location {}.\",\r\n            i\r\n        );\r\n    }\r\n}\r\n\r\npub fn test_multiplicative_inverse\u003cPF\u003e()\r\nwhere\r\n    PF: PackedField + Eq,\r\n    Standard: Distribution\u003cPF::Scalar\u003e,\r\n{\r\n    let vec: PF = packed_from_random(0xb0c7a5153103c5a8);\r\n    let arr = vec.as_slice();\r\n    let vec_inv = PF::from_fn(|i| arr[i].inverse());\r\n    let res = vec * vec_inv;\r\n    assert_eq!(\r\n        res,\r\n        PF::ONE,\r\n        \"Error when testing multiplication by inverse.\"\r\n    );\r\n}\r\n\r\n#[macro_export]\r\nmacro_rules! test_packed_field {\r\n    ($packedfield:ty, $zeros:expr, $specials:expr) =\u003e {\r\n        mod packed_field_tests {\r\n            use p3_field::PrimeCharacteristicRing;\r\n\r\n            #[test]\r\n            fn test_interleaves() {\r\n                $crate::test_interleaves::\u003c$packedfield\u003e();\r\n            }\r\n            #[test]\r\n            fn test_add_neg() {\r\n                $crate::test_add_neg::\u003c$packedfield\u003e($zeros);\r\n            }\r\n            #[test]\r\n            fn test_mul() {\r\n                $crate::test_mul::\u003c$packedfield\u003e($zeros);\r\n            }\r\n            #[test]\r\n            fn test_distributivity() {\r\n                $crate::test_distributivity::\u003c$packedfield\u003e();\r\n            }\r\n            #[test]\r\n            fn test_vs_scalar() {\r\n                $crate::test_vs_scalar::\u003c$packedfield\u003e($specials);\r\n            }\r\n            #[test]\r\n            fn test_multiplicative_inverse() {\r\n                $crate::test_multiplicative_inverse::\u003c$packedfield\u003e();\r\n            }\r\n        }\r\n    };\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":14,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":15,"address":[],"length":0,"stats":{"Line":14123288431433875456}},{"line":19,"address":[],"length":0,"stats":{"Line":1080863910568919041}},{"line":20,"address":[],"length":0,"stats":{"Line":1080863910568919041}},{"line":21,"address":[],"length":0,"stats":{"Line":1080863910568919041}},{"line":22,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":24,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":28,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":29,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":31,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":33,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":34,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":35,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":37,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":38,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":39,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":41,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":42,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":46,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":49,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":54,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":56,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":57,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":59,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":60,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":62,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":63,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":65,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":66,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":67,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":72,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":73,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":86,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":87,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":92,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":98,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":99,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":112,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":123,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":127,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":128,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":132,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":133,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":138,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":139,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":143,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":144,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":149,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":151,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":152,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":162,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":163,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":164,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":166,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":167,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":168,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":172,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":173,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":177,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":178,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":182,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":183,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":187,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":188,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":192,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":193,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":197,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":198,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":202,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":203,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":207,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":208,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":212,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":213,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":217,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":218,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":222,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":223,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":233,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":234,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":235,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":237,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":238,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":239,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":243,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":244,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":249,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":250,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":254,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":255,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":259,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":260,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":264,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":265,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":275,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":276,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":277,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":279,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":280,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":282,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":283,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":284,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":285,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":286,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":287,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":289,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":290,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":291,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":292,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":293,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":294,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":296,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":297,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":298,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":299,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":300,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":301,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":303,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":304,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":305,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":306,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":308,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":309,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":310,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":311,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":313,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":314,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":315,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":316,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":318,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":319,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":320,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":321,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":323,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":324,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":332,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":333,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":338,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":339,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":345,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":346,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":351,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":356,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":362,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":363,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":368,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":373,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":379,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":384,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":389,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":394,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":399,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":404,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":409,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":414,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":426,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":427,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":428,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":429,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":430,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":431,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":432,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":445,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":448,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":449,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":452,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":453,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":456,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":457,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":460,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":461,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":464,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":465,"address":[],"length":0,"stats":{"Line":288230376151711744}}],"covered":238,"coverable":308},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","benches","fold_even_odd.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse itertools::Itertools;\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_field::extension::Complex;\r\nuse p3_field::TwoAdicField;\r\nuse p3_fri::fold_even_odd;\r\nuse p3_goldilocks::Goldilocks;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{thread_rng, Rng};\r\n\r\nfn bench\u003cF: TwoAdicField\u003e(c: \u0026mut Criterion, log_sizes: \u0026[usize])\r\nwhere\r\n    Standard: Distribution\u003cF\u003e,\r\n{\r\n    let name = format!(\"fold_even_odd::\u003c{}\u003e\", type_name::\u003cF\u003e(),);\r\n    let mut group = c.benchmark_group(\u0026name);\r\n    group.sample_size(10);\r\n\r\n    for log_size in log_sizes {\r\n        let n = 1 \u003c\u003c log_size;\r\n\r\n        let mut rng = thread_rng();\r\n        let beta = rng.sample(Standard);\r\n        let poly = rng.sample_iter(Standard).take(n).collect_vec();\r\n\r\n        group.bench_function(BenchmarkId::from_parameter(n), |b| {\r\n            b.iter(|| {\r\n                fold_even_odd(poly.clone(), beta);\r\n            })\r\n        });\r\n    }\r\n}\r\n\r\nfn bench_fold_even_odd(c: \u0026mut Criterion) {\r\n    let log_sizes = [12, 14, 16, 18, 20, 22];\r\n\r\n    bench::\u003cBabyBear\u003e(c, \u0026log_sizes);\r\n    bench::\u003cGoldilocks\u003e(c, \u0026log_sizes);\r\n    bench::\u003cComplex\u003cMersenne31\u003e\u003e(c, \u0026log_sizes);\r\n}\r\n\r\ncriterion_group!(benches, bench_fold_even_odd);\r\ncriterion_main!(benches);\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","config.rs"],"content":"use alloc::vec::Vec;\r\nuse core::fmt::Debug;\r\n\r\nuse p3_field::Field;\r\nuse p3_matrix::Matrix;\r\n\r\n#[derive(Debug)]\r\npub struct FriConfig\u003cM\u003e {\r\n    pub log_blowup: usize,\r\n    // TODO: This parameter and FRI early stopping are not yet implemented in `CirclePcs`.\r\n    pub log_final_poly_len: usize,\r\n    pub num_queries: usize,\r\n    pub proof_of_work_bits: usize,\r\n    pub mmcs: M,\r\n}\r\n\r\nimpl\u003cM\u003e FriConfig\u003cM\u003e {\r\n    pub const fn blowup(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_blowup\r\n    }\r\n\r\n    pub const fn final_poly_len(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_final_poly_len\r\n    }\r\n\r\n    /// Returns the soundness bits of this FRI instance based on the\r\n    /// [ethSTARK](https://eprint.iacr.org/2021/582) conjecture.\r\n    ///\r\n    /// Certain users may instead want to look at proven soundness, a more complex calculation which\r\n    /// isn't currently supported by this crate.\r\n    pub fn conjectured_soundness_bits(\u0026self) -\u003e usize {\r\n        self.log_blowup * self.num_queries + self.proof_of_work_bits\r\n    }\r\n}\r\n\r\n/// Whereas `FriConfig` encompasses parameters the end user can set, `FriGenericConfig` is\r\n/// set by the PCS calling FRI, and abstracts over implementation details of the PCS.\r\npub trait FriGenericConfig\u003cF: Field\u003e {\r\n    type InputProof;\r\n    type InputError: Debug;\r\n\r\n    /// We can ask FRI to sample extra query bits (LSB) for our own purposes.\r\n    /// They will be passed to our callbacks, but ignored (shifted off) by FRI.\r\n    fn extra_query_index_bits(\u0026self) -\u003e usize;\r\n\r\n    /// Fold a row, returning a single column.\r\n    /// Right now the input row will always be 2 columns wide,\r\n    /// but we may support higher folding arity in the future.\r\n    fn fold_row(\r\n        \u0026self,\r\n        index: usize,\r\n        log_height: usize,\r\n        beta: F,\r\n        evals: impl Iterator\u003cItem = F\u003e,\r\n    ) -\u003e F;\r\n\r\n    /// Same as applying fold_row to every row, possibly faster.\r\n    fn fold_matrix\u003cM: Matrix\u003cF\u003e\u003e(\u0026self, beta: F, m: M) -\u003e Vec\u003cF\u003e;\r\n}\r\n\r\n/// Creates a minimal `FriConfig` for testing purposes.\r\n/// This configuration is designed to reduce computational cost during tests.\r\npub fn create_test_fri_config\u003cMmcs\u003e(mmcs: Mmcs) -\u003e FriConfig\u003cMmcs\u003e {\r\n    FriConfig {\r\n        log_blowup: 1,\r\n        log_final_poly_len: 0,\r\n        num_queries: 2,\r\n        proof_of_work_bits: 1,\r\n        mmcs,\r\n    }\r\n}\r\n\r\n/// Creates a `FriConfig` suitable for benchmarking.\r\n/// This configuration represents typical settings used in production-like scenarios.\r\npub fn create_benchmark_fri_config\u003cMmcs\u003e(mmcs: Mmcs) -\u003e FriConfig\u003cMmcs\u003e {\r\n    FriConfig {\r\n        log_blowup: 1,\r\n        log_final_poly_len: 0,\r\n        num_queries: 100,\r\n        proof_of_work_bits: 16,\r\n        mmcs,\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":12393906174523604997}},{"line":19,"address":[],"length":0,"stats":{"Line":12393906174523604997}},{"line":22,"address":[],"length":0,"stats":{"Line":2377900603251621900}},{"line":23,"address":[],"length":0,"stats":{"Line":2377900603251621900}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":75,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":8},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","fold_even_odd.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::TwoAdicField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_strict_usize, reverse_slice_index_bits};\r\nuse tracing::instrument;\r\n\r\n/// Fold a polynomial\r\n/// ```ignore\r\n/// p(x) = p_even(x^2) + x p_odd(x^2)\r\n/// ```\r\n/// into\r\n/// ```ignore\r\n/// p_even(x) + beta p_odd(x)\r\n/// ```\r\n/// Expects input to be bit-reversed evaluations.\r\n#[instrument(skip_all, level = \"debug\")]\r\npub fn fold_even_odd\u003cF: TwoAdicField\u003e(poly: Vec\u003cF\u003e, beta: F) -\u003e Vec\u003cF\u003e {\r\n    // We use the fact that\r\n    //     p_e(x^2) = (p(x) + p(-x)) / 2\r\n    //     p_o(x^2) = (p(x) - p(-x)) / (2 x)\r\n    // that is,\r\n    //     p_e(g^(2i)) = (p(g^i) + p(g^(n/2 + i))) / 2\r\n    //     p_o(g^(2i)) = (p(g^i) - p(g^(n/2 + i))) / (2 g^i)\r\n    // so\r\n    //     result(g^(2i)) = p_e(g^(2i)) + beta p_o(g^(2i))\r\n    //                    = (1/2 + beta/2 g_inv^i) p(g^i)\r\n    //                    + (1/2 - beta/2 g_inv^i) p(g^(n/2 + i))\r\n    let m = RowMajorMatrix::new(poly, 2);\r\n    let g_inv = F::two_adic_generator(log2_strict_usize(m.height()) + 1).inverse();\r\n    let one_half = F::TWO.inverse();\r\n    let half_beta = beta * one_half;\r\n\r\n    // TODO: vectorize this (after we have packed extension fields)\r\n\r\n    // beta/2 times successive powers of g_inv\r\n    let mut powers = g_inv\r\n        .shifted_powers(half_beta)\r\n        .take(m.height())\r\n        .collect_vec();\r\n    reverse_slice_index_bits(\u0026mut powers);\r\n\r\n    m.par_rows()\r\n        .zip(powers)\r\n        .map(|(mut row, power)| {\r\n            let (r0, r1) = row.next_tuple().unwrap();\r\n            (one_half + power) * r0 + (one_half - power) * r1\r\n        })\r\n        .collect()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use itertools::izip;\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_dft::{Radix2Dit, TwoAdicSubgroupDft};\r\n    use rand::{thread_rng, Rng};\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_fold_even_odd() {\r\n        type F = BabyBear;\r\n\r\n        let mut rng = thread_rng();\r\n\r\n        let log_n = 10;\r\n        let n = 1 \u003c\u003c log_n;\r\n        let coeffs = (0..n).map(|_| rng.gen::\u003cF\u003e()).collect::\u003cVec\u003c_\u003e\u003e();\r\n\r\n        let dft = Radix2Dit::default();\r\n        let evals = dft.dft(coeffs.clone());\r\n\r\n        let even_coeffs = coeffs.iter().cloned().step_by(2).collect_vec();\r\n        let even_evals = dft.dft(even_coeffs);\r\n\r\n        let odd_coeffs = coeffs.iter().cloned().skip(1).step_by(2).collect_vec();\r\n        let odd_evals = dft.dft(odd_coeffs);\r\n\r\n        let beta = rng.gen::\u003cF\u003e();\r\n        let expected = izip!(even_evals, odd_evals)\r\n            .map(|(even, odd)| even + beta * odd)\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n\r\n        // fold_even_odd takes and returns in bitrev order.\r\n        let mut folded = evals;\r\n        reverse_slice_index_bits(\u0026mut folded);\r\n        folded = fold_even_odd(folded, beta);\r\n        reverse_slice_index_bits(\u0026mut folded);\r\n\r\n        assert_eq!(expected, folded);\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","hiding_pcs.rs"],"content":"use alloc::vec::Vec;\r\nuse core::cell::RefCell;\r\nuse core::fmt::Debug;\r\n\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::{Mmcs, OpenedValues, Pcs, TwoAdicMultiplicativeCoset};\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::{ExtensionField, Field, TwoAdicField};\r\nuse p3_matrix::bitrev::BitReversalPerm;\r\nuse p3_matrix::dense::{DenseMatrix, RowMajorMatrix};\r\nuse p3_matrix::horizontally_truncated::HorizontallyTruncated;\r\nuse p3_matrix::row_index_mapped::RowIndexMappedView;\r\nuse p3_matrix::Matrix;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse tracing::instrument;\r\n\r\nuse crate::verifier::FriError;\r\nuse crate::{BatchOpening, FriConfig, FriProof, TwoAdicFriPcs};\r\n\r\n/// A hiding FRI PCS. Both MMCSs must also be hiding; this is not enforced at compile time so it's\r\n/// the user's responsibility to configure.\r\n#[derive(Debug)]\r\npub struct HidingFriPcs\u003cVal, Dft, InputMmcs, FriMmcs, R\u003e {\r\n    inner: TwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e,\r\n    num_random_codewords: usize,\r\n    rng: RefCell\u003cR\u003e,\r\n}\r\n\r\nimpl\u003cVal, Dft, InputMmcs, FriMmcs, R\u003e HidingFriPcs\u003cVal, Dft, InputMmcs, FriMmcs, R\u003e {\r\n    pub fn new(\r\n        dft: Dft,\r\n        mmcs: InputMmcs,\r\n        fri: FriConfig\u003cFriMmcs\u003e,\r\n        num_random_codewords: usize,\r\n        rng: R,\r\n    ) -\u003e Self {\r\n        let inner = TwoAdicFriPcs::new(dft, mmcs, fri);\r\n        Self {\r\n            inner,\r\n            num_random_codewords,\r\n            rng: rng.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cVal, Dft, InputMmcs, FriMmcs, Challenge, Challenger, R\u003e Pcs\u003cChallenge, Challenger\u003e\r\n    for HidingFriPcs\u003cVal, Dft, InputMmcs, FriMmcs, R\u003e\r\nwhere\r\n    Val: TwoAdicField,\r\n    Standard: Distribution\u003cVal\u003e,\r\n    Dft: TwoAdicSubgroupDft\u003cVal\u003e,\r\n    InputMmcs: Mmcs\u003cVal\u003e,\r\n    FriMmcs: Mmcs\u003cChallenge\u003e,\r\n    Challenge: TwoAdicField + ExtensionField\u003cVal\u003e,\r\n    Challenger:\r\n        FieldChallenger\u003cVal\u003e + CanObserve\u003cFriMmcs::Commitment\u003e + GrindingChallenger\u003cWitness = Val\u003e,\r\n    R: Rng + Send + Sync,\r\n{\r\n    type Domain = TwoAdicMultiplicativeCoset\u003cVal\u003e;\r\n    type Commitment = InputMmcs::Commitment;\r\n    type ProverData = InputMmcs::ProverData\u003cRowMajorMatrix\u003cVal\u003e\u003e;\r\n    type EvaluationsOnDomain\u003c'a\u003e = HorizontallyTruncated\u003c\r\n        Val,\r\n        RowIndexMappedView\u003cBitReversalPerm, DenseMatrix\u003cVal, \u0026'a [Val]\u003e\u003e,\r\n    \u003e;\r\n    /// The first item contains the openings of the random polynomials added by this wrapper.\r\n    /// The second item is the usual FRI proof.\r\n    type Proof = (\r\n        OpenedValues\u003cChallenge\u003e,\r\n        FriProof\u003cChallenge, FriMmcs, Val, Vec\u003cBatchOpening\u003cVal, InputMmcs\u003e\u003e\u003e,\r\n    );\r\n    type Error = FriError\u003cFriMmcs::Error, InputMmcs::Error\u003e;\r\n\r\n    fn natural_domain_for_degree(\u0026self, degree: usize) -\u003e Self::Domain {\r\n        \u003cTwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e as Pcs\u003cChallenge, Challenger\u003e\u003e::natural_domain_for_degree(\r\n            \u0026self.inner, degree)\r\n    }\r\n\r\n    fn commit(\r\n        \u0026self,\r\n        evaluations: Vec\u003c(Self::Domain, RowMajorMatrix\u003cVal\u003e)\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData) {\r\n        let randomized_evaluations = evaluations\r\n            .into_iter()\r\n            .map(|(domain, mat)| {\r\n                (\r\n                    domain,\r\n                    add_random_cols(mat, self.num_random_codewords, \u0026mut *self.rng.borrow_mut()),\r\n                )\r\n            })\r\n            .collect();\r\n        \u003cTwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e as Pcs\u003cChallenge, Challenger\u003e\u003e::commit(\r\n            \u0026self.inner,\r\n            randomized_evaluations,\r\n        )\r\n    }\r\n\r\n    fn get_evaluations_on_domain\u003c'a\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData,\r\n        idx: usize,\r\n        domain: Self::Domain,\r\n    ) -\u003e Self::EvaluationsOnDomain\u003c'a\u003e {\r\n        let inner_evals = \u003cTwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e as Pcs\u003c\r\n            Challenge,\r\n            Challenger,\r\n        \u003e\u003e::get_evaluations_on_domain(\r\n            \u0026self.inner, prover_data, idx, domain\r\n        );\r\n        let inner_width = inner_evals.width();\r\n        // Truncate off the columns representing random codewords we added in `commit` above.\r\n        HorizontallyTruncated::new(inner_evals, inner_width - self.num_random_codewords)\r\n    }\r\n\r\n    fn open(\r\n        \u0026self,\r\n        // For each round,\r\n        rounds: Vec\u003c(\r\n            \u0026Self::ProverData,\r\n            // for each matrix,\r\n            Vec\u003c\r\n                // points to open\r\n                Vec\u003cChallenge\u003e,\r\n            \u003e,\r\n        )\u003e,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e (OpenedValues\u003cChallenge\u003e, Self::Proof) {\r\n        let (mut inner_opened_values, inner_proof) = self.inner.open(rounds, challenger);\r\n\r\n        // inner_opened_values includes opened values for the random codewords. Those should be\r\n        // hidden from our caller, so we split them off and store them in the proof.\r\n        let opened_values_rand = inner_opened_values\r\n            .iter_mut()\r\n            .map(|opened_values_for_round| {\r\n                opened_values_for_round\r\n                    .iter_mut()\r\n                    .map(|opened_values_for_mat| {\r\n                        opened_values_for_mat\r\n                            .iter_mut()\r\n                            .map(|opened_values_for_point| {\r\n                                let split =\r\n                                    opened_values_for_point.len() - self.num_random_codewords;\r\n                                opened_values_for_point.drain(split..).collect()\r\n                            })\r\n                            .collect()\r\n                    })\r\n                    .collect()\r\n            })\r\n            .collect();\r\n\r\n        (inner_opened_values, (opened_values_rand, inner_proof))\r\n    }\r\n\r\n    fn verify(\r\n        \u0026self,\r\n        // For each round:\r\n        mut rounds: Vec\u003c(\r\n            Self::Commitment,\r\n            // for each matrix:\r\n            Vec\u003c(\r\n                // its domain,\r\n                Self::Domain,\r\n                // for each point:\r\n                Vec\u003c(\r\n                    // the point,\r\n                    Challenge,\r\n                    // values at the point\r\n                    Vec\u003cChallenge\u003e,\r\n                )\u003e,\r\n            )\u003e,\r\n        )\u003e,\r\n        proof: \u0026Self::Proof,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        let (opened_values_for_rand_cws, inner_proof) = proof;\r\n        // Now we merge `opened_values_for_rand_cws` into the opened values in `rounds`, undoing\r\n        // the split that we did in `open`, to get a complete set of opened values for the inner PCS\r\n        // to check.\r\n        for (round, rand_round) in rounds.iter_mut().zip(opened_values_for_rand_cws) {\r\n            for (mat, rand_mat) in round.1.iter_mut().zip(rand_round) {\r\n                for (point, rand_point) in mat.1.iter_mut().zip(rand_mat) {\r\n                    point.1.extend(rand_point);\r\n                }\r\n            }\r\n        }\r\n        self.inner.verify(rounds, inner_proof, challenger)\r\n    }\r\n}\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn add_random_cols\u003cVal, R\u003e(\r\n    mat: RowMajorMatrix\u003cVal\u003e,\r\n    num_random_codewords: usize,\r\n    mut rng: R,\r\n) -\u003e RowMajorMatrix\u003cVal\u003e\r\nwhere\r\n    Val: Field,\r\n    R: Rng + Send + Sync,\r\n    Standard: Distribution\u003cVal\u003e,\r\n{\r\n    let old_w = mat.width();\r\n    let new_w = old_w + num_random_codewords;\r\n    let h = mat.height();\r\n\r\n    let new_values = Val::zero_vec(new_w * h);\r\n    let mut result = RowMajorMatrix::new(new_values, new_w);\r\n    // Can be parallelized by adding par_, but there are some complications with the RNG.\r\n    // We could just use thread_rng(), but ideally we want to keep it generic...\r\n    result\r\n        .rows_mut()\r\n        .zip(mat.row_slices())\r\n        .for_each(|(new_row, old_row)| {\r\n            new_row[..old_w].copy_from_slice(old_row);\r\n            new_row[old_w..].iter_mut().for_each(|v| *v = rng.gen());\r\n        });\r\n    result\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":50},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","lib.rs"],"content":"//! An implementation of the FRI low-degree test (LDT).\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod config;\r\nmod fold_even_odd;\r\nmod hiding_pcs;\r\nmod proof;\r\npub mod prover;\r\nmod two_adic_pcs;\r\npub mod verifier;\r\n\r\npub use config::*;\r\npub use fold_even_odd::*;\r\npub use hiding_pcs::*;\r\npub use proof::*;\r\npub use two_adic_pcs::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","proof.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_commit::Mmcs;\r\nuse p3_field::Field;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound(\r\n    serialize = \"Witness: Serialize, InputProof: Serialize\",\r\n    deserialize = \"Witness: Deserialize\u003c'de\u003e, InputProof: Deserialize\u003c'de\u003e\"\r\n))]\r\npub struct FriProof\u003cF: Field, M: Mmcs\u003cF\u003e, Witness, InputProof\u003e {\r\n    pub commit_phase_commits: Vec\u003cM::Commitment\u003e,\r\n    pub query_proofs: Vec\u003cQueryProof\u003cF, M, InputProof\u003e\u003e,\r\n    pub final_poly: Vec\u003cF\u003e,\r\n    pub pow_witness: Witness,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound(\r\n    serialize = \"InputProof: Serialize\",\r\n    deserialize = \"InputProof: Deserialize\u003c'de\u003e\",\r\n))]\r\npub struct QueryProof\u003cF: Field, M: Mmcs\u003cF\u003e, InputProof\u003e {\r\n    pub input_proof: InputProof,\r\n    /// For each commit phase commitment, this contains openings of a commit phase codeword at the\r\n    /// queried location, along with an opening proof.\r\n    pub commit_phase_openings: Vec\u003cCommitPhaseProofStep\u003cF, M\u003e\u003e,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize, Clone)]\r\n#[serde(bound = \"\")]\r\npub struct CommitPhaseProofStep\u003cF: Field, M: Mmcs\u003cF\u003e\u003e {\r\n    /// The opening of the commit phase codeword at the sibling location.\r\n    // This may change to Vec\u003cFC::Challenge\u003e if the library is generalized to support other FRI\r\n    // folding arities besides 2, meaning that there can be multiple siblings.\r\n    pub sibling_value: F,\r\n\r\n    pub opening_proof: M::Proof,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","prover.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::iter;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::Mmcs;\r\nuse p3_dft::{Radix2Dit, TwoAdicSubgroupDft};\r\nuse p3_field::{ExtensionField, Field, TwoAdicField};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_util::{log2_strict_usize, reverse_slice_index_bits};\r\nuse tracing::{debug_span, info_span, instrument};\r\n\r\nuse crate::{CommitPhaseProofStep, FriConfig, FriGenericConfig, FriProof, QueryProof};\r\n\r\n#[instrument(name = \"FRI prover\", skip_all)]\r\npub fn prove\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    inputs: Vec\u003cVec\u003cChallenge\u003e\u003e,\r\n    challenger: \u0026mut Challenger,\r\n    open_input: impl Fn(usize) -\u003e G::InputProof,\r\n) -\u003e FriProof\u003cChallenge, M, Challenger::Witness, G::InputProof\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e + TwoAdicField,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + GrindingChallenger + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    assert!(!inputs.is_empty());\r\n    assert!(\r\n        inputs\r\n            .iter()\r\n            .tuple_windows()\r\n            .all(|(l, r)| l.len() \u003e= r.len()),\r\n        \"Inputs are not sorted in descending order of length.\"\r\n    );\r\n\r\n    let log_max_height = log2_strict_usize(inputs[0].len());\r\n    let log_min_height = log2_strict_usize(inputs.last().unwrap().len());\r\n    if config.log_final_poly_len \u003e 0 {\r\n        assert!(log_min_height \u003e config.log_final_poly_len + config.log_blowup);\r\n    }\r\n\r\n    let commit_phase_result = commit_phase(g, config, inputs, challenger);\r\n\r\n    let pow_witness = challenger.grind(config.proof_of_work_bits);\r\n\r\n    let query_proofs = info_span!(\"query phase\").in_scope(|| {\r\n        iter::repeat_with(|| challenger.sample_bits(log_max_height + g.extra_query_index_bits()))\r\n            .take(config.num_queries)\r\n            .map(|index| QueryProof {\r\n                input_proof: open_input(index),\r\n                commit_phase_openings: answer_query(\r\n                    config,\r\n                    \u0026commit_phase_result.data,\r\n                    index \u003e\u003e g.extra_query_index_bits(),\r\n                ),\r\n            })\r\n            .collect()\r\n    });\r\n\r\n    FriProof {\r\n        commit_phase_commits: commit_phase_result.commits,\r\n        query_proofs,\r\n        final_poly: commit_phase_result.final_poly,\r\n        pow_witness,\r\n    }\r\n}\r\n\r\nstruct CommitPhaseResult\u003cF: Field, M: Mmcs\u003cF\u003e\u003e {\r\n    commits: Vec\u003cM::Commitment\u003e,\r\n    data: Vec\u003cM::ProverData\u003cRowMajorMatrix\u003cF\u003e\u003e\u003e,\r\n    final_poly: Vec\u003cF\u003e,\r\n}\r\n\r\n#[instrument(name = \"commit phase\", skip_all)]\r\nfn commit_phase\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    inputs: Vec\u003cVec\u003cChallenge\u003e\u003e,\r\n    challenger: \u0026mut Challenger,\r\n) -\u003e CommitPhaseResult\u003cChallenge, M\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e + TwoAdicField,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    let mut inputs_iter = inputs.into_iter().peekable();\r\n    let mut folded = inputs_iter.next().unwrap();\r\n    let mut commits = vec![];\r\n    let mut data = vec![];\r\n\r\n    while folded.len() \u003e config.blowup() * config.final_poly_len() {\r\n        let leaves = RowMajorMatrix::new(folded, 2);\r\n        let (commit, prover_data) = config.mmcs.commit_matrix(leaves);\r\n        challenger.observe(commit.clone());\r\n\r\n        let beta: Challenge = challenger.sample_algebra_element();\r\n        // We passed ownership of `current` to the MMCS, so get a reference to it\r\n        let leaves = config.mmcs.get_matrices(\u0026prover_data).pop().unwrap();\r\n        folded = g.fold_matrix(beta, leaves.as_view());\r\n\r\n        commits.push(commit);\r\n        data.push(prover_data);\r\n\r\n        if let Some(v) = inputs_iter.next_if(|v| v.len() == folded.len()) {\r\n            izip!(\u0026mut folded, v).for_each(|(c, x)| *c += x);\r\n        }\r\n    }\r\n\r\n    // After repeated folding steps, we end up working over a coset hJ instead of the original\r\n    // domain. The IDFT we apply operates over a subgroup J, not hJ. This means the polynomial we\r\n    // recover is G(x), where G(x) = F(hx), and F is the polynomial whose evaluations we actually\r\n    // observed. For our current construction, this does not cause issues since degree properties\r\n    // and zero-checks remain valid. If we changed our domain construction (e.g., using multiple\r\n    // cosets), we would need to carefully reconsider these assumptions.\r\n\r\n    reverse_slice_index_bits(\u0026mut folded);\r\n    // TODO: For better performance, we could run the IDFT on only the first half\r\n    //       (or less, depending on `log_blowup`) of `final_poly`.\r\n    let final_poly = debug_span!(\"idft final poly\").in_scope(|| Radix2Dit::default().idft(folded));\r\n\r\n    // The evaluation domain is \"blown-up\" relative to the polynomial degree of `final_poly`,\r\n    // so all coefficients after the first final_poly_len should be zero.\r\n    debug_assert!(\r\n        final_poly\r\n            .iter()\r\n            .skip(1 \u003c\u003c config.log_final_poly_len)\r\n            .all(|x| x.is_zero()),\r\n        \"All coefficients beyond final_poly_len must be zero\"\r\n    );\r\n\r\n    // Observe all coefficients of the final polynomial.\r\n    for \u0026x in \u0026final_poly {\r\n        challenger.observe_algebra_element(x);\r\n    }\r\n\r\n    CommitPhaseResult {\r\n        commits,\r\n        data,\r\n        final_poly,\r\n    }\r\n}\r\n\r\nfn answer_query\u003cF, M\u003e(\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    commit_phase_commits: \u0026[M::ProverData\u003cRowMajorMatrix\u003cF\u003e\u003e],\r\n    index: usize,\r\n) -\u003e Vec\u003cCommitPhaseProofStep\u003cF, M\u003e\u003e\r\nwhere\r\n    F: Field,\r\n    M: Mmcs\u003cF\u003e,\r\n{\r\n    commit_phase_commits\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(i, commit)| {\r\n            let index_i = index \u003e\u003e i;\r\n            let index_i_sibling = index_i ^ 1;\r\n            let index_pair = index_i \u003e\u003e 1;\r\n\r\n            let (mut opened_rows, opening_proof) = config.mmcs.open_batch(index_pair, commit);\r\n            assert_eq!(opened_rows.len(), 1);\r\n            let opened_row = opened_rows.pop().unwrap();\r\n            assert_eq!(opened_row.len(), 2, \"Committed data should be in pairs\");\r\n            let sibling_value = opened_row[index_i_sibling % 2];\r\n\r\n            CommitPhaseProofStep {\r\n                sibling_value,\r\n                opening_proof,\r\n            }\r\n        })\r\n        .collect()\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":8214565720323784704}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":4323455642275676220}},{"line":51,"address":[],"length":0,"stats":{"Line":4035225266123964536}},{"line":52,"address":[],"length":0,"stats":{"Line":4323455642275676220}},{"line":53,"address":[],"length":0,"stats":{"Line":18158513697557839933}},{"line":54,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":55,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":56,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":57,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":58,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":61,"address":[],"length":0,"stats":{"Line":4323455642275676220}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":8070450532247928843}},{"line":111,"address":[],"length":0,"stats":{"Line":6917529027641081857}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":158,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":161,"address":[],"length":0,"stats":{"Line":14843864371813154817}},{"line":162,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":163,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":164,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":166,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":167,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":168,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":169,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":170,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":172,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":173,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":174,"address":[],"length":0,"stats":{"Line":1008806316530991115}}],"covered":29,"coverable":64},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","two_adic_pcs.rs"],"content":"use alloc::collections::BTreeMap;\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt::Debug;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::{Mmcs, OpenedValues, Pcs, PolynomialSpace, TwoAdicMultiplicativeCoset};\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::{\r\n    batch_multiplicative_inverse, cyclic_subgroup_coset_known_order, dot_product, ExtensionField,\r\n    Field, TwoAdicField,\r\n};\r\nuse p3_interpolation::interpolate_coset;\r\nuse p3_matrix::bitrev::{BitReversableMatrix, BitReversalPerm, BitReversedMatrixView};\r\nuse p3_matrix::dense::{DenseMatrix, RowMajorMatrix};\r\nuse p3_matrix::{Dimensions, Matrix};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::linear_map::LinearMap;\r\nuse p3_util::{log2_strict_usize, reverse_bits_len, reverse_slice_index_bits};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::{info_span, instrument};\r\n\r\nuse crate::verifier::{self, FriError};\r\nuse crate::{prover, FriConfig, FriGenericConfig, FriProof};\r\n\r\n#[derive(Debug)]\r\npub struct TwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e {\r\n    dft: Dft,\r\n    mmcs: InputMmcs,\r\n    fri: FriConfig\u003cFriMmcs\u003e,\r\n    _phantom: PhantomData\u003cVal\u003e,\r\n}\r\n\r\nimpl\u003cVal, Dft, InputMmcs, FriMmcs\u003e TwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e {\r\n    pub const fn new(dft: Dft, mmcs: InputMmcs, fri: FriConfig\u003cFriMmcs\u003e) -\u003e Self {\r\n        Self {\r\n            dft,\r\n            mmcs,\r\n            fri,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Clone)]\r\n#[serde(bound = \"\")]\r\npub struct BatchOpening\u003cVal: Field, InputMmcs: Mmcs\u003cVal\u003e\u003e {\r\n    pub opened_values: Vec\u003cVec\u003cVal\u003e\u003e,\r\n    pub opening_proof: \u003cInputMmcs as Mmcs\u003cVal\u003e\u003e::Proof,\r\n}\r\n\r\npub struct TwoAdicFriGenericConfig\u003cInputProof, InputError\u003e(\r\n    pub PhantomData\u003c(InputProof, InputError)\u003e,\r\n);\r\n\r\npub type TwoAdicFriGenericConfigForMmcs\u003cF, M\u003e =\r\n    TwoAdicFriGenericConfig\u003cVec\u003cBatchOpening\u003cF, M\u003e\u003e, \u003cM as Mmcs\u003cF\u003e\u003e::Error\u003e;\r\n\r\nimpl\u003cF: TwoAdicField, InputProof, InputError: Debug\u003e FriGenericConfig\u003cF\u003e\r\n    for TwoAdicFriGenericConfig\u003cInputProof, InputError\u003e\r\n{\r\n    type InputProof = InputProof;\r\n    type InputError = InputError;\r\n\r\n    fn extra_query_index_bits(\u0026self) -\u003e usize {\r\n        0\r\n    }\r\n\r\n    fn fold_row(\r\n        \u0026self,\r\n        index: usize,\r\n        log_height: usize,\r\n        beta: F,\r\n        evals: impl Iterator\u003cItem = F\u003e,\r\n    ) -\u003e F {\r\n        let arity = 2;\r\n        let log_arity = 1;\r\n        let (e0, e1) = evals\r\n            .collect_tuple()\r\n            .expect(\"TwoAdicFriFolder only supports arity=2\");\r\n        // If performance critical, make this API stateful to avoid this\r\n        // This is a bit more math than is necessary, but leaving it here\r\n        // in case we want higher arity in the future\r\n        let subgroup_start = F::two_adic_generator(log_height + log_arity)\r\n            .exp_u64(reverse_bits_len(index, log_height) as u64);\r\n        let mut xs = F::two_adic_generator(log_arity)\r\n            .shifted_powers(subgroup_start)\r\n            .take(arity)\r\n            .collect_vec();\r\n        reverse_slice_index_bits(\u0026mut xs);\r\n        assert_eq!(log_arity, 1, \"can only interpolate two points for now\");\r\n        // interpolate and evaluate at beta\r\n        e0 + (beta - xs[0]) * (e1 - e0) / (xs[1] - xs[0])\r\n    }\r\n\r\n    fn fold_matrix\u003cM: Matrix\u003cF\u003e\u003e(\u0026self, beta: F, m: M) -\u003e Vec\u003cF\u003e {\r\n        // We use the fact that\r\n        //     p_e(x^2) = (p(x) + p(-x)) / 2\r\n        //     p_o(x^2) = (p(x) - p(-x)) / (2 x)\r\n        // that is,\r\n        //     p_e(g^(2i)) = (p(g^i) + p(g^(n/2 + i))) / 2\r\n        //     p_o(g^(2i)) = (p(g^i) - p(g^(n/2 + i))) / (2 g^i)\r\n        // so\r\n        //     result(g^(2i)) = p_e(g^(2i)) + beta p_o(g^(2i))\r\n        //                    = (1/2 + beta/2 g_inv^i) p(g^i)\r\n        //                    + (1/2 - beta/2 g_inv^i) p(g^(n/2 + i))\r\n        let g_inv = F::two_adic_generator(log2_strict_usize(m.height()) + 1).inverse();\r\n        let one_half = F::ONE.halve();\r\n        let half_beta = beta * one_half;\r\n\r\n        // TODO: vectorize this (after we have packed extension fields)\r\n\r\n        // beta/2 times successive powers of g_inv\r\n        let mut powers = g_inv\r\n            .shifted_powers(half_beta)\r\n            .take(m.height())\r\n            .collect_vec();\r\n        reverse_slice_index_bits(\u0026mut powers);\r\n\r\n        m.par_rows()\r\n            .zip(powers)\r\n            .map(|(mut row, power)| {\r\n                let (lo, hi) = row.next_tuple().unwrap();\r\n                (one_half + power) * lo + (one_half - power) * hi\r\n            })\r\n            .collect()\r\n    }\r\n}\r\n\r\nimpl\u003cVal, Dft, InputMmcs, FriMmcs, Challenge, Challenger\u003e Pcs\u003cChallenge, Challenger\u003e\r\n    for TwoAdicFriPcs\u003cVal, Dft, InputMmcs, FriMmcs\u003e\r\nwhere\r\n    Val: TwoAdicField,\r\n    Dft: TwoAdicSubgroupDft\u003cVal\u003e,\r\n    InputMmcs: Mmcs\u003cVal\u003e,\r\n    FriMmcs: Mmcs\u003cChallenge\u003e,\r\n    Challenge: TwoAdicField + ExtensionField\u003cVal\u003e,\r\n    Challenger:\r\n        FieldChallenger\u003cVal\u003e + CanObserve\u003cFriMmcs::Commitment\u003e + GrindingChallenger\u003cWitness = Val\u003e,\r\n{\r\n    type Domain = TwoAdicMultiplicativeCoset\u003cVal\u003e;\r\n    type Commitment = InputMmcs::Commitment;\r\n    type ProverData = InputMmcs::ProverData\u003cRowMajorMatrix\u003cVal\u003e\u003e;\r\n    type EvaluationsOnDomain\u003c'a\u003e = BitReversedMatrixView\u003cDenseMatrix\u003cVal, \u0026'a [Val]\u003e\u003e;\r\n    type Proof = FriProof\u003cChallenge, FriMmcs, Val, Vec\u003cBatchOpening\u003cVal, InputMmcs\u003e\u003e\u003e;\r\n    type Error = FriError\u003cFriMmcs::Error, InputMmcs::Error\u003e;\r\n\r\n    fn natural_domain_for_degree(\u0026self, degree: usize) -\u003e Self::Domain {\r\n        let log_n = log2_strict_usize(degree);\r\n        TwoAdicMultiplicativeCoset {\r\n            log_n,\r\n            shift: Val::ONE,\r\n        }\r\n    }\r\n\r\n    fn commit(\r\n        \u0026self,\r\n        evaluations: Vec\u003c(Self::Domain, RowMajorMatrix\u003cVal\u003e)\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData) {\r\n        let ldes: Vec\u003c_\u003e = evaluations\r\n            .into_iter()\r\n            .map(|(domain, evals)| {\r\n                assert_eq!(domain.size(), evals.height());\r\n                let shift = Val::GENERATOR / domain.shift;\r\n                // Commit to the bit-reversed LDE.\r\n                self.dft\r\n                    .coset_lde_batch(evals, self.fri.log_blowup, shift)\r\n                    .bit_reverse_rows()\r\n                    .to_row_major_matrix()\r\n            })\r\n            .collect();\r\n\r\n        self.mmcs.commit(ldes)\r\n    }\r\n\r\n    fn get_evaluations_on_domain\u003c'a\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData,\r\n        idx: usize,\r\n        domain: Self::Domain,\r\n    ) -\u003e Self::EvaluationsOnDomain\u003c'a\u003e {\r\n        // todo: handle extrapolation for LDEs we don't have\r\n        assert_eq!(domain.shift, Val::GENERATOR);\r\n        let lde = self.mmcs.get_matrices(prover_data)[idx];\r\n        assert!(lde.height() \u003e= domain.size());\r\n        lde.split_rows(domain.size()).0.bit_reverse_rows()\r\n    }\r\n\r\n    fn open(\r\n        \u0026self,\r\n        // For each round,\r\n        rounds: Vec\u003c(\r\n            \u0026Self::ProverData,\r\n            // for each matrix,\r\n            Vec\u003c\r\n                // points to open\r\n                Vec\u003cChallenge\u003e,\r\n            \u003e,\r\n        )\u003e,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e (OpenedValues\u003cChallenge\u003e, Self::Proof) {\r\n        /*\r\n\r\n        A quick rundown of the optimizations in this function:\r\n        We are trying to compute sum_i alpha^i * (p(X) - y)/(X - z),\r\n        for each z an opening point, y = p(z). Each p(X) is given as evaluations in bit-reversed order\r\n        in the columns of the matrices. y is computed by barycentric interpolation.\r\n        X and p(X) are in the base field; alpha, y and z are in the extension.\r\n        The primary goal is to minimize extension multiplications.\r\n\r\n        - Instead of computing all alpha^i, we just compute alpha^i for i up to the largest width\r\n        of a matrix, then multiply by an \"alpha offset\" when accumulating.\r\n              a^0 x0 + a^1 x1 + a^2 x2 + a^3 x3 + ...\r\n            = a^0 ( a^0 x0 + a^1 x1 ) + a^2 ( a^0 x2 + a^1 x3 ) + ...\r\n            (see `alpha_pows`, `alpha_pow_offset`, `num_reduced`)\r\n\r\n        - For each unique point z, we precompute 1/(X-z) for the largest subgroup opened at this point.\r\n        Since we compute it in bit-reversed order, smaller subgroups can simply truncate the vector.\r\n            (see `inv_denoms`)\r\n\r\n        - Then, for each matrix (with columns p_i) and opening point z, we want:\r\n            for each row (corresponding to subgroup element X):\r\n                reduced[X] += alpha_offset * sum_i [ alpha^i * inv_denom[X] * (p_i[X] - y[i]) ]\r\n\r\n            We can factor out inv_denom, and expand what's left:\r\n                reduced[X] += alpha_offset * inv_denom[X] * sum_i [ alpha^i * p_i[X] - alpha^i * y[i] ]\r\n\r\n            And separate the sum:\r\n                reduced[X] += alpha_offset * inv_denom[X] * [ sum_i [ alpha^i * p_i[X] ] - sum_i [ alpha^i * y[i] ] ]\r\n\r\n            And now the last sum doesn't depend on X, so we can precompute that for the matrix, too.\r\n            So the hot loop (that depends on both X and i) is just:\r\n                sum_i [ alpha^i * p_i[X] ]\r\n\r\n            with alpha^i an extension, p_i[X] a base\r\n\r\n        */\r\n\r\n        let mats_and_points = rounds\r\n            .iter()\r\n            .map(|(data, points)| {\r\n                (\r\n                    self.mmcs\r\n                        .get_matrices(data)\r\n                        .into_iter()\r\n                        .map(|m| m.as_view())\r\n                        .collect_vec(),\r\n                    points,\r\n                )\r\n            })\r\n            .collect_vec();\r\n        let mats = mats_and_points\r\n            .iter()\r\n            .flat_map(|(mats, _)| mats)\r\n            .collect_vec();\r\n\r\n        let global_max_height = mats.iter().map(|m| m.height()).max().unwrap();\r\n        let log_global_max_height = log2_strict_usize(global_max_height);\r\n\r\n        // For each unique opening point z, we will find the largest degree bound\r\n        // for that point, and precompute 1/(z - X) for the largest subgroup (in bitrev order).\r\n        let inv_denoms = compute_inverse_denominators(\u0026mats_and_points, Val::GENERATOR);\r\n\r\n        // Evaluate coset representations and write openings to the challenger\r\n        let all_opened_values = mats_and_points\r\n            .iter()\r\n            .map(|(mats, points)| {\r\n                izip!(mats.iter(), points.iter())\r\n                    .map(|(mat, points_for_mat)| {\r\n                        points_for_mat\r\n                            .iter()\r\n                            .map(|\u0026point| {\r\n                                let _guard =\r\n                                    info_span!(\"evaluate matrix\", dims = %mat.dimensions())\r\n                                        .entered();\r\n\r\n                                // Use Barycentric interpolation to evaluate the matrix at the given point.\r\n                                let ys =\r\n                                    info_span!(\"compute opened values with Lagrange interpolation\")\r\n                                        .in_scope(|| {\r\n                                            let h = mat.height() \u003e\u003e self.fri.log_blowup;\r\n                                            let (low_coset, _) = mat.split_rows(h);\r\n                                            let mut inv_denoms =\r\n                                                inv_denoms.get(\u0026point).unwrap()[..h].to_vec();\r\n                                            reverse_slice_index_bits(\u0026mut inv_denoms);\r\n                                            interpolate_coset(\r\n                                                \u0026BitReversalPerm::new_view(low_coset),\r\n                                                Val::GENERATOR,\r\n                                                point,\r\n                                                Some(\u0026inv_denoms),\r\n                                            )\r\n                                        });\r\n                                ys.iter()\r\n                                    .for_each(|\u0026y| challenger.observe_algebra_element(y));\r\n                                ys\r\n                            })\r\n                            .collect_vec()\r\n                    })\r\n                    .collect_vec()\r\n            })\r\n            .collect_vec();\r\n\r\n        // Batch combination challenge\r\n        let alpha: Challenge = challenger.sample_algebra_element();\r\n\r\n        let mut num_reduced = [0; 32];\r\n        let mut reduced_openings: [_; 32] = core::array::from_fn(|_| None);\r\n\r\n        for ((mats, points), openings_for_round) in\r\n            mats_and_points.iter().zip(all_opened_values.iter())\r\n        {\r\n            for (mat, points_for_mat, openings_for_mat) in\r\n                izip!(mats.iter(), points.iter(), openings_for_round.iter())\r\n            {\r\n                let _guard =\r\n                    info_span!(\"reduce matrix quotient\", dims = %mat.dimensions()).entered();\r\n\r\n                let log_height = log2_strict_usize(mat.height());\r\n                let reduced_opening_for_log_height = reduced_openings[log_height]\r\n                    .get_or_insert_with(|| vec![Challenge::ZERO; mat.height()]);\r\n                debug_assert_eq!(reduced_opening_for_log_height.len(), mat.height());\r\n\r\n                let mat_compressed = info_span!(\"compress mat\")\r\n                    .in_scope(|| mat.dot_ext_powers(alpha).collect::\u003cVec\u003c_\u003e\u003e());\r\n\r\n                for (\u0026point, openings) in points_for_mat.iter().zip(openings_for_mat) {\r\n                    let alpha_pow_offset = alpha.exp_u64(num_reduced[log_height] as u64);\r\n                    let reduced_openings: Challenge =\r\n                        dot_product(alpha.powers(), openings.iter().copied());\r\n\r\n                    info_span!(\"reduce rows\").in_scope(|| {\r\n                        mat_compressed\r\n                            .par_iter()\r\n                            .zip(reduced_opening_for_log_height.par_iter_mut())\r\n                            // This might be longer, but zip will truncate to smaller subgroup\r\n                            // (which is ok because it's bitrev)\r\n                            .zip(inv_denoms.get(\u0026point).unwrap().par_iter())\r\n                            .for_each(|((\u0026reduced_row, ro), \u0026inv_denom)| {\r\n                                *ro +=\r\n                                    alpha_pow_offset * (reduced_openings - reduced_row) * inv_denom\r\n                            });\r\n                    });\r\n\r\n                    num_reduced[log_height] += mat.width();\r\n                }\r\n            }\r\n        }\r\n\r\n        let fri_input = reduced_openings.into_iter().rev().flatten().collect_vec();\r\n\r\n        let g: TwoAdicFriGenericConfigForMmcs\u003cVal, InputMmcs\u003e =\r\n            TwoAdicFriGenericConfig(PhantomData);\r\n\r\n        let fri_proof = prover::prove(\u0026g, \u0026self.fri, fri_input, challenger, |index| {\r\n            rounds\r\n                .iter()\r\n                .map(|(data, _)| {\r\n                    let log_max_height = log2_strict_usize(self.mmcs.get_max_height(data));\r\n                    let bits_reduced = log_global_max_height - log_max_height;\r\n                    let reduced_index = index \u003e\u003e bits_reduced;\r\n                    let (opened_values, opening_proof) = self.mmcs.open_batch(reduced_index, data);\r\n                    BatchOpening {\r\n                        opened_values,\r\n                        opening_proof,\r\n                    }\r\n                })\r\n                .collect()\r\n        });\r\n\r\n        (all_opened_values, fri_proof)\r\n    }\r\n\r\n    fn verify(\r\n        \u0026self,\r\n        // For each round:\r\n        rounds: Vec\u003c(\r\n            Self::Commitment,\r\n            // for each matrix:\r\n            Vec\u003c(\r\n                // its domain,\r\n                Self::Domain,\r\n                // for each point:\r\n                Vec\u003c(\r\n                    // the point,\r\n                    Challenge,\r\n                    // values at the point\r\n                    Vec\u003cChallenge\u003e,\r\n                )\u003e,\r\n            )\u003e,\r\n        )\u003e,\r\n        proof: \u0026Self::Proof,\r\n        challenger: \u0026mut Challenger,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        // Write evaluations to challenger\r\n        for (_, round) in rounds.iter() {\r\n            for (_, mat) in round.iter() {\r\n                for (_, point) in mat.iter() {\r\n                    point\r\n                        .iter()\r\n                        .for_each(|\u0026opening| challenger.observe_algebra_element(opening));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Batch combination challenge\r\n        let alpha: Challenge = challenger.sample_algebra_element();\r\n\r\n        let log_global_max_height =\r\n            proof.commit_phase_commits.len() + self.fri.log_blowup + self.fri.log_final_poly_len;\r\n\r\n        let g: TwoAdicFriGenericConfigForMmcs\u003cVal, InputMmcs\u003e =\r\n            TwoAdicFriGenericConfig(PhantomData);\r\n\r\n        verifier::verify(\u0026g, \u0026self.fri, proof, challenger, |index, input_proof| {\r\n            // TODO: separate this out into functions\r\n\r\n            // log_height -\u003e (alpha_pow, reduced_opening)\r\n            let mut reduced_openings = BTreeMap::\u003cusize, (Challenge, Challenge)\u003e::new();\r\n\r\n            for (batch_opening, (batch_commit, mats)) in izip!(input_proof, \u0026rounds) {\r\n                let batch_heights = mats\r\n                    .iter()\r\n                    .map(|(domain, _)| domain.size() \u003c\u003c self.fri.log_blowup)\r\n                    .collect_vec();\r\n                let batch_dims = batch_heights\r\n                    .iter()\r\n                    // TODO: MMCS doesn't really need width; we put 0 for now.\r\n                    .map(|\u0026height| Dimensions { width: 0, height })\r\n                    .collect_vec();\r\n\r\n                if let Some(batch_max_height) = batch_heights.iter().max() {\r\n                    let log_batch_max_height = log2_strict_usize(*batch_max_height);\r\n                    let bits_reduced = log_global_max_height - log_batch_max_height;\r\n                    let reduced_index = index \u003e\u003e bits_reduced;\r\n\r\n                    self.mmcs.verify_batch(\r\n                        batch_commit,\r\n                        \u0026batch_dims,\r\n                        reduced_index,\r\n                        \u0026batch_opening.opened_values,\r\n                        \u0026batch_opening.opening_proof,\r\n                    )?;\r\n                } else {\r\n                    // Empty batch?\r\n                    self.mmcs.verify_batch(\r\n                        batch_commit,\r\n                        \u0026[],\r\n                        0,\r\n                        \u0026batch_opening.opened_values,\r\n                        \u0026batch_opening.opening_proof,\r\n                    )?;\r\n                }\r\n\r\n                for (mat_opening, (mat_domain, mat_points_and_values)) in\r\n                    izip!(\u0026batch_opening.opened_values, mats)\r\n                {\r\n                    let log_height = log2_strict_usize(mat_domain.size()) + self.fri.log_blowup;\r\n\r\n                    let bits_reduced = log_global_max_height - log_height;\r\n                    let rev_reduced_index = reverse_bits_len(index \u003e\u003e bits_reduced, log_height);\r\n\r\n                    // todo: this can be nicer with domain methods?\r\n\r\n                    let x = Val::GENERATOR\r\n                        * Val::two_adic_generator(log_height).exp_u64(rev_reduced_index as u64);\r\n\r\n                    let (alpha_pow, ro) = reduced_openings\r\n                        .entry(log_height)\r\n                        .or_insert((Challenge::ONE, Challenge::ZERO));\r\n\r\n                    for (z, ps_at_z) in mat_points_and_values {\r\n                        for (\u0026p_at_x, \u0026p_at_z) in izip!(mat_opening, ps_at_z) {\r\n                            let quotient = (-p_at_z + p_at_x) / (-*z + x);\r\n                            *ro += *alpha_pow * quotient;\r\n                            *alpha_pow *= alpha;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // `reduced_openings` would have a log_height = log_blowup entry only if there was a\r\n            // trace matrix of height 1. In this case the reduced opening can be skipped as it will\r\n            // not be checked against any commit phase commit.\r\n            if let Some((_alpha_pow, ro)) = reduced_openings.remove(\u0026self.fri.log_blowup) {\r\n                assert!(ro.is_zero());\r\n            }\r\n\r\n            // Return reduced openings descending by log_height.\r\n            Ok(reduced_openings\r\n                .into_iter()\r\n                .rev()\r\n                .map(|(log_height, (_alpha_pow, ro))| (log_height, ro))\r\n                .collect())\r\n        })?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[instrument(skip_all)]\r\nfn compute_inverse_denominators\u003cF: TwoAdicField, EF: ExtensionField\u003cF\u003e, M: Matrix\u003cF\u003e\u003e(\r\n    mats_and_points: \u0026[(Vec\u003cM\u003e, \u0026Vec\u003cVec\u003cEF\u003e\u003e)],\r\n    coset_shift: F,\r\n) -\u003e LinearMap\u003cEF, Vec\u003cEF\u003e\u003e {\r\n    let mut max_log_height_for_point: LinearMap\u003cEF, usize\u003e = LinearMap::new();\r\n    for (mats, points) in mats_and_points {\r\n        for (mat, points_for_mat) in izip!(mats, *points) {\r\n            let log_height = log2_strict_usize(mat.height());\r\n            for \u0026z in points_for_mat {\r\n                if let Some(lh) = max_log_height_for_point.get_mut(\u0026z) {\r\n                    *lh = core::cmp::max(*lh, log_height);\r\n                } else {\r\n                    max_log_height_for_point.insert(z, log_height);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Compute the largest subgroup we will use, in bitrev order.\r\n    let max_log_height = *max_log_height_for_point.values().max().unwrap();\r\n    let mut subgroup = cyclic_subgroup_coset_known_order(\r\n        F::two_adic_generator(max_log_height),\r\n        coset_shift,\r\n        1 \u003c\u003c max_log_height,\r\n    )\r\n    .collect_vec();\r\n    reverse_slice_index_bits(\u0026mut subgroup);\r\n\r\n    max_log_height_for_point\r\n        .into_iter()\r\n        .map(|(z, log_height)| {\r\n            (\r\n                z,\r\n                batch_multiplicative_inverse(\r\n                    \u0026subgroup[..(1 \u003c\u003c log_height)]\r\n                        .iter()\r\n                        .map(|\u0026x| z - x)\r\n                        .collect_vec(),\r\n                ),\r\n            )\r\n        })\r\n        .collect()\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":1224979098644774913}},{"line":67,"address":[],"length":0,"stats":{"Line":18}},{"line":68,"address":[],"length":0,"stats":{"Line":18}},{"line":71,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":78,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":79,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":80,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":86,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":87,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":88,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":89,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":90,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":92,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":93,"address":[],"length":0,"stats":{"Line":1008806316530991095}},{"line":95,"address":[],"length":0,"stats":{"Line":1008806316530991115}},{"line":98,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":109,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":110,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":111,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":116,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":117,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":118,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":120,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":122,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":123,"address":[],"length":0,"stats":{"Line":2666130979403333965}},{"line":124,"address":[],"length":0,"stats":{"Line":72057594037928270}},{"line":125,"address":[],"length":0,"stats":{"Line":15852670688344145921}},{"line":126,"address":[],"length":0,"stats":{"Line":15852670688344145921}},{"line":150,"address":[],"length":0,"stats":{"Line":14411518807585587203}},{"line":151,"address":[],"length":0,"stats":{"Line":14411518807585587203}},{"line":158,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":162,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":164,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":165,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":166,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":168,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":169,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":170,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":171,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":175,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":178,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":185,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":186,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":187,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":188,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":191,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":204,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":206,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":207,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":208,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":209,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":210,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":211,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":213,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":214,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":215,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":216,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":217,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":219,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":220,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":221,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":223,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":224,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":225,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":227,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":228,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":230,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":231,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":233,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":234,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":235,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":237,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":239,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":241,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":243,"address":[],"length":0,"stats":{"Line":9655717601082343433}},{"line":245,"address":[],"length":0,"stats":{"Line":5620492334958379017}},{"line":246,"address":[],"length":0,"stats":{"Line":5620492334958379017}},{"line":247,"address":[],"length":0,"stats":{"Line":5620492334958379017}},{"line":248,"address":[],"length":0,"stats":{"Line":7782220156096217106}},{"line":249,"address":[],"length":0,"stats":{"Line":5620492334958379017}},{"line":250,"address":[],"length":0,"stats":{"Line":5620492334958379017}},{"line":254,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":256,"address":[],"length":0,"stats":{"Line":13690942867206307840}},{"line":259,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":260,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":264,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":267,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":269,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":270,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":271,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":272,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":273,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":274,"address":[],"length":0,"stats":{"Line":11961560610296037384}},{"line":275,"address":[],"length":0,"stats":{"Line":15420325124116578312}},{"line":276,"address":[],"length":0,"stats":{"Line":15420325124116578312}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":15420325124116578312}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":283,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":284,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":285,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":286,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":287,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":288,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":289,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":290,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":291,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":292,"address":[],"length":0,"stats":{"Line":15420325124116578367}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":301,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":306,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":308,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":309,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":311,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":312,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":314,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":315,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":317,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":318,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":10808639105689190406}},{"line":323,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":325,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":326,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":328,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":329,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":330,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":331,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":333,"address":[],"length":0,"stats":{"Line":9367487224930631680}},{"line":334,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":335,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":336,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":339,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":340,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":341,"address":[],"length":0,"stats":{"Line":12538021362599460864}},{"line":342,"address":[],"length":0,"stats":{"Line":12538021362599460864}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":353,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":354,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":356,"address":[],"length":0,"stats":{"Line":14987979559889010688}},{"line":357,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":358,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":359,"address":[],"length":0,"stats":{"Line":8358680908399640719}},{"line":360,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":361,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":362,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":363,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":364,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":365,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":366,"address":[],"length":0,"stats":{"Line":15852670688344146063}},{"line":369,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":372,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":375,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":397,"address":[],"length":0,"stats":{"Line":9655717601082343424}},{"line":398,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":399,"address":[],"length":0,"stats":{"Line":8935141660703064064}},{"line":400,"address":[],"length":0,"stats":{"Line":15420325124116578304}},{"line":402,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":408,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":410,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":411,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":413,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":414,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":416,"address":[],"length":0,"stats":{"Line":14987979559889010696}},{"line":420,"address":[],"length":0,"stats":{"Line":10952754293765046280}},{"line":422,"address":[],"length":0,"stats":{"Line":8358680908399640584}},{"line":423,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":424,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":425,"address":[],"length":0,"stats":{"Line":10952754293765046275}},{"line":426,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":427,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":428,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":430,"address":[],"length":0,"stats":{"Line":10952754293765046277}},{"line":431,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":433,"address":[],"length":0,"stats":{"Line":13258597302978740221}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":3}},{"line":448,"address":[],"length":0,"stats":{"Line":3}},{"line":449,"address":[],"length":0,"stats":{"Line":3}},{"line":450,"address":[],"length":0,"stats":{"Line":3}},{"line":451,"address":[],"length":0,"stats":{"Line":3}},{"line":452,"address":[],"length":0,"stats":{"Line":3}},{"line":456,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":457,"address":[],"length":0,"stats":{"Line":15852670688344145917}},{"line":459,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":461,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":462,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":466,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":467,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":469,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":470,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":471,"address":[],"length":0,"stats":{"Line":16140901064495857664}},{"line":473,"address":[],"length":0,"stats":{"Line":16717361816799281160}},{"line":474,"address":[],"length":0,"stats":{"Line":6917529027641081874}},{"line":475,"address":[],"length":0,"stats":{"Line":12682136550675316745}},{"line":476,"address":[],"length":0,"stats":{"Line":12682136550675316745}},{"line":477,"address":[],"length":0,"stats":{"Line":12682136550675316745}},{"line":486,"address":[],"length":0,"stats":{"Line":11096869481840902145}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":10952754293765046274}},{"line":492,"address":[],"length":0,"stats":{"Line":10952754293765046274}},{"line":493,"address":[],"length":0,"stats":{"Line":10952754293765046274}},{"line":494,"address":[],"length":0,"stats":{"Line":15708555500268290059}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":4395513236313604106}},{"line":535,"address":[],"length":0,"stats":{"Line":4395513236313604106}},{"line":536,"address":[],"length":0,"stats":{"Line":4395513236313604106}},{"line":537,"address":[],"length":0,"stats":{"Line":4395513236313604106}},{"line":538,"address":[],"length":0,"stats":{"Line":4395513236313604106}},{"line":539,"address":[],"length":0,"stats":{"Line":13546827679130452044}},{"line":540,"address":[],"length":0,"stats":{"Line":4395513236313604106}}],"covered":208,"coverable":240},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","src","verifier.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_challenger::{CanObserve, FieldChallenger, GrindingChallenger};\r\nuse p3_commit::Mmcs;\r\nuse p3_field::{ExtensionField, Field, TwoAdicField};\r\nuse p3_matrix::Dimensions;\r\nuse p3_util::reverse_bits_len;\r\n\r\nuse crate::{CommitPhaseProofStep, FriConfig, FriGenericConfig, FriProof};\r\n\r\n#[derive(Debug)]\r\npub enum FriError\u003cCommitMmcsErr, InputError\u003e {\r\n    InvalidProofShape,\r\n    CommitPhaseMmcsError(CommitMmcsErr),\r\n    InputError(InputError),\r\n    FinalPolyMismatch,\r\n    InvalidPowWitness,\r\n}\r\n\r\npub fn verify\u003cG, Val, Challenge, M, Challenger\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    proof: \u0026FriProof\u003cChallenge, M, Challenger::Witness, G::InputProof\u003e,\r\n    challenger: \u0026mut Challenger,\r\n    open_input: impl Fn(usize, \u0026G::InputProof) -\u003e Result\u003cVec\u003c(usize, Challenge)\u003e, G::InputError\u003e,\r\n) -\u003e Result\u003c(), FriError\u003cM::Error, G::InputError\u003e\u003e\r\nwhere\r\n    Val: Field,\r\n    Challenge: ExtensionField\u003cVal\u003e + TwoAdicField,\r\n    M: Mmcs\u003cChallenge\u003e,\r\n    Challenger: FieldChallenger\u003cVal\u003e + GrindingChallenger + CanObserve\u003cM::Commitment\u003e,\r\n    G: FriGenericConfig\u003cChallenge\u003e,\r\n{\r\n    let betas: Vec\u003cChallenge\u003e = proof\r\n        .commit_phase_commits\r\n        .iter()\r\n        .map(|comm| {\r\n            challenger.observe(comm.clone());\r\n            challenger.sample_algebra_element()\r\n        })\r\n        .collect();\r\n\r\n    // Observe all coefficients of the final polynomial.\r\n    proof\r\n        .final_poly\r\n        .iter()\r\n        .for_each(|x| challenger.observe_algebra_element(*x));\r\n\r\n    if proof.query_proofs.len() != config.num_queries {\r\n        return Err(FriError::InvalidProofShape);\r\n    }\r\n\r\n    // Check PoW.\r\n    if !challenger.check_witness(config.proof_of_work_bits, proof.pow_witness) {\r\n        return Err(FriError::InvalidPowWitness);\r\n    }\r\n\r\n    let log_max_height =\r\n        proof.commit_phase_commits.len() + config.log_blowup + config.log_final_poly_len;\r\n\r\n    for qp in \u0026proof.query_proofs {\r\n        let index = challenger.sample_bits(log_max_height + g.extra_query_index_bits());\r\n        let ro = open_input(index, \u0026qp.input_proof).map_err(FriError::InputError)?;\r\n\r\n        debug_assert!(\r\n            ro.iter().tuple_windows().all(|((l, _), (r, _))| l \u003e r),\r\n            \"reduced openings sorted by height descending\"\r\n        );\r\n\r\n        let folded_eval = verify_query(\r\n            g,\r\n            config,\r\n            index \u003e\u003e g.extra_query_index_bits(),\r\n            izip!(\r\n                \u0026betas,\r\n                \u0026proof.commit_phase_commits,\r\n                \u0026qp.commit_phase_openings\r\n            ),\r\n            ro,\r\n            log_max_height,\r\n        )?;\r\n\r\n        let final_poly_index = index \u003e\u003e (proof.commit_phase_commits.len());\r\n\r\n        let mut eval = Challenge::ZERO;\r\n\r\n        // We open the final polynomial at index `final_poly_index`, which corresponds to evaluating\r\n        // the polynomial at x^k, where x is the 2-adic generator of order `max_height` and k is\r\n        // `reverse_bits_len(final_poly_index, log_max_height)`.\r\n        let x = Challenge::two_adic_generator(log_max_height)\r\n            .exp_u64(reverse_bits_len(final_poly_index, log_max_height) as u64);\r\n        let mut x_pow = Challenge::ONE;\r\n\r\n        // Evaluate the final polynomial at x.\r\n        for coeff in \u0026proof.final_poly {\r\n            eval += *coeff * x_pow;\r\n            x_pow *= x;\r\n        }\r\n\r\n        if eval != folded_eval {\r\n            return Err(FriError::FinalPolyMismatch);\r\n        }\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\ntype CommitStep\u003c'a, F, M\u003e = (\r\n    \u0026'a F,\r\n    \u0026'a \u003cM as Mmcs\u003cF\u003e\u003e::Commitment,\r\n    \u0026'a CommitPhaseProofStep\u003cF, M\u003e,\r\n);\r\n\r\nfn verify_query\u003c'a, G, F, M\u003e(\r\n    g: \u0026G,\r\n    config: \u0026FriConfig\u003cM\u003e,\r\n    mut index: usize,\r\n    steps: impl Iterator\u003cItem = CommitStep\u003c'a, F, M\u003e\u003e,\r\n    reduced_openings: Vec\u003c(usize, F)\u003e,\r\n    log_max_height: usize,\r\n) -\u003e Result\u003cF, FriError\u003cM::Error, G::InputError\u003e\u003e\r\nwhere\r\n    F: Field,\r\n    M: Mmcs\u003cF\u003e + 'a,\r\n    G: FriGenericConfig\u003cF\u003e,\r\n{\r\n    let mut folded_eval = F::ZERO;\r\n    let mut ro_iter = reduced_openings.into_iter().peekable();\r\n\r\n    for (log_folded_height, (\u0026beta, comm, opening)) in izip!((0..log_max_height).rev(), steps) {\r\n        if let Some((_, ro)) = ro_iter.next_if(|(lh, _)| *lh == log_folded_height + 1) {\r\n            folded_eval += ro;\r\n        }\r\n\r\n        let index_sibling = index ^ 1;\r\n        let index_pair = index \u003e\u003e 1;\r\n\r\n        let mut evals = vec![folded_eval; 2];\r\n        evals[index_sibling % 2] = opening.sibling_value;\r\n\r\n        let dims = \u0026[Dimensions {\r\n            width: 2,\r\n            height: 1 \u003c\u003c log_folded_height,\r\n        }];\r\n        config\r\n            .mmcs\r\n            .verify_batch(\r\n                comm,\r\n                dims,\r\n                index_pair,\r\n                \u0026[evals.clone()],\r\n                \u0026opening.opening_proof,\r\n            )\r\n            .map_err(FriError::CommitPhaseMmcsError)?;\r\n\r\n        index = index_pair;\r\n\r\n        folded_eval = g.fold_row(index, log_folded_height, beta, evals.into_iter());\r\n    }\r\n\r\n    debug_assert!(\r\n        index \u003c config.blowup() * config.final_poly_len(),\r\n        \"index was {}\",\r\n        index,\r\n    );\r\n    debug_assert!(\r\n        ro_iter.next().is_none(),\r\n        \"verifier reduced_openings were not in descending order?\"\r\n    );\r\n\r\n    Ok(folded_eval)\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":36,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":37,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":39,"address":[],"length":0,"stats":{"Line":6989586621679009797}},{"line":40,"address":[],"length":0,"stats":{"Line":2666130979403333637}},{"line":41,"address":[],"length":0,"stats":{"Line":2666130979403333637}},{"line":46,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":47,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":49,"address":[],"length":0,"stats":{"Line":14843864371813154827}},{"line":51,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":61,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":63,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":14699749183737298947}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":74,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":75,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":76,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":77,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":78,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":79,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":81,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":82,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":8358680908399640579}},{"line":98,"address":[],"length":0,"stats":{"Line":4323455642275676161}},{"line":99,"address":[],"length":0,"stats":{"Line":4323455642275676161}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":116,"address":[],"length":0,"stats":{"Line":13835058055282163953}},{"line":129,"address":[],"length":0,"stats":{"Line":13835058055282163953}},{"line":130,"address":[],"length":0,"stats":{"Line":13835058055282163953}},{"line":132,"address":[],"length":0,"stats":{"Line":14843864371813155058}},{"line":133,"address":[],"length":0,"stats":{"Line":4899916394579099707}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":138,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":140,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":141,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":143,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":144,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":145,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":147,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":148,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":150,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":151,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":152,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":153,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":154,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":156,"address":[],"length":0,"stats":{"Line":1008806316530991106}},{"line":158,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":160,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":163,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":164,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":165,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":169,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":13835058055282163716}}],"covered":57,"coverable":72},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","tests","fri.rs"],"content":"use core::cmp::Reverse;\r\nuse std::marker::PhantomData;\r\n\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_challenger::{CanSampleBits, DuplexChallenger, FieldChallenger};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::{Radix2Dit, TwoAdicSubgroupDft};\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_fri::{prover, verifier, FriConfig, TwoAdicFriGenericConfig};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::util::reverse_matrix_index_bits;\r\nuse p3_matrix::Matrix;\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\r\nuse p3_util::log2_strict_usize;\r\nuse rand::{Rng, SeedableRng};\r\nuse rand_chacha::ChaCha20Rng;\r\n\r\ntype Val = BabyBear;\r\ntype Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\ntype Perm = Poseidon2BabyBear\u003c16\u003e;\r\ntype MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\ntype MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\ntype ValMmcs =\r\n    MerkleTreeMmcs\u003c\u003cVal as Field\u003e::Packing, \u003cVal as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\r\ntype ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\ntype Challenger = DuplexChallenger\u003cVal, Perm, 16, 8\u003e;\r\ntype MyFriConfig = FriConfig\u003cChallengeMmcs\u003e;\r\n\r\nfn get_ldt_for_testing\u003cR: Rng\u003e(rng: \u0026mut R, log_final_poly_len: usize) -\u003e (Perm, MyFriConfig) {\r\n    let perm = Perm::new_from_rng_128(rng);\r\n    let hash = MyHash::new(perm.clone());\r\n    let compress = MyCompress::new(perm.clone());\r\n    let mmcs = ChallengeMmcs::new(ValMmcs::new(hash, compress));\r\n    let fri_config = FriConfig {\r\n        log_blowup: 1,\r\n        log_final_poly_len,\r\n        num_queries: 10,\r\n        proof_of_work_bits: 8,\r\n        mmcs,\r\n    };\r\n    (perm, fri_config)\r\n}\r\n\r\nfn do_test_fri_ldt\u003cR: Rng\u003e(rng: \u0026mut R, log_final_poly_len: usize) {\r\n    let (perm, fc) = get_ldt_for_testing(rng, log_final_poly_len);\r\n    let dft = Radix2Dit::default();\r\n\r\n    let shift = Val::GENERATOR;\r\n\r\n    let ldes: Vec\u003cRowMajorMatrix\u003cVal\u003e\u003e = (5..10)\r\n        .map(|deg_bits| {\r\n            let evals = RowMajorMatrix::\u003cVal\u003e::rand_nonzero(rng, 1 \u003c\u003c deg_bits, 16);\r\n            let mut lde = dft.coset_lde_batch(evals, 1, shift);\r\n            reverse_matrix_index_bits(\u0026mut lde);\r\n            lde\r\n        })\r\n        .collect();\r\n\r\n    let (proof, p_sample) = {\r\n        // Prover world\r\n        let mut chal = Challenger::new(perm.clone());\r\n        let alpha: Challenge = chal.sample_algebra_element();\r\n\r\n        let input: [_; 32] = core::array::from_fn(|log_height| {\r\n            let matrices_with_log_height: Vec\u003c\u0026RowMajorMatrix\u003cVal\u003e\u003e = ldes\r\n                .iter()\r\n                .filter(|m| log2_strict_usize(m.height()) == log_height)\r\n                .collect();\r\n            if matrices_with_log_height.is_empty() {\r\n                None\r\n            } else {\r\n                let reduced: Vec\u003cChallenge\u003e = (0..(1 \u003c\u003c log_height))\r\n                    .map(|r| {\r\n                        alpha\r\n                            .powers()\r\n                            .zip(matrices_with_log_height.iter().flat_map(|m| m.row(r)))\r\n                            .map(|(alpha_pow, v)| alpha_pow * v)\r\n                            .sum()\r\n                    })\r\n                    .collect();\r\n                Some(reduced)\r\n            }\r\n        });\r\n\r\n        let input: Vec\u003cVec\u003cChallenge\u003e\u003e = input.into_iter().rev().flatten().collect();\r\n\r\n        let log_max_height = log2_strict_usize(input[0].len());\r\n\r\n        let proof = prover::prove(\r\n            \u0026TwoAdicFriGenericConfig::\u003cVec\u003c(usize, Challenge)\u003e, ()\u003e(PhantomData),\r\n            \u0026fc,\r\n            input.clone(),\r\n            \u0026mut chal,\r\n            |idx| {\r\n                // As our \"input opening proof\", just pass through the literal reduced openings.\r\n                let mut ro = vec![];\r\n                for v in \u0026input {\r\n                    let log_height = log2_strict_usize(v.len());\r\n                    ro.push((log_height, v[idx \u003e\u003e (log_max_height - log_height)]));\r\n                }\r\n                ro.sort_by_key(|(lh, _)| Reverse(*lh));\r\n                ro\r\n            },\r\n        );\r\n\r\n        (proof, chal.sample_bits(8))\r\n    };\r\n\r\n    let mut v_challenger = Challenger::new(perm);\r\n    let _alpha: Challenge = v_challenger.sample_algebra_element();\r\n    verifier::verify(\r\n        \u0026TwoAdicFriGenericConfig::\u003cVec\u003c(usize, Challenge)\u003e, ()\u003e(PhantomData),\r\n        \u0026fc,\r\n        \u0026proof,\r\n        \u0026mut v_challenger,\r\n        |_index, proof| Ok(proof.clone()),\r\n    )\r\n    .unwrap();\r\n\r\n    assert_eq!(\r\n        p_sample,\r\n        v_challenger.sample_bits(8),\r\n        \"prover and verifier transcript have same state after FRI\"\r\n    );\r\n}\r\n\r\n#[test]\r\nfn test_fri_ldt() {\r\n    // FRI is kind of flaky depending on indexing luck\r\n    for i in 0..4 {\r\n        let mut rng = ChaCha20Rng::seed_from_u64(i as u64);\r\n        do_test_fri_ldt(\u0026mut rng, i + 1);\r\n    }\r\n}\r\n\r\n// This test is expected to panic because the polynomial degree is less than the final_poly_degree in the config.\r\n#[test]\r\n#[should_panic]\r\nfn test_fri_ldt_should_panic() {\r\n    // FRI is kind of flaky depending on indexing luck\r\n    for i in 0..4 {\r\n        let mut rng = ChaCha20Rng::seed_from_u64(i);\r\n        do_test_fri_ldt(\u0026mut rng, 5);\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":33,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":34,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":35,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":36,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":47,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":48,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":49,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":51,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":53,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":54,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":55,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":56,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":57,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":58,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":62,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":64,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":65,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":67,"address":[],"length":0,"stats":{"Line":11889503016258109440}},{"line":68,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":69,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":70,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":71,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":72,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":73,"address":[],"length":0,"stats":{"Line":9727775195120271360}},{"line":75,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":76,"address":[],"length":0,"stats":{"Line":15636497906230362115}},{"line":77,"address":[],"length":0,"stats":{"Line":13835058055282163715}},{"line":78,"address":[],"length":0,"stats":{"Line":13835058055282163715}},{"line":79,"address":[],"length":0,"stats":{"Line":4611686018427387948}},{"line":80,"address":[],"length":0,"stats":{"Line":9223372036854775852}},{"line":81,"address":[],"length":0,"stats":{"Line":13835058055282163715}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":90,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":93,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":94,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":95,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":96,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":97,"address":[],"length":0,"stats":{"Line":3242591731706757740}},{"line":99,"address":[],"length":0,"stats":{"Line":2882303761517118060}},{"line":100,"address":[],"length":0,"stats":{"Line":9223372036854776428}},{"line":101,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":102,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":104,"address":[],"length":0,"stats":{"Line":10376293541461624024}},{"line":105,"address":[],"length":0,"stats":{"Line":2882303761517118060}},{"line":109,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":112,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":113,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":115,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":116,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":117,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":118,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":119,"address":[],"length":0,"stats":{"Line":3602879701896396801}},{"line":123,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":124,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":125,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":58,"coverable":60},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","fri","tests","pcs.rs"],"content":"use itertools::{izip, Itertools};\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_challenger::{CanObserve, DuplexChallenger, FieldChallenger};\r\nuse p3_commit::{ExtensionMmcs, Pcs, PolynomialSpace};\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field::{ExtensionField, Field};\r\nuse p3_fri::{FriConfig, TwoAdicFriPcs};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{Rng, SeedableRng};\r\nuse rand_chacha::ChaCha20Rng;\r\n\r\nfn seeded_rng() -\u003e impl Rng {\r\n    ChaCha20Rng::seed_from_u64(0)\r\n}\r\n\r\nfn do_test_fri_pcs\u003cVal, Challenge, Challenger, P\u003e(\r\n    (pcs, challenger): \u0026(P, Challenger),\r\n    log_degrees_by_round: \u0026[\u0026[usize]],\r\n) where\r\n    P: Pcs\u003cChallenge, Challenger\u003e,\r\n    P::Domain: PolynomialSpace\u003cVal = Val\u003e,\r\n    Val: Field,\r\n    Standard: Distribution\u003cVal\u003e,\r\n    Challenge: ExtensionField\u003cVal\u003e,\r\n    Challenger: Clone + CanObserve\u003cP::Commitment\u003e + FieldChallenger\u003cVal\u003e,\r\n{\r\n    let num_rounds = log_degrees_by_round.len();\r\n    let mut rng = seeded_rng();\r\n\r\n    let mut p_challenger = challenger.clone();\r\n\r\n    let domains_and_polys_by_round = log_degrees_by_round\r\n        .iter()\r\n        .map(|log_degrees| {\r\n            log_degrees\r\n                .iter()\r\n                .map(|\u0026log_degree| {\r\n                    let d = 1 \u003c\u003c log_degree;\r\n                    // random width 5-15\r\n                    let width = 5 + rng.gen_range(0..=10);\r\n                    (\r\n                        pcs.natural_domain_for_degree(d),\r\n                        RowMajorMatrix::\u003cVal\u003e::rand(\u0026mut rng, d, width),\r\n                    )\r\n                })\r\n                .collect_vec()\r\n        })\r\n        .collect_vec();\r\n\r\n    let (commits_by_round, data_by_round): (Vec\u003c_\u003e, Vec\u003c_\u003e) = domains_and_polys_by_round\r\n        .iter()\r\n        .map(|domains_and_polys| pcs.commit(domains_and_polys.clone()))\r\n        .unzip();\r\n    assert_eq!(commits_by_round.len(), num_rounds);\r\n    assert_eq!(data_by_round.len(), num_rounds);\r\n    p_challenger.observe_slice(\u0026commits_by_round);\r\n\r\n    let zeta: Challenge = p_challenger.sample_algebra_element();\r\n\r\n    let points_by_round = log_degrees_by_round\r\n        .iter()\r\n        .map(|log_degrees| vec![vec![zeta]; log_degrees.len()])\r\n        .collect_vec();\r\n    let data_and_points = data_by_round.iter().zip(points_by_round).collect();\r\n    let (opening_by_round, proof) = pcs.open(data_and_points, \u0026mut p_challenger);\r\n    assert_eq!(opening_by_round.len(), num_rounds);\r\n\r\n    // Verify the proof.\r\n    let mut v_challenger = challenger.clone();\r\n    v_challenger.observe_slice(\u0026commits_by_round);\r\n    let verifier_zeta: Challenge = v_challenger.sample_algebra_element();\r\n    assert_eq!(verifier_zeta, zeta);\r\n\r\n    let commits_and_claims_by_round = izip!(\r\n        commits_by_round,\r\n        domains_and_polys_by_round,\r\n        opening_by_round\r\n    )\r\n    .map(|(commit, domains_and_polys, openings)| {\r\n        let claims = domains_and_polys\r\n            .iter()\r\n            .zip(openings)\r\n            .map(|((domain, _), mat_openings)| (*domain, vec![(zeta, mat_openings[0].clone())]))\r\n            .collect_vec();\r\n        (commit, claims)\r\n    })\r\n    .collect_vec();\r\n    assert_eq!(commits_and_claims_by_round.len(), num_rounds);\r\n\r\n    pcs.verify(commits_and_claims_by_round, \u0026proof, \u0026mut v_challenger)\r\n        .unwrap()\r\n}\r\n\r\n// Set it up so we create tests inside a module for each pcs, so we get nice error reports\r\n// specific to a failing PCS.\r\nmacro_rules! make_tests_for_pcs {\r\n    ($p:expr) =\u003e {\r\n        #[test]\r\n        fn single() {\r\n            let p = $p;\r\n            for i in 3..6 {\r\n                $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[i]]);\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn many_equal() {\r\n            let p = $p;\r\n            for i in 5..8 {\r\n                $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[i; 5]]);\r\n                println!(\"{i} ok\");\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn many_different() {\r\n            let p = $p;\r\n            for i in 3..8 {\r\n                let degrees = (3..3 + i).collect::\u003cVec\u003c_\u003e\u003e();\r\n                $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026degrees]);\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn many_different_rev() {\r\n            let p = $p;\r\n            for i in 3..8 {\r\n                let degrees = (3..3 + i).rev().collect::\u003cVec\u003c_\u003e\u003e();\r\n                $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026degrees]);\r\n            }\r\n        }\r\n\r\n        #[test]\r\n        fn multiple_rounds() {\r\n            let p = $p;\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[3]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[3], \u0026[3]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[3], \u0026[2]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[2], \u0026[3]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[3, 4], \u0026[3, 4]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[4, 2], \u0026[4, 2]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[2, 2], \u0026[3, 3]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[3, 3], \u0026[2, 2]]);\r\n            $crate::do_test_fri_pcs(\u0026p, \u0026[\u0026[2], \u0026[3, 3]]);\r\n        }\r\n    };\r\n}\r\n\r\nmod babybear_fri_pcs {\r\n    use super::*;\r\n\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n\r\n    type ValMmcs =\r\n        MerkleTreeMmcs\u003c\u003cVal as Field\u003e::Packing, \u003cVal as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    type Challenger = DuplexChallenger\u003cVal, Perm, 16, 8\u003e;\r\n    type MyPcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n\r\n    fn get_pcs(log_blowup: usize) -\u003e (MyPcs, Challenger) {\r\n        let perm = Perm::new_from_rng_128(\u0026mut seeded_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm.clone());\r\n\r\n        let val_mmcs = ValMmcs::new(hash, compress);\r\n        let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n        let fri_config = FriConfig {\r\n            log_blowup,\r\n            log_final_poly_len: 0,\r\n            num_queries: 10,\r\n            proof_of_work_bits: 8,\r\n            mmcs: challenge_mmcs,\r\n        };\r\n\r\n        let pcs = MyPcs::new(Dft::default(), val_mmcs, fri_config);\r\n        (pcs, Challenger::new(perm.clone()))\r\n    }\r\n\r\n    mod blowup_1 {\r\n        make_tests_for_pcs!(super::get_pcs(1));\r\n    }\r\n    mod blowup_2 {\r\n        make_tests_for_pcs!(super::get_pcs(2));\r\n    }\r\n}\r\n\r\nmod m31_fri_pcs {\r\n    use std::marker::PhantomData;\r\n\r\n    use p3_challenger::{HashChallenger, SerializingChallenger32};\r\n    use p3_circle::CirclePcs;\r\n    use p3_keccak::Keccak256Hash;\r\n    use p3_mersenne_31::Mersenne31;\r\n    use p3_symmetric::{CompressionFunctionFromHasher, SerializingHasher32};\r\n\r\n    use super::*;\r\n\r\n    type Val = Mersenne31;\r\n    type Challenge = BinomialExtensionField\u003cMersenne31, 3\u003e;\r\n\r\n    type ByteHash = Keccak256Hash;\r\n    type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    type Pcs = CirclePcs\u003cVal, ValMmcs, ChallengeMmcs\u003e;\r\n\r\n    fn get_pcs(log_blowup: usize) -\u003e (Pcs, Challenger) {\r\n        let byte_hash = ByteHash {};\r\n        let field_hash = FieldHash::new(byte_hash);\r\n        let compress = MyCompress::new(byte_hash);\r\n        let val_mmcs = ValMmcs::new(field_hash, compress);\r\n        let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n        let fri_config = FriConfig {\r\n            log_blowup,\r\n            log_final_poly_len: 0,\r\n            num_queries: 10,\r\n            proof_of_work_bits: 8,\r\n            mmcs: challenge_mmcs,\r\n        };\r\n        let pcs = Pcs {\r\n            mmcs: val_mmcs,\r\n            fri_config,\r\n            _phantom: PhantomData,\r\n        };\r\n        (pcs, Challenger::from_hasher(vec![], byte_hash))\r\n    }\r\n\r\n    mod blowup_1 {\r\n        make_tests_for_pcs!(super::get_pcs(1));\r\n    }\r\n    mod blowup_2 {\r\n        make_tests_for_pcs!(super::get_pcs(2));\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":7926335344172073833}},{"line":17,"address":[],"length":0,"stats":{"Line":7926335344172073833}},{"line":20,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":31,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":32,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":34,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":36,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":38,"address":[],"length":0,"stats":{"Line":16717361816799281160}},{"line":39,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":40,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":41,"address":[],"length":0,"stats":{"Line":9511602413006487551}},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":44,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":46,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":47,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":50,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":54,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":56,"address":[],"length":0,"stats":{"Line":5476377146882523152}},{"line":58,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":59,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":60,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":62,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":64,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":66,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":68,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":69,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":70,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":73,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":74,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":75,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":76,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":78,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":79,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":80,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":81,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":83,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":84,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":85,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":86,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":87,"address":[],"length":0,"stats":{"Line":576460752303423487}},{"line":88,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":89,"address":[],"length":0,"stats":{"Line":9511602413006487552}},{"line":92,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":94,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711757}},{"line":104,"address":[],"length":0,"stats":{"Line":288230376151711757}},{"line":105,"address":[],"length":0,"stats":{"Line":2882303761517117453}},{"line":106,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":112,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":113,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":114,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":115,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":120,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":122,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":123,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":124,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":130,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":131,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":132,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":133,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":138,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":139,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":141,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":142,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":143,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":144,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":146,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":147,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":148,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":171,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":172,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":173,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":174,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":176,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":177,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":187,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":188,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":226,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":227,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":228,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":229,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":230,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":231,"address":[],"length":0,"stats":{"Line":720575940379279361}},{"line":244,"address":[],"length":0,"stats":{"Line":720575940379279361}}],"covered":89,"coverable":89},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","benches","bench_field.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BatchSize, Criterion};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_add_latency, benchmark_add_throughput, benchmark_inv, benchmark_iter_sum,\r\n    benchmark_sub_latency, benchmark_sub_throughput,\r\n};\r\nuse p3_field_testing::{benchmark_mul_latency, benchmark_mul_throughput};\r\nuse p3_goldilocks::Goldilocks;\r\n\r\ntype F = Goldilocks;\r\n\r\nfn bench_field(c: \u0026mut Criterion) {\r\n    let name = \"Goldilocks\";\r\n    const REPS: usize = 1000;\r\n    benchmark_mul_latency::\u003cF, 100\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cF, 25\u003e(c, name);\r\n    benchmark_inv::\u003cF\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 4, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 8, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 12, REPS\u003e(c, name);\r\n\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const L_REPS: usize = 10 * REPS;\r\n    benchmark_add_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_add_throughput::\u003cF, REPS\u003e(c, name);\r\n    benchmark_sub_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_sub_throughput::\u003cF, REPS\u003e(c, name);\r\n\r\n    c.bench_function(\"7th_root\", |b| {\r\n        b.iter_batched(\r\n            rand::random::\u003cF\u003e,\r\n            |x| x.exp_u64(10540996611094048183),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\nfn bench_packedfield(c: \u0026mut Criterion) {\r\n    let name = type_name::\u003c\u003cF as Field\u003e::Packing\u003e().to_string();\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const REPS: usize = 100;\r\n    const L_REPS: usize = 10 * REPS;\r\n\r\n    benchmark_add_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_add_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_sub_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_sub_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_mul_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_mul_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n}\r\n\r\ncriterion_group!(goldilocks_arithmetic, bench_field, bench_packedfield);\r\ncriterion_main!(goldilocks_arithmetic);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","benches","extension.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_inv, benchmark_mul_latency, benchmark_mul_throughput, benchmark_square,\r\n};\r\nuse p3_goldilocks::Goldilocks;\r\n\r\ntype EF2 = BinomialExtensionField\u003cGoldilocks, 2\u003e;\r\n\r\n// Note that each round of throughput has 10 operations\r\n// So we should have 10 * more repetitions for latency tests.\r\nconst REPS: usize = 50;\r\nconst L_REPS: usize = 10 * REPS;\r\n\r\nfn bench_qudratic_extension(c: \u0026mut Criterion) {\r\n    let name = \"BinomialExtensionField\u003cGoldilocks, 2\u003e\";\r\n    benchmark_square::\u003cEF2\u003e(c, name);\r\n    benchmark_inv::\u003cEF2\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cEF2, REPS\u003e(c, name);\r\n    benchmark_mul_latency::\u003cEF2, L_REPS\u003e(c, name);\r\n}\r\n\r\ncriterion_group!(bench_goldilocks_ef2, bench_qudratic_extension);\r\ncriterion_main!(bench_goldilocks_ef2);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","extension.rs"],"content":"use p3_field::extension::{BinomiallyExtendable, HasTwoAdicBinomialExtension};\r\nuse p3_field::{PrimeCharacteristicRing, TwoAdicField};\r\n\r\nuse crate::Goldilocks;\r\n\r\nimpl BinomiallyExtendable\u003c2\u003e for Goldilocks {\r\n    // Verifiable in Sage with\r\n    // `R.\u003cx\u003e = GF(p)[]; assert (x^2 - 7).is_irreducible()`.\r\n    const W: Self = Self::new(7);\r\n\r\n    // DTH_ROOT = W^((p - 1)/2).\r\n    const DTH_ROOT: Self = Self::new(18446744069414584320);\r\n\r\n    const EXT_GENERATOR: [Self; 2] = [\r\n        Self::new(18081566051660590251),\r\n        Self::new(16121475356294670766),\r\n    ];\r\n}\r\n\r\nimpl HasTwoAdicBinomialExtension\u003c2\u003e for Goldilocks {\r\n    const EXT_TWO_ADICITY: usize = 33;\r\n\r\n    fn ext_two_adic_generator(bits: usize) -\u003e [Self; 2] {\r\n        assert!(bits \u003c= 33);\r\n\r\n        if bits == 33 {\r\n            [Self::ZERO, Self::new(15659105665374529263)]\r\n        } else {\r\n            [Self::two_adic_generator(bits), Self::ZERO]\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_quadratic_extension {\r\n\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::Goldilocks;\r\n\r\n    type F = Goldilocks;\r\n    type EF = BinomialExtensionField\u003cF, 2\u003e;\r\n\r\n    test_field!(super::EF);\r\n\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":3314649325745740571}},{"line":24,"address":[],"length":0,"stats":{"Line":3314649325745740571}},{"line":26,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":3170534137668829184}}],"covered":5,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","goldilocks.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt;\r\nuse core::fmt::{Debug, Display, Formatter};\r\nuse core::hash::{Hash, Hasher};\r\nuse core::intrinsics::transmute;\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse num_bigint::BigUint;\r\nuse p3_field::exponentiation::exp_10540996611094048183;\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{\r\n    halve_u64, quotient_map_large_iint, quotient_map_large_uint, quotient_map_small_int, Field,\r\n    InjectiveMonomial, Packable, PermutationMonomial, PrimeCharacteristicRing, PrimeField,\r\n    PrimeField64, TwoAdicField,\r\n};\r\nuse p3_util::{assume, branch_hint};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// The Goldilocks prime\r\nconst P: u64 = 0xFFFF_FFFF_0000_0001;\r\n\r\n/// The prime field known as Goldilocks, defined as `F_p` where `p = 2^64 - 2^32 + 1`.\r\n///\r\n/// Note that the safety of deriving `Serialize` and `Deserialize` relies on the fact that the internal value can be any u64.\r\n#[derive(Copy, Clone, Default, Serialize, Deserialize)]\r\n#[repr(transparent)] // Packed field implementations rely on this!\r\npub struct Goldilocks {\r\n    /// Not necessarily canonical.\r\n    pub(crate) value: u64,\r\n}\r\n\r\nimpl Goldilocks {\r\n    pub(crate) const fn new(value: u64) -\u003e Self {\r\n        Self { value }\r\n    }\r\n\r\n    /// Convert a constant u64 array into a constant Goldilocks array.\r\n    ///\r\n    /// This is a const version of `.map(Goldilocks::new)`.\r\n    #[inline]\r\n    #[must_use]\r\n    pub(crate) const fn new_array\u003cconst N: usize\u003e(input: [u64; N]) -\u003e [Goldilocks; N] {\r\n        let mut output = [Goldilocks::ZERO; N];\r\n        let mut i = 0;\r\n        loop {\r\n            if i == N {\r\n                break;\r\n            }\r\n            output[i].value = input[i];\r\n            i += 1;\r\n        }\r\n        output\r\n    }\r\n\r\n    /// Two's complement of `ORDER`, i.e. `2^64 - ORDER = 2^32 - 1`.\r\n    const NEG_ORDER: u64 = Self::ORDER_U64.wrapping_neg();\r\n}\r\n\r\nimpl PartialEq for Goldilocks {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        self.as_canonical_u64() == other.as_canonical_u64()\r\n    }\r\n}\r\n\r\nimpl Eq for Goldilocks {}\r\n\r\nimpl Packable for Goldilocks {}\r\n\r\nimpl Hash for Goldilocks {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        state.write_u64(self.as_canonical_u64());\r\n    }\r\n}\r\n\r\nimpl Ord for Goldilocks {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e core::cmp::Ordering {\r\n        self.as_canonical_u64().cmp(\u0026other.as_canonical_u64())\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Goldilocks {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccore::cmp::Ordering\u003e {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\nimpl Display for Goldilocks {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Display::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl Debug for Goldilocks {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Debug::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cGoldilocks\u003e for Standard {\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Goldilocks {\r\n        loop {\r\n            let next_u64 = rng.next_u64();\r\n            let is_canonical = next_u64 \u003c Goldilocks::ORDER_U64;\r\n            if is_canonical {\r\n                return Goldilocks::new(next_u64);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for Goldilocks {\r\n    type PrimeSubfield = Self;\r\n\r\n    const ZERO: Self = Self::new(0);\r\n    const ONE: Self = Self::new(1);\r\n    const TWO: Self = Self::new(2);\r\n    const NEG_ONE: Self = Self::new(Self::ORDER_U64 - 1);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f\r\n    }\r\n\r\n    fn from_bool(b: bool) -\u003e Self {\r\n        Self::new(b.into())\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: repr(transparent) ensures transmutation safety.\r\n        unsafe { transmute(vec![0u64; len]) }\r\n    }\r\n}\r\n\r\n/// Degree of the smallest permutation polynomial for Goldilocks.\r\n///\r\n/// As p - 1 = 2^32 * 3 * 5 * 17 * ... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 7.\r\nimpl InjectiveMonomial\u003c7\u003e for Goldilocks {}\r\n\r\nimpl PermutationMonomial\u003c7\u003e for Goldilocks {\r\n    /// In the field `Goldilocks`, `a^{1/7}` is equal to a^{10540996611094048183}.\r\n    ///\r\n    /// This follows from the calculation `7*10540996611094048183 = 4*(2^64 - 2**32) + 1 = 1 mod (p - 1)`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_10540996611094048183(*self)\r\n    }\r\n}\r\n\r\nimpl Field for Goldilocks {\r\n    // TODO: Add cfg-guarded Packing for NEON\r\n\r\n    #[cfg(all(\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx2\",\r\n        not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n    ))]\r\n    type Packing = crate::PackedGoldilocksAVX2;\r\n\r\n    #[cfg(all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ))]\r\n    type Packing = crate::PackedGoldilocksAVX512;\r\n    #[cfg(not(any(\r\n        all(\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx2\",\r\n            not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n        ),\r\n        all(\r\n            feature = \"nightly-features\",\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx512f\"\r\n        ),\r\n    )))]\r\n    type Packing = Self;\r\n\r\n    // Sage: GF(2^64 - 2^32 + 1).multiplicative_generator()\r\n    const GENERATOR: Self = Self::new(7);\r\n\r\n    fn is_zero(\u0026self) -\u003e bool {\r\n        self.value == 0 || self.value == Self::ORDER_U64\r\n    }\r\n\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\r\n        if self.is_zero() {\r\n            return None;\r\n        }\r\n\r\n        // From Fermat's little theorem, in a prime field `F_p`, the inverse of `a` is `a^(p-2)`.\r\n        //\r\n        // compute a^(p - 2) using 72 multiplications\r\n        // The exponent p - 2 is represented in binary as:\r\n        // 0b1111111111111111111111111111111011111111111111111111111111111111\r\n        // Adapted from: https://github.com/facebook/winterfell/blob/d238a1/math/src/field/f64/mod.rs#L136-L164\r\n\r\n        // compute base^11\r\n        let t2 = self.square() * *self;\r\n\r\n        // compute base^111\r\n        let t3 = t2.square() * *self;\r\n\r\n        // compute base^111111 (6 ones)\r\n        // repeatedly square t3 3 times and multiply by t3\r\n        let t6 = exp_acc::\u003c3\u003e(t3, t3);\r\n        let t60 = t6.square();\r\n        let t7 = t60 * *self;\r\n\r\n        // compute base^111111111111 (12 ones)\r\n        // repeatedly square t6 6 times and multiply by t6\r\n        let t12 = exp_acc::\u003c5\u003e(t60, t6);\r\n\r\n        // compute base^111111111111111111111111 (24 ones)\r\n        // repeatedly square t12 12 times and multiply by t12\r\n        let t24 = exp_acc::\u003c12\u003e(t12, t12);\r\n\r\n        // compute base^1111111111111111111111111111111 (31 ones)\r\n        // repeatedly square t24 6 times and multiply by t6 first. then square t30 and\r\n        // multiply by base\r\n        let t31 = exp_acc::\u003c7\u003e(t24, t7);\r\n\r\n        // compute base^111111111111111111111111111111101111111111111111111111111111111\r\n        // repeatedly square t31 32 times and multiply by t31\r\n        let t63 = exp_acc::\u003c32\u003e(t31, t31);\r\n\r\n        // compute base^1111111111111111111111111111111011111111111111111111111111111111\r\n        Some(t63.square() * *self)\r\n    }\r\n\r\n    #[inline]\r\n    fn halve(\u0026self) -\u003e Self {\r\n        Goldilocks::new(halve_u64::\u003cP\u003e(self.value))\r\n    }\r\n\r\n    #[inline]\r\n    fn order() -\u003e BigUint {\r\n        P.into()\r\n    }\r\n}\r\n\r\n// We use macros to implement QuotientMap\u003cInt\u003e for all integer types except for u64 and i64.\r\nquotient_map_small_int!(Goldilocks, u64, [u8, u16, u32]);\r\nquotient_map_small_int!(Goldilocks, i64, [i8, i16, i32]);\r\nquotient_map_large_uint!(\r\n    Goldilocks,\r\n    u64,\r\n    Goldilocks::ORDER_U64,\r\n    \"`[0, 2^64 - 2^32]`\",\r\n    \"`[0, 2^64 - 1]`\",\r\n    [u128]\r\n);\r\nquotient_map_large_iint!(\r\n    Goldilocks,\r\n    i64,\r\n    \"`[-(2^63 - 2^31), 2^63 - 2^31]`\",\r\n    \"`[1 + 2^32 - 2^64, 2^64 - 1]`\",\r\n    [(i128, u128)]\r\n);\r\n\r\nimpl QuotientMap\u003cu64\u003e for Goldilocks {\r\n    /// Convert a given `u64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// No reduction is needed as the internal value is allowed\r\n    /// to be any u64.\r\n    #[inline]\r\n    fn from_int(int: u64) -\u003e Self {\r\n        Self::new(int)\r\n    }\r\n\r\n    /// Convert a given `u64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// Return `None` if the given integer is greater than `p = 2^64 - 2^32 + 1`.\r\n    #[inline]\r\n    fn from_canonical_checked(int: u64) -\u003e Option\u003cSelf\u003e {\r\n        if int \u003c Self::ORDER_U64 {\r\n            Some(Self::new(int))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `u64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// # Safety\r\n    /// In this case this function is actually always safe as the internal\r\n    /// value is allowed to be any u64.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: u64) -\u003e Goldilocks {\r\n        Self::new(int)\r\n    }\r\n}\r\n\r\nimpl QuotientMap\u003ci64\u003e for Goldilocks {\r\n    /// Convert a given `i64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// We simply need to deal with the sign.\r\n    #[inline]\r\n    fn from_int(int: i64) -\u003e Self {\r\n        if int \u003e= 0 {\r\n            Self::new(int as u64)\r\n        } else {\r\n            Self::new(Self::ORDER_U64.wrapping_add_signed(int))\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// Returns none if the input does not lie in the range `(-(2^63 - 2^31), 2^63 - 2^31)`.\r\n    #[inline]\r\n    fn from_canonical_checked(int: i64) -\u003e Option\u003cGoldilocks\u003e {\r\n        const POS_BOUND: i64 = (P \u003e\u003e 1) as i64;\r\n        const NEG_BOUND: i64 = -POS_BOUND;\r\n        match int {\r\n            0..=POS_BOUND =\u003e Some(Self::new(int as u64)),\r\n            NEG_BOUND..0 =\u003e Some(Self::new(Self::ORDER_U64.wrapping_add_signed(int))),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i64` integer into an element of the `Goldilocks` field.\r\n    ///\r\n    /// # Safety\r\n    /// In this case this function is actually always safe as the internal\r\n    /// value is allowed to be any u64.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: i64) -\u003e Goldilocks {\r\n        Self::from_int(int)\r\n    }\r\n}\r\n\r\nimpl PrimeField for Goldilocks {\r\n    fn as_canonical_biguint(\u0026self) -\u003e BigUint {\r\n        \u003cSelf as PrimeField64\u003e::as_canonical_u64(self).into()\r\n    }\r\n}\r\n\r\nimpl PrimeField64 for Goldilocks {\r\n    const ORDER_U64: u64 = P;\r\n\r\n    #[inline]\r\n    fn as_canonical_u64(\u0026self) -\u003e u64 {\r\n        let mut c = self.value;\r\n        // We only need one condition subtraction, since 2 * ORDER would not fit in a u64.\r\n        if c \u003e= Self::ORDER_U64 {\r\n            c -= Self::ORDER_U64;\r\n        }\r\n        c\r\n    }\r\n}\r\n\r\nimpl TwoAdicField for Goldilocks {\r\n    const TWO_ADICITY: usize = 32;\r\n\r\n    fn two_adic_generator(bits: usize) -\u003e Self {\r\n        assert!(bits \u003c= Self::TWO_ADICITY);\r\n        let base = Self::new(1_753_635_133_440_165_772); // generates the whole 2^TWO_ADICITY group\r\n        base.exp_power_of_2(Self::TWO_ADICITY - bits)\r\n    }\r\n}\r\n\r\nimpl Add for Goldilocks {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let (sum, over) = self.value.overflowing_add(rhs.value);\r\n        let (mut sum, over) = sum.overflowing_add(u64::from(over) * Self::NEG_ORDER);\r\n        if over {\r\n            // NB: self.value \u003e Self::ORDER \u0026\u0026 rhs.value \u003e Self::ORDER is necessary but not\r\n            // sufficient for double-overflow.\r\n            // This assume does two things:\r\n            //  1. If compiler knows that either self.value or rhs.value \u003c= ORDER, then it can skip\r\n            //     this check.\r\n            //  2. Hints to the compiler how rare this double-overflow is (thus handled better with\r\n            //     a branch).\r\n            assume(self.value \u003e Self::ORDER_U64 \u0026\u0026 rhs.value \u003e Self::ORDER_U64);\r\n            branch_hint();\r\n            sum += Self::NEG_ORDER; // Cannot overflow.\r\n        }\r\n        Self::new(sum)\r\n    }\r\n}\r\n\r\nimpl AddAssign for Goldilocks {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for Goldilocks {\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        // This is faster than iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO) for iterators of length \u003e 2.\r\n\r\n        // This sum will not overflow so long as iter.len() \u003c 2^64.\r\n        let sum = iter.map(|x| x.value as u128).sum::\u003cu128\u003e();\r\n        reduce128(sum)\r\n    }\r\n}\r\n\r\nimpl Sub for Goldilocks {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let (diff, under) = self.value.overflowing_sub(rhs.value);\r\n        let (mut diff, under) = diff.overflowing_sub(u64::from(under) * Self::NEG_ORDER);\r\n        if under {\r\n            // NB: self.value \u003c NEG_ORDER - 1 \u0026\u0026 rhs.value \u003e ORDER is necessary but not\r\n            // sufficient for double-underflow.\r\n            // This assume does two things:\r\n            //  1. If compiler knows that either self.value \u003e= NEG_ORDER - 1 or rhs.value \u003c= ORDER,\r\n            //     then it can skip this check.\r\n            //  2. Hints to the compiler how rare this double-underflow is (thus handled better\r\n            //     with a branch).\r\n            assume(self.value \u003c Self::NEG_ORDER - 1 \u0026\u0026 rhs.value \u003e Self::ORDER_U64);\r\n            branch_hint();\r\n            diff -= Self::NEG_ORDER; // Cannot underflow.\r\n        }\r\n        Self::new(diff)\r\n    }\r\n}\r\n\r\nimpl SubAssign for Goldilocks {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Neg for Goldilocks {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self::Output {\r\n        Self::new(Self::ORDER_U64 - self.as_canonical_u64())\r\n    }\r\n}\r\n\r\nimpl Mul for Goldilocks {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        reduce128(u128::from(self.value) * u128::from(rhs.value))\r\n    }\r\n}\r\n\r\nimpl MulAssign for Goldilocks {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl Product for Goldilocks {\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl Div for Goldilocks {\r\n    type Output = Self;\r\n\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    fn div(self, rhs: Self) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\n/// Squares the base N number of times and multiplies the result by the tail value.\r\n#[inline(always)]\r\nfn exp_acc\u003cconst N: usize\u003e(base: Goldilocks, tail: Goldilocks) -\u003e Goldilocks {\r\n    base.exp_power_of_2(N) * tail\r\n}\r\n\r\n/// Reduces to a 64-bit value. The result might not be in canonical form; it could be in between the\r\n/// field order and `2^64`.\r\n#[inline]\r\npub(crate) fn reduce128(x: u128) -\u003e Goldilocks {\r\n    let (x_lo, x_hi) = split(x); // This is a no-op\r\n    let x_hi_hi = x_hi \u003e\u003e 32;\r\n    let x_hi_lo = x_hi \u0026 Goldilocks::NEG_ORDER;\r\n\r\n    let (mut t0, borrow) = x_lo.overflowing_sub(x_hi_hi);\r\n    if borrow {\r\n        branch_hint(); // A borrow is exceedingly rare. It is faster to branch.\r\n        t0 -= Goldilocks::NEG_ORDER; // Cannot underflow.\r\n    }\r\n    let t1 = x_hi_lo * Goldilocks::NEG_ORDER;\r\n    let t2 = unsafe { add_no_canonicalize_trashing_input(t0, t1) };\r\n    Goldilocks::new(t2)\r\n}\r\n\r\n#[inline]\r\n#[allow(clippy::cast_possible_truncation)]\r\nconst fn split(x: u128) -\u003e (u64, u64) {\r\n    (x as u64, (x \u003e\u003e 64) as u64)\r\n}\r\n\r\n/// Fast addition modulo ORDER for x86-64.\r\n/// This function is marked unsafe for the following reasons:\r\n///   - It is only correct if x + y \u003c 2**64 + ORDER = 0x1ffffffff00000001.\r\n///   - It is only faster in some circumstances. In particular, on x86 it overwrites both inputs in\r\n///     the registers, so its use is not recommended when either input will be used again.\r\n#[inline(always)]\r\n#[cfg(target_arch = \"x86_64\")]\r\nunsafe fn add_no_canonicalize_trashing_input(x: u64, y: u64) -\u003e u64 {\r\n    let res_wrapped: u64;\r\n    let adjustment: u64;\r\n    core::arch::asm!(\r\n        \"add {0}, {1}\",\r\n        // Trick. The carry flag is set iff the addition overflowed.\r\n        // sbb x, y does x := x - y - CF. In our case, x and y are both {1:e}, so it simply does\r\n        // {1:e} := 0xffffffff on overflow and {1:e} := 0 otherwise. {1:e} is the low 32 bits of\r\n        // {1}; the high 32-bits are zeroed on write. In the end, we end up with 0xffffffff in {1}\r\n        // on overflow; this happens be NEG_ORDER.\r\n        // Note that the CPU does not realize that the result of sbb x, x does not actually depend\r\n        // on x. We must write the result to a register that we know to be ready. We have a\r\n        // dependency on {1} anyway, so let's use it.\r\n        \"sbb {1:e}, {1:e}\",\r\n        inlateout(reg) x =\u003e res_wrapped,\r\n        inlateout(reg) y =\u003e adjustment,\r\n        options(pure, nomem, nostack),\r\n    );\r\n    assume(x != 0 || (res_wrapped == y \u0026\u0026 adjustment == 0));\r\n    assume(y != 0 || (res_wrapped == x \u0026\u0026 adjustment == 0));\r\n    // Add NEG_ORDER == subtract ORDER.\r\n    // Cannot overflow unless the assumption if x + y \u003c 2**64 + ORDER is incorrect.\r\n    res_wrapped + adjustment\r\n}\r\n\r\n#[inline(always)]\r\n#[cfg(not(target_arch = \"x86_64\"))]\r\nunsafe fn add_no_canonicalize_trashing_input(x: u64, y: u64) -\u003e u64 {\r\n    let (res_wrapped, carry) = x.overflowing_add(y);\r\n    // Below cannot overflow unless the assumption if x + y \u003c 2**64 + ORDER is incorrect.\r\n    res_wrapped + Goldilocks::NEG_ORDER * u64::from(carry)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::{\r\n        test_field, test_field_dft, test_prime_field, test_prime_field_64, test_two_adic_field,\r\n    };\r\n\r\n    use super::*;\r\n\r\n    type F = Goldilocks;\r\n\r\n    #[test]\r\n    fn test_goldilocks() {\r\n        let f = F::new(100);\r\n        assert_eq!(f.as_canonical_u64(), 100);\r\n\r\n        // Over the Goldilocks field, the following set of equations hold\r\n        // p               = 0\r\n        // 2^64 - 2^32 + 1 = 0\r\n        // 2^64            = 2^32 - 1\r\n        let f = F::new(u64::MAX);\r\n        assert_eq!(f.as_canonical_u64(), u32::MAX as u64 - 1);\r\n\r\n        let f = F::from_u64(u64::MAX);\r\n        assert_eq!(f.as_canonical_u64(), u32::MAX as u64 - 1);\r\n\r\n        // Generator check\r\n        let expected_multiplicative_group_generator = F::new(7);\r\n        assert_eq!(F::GENERATOR, expected_multiplicative_group_generator);\r\n        assert_eq!(F::GENERATOR.as_canonical_u64(), 7_u64);\r\n\r\n        // Check on `reduce_u128`\r\n        let x = u128::MAX;\r\n        let y = reduce128(x);\r\n        // The following equalitiy sequence holds, modulo p = 2^64 - 2^32 + 1\r\n        // 2^128 - 1 = (2^64 - 1) * (2^64 + 1)\r\n        //           = (2^32 - 1 - 1) * (2^32 - 1 + 1)\r\n        //           = (2^32 - 2) * (2^32)\r\n        //           = 2^64 - 2 * 2^32\r\n        //           = 2^64 - 2^33\r\n        //           = 2^32 - 1 - 2^33\r\n        //           = - 2^32 - 1\r\n        let expected_result = -F::TWO.exp_power_of_2(5) - F::ONE;\r\n        assert_eq!(y, expected_result);\r\n\r\n        let f = F::new(100);\r\n        assert_eq!(f.injective_exp_n().injective_exp_root_n(), f);\r\n        assert_eq!(y.injective_exp_n().injective_exp_root_n(), y);\r\n        assert_eq!(F::TWO.injective_exp_n().injective_exp_root_n(), F::TWO);\r\n    }\r\n\r\n    test_field!(crate::Goldilocks);\r\n    test_prime_field!(crate::Goldilocks);\r\n    test_prime_field_64!(crate::Goldilocks);\r\n    test_two_adic_field!(crate::Goldilocks);\r\n\r\n    test_field_dft!(radix2dit, crate::Goldilocks, p3_dft::Radix2Dit\u003c_\u003e);\r\n    test_field_dft!(bowers, crate::Goldilocks, p3_dft::Radix2Bowers);\r\n    test_field_dft!(\r\n        parallel,\r\n        crate::Goldilocks,\r\n        p3_dft::Radix2DitParallel\u003ccrate::Goldilocks\u003e\r\n    );\r\n}\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":17221764975064776704}},{"line":46,"address":[],"length":0,"stats":{"Line":3242591731706757384}},{"line":47,"address":[],"length":0,"stats":{"Line":3242591731706757384}},{"line":48,"address":[],"length":0,"stats":{"Line":3242591731706757384}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":51,"address":[],"length":0,"stats":{"Line":3242591731706757384}},{"line":53,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":54,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":56,"address":[],"length":0,"stats":{"Line":3242591731706757384}},{"line":64,"address":[],"length":0,"stats":{"Line":504403158266422340}},{"line":65,"address":[],"length":0,"stats":{"Line":504403158266422340}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151712222}},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151712222}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":14339461213547659719}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":14339461213547660174}},{"line":107,"address":[],"length":0,"stats":{"Line":14339461213547660174}},{"line":108,"address":[],"length":0,"stats":{"Line":14339461213547660174}},{"line":109,"address":[],"length":0,"stats":{"Line":14339461213547659719}},{"line":124,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":125,"address":[],"length":0,"stats":{"Line":13546827679130451968}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":135,"address":[],"length":0,"stats":{"Line":720575940379279364}},{"line":148,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":150,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":187,"address":[],"length":0,"stats":{"Line":17149707381026848768}},{"line":188,"address":[],"length":0,"stats":{"Line":15780613094306217972}},{"line":191,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":192,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927945}},{"line":204,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":207,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":211,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":212,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":213,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":217,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":221,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":226,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":230,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":233,"address":[],"length":0,"stats":{"Line":360287970189639671}},{"line":237,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":238,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":242,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":243,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":272,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":273,"address":[],"length":0,"stats":{"Line":9439544818968559616}},{"line":280,"address":[],"length":0,"stats":{"Line":1369094286720630795}},{"line":281,"address":[],"length":0,"stats":{"Line":1369094286720630795}},{"line":282,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":284,"address":[],"length":0,"stats":{"Line":216172782113783819}},{"line":294,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":295,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":304,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":305,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":306,"address":[],"length":0,"stats":{"Line":7349874591868649472}},{"line":308,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":316,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":319,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":320,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":321,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":322,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":332,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":333,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":348,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":350,"address":[],"length":0,"stats":{"Line":8142508126285857729}},{"line":351,"address":[],"length":0,"stats":{"Line":2954361355555046337}},{"line":353,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":360,"address":[],"length":0,"stats":{"Line":15276209936040722444}},{"line":361,"address":[],"length":0,"stats":{"Line":15276209936040722444}},{"line":362,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":363,"address":[],"length":0,"stats":{"Line":15276209936040722433}},{"line":371,"address":[],"length":0,"stats":{"Line":11817445422220181505}},{"line":372,"address":[],"length":0,"stats":{"Line":11817445422220181505}},{"line":373,"address":[],"length":0,"stats":{"Line":11817445422220181505}},{"line":374,"address":[],"length":0,"stats":{"Line":11817445422220181505}},{"line":382,"address":[],"length":0,"stats":{"Line":395970}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":11817445422219785535}},{"line":392,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":393,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":398,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":402,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":403,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":411,"address":[],"length":0,"stats":{"Line":16933534598913458330}},{"line":412,"address":[],"length":0,"stats":{"Line":16933534598913458330}},{"line":413,"address":[],"length":0,"stats":{"Line":16933534598913458330}},{"line":414,"address":[],"length":0,"stats":{"Line":16933534598913458330}},{"line":422,"address":[],"length":0,"stats":{"Line":2582}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":16933534598913455748}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":442,"address":[],"length":0,"stats":{"Line":2377900603251621888}},{"line":450,"address":[],"length":0,"stats":{"Line":2666130979403333639}},{"line":451,"address":[],"length":0,"stats":{"Line":2666130979403333639}},{"line":457,"address":[],"length":0,"stats":{"Line":9295429630893231496}},{"line":458,"address":[],"length":0,"stats":{"Line":9295429630893231496}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":432345564227698955}},{"line":473,"address":[],"length":0,"stats":{"Line":432345564227698955}},{"line":479,"address":[],"length":0,"stats":{"Line":1801439850948198436}},{"line":480,"address":[],"length":0,"stats":{"Line":1801439850948198436}},{"line":486,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":487,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":488,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":489,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":491,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":492,"address":[],"length":0,"stats":{"Line":3242591731707284892}},{"line":493,"address":[],"length":0,"stats":{"Line":14987979559889538448}},{"line":494,"address":[],"length":0,"stats":{"Line":14987979559889538448}},{"line":496,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":497,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":498,"address":[],"length":0,"stats":{"Line":6701356245527298060}},{"line":503,"address":[],"length":0,"stats":{"Line":6701356245527299050}},{"line":504,"address":[],"length":0,"stats":{"Line":6701356245527299050}},{"line":514,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":515,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":516,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":517,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":518,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":527,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":528,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":529,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":530,"address":[],"length":0,"stats":{"Line":16212958658534313361}},{"line":532,"address":[],"length":0,"stats":{"Line":648518346342406809}},{"line":533,"address":[],"length":0,"stats":{"Line":10880696699728700265}},{"line":536,"address":[],"length":0,"stats":{"Line":16212958658534313494}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}}],"covered":123,"coverable":148},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","lib.rs"],"content":"//! The prime field known as Goldilocks, defined as `F_p` where `p = 2^64 - 2^32 + 1`.\r\n\r\n#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nextern crate alloc;\r\n\r\nmod extension;\r\nmod goldilocks;\r\nmod mds;\r\nmod poseidon2;\r\n\r\npub use goldilocks::*;\r\npub use mds::*;\r\npub use poseidon2::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\nmod x86_64_avx2;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use x86_64_avx2::*;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\nmod x86_64_avx512;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use x86_64_avx512::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","mds.rs"],"content":"//! MDS matrices over the Goldilocks field, and permutations defined by them.\r\n//!\r\n//! NB: Not all sizes have fast implementations of their permutations.\r\n//! Supported sizes: 8, 12, 16, 24, 32, 64, 68.\r\n//! Sizes 8 and 12 are from Plonky2, size 16 was found as part of concurrent\r\n//! work by Angus Gruen and Hamish Ivey-Law. Other sizes are from Ulrich Habck's\r\n//! database.\r\n\r\nuse p3_dft::Radix2Bowers;\r\nuse p3_mds::karatsuba_convolution::Convolve;\r\nuse p3_mds::util::{apply_circulant, apply_circulant_fft, first_row_to_first_col};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\n\r\nuse crate::{reduce128, Goldilocks};\r\n\r\n#[derive(Clone, Debug, Default)]\r\npub struct MdsMatrixGoldilocks;\r\n\r\n/// Instantiate convolution for \"small\" RHS vectors over Goldilocks.\r\n///\r\n/// Here \"small\" means N = len(rhs) \u003c= 16 and sum(r for r in rhs) \u003c\r\n/// 2^51, though in practice the sum will be less than 2^9.\r\n#[derive(Debug)]\r\npub struct SmallConvolveGoldilocks;\r\nimpl Convolve\u003cGoldilocks, i128, i64, i128\u003e for SmallConvolveGoldilocks {\r\n    /// Return the lift of a Goldilocks element, 0 \u003c= input.value \u003c= P\r\n    /// \u003c 2^64. We widen immediately, since some valid Goldilocks elements\r\n    /// don't fit in an i64, and since in any case overflow can occur\r\n    /// for even the smallest convolutions.\r\n    #[inline(always)]\r\n    fn read(input: Goldilocks) -\u003e i128 {\r\n        input.value as i128\r\n    }\r\n\r\n    /// For a convolution of size N, |x| \u003c N * 2^64 and (as per the\r\n    /// assumption above), |y| \u003c 2^51. So the product is at most N *\r\n    /// 2^115 which will not overflow for N \u003c= 16. We widen `y` at\r\n    /// this point to perform the multiplication.\r\n    #[inline(always)]\r\n    fn parity_dot\u003cconst N: usize\u003e(u: [i128; N], v: [i64; N]) -\u003e i128 {\r\n        let mut s = 0i128;\r\n        for i in 0..N {\r\n            s += u[i] * v[i] as i128;\r\n        }\r\n        s\r\n    }\r\n\r\n    /// The assumptions above mean z \u003c N^2 * 2^115, which is at most\r\n    /// 2^123 when N \u003c= 16.\r\n    ///\r\n    /// NB: Even though intermediate values could be negative, the\r\n    /// output must be non-negative since the inputs were\r\n    /// non-negative.\r\n    #[inline(always)]\r\n    fn reduce(z: i128) -\u003e Goldilocks {\r\n        debug_assert!(z \u003e= 0);\r\n        reduce128(z as u128)\r\n    }\r\n}\r\n\r\nconst FFT_ALGO: Radix2Bowers = Radix2Bowers;\r\n\r\npub(crate) const MATRIX_CIRC_MDS_8_SML_ROW: [i64; 8] = [7, 1, 3, 8, 8, 3, 4, 9];\r\n\r\nimpl Permutation\u003c[Goldilocks; 8]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 8]) -\u003e [Goldilocks; 8] {\r\n        const MATRIX_CIRC_MDS_8_SML_COL: [i64; 8] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_8_SML_ROW);\r\n        SmallConvolveGoldilocks::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_8_SML_COL,\r\n            SmallConvolveGoldilocks::conv8,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 8]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 8\u003e for MdsMatrixGoldilocks {}\r\n\r\npub(crate) const MATRIX_CIRC_MDS_12_SML_ROW: [i64; 12] = [1, 1, 2, 1, 8, 9, 10, 7, 5, 9, 4, 10];\r\n\r\nimpl Permutation\u003c[Goldilocks; 12]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 12]) -\u003e [Goldilocks; 12] {\r\n        const MATRIX_CIRC_MDS_12_SML_COL: [i64; 12] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_12_SML_ROW);\r\n        SmallConvolveGoldilocks::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_12_SML_COL,\r\n            SmallConvolveGoldilocks::conv12,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 12]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 12\u003e for MdsMatrixGoldilocks {}\r\n\r\npub(crate) const MATRIX_CIRC_MDS_16_SML_ROW: [i64; 16] =\r\n    [1, 1, 51, 1, 11, 17, 2, 1, 101, 63, 15, 2, 67, 22, 13, 3];\r\n\r\nimpl Permutation\u003c[Goldilocks; 16]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 16]) -\u003e [Goldilocks; 16] {\r\n        const MATRIX_CIRC_MDS_16_SML_COL: [i64; 16] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_16_SML_ROW);\r\n        SmallConvolveGoldilocks::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_16_SML_COL,\r\n            SmallConvolveGoldilocks::conv16,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 16]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 16\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[rustfmt::skip]\r\npub(crate) const MATRIX_CIRC_MDS_24_GOLDILOCKS: [u64; 24] = [\r\n    0x5FFFFFFFA00AAAAB, 0x24021AB75BBFE656, 0x7BE9082D73B06DF5, 0x2282863E9C3A5A62,\r\n    0xE0071C70DFFC71C8, 0x796CB65AB42A1A63, 0xDBBBBFFADFFDDDE3, 0x23B88EE217C5C9C2,\r\n    0x20030C309FFB6DB7, 0x23C3C64763BE1E1D, 0x0F93B7C9CC51362E, 0xC697A1094BD0850A,\r\n    0xDFFFFFFF1FFC71C8, 0xC15A4FD614950302, 0xC41D883A4C4DEDF2, 0x187879BC23C46462,\r\n    0x5FFCF3CEDFFE79E8, 0x1C41DF105B82398E, 0x64444003DFFDDDDA, 0x76EDDBB6F7E51F95,\r\n    0x1FF8E38E20038E39, 0x214139BD5C40A09D, 0x3065B7CCF3B3B621, 0x23B6F4622485CEDC,\r\n];\r\n\r\nimpl Permutation\u003c[Goldilocks; 24]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 24]) -\u003e [Goldilocks; 24] {\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_24_GOLDILOCKS, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 24]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 24\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[rustfmt::skip]\r\nconst MATRIX_CIRC_MDS_32_GOLDILOCKS: [u64; 32] = [\r\n    0x0800000000000000, 0x69249248B4924925, 0x3ABD5EAF15EAF57B, 0x294A5294739CE73A,\r\n    0x59E2D2CEB4B3C5A6, 0x087FBE00FF7C0220, 0xA554AA94A554AA96, 0xF00080FEFFDF8005,\r\n    0x64CCCCCC6666699A, 0x5B13AD8973B139D9, 0xAD4A55ACA54AD5AA, 0xDA496DA3B492DB8A,\r\n    0x4AD696955A5694B5, 0xA4A6B29A25B496D3, 0xA74EA162162BD3A9, 0xC698B3A5662CE98C,\r\n    0xA7FFFFFF55555556, 0x4AAAAAAA5AAAAAAB, 0xB047DC113DC11F71, 0x8BA2E8B99B26C9B3,\r\n    0xD259696C5A5B4D2E, 0xA7D540AA557EA9F6, 0x8B6E922D26DB249C, 0xFAAA805455602AAD,\r\n    0xCB33333266666334, 0xD13B17619B13B277, 0x45B26D9326E9374A, 0x52AB552A5AA9556B,\r\n    0x68ED2D2DB4B87697, 0x8B264C98A74E9D3B, 0x09EC23D83D847B09, 0x2C9A4D26669349A5,\r\n];\r\n\r\nimpl Permutation\u003c[Goldilocks; 32]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 32]) -\u003e [Goldilocks; 32] {\r\n        const ENTRIES: [u64; 32] = first_row_to_first_col(\u0026MATRIX_CIRC_MDS_32_GOLDILOCKS);\r\n        apply_circulant_fft(FFT_ALGO, ENTRIES, \u0026input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 32]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 32\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[rustfmt::skip]\r\nconst MATRIX_CIRC_MDS_64_GOLDILOCKS: [u64; 64] = [\r\n    0x07FFFFFFFC000000, 0xFBFFFFFF04000001, 0x436DB6DB25B6DB6E, 0x4AAAAAAA5AAAAAAB,\r\n    0x45B2D96C6D96CB66, 0x3BC7BC7B87BC7BC8, 0x6318C63125294A53, 0xCB3672CCCD9CB368,\r\n    0xB43CB5A12D68796C, 0xFBFBFBFAFBFBFBFD, 0x883DBF107B7E2210, 0x8A7689B59B629DA3,\r\n    0xF7FEFFDF00000001, 0x7B7C83BBC83BC47C, 0xEFF0410107EF7F83, 0x2CD8B3629CB272CA,\r\n    0x9800019900CCCE67, 0xFBFFFBFF07FFFC01, 0x94EC4A758C4EC628, 0xDA5A5B4A6D2D2E1F,\r\n    0xFFEFC080FC003FFF, 0xBC387BC2C783BC79, 0xB492DB686D24B6F3, 0x1DB6925B4B6E2477,\r\n    0x7801E0EF87BFFF10, 0xFC0803FAFBFC0409, 0x3780FE03C086F21C, 0x8B749B224DB22D94,\r\n    0x32648B36B76E9923, 0x3BC3C3C387C3C3C4, 0x79AF286B4FCA1AF3, 0x9E2762758B627628,\r\n    0x52AAAAAA56AAAAAB, 0xFBFFFFFEFC000001, 0xF7FFFFFF08000001, 0x2CCCCCCC9CCCCCCD,\r\n    0xCF286BC946BCA1B0, 0xBC483B7B883B7C49, 0xD9364D9287C1F07D, 0xAD5A94A8A95AD5AA,\r\n    0xFF871002C400F1E1, 0xFC03FC02FC03FC05, 0xD29495A4D6D4B4A6, 0x6C926DD1DD24DB65,\r\n    0x1EDC247B4DB64937, 0x7C7B843B47BC437D, 0xA55A95AAAD5AD52C, 0x4A96D5A45AD694A6,\r\n    0xFE6664CBCD999801, 0xFC0003FF08000401, 0x1EC4F09D64EC4D8A, 0x9E1E1D2C8B4B4A5B,\r\n    0xD9270937709B64DC, 0x3BB77C4448843B78, 0xFFFFFFDF03FF0021, 0x59D8761D2D8A6299,\r\n    0xC3496878A5E5A4B5, 0xFBF80402FC0403F9, 0x5ECD9B360E142851, 0x6D925D6429D64976,\r\n    0xA8AE615C19CC2B99, 0xBC44444388444445, 0xDFE3F1F81CFC7E40, 0xDA4924916D24924A,\r\n];\r\n\r\nimpl Permutation\u003c[Goldilocks; 64]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 64]) -\u003e [Goldilocks; 64] {\r\n        const ENTRIES: [u64; 64] = first_row_to_first_col(\u0026MATRIX_CIRC_MDS_64_GOLDILOCKS);\r\n        apply_circulant_fft(FFT_ALGO, ENTRIES, \u0026input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 64]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 64\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[rustfmt::skip]\r\nconst MATRIX_CIRC_MDS_68_GOLDILOCKS: [u64; 68] = [\r\n    0x03C3C3C3FC3C3C3C, 0x6799AFC54A69BC7D, 0xDA8C2C496A74B03B, 0x1E641D7AB35ED229,\r\n    0x9239DA20DA3A2686, 0x6E23D41459EBA8C4, 0x7BC412896E2A6B3A, 0x9082059089ABD4FC,\r\n    0x94A16FA8B0339EEE, 0x85650EC91BB519C9, 0x1600745267E94DE1, 0xFFFD8405C82020AB,\r\n    0x21BDE80429DCED6A, 0x8ACE123AF754E343, 0xFFC7211605D2BDAE, 0xC21187AE15900F4D,\r\n    0x9C4A889708568DC6, 0x65A5A726B5758D8E, 0x949DB90B9AC0D11A, 0x23B6CF7C368BBE52,\r\n    0xD5128DDF59CB5A35, 0xF53BCC5BDADF3A0A, 0xBA7C5112F4BAB1CD, 0x4B93989C5B729351,\r\n    0x6534B7E50E4AD1CB, 0x640061B54C918405, 0x0E66E1F90D2C9311, 0x31C8649B0FE7557F,\r\n    0x0E9190D165F4A8F3, 0x52DF336BB708F919, 0x3C0F6697F14065A5, 0xBE8190942EC50031,\r\n    0x60038E9ACC701118, 0x73F105909A55A88B, 0xFEBEBEBDABEBEBED, 0x6F52163A64B03467,\r\n    0xFBAE131F23A12F56, 0x1950493BC70D0676, 0x2886550DB5A1BBBF, 0x15B003D6E58181D7,\r\n    0x3A4E7D9D44F100F8, 0x6CC3AB896025E6A0, 0x7E23E68456F825E5, 0x079CDD570B591A16,\r\n    0xEC15A830C3D2CCD1, 0xCF4C722D2C0F8A0E, 0xC1BB6F5591B59A26, 0xB63A5931A607BDE0,\r\n    0x43A0AD0B71040187, 0x7E4B492889D1CEE0, 0x734153F3F0C31C5B, 0x98D8D756B2725A5B,\r\n    0x5589D20D74BA00B8, 0xB2DF58DF0A312509, 0xFABC378690D64A3A, 0x700640AFC244B695,\r\n    0xFFA652236547F3BE, 0x2B9CA498A001D059, 0x7DACA6F16787D5DE, 0xAAAD774FAC613EA3,\r\n    0xA88583816975CD56, 0x78B71DC516FF49CA, 0xC7BF095DF702FFA6, 0x78A60B3F971783B3,\r\n    0xCB158EF40BC75CAC, 0xA97E818DBC152B4C, 0x9FC8339D415C3999, 0x006A88C0A0D8201C,\r\n];\r\n\r\nimpl Permutation\u003c[Goldilocks; 68]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [Goldilocks; 68]) -\u003e [Goldilocks; 68] {\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_68_GOLDILOCKS, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Goldilocks; 68]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cGoldilocks, 68\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n\r\n    use super::{Goldilocks, MdsMatrixGoldilocks};\r\n\r\n    #[test]\r\n    fn goldilocks8() {\r\n        let input: [Goldilocks; 8] = Goldilocks::new_array([\r\n            2434589605738284713,\r\n            4817685620989478889,\r\n            13397079175138649456,\r\n            11944520631108649751,\r\n            1033251468644039632,\r\n            3092099742268329866,\r\n            7160548811622790454,\r\n            9959569614427134344,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 8] = Goldilocks::new_array([\r\n            16726687146516531007,\r\n            14721040752765534861,\r\n            15566838577475948790,\r\n            9095485010737904250,\r\n            11353934351835864222,\r\n            11056556168691087893,\r\n            4199602889124860181,\r\n            315643510993921470,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks12() {\r\n        let input: [Goldilocks; 12] = Goldilocks::new_array([\r\n            14847187883725400244,\r\n            969392934980971521,\r\n            6996647758016470432,\r\n            4674844440624672154,\r\n            264841656685969785,\r\n            1246852265697711623,\r\n            18223868478428473484,\r\n            12122736699239070772,\r\n            11263701854732819430,\r\n            12739925508864285577,\r\n            11648637570857932167,\r\n            14090978315217600393,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 12] = Goldilocks::new_array([\r\n            9322351889214742299,\r\n            8700136572060418355,\r\n            4881757876459003977,\r\n            9899544690241851021,\r\n            480548822895830465,\r\n            5445915149371405525,\r\n            14955363277757168581,\r\n            6672733082273363313,\r\n            190938676320003294,\r\n            1613225933948270736,\r\n            3549006224849989171,\r\n            12169032187873197425,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks16() {\r\n        let input: [Goldilocks; 16] = Goldilocks::new_array([\r\n            13216135600341032847,\r\n            15626390207663319651,\r\n            2052474569300149934,\r\n            4375663431730581786,\r\n            16596827905941257435,\r\n            10019626608444427271,\r\n            7831946179065963230,\r\n            17104499871144693506,\r\n            9021930732511690478,\r\n            6899419210615882449,\r\n            8131182521761419514,\r\n            432489675596019804,\r\n            8508050013409958723,\r\n            14134506582804571789,\r\n            13283546413390931641,\r\n            14711125975653831032,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 16] = Goldilocks::new_array([\r\n            9484392671298797780,\r\n            149770626972189150,\r\n            12125722600598304117,\r\n            15945232149672903756,\r\n            13199929870021500593,\r\n            18443980893262804946,\r\n            317150800081307627,\r\n            16910019239751125049,\r\n            1996802739033818490,\r\n            11668458913264624237,\r\n            11078800762167869397,\r\n            13758408662406282356,\r\n            11119677412113674380,\r\n            7344117715971661026,\r\n            4202436890275702092,\r\n            681166793519210465,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks24() {\r\n        let input: [Goldilocks; 24] = Goldilocks::new_array([\r\n            11426771245122339662,\r\n            5975488243963332229,\r\n            11441424994503305651,\r\n            5755561333702259678,\r\n            7295454168648181339,\r\n            16724279929816174064,\r\n            32359231037136391,\r\n            3713621595270370753,\r\n            8421765959140936778,\r\n            12370571593326246544,\r\n            8633733294559731287,\r\n            12765436832373161027,\r\n            15606692828890413034,\r\n            8068160018166226874,\r\n            10719661629577139538,\r\n            13036735610140127982,\r\n            10213543772818211674,\r\n            8041886705706266368,\r\n            12022983417703446028,\r\n            4179370708601587579,\r\n            11125302089484330465,\r\n            9904943018174649533,\r\n            16178194376951442671,\r\n            1545799842160818502,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 24] = Goldilocks::new_array([\r\n            18431075688485197060,\r\n            14823984346528185622,\r\n            7262979358411339215,\r\n            14816911393874702213,\r\n            6721523710303409972,\r\n            10829861327716364029,\r\n            2456948878733883601,\r\n            11088379938350287658,\r\n            3820735023521527858,\r\n            9062288923770492958,\r\n            5159244568306327366,\r\n            1401669669887165869,\r\n            11908734248351870182,\r\n            10640195377186320543,\r\n            6552733980894593378,\r\n            17103376282032495459,\r\n            5204287788603805758,\r\n            17783185518697631139,\r\n            9006863878586007300,\r\n            11122535637762904803,\r\n            5271621316102699962,\r\n            9734499541452484536,\r\n            11778274360927642637,\r\n            3217831681350496533,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks32() {\r\n        let input: [Goldilocks; 32] = Goldilocks::new_array([\r\n            8401806579759049284,\r\n            14709608922272986544,\r\n            8130995604641968478,\r\n            7833133203357642391,\r\n            10700492548100684406,\r\n            3941105252506602047,\r\n            8122370916776133262,\r\n            15079919378435648206,\r\n            8774521769784086994,\r\n            16794844316583392853,\r\n            9356562741425567167,\r\n            13317198313361936216,\r\n            7187680218428599522,\r\n            16525662096158660997,\r\n            540453741156061014,\r\n            16543585577270698663,\r\n            3802215918136285729,\r\n            11389297895303247764,\r\n            5133769394766075512,\r\n            1057795099426170863,\r\n            18037861421172314665,\r\n            17632255188776359310,\r\n            17616515088477043142,\r\n            13307921676744533876,\r\n            17602277262015191215,\r\n            15819040654617566738,\r\n            11961318546000835928,\r\n            15593174310433874065,\r\n            9152657050882549004,\r\n            4801868480369948110,\r\n            13202076339494141066,\r\n            726396847460932316,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 32] = Goldilocks::new_array([\r\n            1179701925859507209,\r\n            5543239597787055637,\r\n            5978278622530964070,\r\n            3622388166841103287,\r\n            11383243182536830899,\r\n            14719109850604985734,\r\n            17672601866826623850,\r\n            4879627080283827596,\r\n            7556887460241466109,\r\n            9548493506061808122,\r\n            13980851986825291174,\r\n            2029844508485082398,\r\n            10375517623784134775,\r\n            13067093881736606569,\r\n            6446569064196467795,\r\n            15375603814779462714,\r\n            11307946648742033371,\r\n            1593906954637160608,\r\n            5776169226282316678,\r\n            8167048017892669861,\r\n            3954052226208277367,\r\n            9346878497567392707,\r\n            5570872870988220142,\r\n            10792661164389799960,\r\n            17494962593174487938,\r\n            7080549557843445752,\r\n            14059834522311268132,\r\n            17747288366997773235,\r\n            17158122400620315305,\r\n            6816598002359267850,\r\n            12363049840026116993,\r\n            13313901185845854868,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks64() {\r\n        let input: [Goldilocks; 64] = Goldilocks::new_array([\r\n            3471075506106776899,\r\n            4817046918282259009,\r\n            3480368692354016145,\r\n            18110937755057600106,\r\n            3130862083451221140,\r\n            15376650156021437015,\r\n            7997596749112997445,\r\n            7742916918728590149,\r\n            421644639408377358,\r\n            2491271421424548020,\r\n            1940196613872160755,\r\n            7152053147988203177,\r\n            13697425352450853423,\r\n            15877844788345672674,\r\n            17787098720906653510,\r\n            6857627524724866519,\r\n            8541180216786820396,\r\n            10769715704553877654,\r\n            9265712399189924160,\r\n            10220120296438955872,\r\n            18201417281995610945,\r\n            6749698931189855822,\r\n            13700000989116811950,\r\n            13205437213697578097,\r\n            10514342943989454609,\r\n            9926015350795325725,\r\n            2289808224483690257,\r\n            12598806357998460973,\r\n            14393945610969324307,\r\n            4744625557965362093,\r\n            2270701163031951561,\r\n            2927942398784334090,\r\n            5250916386894733430,\r\n            4030189910566345872,\r\n            4953663590324639075,\r\n            1241519685782896035,\r\n            8681312160951359069,\r\n            8236353015475387411,\r\n            4972690458759871996,\r\n            1396852754187463352,\r\n            17512022752774329733,\r\n            14009268822557836700,\r\n            1346736409027879377,\r\n            7609463340861239931,\r\n            10701512803758419515,\r\n            5067199073587389986,\r\n            5030018986055211116,\r\n            17692625804700013551,\r\n            9992938630604785132,\r\n            15350127009762647067,\r\n            10247405821493235386,\r\n            15172888833500531069,\r\n            14657693742399622179,\r\n            7391511805216089127,\r\n            2035742693690795598,\r\n            4047216012963057952,\r\n            12602085105939403203,\r\n            16985723692990258059,\r\n            12141021186082151434,\r\n            3174646196626212833,\r\n            16484520987666295947,\r\n            10579720164460442970,\r\n            9596917135039689219,\r\n            13761818390665814258,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 64] = Goldilocks::new_array([\r\n            9158798369861934356,\r\n            9224859686427886689,\r\n            16948559910286211274,\r\n            15765762765140902574,\r\n            16202509467561200764,\r\n            1911749439284071529,\r\n            4607026757869726805,\r\n            8473827004973131317,\r\n            13716800466551879373,\r\n            6670177022201597800,\r\n            17416833238376299449,\r\n            14953676562252669578,\r\n            5828107070718286209,\r\n            17980287408679531241,\r\n            2220583438808757820,\r\n            14564318040622847100,\r\n            3950519594558514416,\r\n            12164610170526828198,\r\n            457385640833960098,\r\n            14068973922383216628,\r\n            9614382247226943793,\r\n            3932756878771319222,\r\n            12728498054939249570,\r\n            9435109056498897661,\r\n            7283114805836756402,\r\n            1720178259138435097,\r\n            11496602000538177285,\r\n            7736206812858942065,\r\n            14289784438950643645,\r\n            12052665489155550962,\r\n            12918409840610303255,\r\n            5224324424989208352,\r\n            7826309014606327907,\r\n            11657314889847733528,\r\n            13899641072303006348,\r\n            7501780959676548477,\r\n            1064261716045449147,\r\n            1487682458939665452,\r\n            10894217148983862136,\r\n            12785338167343566981,\r\n            8043323074629160032,\r\n            10852328074701301213,\r\n            15029722608724150267,\r\n            2611937278660861263,\r\n            13995790409949796943,\r\n            7103138700054564899,\r\n            12756778219044204581,\r\n            4147399997707606088,\r\n            11930966590061754579,\r\n            16708700985380478903,\r\n            2370160521342035603,\r\n            14893791582608133454,\r\n            15313288276425450946,\r\n            16224601303711716386,\r\n            4488931442519177087,\r\n            7443169181907410918,\r\n            12381442753785370161,\r\n            16366345507676500076,\r\n            8097905256807642731,\r\n            8504207502183388457,\r\n            11400931328719780407,\r\n            10879211614969476303,\r\n            7265889003783205111,\r\n            7322738272300165489,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn goldilocks68() {\r\n        let input: [Goldilocks; 68] = Goldilocks::new_array([\r\n            16450563043143968653,\r\n            3688080826640678185,\r\n            133253417037384537,\r\n            17501558583799613353,\r\n            14920674569425704293,\r\n            5030578721963251055,\r\n            9795600398273758687,\r\n            402012644192671817,\r\n            10657312189068414445,\r\n            9508835336085746575,\r\n            16081669758721272608,\r\n            2072823794278273547,\r\n            16831381326702573736,\r\n            11381683312293543190,\r\n            5679539322738625588,\r\n            9346499485038639332,\r\n            15554202803455984983,\r\n            18373955571490331663,\r\n            11323895584334729789,\r\n            16834542679468148445,\r\n            14751528164286075953,\r\n            3755158780970327991,\r\n            12622814707645103582,\r\n            10329238611694882547,\r\n            7642766530280843057,\r\n            4876120096290984742,\r\n            412912224820604426,\r\n            9118233770240274553,\r\n            3626520971021993076,\r\n            10841049054903806738,\r\n            18205546599950141835,\r\n            7198482606375262809,\r\n            17183313930831625294,\r\n            10181033256431249241,\r\n            1061211413812819905,\r\n            3980261141891682525,\r\n            5674176959446948353,\r\n            6062696542969845681,\r\n            3383081006315025715,\r\n            8812665902421024067,\r\n            3093645099818246186,\r\n            16178737149039707082,\r\n            8204245222345541411,\r\n            11072582337937050490,\r\n            17969785901925882398,\r\n            4670890092981706609,\r\n            12537558683977529426,\r\n            12084598516323376868,\r\n            16293685096019175644,\r\n            10117612240421467846,\r\n            17873102395739074620,\r\n            11220493906741851877,\r\n            4632957003022201019,\r\n            12934229307704669322,\r\n            2152792796882257594,\r\n            12521131928134126701,\r\n            17472006670677761650,\r\n            4560570065837283016,\r\n            6315543803073912887,\r\n            4098689719955359793,\r\n            1784883877365258237,\r\n            6837590090927294950,\r\n            2391417016765166652,\r\n            16389291664603960875,\r\n            12285946887702044436,\r\n            7231705445010258971,\r\n            12976071926225281356,\r\n            8829402645443096358,\r\n        ]);\r\n\r\n        let output = MdsMatrixGoldilocks.permute(input);\r\n\r\n        let expected: [Goldilocks; 68] = Goldilocks::new_array([\r\n            4984914285749049383,\r\n            10397959071664799177,\r\n            3331616814639908945,\r\n            4252459885611162121,\r\n            5517786723806029201,\r\n            1826620401370703815,\r\n            8257849352373689773,\r\n            1722805960790112693,\r\n            17654983138917187833,\r\n            7542660006721409612,\r\n            1970182718241277021,\r\n            12865815507550811641,\r\n            17507096607056552658,\r\n            7988714902687660369,\r\n            150082662759625574,\r\n            17329095993317360383,\r\n            965880604543562997,\r\n            2820931239306841741,\r\n            1980667983336380501,\r\n            3781794112174728826,\r\n            7323192150179872391,\r\n            12243426826276589932,\r\n            315076483410634889,\r\n            3221894784246078707,\r\n            3515955216509190252,\r\n            964376148920419876,\r\n            7679719864273407732,\r\n            2516714701741920303,\r\n            4837221266652621366,\r\n            15301563603415983061,\r\n            10380321314559647625,\r\n            3023678426639670063,\r\n            12020917879204725519,\r\n            10595808165609787680,\r\n            14199186729378048831,\r\n            4520610719509879248,\r\n            9983949546821718635,\r\n            5066092593424854949,\r\n            13843503196305181790,\r\n            14296362815835302652,\r\n            6766348697864530153,\r\n            13804582129741554661,\r\n            8032169955336281598,\r\n            5198513488794721460,\r\n            10613667919514788349,\r\n            7948289550930596506,\r\n            14118391408956101449,\r\n            4356952068887595371,\r\n            709878153008378134,\r\n            17168579964784489802,\r\n            17840495726541494819,\r\n            2710471020841761312,\r\n            9950159372116756450,\r\n            3909574932971200058,\r\n            2430964021804554670,\r\n            6035162446515244642,\r\n            14656543530572478095,\r\n            1539013407173403800,\r\n            4150113154618904744,\r\n            4904646199269229662,\r\n            17257014030727492672,\r\n            3791823431764085889,\r\n            13680668409434600948,\r\n            12367427987617118934,\r\n            12462908457168650050,\r\n            10891613749697412017,\r\n            6867760775372053830,\r\n            12474954319307005079,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":33,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":41,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":43,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":44,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":46,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":56,"address":[],"length":0,"stats":{"Line":6629298651489370121}},{"line":57,"address":[],"length":0,"stats":{"Line":13258597302978740237}},{"line":58,"address":[],"length":0,"stats":{"Line":6629298651489370121}},{"line":67,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":71,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":72,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":73,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":77,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":78,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":86,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":90,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":91,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":92,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":96,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":97,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":106,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":110,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":111,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":112,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":116,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":117,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":133,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":134,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":137,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":138,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":156,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":158,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":190,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":222,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":44},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","poseidon2.rs"],"content":"//! Implementation of Poseidon2, see: https://eprint.iacr.org/2023/323\r\n\r\n//! For now we recreate the implementation given in:\r\n//! https://github.com/HorizenLabs/poseidon2/blob/main/plain_implementations/src/poseidon2/poseidon2_instance_goldilocks.rs\r\n//! This uses the constants below along with using the 4x4 matrix:\r\n//! [[5, 7, 1, 3], [4, 6, 1, 1], [1, 3, 5, 7], [1, 1, 4, 6]]\r\n//! to build the 4t x 4t matrix used for the external (full) rounds).\r\n\r\n//! Long term we will use more optimised internal and external linear layers.\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{Algebra, InjectiveMonomial};\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    internal_permute_state, matmul_internal, ExternalLayer, ExternalLayerConstants,\r\n    ExternalLayerConstructor, HLMDSMat4, InternalLayer, InternalLayerConstructor, MDSMat4,\r\n    Poseidon2,\r\n};\r\n\r\nuse crate::Goldilocks;\r\n\r\n/// Degree of the chosen permutation polynomial for Goldilocks, used as the Poseidon2 S-Box.\r\n///\r\n/// As p - 1 = 2^32 * 3 * 5 * 17 * ... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 7.\r\nconst GOLDILOCKS_S_BOX_DEGREE: u64 = 7;\r\n\r\n/// An implementation of the Poseidon2 hash function for the Goldilocks field.\r\n///\r\n/// It acts on arrays of the form `[Goldilocks; WIDTH]`.\r\n/// Currently the internal layers are unoptimized. These could be sped up in a similar way to\r\n/// how it was done for Monty31 fields.\r\npub type Poseidon2Goldilocks\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    Goldilocks,\r\n    Poseidon2ExternalLayerGoldilocks\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerGoldilocks,\r\n    WIDTH,\r\n    GOLDILOCKS_S_BOX_DEGREE,\r\n\u003e;\r\n\r\n/// A recreating of the Poseidon2 implementation by Horizen Labs for the Goldilocks field.\r\n///\r\n/// It acts on arrays of the form `[Goldilocks; WIDTH]`\r\n/// The original implementation can be found here: https://github.com/HorizenLabs/poseidon2.\r\n/// This implementation is slightly slower than `Poseidon2Goldilocks` as is uses a slower matrix\r\n/// for the external rounds.\r\npub type Poseidon2GoldilocksHL\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    Goldilocks,\r\n    Poseidon2ExternalLayerGoldilocksHL\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerGoldilocks,\r\n    WIDTH,\r\n    GOLDILOCKS_S_BOX_DEGREE,\r\n\u003e;\r\n\r\npub const MATRIX_DIAG_8_GOLDILOCKS: [Goldilocks; 8] = Goldilocks::new_array([\r\n    0xa98811a1fed4e3a5,\r\n    0x1cc48b54f377e2a0,\r\n    0xe40cd4f6c5609a26,\r\n    0x11de79ebca97a4a3,\r\n    0x9177c73d8b7e929c,\r\n    0x2a6fe8085797e791,\r\n    0x3de6e93329f8d5ad,\r\n    0x3f7af9125da962fe,\r\n]);\r\n\r\npub const MATRIX_DIAG_12_GOLDILOCKS: [Goldilocks; 12] = Goldilocks::new_array([\r\n    0xc3b6c08e23ba9300,\r\n    0xd84b5de94a324fb6,\r\n    0x0d0c371c5b35b84f,\r\n    0x7964f570e7188037,\r\n    0x5daf18bbd996604b,\r\n    0x6743bc47b9595257,\r\n    0x5528b9362c59bb70,\r\n    0xac45e25b7127b68b,\r\n    0xa2077d7dfbb606b5,\r\n    0xf3faac6faee378ae,\r\n    0x0c6388b51545e883,\r\n    0xd27dbb6944917b60,\r\n]);\r\n\r\npub const MATRIX_DIAG_16_GOLDILOCKS: [Goldilocks; 16] = Goldilocks::new_array([\r\n    0xde9b91a467d6afc0,\r\n    0xc5f16b9c76a9be17,\r\n    0x0ab0fef2d540ac55,\r\n    0x3001d27009d05773,\r\n    0xed23b1f906d3d9eb,\r\n    0x5ce73743cba97054,\r\n    0x1c3bab944af4ba24,\r\n    0x2faa105854dbafae,\r\n    0x53ffb3ae6d421a10,\r\n    0xbcda9df8884ba396,\r\n    0xfc1273e4a31807bb,\r\n    0xc77952573d5142c0,\r\n    0x56683339a819b85e,\r\n    0x328fcbd8f0ddc8eb,\r\n    0xb5101e303fce9cb7,\r\n    0x774487b8c40089bb,\r\n]);\r\n\r\npub const MATRIX_DIAG_20_GOLDILOCKS: [Goldilocks; 20] = Goldilocks::new_array([\r\n    0x95c381fda3b1fa57,\r\n    0xf36fe9eb1288f42c,\r\n    0x89f5dcdfef277944,\r\n    0x106f22eadeb3e2d2,\r\n    0x684e31a2530e5111,\r\n    0x27435c5d89fd148e,\r\n    0x3ebed31c414dbf17,\r\n    0xfd45b0b2d294e3cc,\r\n    0x48c904473a7f6dbf,\r\n    0xe0d1b67809295b4d,\r\n    0xddd1941e9d199dcb,\r\n    0x8cfe534eeb742219,\r\n    0xa6e5261d9e3b8524,\r\n    0x6897ee5ed0f82c1b,\r\n    0x0e7dcd0739ee5f78,\r\n    0x493253f3d0d32363,\r\n    0xbb2737f5845f05c0,\r\n    0xa187e810b06ad903,\r\n    0xb635b995936c4918,\r\n    0x0b3694a940bd2394,\r\n]);\r\n\r\n/// The internal layers of the Poseidon2 permutation.\r\n#[derive(Debug, Clone, Default)]\r\npub struct Poseidon2InternalLayerGoldilocks {\r\n    internal_constants: Vec\u003cGoldilocks\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cGoldilocks\u003e for Poseidon2InternalLayerGoldilocks {\r\n    fn new_from_constants(internal_constants: Vec\u003cGoldilocks\u003e) -\u003e Self {\r\n        Self { internal_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e\u003e\r\n    InternalLayer\u003cA, 8, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2InternalLayerGoldilocks\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [A; 8]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| matmul_internal(x, MATRIX_DIAG_8_GOLDILOCKS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e\u003e\r\n    InternalLayer\u003cA, 12, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2InternalLayerGoldilocks\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [A; 12]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| matmul_internal(x, MATRIX_DIAG_12_GOLDILOCKS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e\u003e\r\n    InternalLayer\u003cA, 16, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2InternalLayerGoldilocks\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [A; 16]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| matmul_internal(x, MATRIX_DIAG_16_GOLDILOCKS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e\u003e\r\n    InternalLayer\u003cA, 20, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2InternalLayerGoldilocks\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [A; 20]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| matmul_internal(x, MATRIX_DIAG_20_GOLDILOCKS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerGoldilocks\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cGoldilocks, WIDTH\u003e,\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cGoldilocks, WIDTH\u003e\r\n    for Poseidon2ExternalLayerGoldilocks\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cGoldilocks, WIDTH\u003e) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e, const WIDTH: usize\u003e\r\n    ExternalLayer\u003cA, WIDTH, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2ExternalLayerGoldilocks\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation used by Horizen Labs.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerGoldilocksHL\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cGoldilocks, WIDTH\u003e,\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cGoldilocks, WIDTH\u003e\r\n    for Poseidon2ExternalLayerGoldilocksHL\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cGoldilocks, WIDTH\u003e) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cGoldilocks\u003e + InjectiveMonomial\u003cGOLDILOCKS_S_BOX_DEGREE\u003e, const WIDTH: usize\u003e\r\n    ExternalLayer\u003cA, WIDTH, GOLDILOCKS_S_BOX_DEGREE\u003e for Poseidon2ExternalLayerGoldilocksHL\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026HLMDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026HLMDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\npub const HL_GOLDILOCKS_8_EXTERNAL_ROUND_CONSTANTS: [[[u64; 8]; 4]; 2] = [\r\n    [\r\n        [\r\n            0xdd5743e7f2a5a5d9,\r\n            0xcb3a864e58ada44b,\r\n            0xffa2449ed32f8cdc,\r\n            0x42025f65d6bd13ee,\r\n            0x7889175e25506323,\r\n            0x34b98bb03d24b737,\r\n            0xbdcc535ecc4faa2a,\r\n            0x5b20ad869fc0d033,\r\n        ],\r\n        [\r\n            0xf1dda5b9259dfcb4,\r\n            0x27515210be112d59,\r\n            0x4227d1718c766c3f,\r\n            0x26d333161a5bd794,\r\n            0x49b938957bf4b026,\r\n            0x4a56b5938b213669,\r\n            0x1120426b48c8353d,\r\n            0x6b323c3f10a56cad,\r\n        ],\r\n        [\r\n            0xce57d6245ddca6b2,\r\n            0xb1fc8d402bba1eb1,\r\n            0xb5c5096ca959bd04,\r\n            0x6db55cd306d31f7f,\r\n            0xc49d293a81cb9641,\r\n            0x1ce55a4fe979719f,\r\n            0xa92e60a9d178a4d1,\r\n            0x002cc64973bcfd8c,\r\n        ],\r\n        [\r\n            0xcea721cce82fb11b,\r\n            0xe5b55eb8098ece81,\r\n            0x4e30525c6f1ddd66,\r\n            0x43c6702827070987,\r\n            0xaca68430a7b5762a,\r\n            0x3674238634df9c93,\r\n            0x88cee1c825e33433,\r\n            0xde99ae8d74b57176,\r\n        ],\r\n    ],\r\n    [\r\n        [\r\n            0x014ef1197d341346,\r\n            0x9725e20825d07394,\r\n            0xfdb25aef2c5bae3b,\r\n            0xbe5402dc598c971e,\r\n            0x93a5711f04cdca3d,\r\n            0xc45a9a5b2f8fb97b,\r\n            0xfe8946a924933545,\r\n            0x2af997a27369091c,\r\n        ],\r\n        [\r\n            0xaa62c88e0b294011,\r\n            0x058eb9d810ce9f74,\r\n            0xb3cb23eced349ae4,\r\n            0xa3648177a77b4a84,\r\n            0x43153d905992d95d,\r\n            0xf4e2a97cda44aa4b,\r\n            0x5baa2702b908682f,\r\n            0x082923bdf4f750d1,\r\n        ],\r\n        [\r\n            0x98ae09a325893803,\r\n            0xf8a6475077968838,\r\n            0xceb0735bf00b2c5f,\r\n            0x0a1a5d953888e072,\r\n            0x2fcb190489f94475,\r\n            0xb5be06270dec69fc,\r\n            0x739cb934b09acf8b,\r\n            0x537750b75ec7f25b,\r\n        ],\r\n        [\r\n            0xe9dd318bae1f3961,\r\n            0xf7462137299efe1a,\r\n            0xb1f6b8eee9adb940,\r\n            0xbdebcc8a809dfe6b,\r\n            0x40fc1f791b178113,\r\n            0x3ac1c3362d014864,\r\n            0x9a016184bdb8aeba,\r\n            0x95f2394459fbc25e,\r\n        ],\r\n    ],\r\n];\r\npub const HL_GOLDILOCKS_8_INTERNAL_ROUND_CONSTANTS: [u64; 22] = [\r\n    0x488897d85ff51f56,\r\n    0x1140737ccb162218,\r\n    0xa7eeb9215866ed35,\r\n    0x9bd2976fee49fcc9,\r\n    0xc0c8f0de580a3fcc,\r\n    0x4fb2dae6ee8fc793,\r\n    0x343a89f35f37395b,\r\n    0x223b525a77ca72c8,\r\n    0x56ccb62574aaa918,\r\n    0xc4d507d8027af9ed,\r\n    0xa080673cf0b7e95c,\r\n    0xf0184884eb70dcf8,\r\n    0x044f10b0cb3d5c69,\r\n    0xe9e3f7993938f186,\r\n    0x1b761c80e772f459,\r\n    0x606cec607a1b5fac,\r\n    0x14a0c2e1d45f03cd,\r\n    0x4eace8855398574f,\r\n    0xf905ca7103eff3e6,\r\n    0xf8c8f8d20862c059,\r\n    0xb524fe8bdd678e5a,\r\n    0xfbb7865901a1ec41,\r\n];\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use core::array;\r\n\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_poseidon2::Poseidon2;\r\n    use p3_symmetric::Permutation;\r\n\r\n    use super::*;\r\n\r\n    type F = Goldilocks;\r\n\r\n    // A function which recreates the poseidon2 implementation in\r\n    // https://github.com/HorizenLabs/poseidon2\r\n    fn hl_poseidon2_goldilocks_width_8(input: \u0026mut [F; 8]) {\r\n        const WIDTH: usize = 8;\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2: Poseidon2GoldilocksHL\u003cWIDTH\u003e = Poseidon2::new(\r\n            ExternalLayerConstants::\u003cGoldilocks, WIDTH\u003e::new_from_saved_array(\r\n                HL_GOLDILOCKS_8_EXTERNAL_ROUND_CONSTANTS,\r\n                Goldilocks::new_array,\r\n            ),\r\n            Goldilocks::new_array(HL_GOLDILOCKS_8_INTERNAL_ROUND_CONSTANTS).to_vec(),\r\n        );\r\n\r\n        poseidon2.permute_mut(input);\r\n    }\r\n\r\n    /// Test on the constant 0 input.\r\n    #[test]\r\n    fn test_poseidon2_width_8_zeroes() {\r\n        let mut input: [F; 8] = [Goldilocks::ZERO; 8];\r\n\r\n        let expected: [F; 8] = Goldilocks::new_array([\r\n            4214787979728720400,\r\n            12324939279576102560,\r\n            10353596058419792404,\r\n            15456793487362310586,\r\n            10065219879212154722,\r\n            16227496357546636742,\r\n            2959271128466640042,\r\n            14285409611125725709,\r\n        ]);\r\n        hl_poseidon2_goldilocks_width_8(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test on the input 0..16.\r\n    #[test]\r\n    fn test_poseidon2_width_8_range() {\r\n        let mut input: [F; 8] = array::from_fn(|i| F::from_u64(i as u64));\r\n\r\n        let expected: [F; 8] = Goldilocks::new_array([\r\n            14266028122062624699,\r\n            5353147180106052723,\r\n            15203350112844181434,\r\n            17630919042639565165,\r\n            16601551015858213987,\r\n            10184091939013874068,\r\n            16774100645754596496,\r\n            12047415603622314780,\r\n        ]);\r\n        hl_poseidon2_goldilocks_width_8(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(2468)\r\n    /// vector([ZZ.random_element(2**31) for t in range(16)])\r\n    #[test]\r\n    fn test_poseidon2_width_8_random() {\r\n        let mut input: [F; 8] = Goldilocks::new_array([\r\n            5116996373749832116,\r\n            8931548647907683339,\r\n            17132360229780760684,\r\n            11280040044015983889,\r\n            11957737519043010992,\r\n            15695650327991256125,\r\n            17604752143022812942,\r\n            543194415197607509,\r\n        ]);\r\n\r\n        let expected: [F; 8] = Goldilocks::new_array([\r\n            1831346684315917658,\r\n            13497752062035433374,\r\n            12149460647271516589,\r\n            15656333994315312197,\r\n            4671534937670455565,\r\n            3140092508031220630,\r\n            4251208148861706881,\r\n            6973971209430822232,\r\n        ]);\r\n\r\n        hl_poseidon2_goldilocks_width_8(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n}\r\n","traces":[{"line":129,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":138,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":141,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":142,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":242,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":244,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":245,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":246,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":247,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":252,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":254,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":255,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":257,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":16,"coverable":39},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx2","mds.rs"],"content":"use p3_mds::util::apply_circulant;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\n\r\nuse crate::x86_64_avx2::packing::PackedGoldilocksAVX2;\r\nuse crate::{\r\n    MdsMatrixGoldilocks, MATRIX_CIRC_MDS_12_SML_ROW, MATRIX_CIRC_MDS_16_SML_ROW,\r\n    MATRIX_CIRC_MDS_24_GOLDILOCKS, MATRIX_CIRC_MDS_8_SML_ROW,\r\n};\r\nconst fn convert_array\u003cconst N: usize\u003e(arr: [i64; N]) -\u003e [u64; N] {\r\n    let mut result: [u64; N] = [0; N];\r\n    let mut i = 0;\r\n    while i \u003c N {\r\n        result[i] = arr[i] as u64;\r\n        i += 1;\r\n    }\r\n    result\r\n}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX2; 8]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX2; 8]) -\u003e [PackedGoldilocksAVX2; 8] {\r\n        const MATRIX_CIRC_MDS_8_SML_ROW_U64: [u64; 8] = convert_array(MATRIX_CIRC_MDS_8_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_8_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX2; 8]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX2, 8\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX2; 12]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX2; 12]) -\u003e [PackedGoldilocksAVX2; 12] {\r\n        const MATRIX_CIRC_MDS_12_SML_ROW_U64: [u64; 12] = convert_array(MATRIX_CIRC_MDS_12_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_12_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX2; 12]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX2, 12\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX2; 16]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX2; 16]) -\u003e [PackedGoldilocksAVX2; 16] {\r\n        const MATRIX_CIRC_MDS_16_SML_ROW_U64: [u64; 16] = convert_array(MATRIX_CIRC_MDS_16_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_16_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX2; 16]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX2, 16\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX2; 24]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX2; 24]) -\u003e [PackedGoldilocksAVX2; 24] {\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_24_GOLDILOCKS, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX2; 24]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX2, 24\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_poseidon::Poseidon;\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{Goldilocks, MdsMatrixGoldilocks, PackedGoldilocksAVX2};\r\n\r\n    #[test]\r\n    fn test_avx2_poseidon_width_8() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 8, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 8] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX2\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx2_poseidon_width_12() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 12, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 12] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX2\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx2_poseidon_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 16, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX2\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx2_poseidon_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 24, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX2\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":23,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":26,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":27,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":34,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":36,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":39,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":40,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":47,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":49,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":52,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":53,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":60,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":61,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":64,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":65,"address":[],"length":0,"stats":{"Line":2161727821137838080}}],"covered":16,"coverable":23},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx2","mod.rs"],"content":"mod mds;\r\nmod packing;\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx2","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::*;\r\nuse core::fmt;\r\nuse core::fmt::{Debug, Formatter};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::exponentiation::exp_10540996611094048183;\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing, PrimeField64,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Goldilocks;\r\n\r\nconst WIDTH: usize = 4;\r\n\r\n/// AVX2 Goldilocks Field\r\n///\r\n/// Ideally `PackedGoldilocksAVX2` would wrap `__m256i`. Unfortunately, `__m256i` has an alignment of\r\n/// 32B, which would preclude us from casting `[Goldilocks; 4]` (alignment 8B) to\r\n/// `PackedGoldilocksAVX2`. We need to ensure that `PackedGoldilocksAVX2` has the same alignment as\r\n/// `Goldilocks`. Thus we wrap `[Goldilocks; 4]` and use the `new` and `get` methods to\r\n/// convert to and from `__m256i`.\r\n#[derive(Copy, Clone, PartialEq, Eq)]\r\n#[repr(transparent)]\r\npub struct PackedGoldilocksAVX2(pub [Goldilocks; WIDTH]);\r\n\r\nimpl PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn new(x: __m256i) -\u003e Self {\r\n        unsafe { transmute(x) }\r\n    }\r\n    #[inline]\r\n    fn get(\u0026self) -\u003e __m256i {\r\n        unsafe { transmute(*self) }\r\n    }\r\n}\r\n\r\nimpl Add\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { add(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Add\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Goldilocks) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\nimpl Add\u003cPackedGoldilocksAVX2\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX2;\r\n    #[inline]\r\n    fn add(self, rhs: Self::Output) -\u003e Self::Output {\r\n        Self::Output::from(self) + rhs\r\n    }\r\n}\r\nimpl AddAssign\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\nimpl AddAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl Debug for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        write!(f, \"({:?})\", self.get())\r\n    }\r\n}\r\n\r\nimpl Default for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        Self::ZERO\r\n    }\r\n}\r\n\r\nimpl Div\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Goldilocks) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\nimpl DivAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    #[allow(clippy::suspicious_op_assign_impl)]\r\n    #[inline]\r\n    fn div_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self *= rhs.inverse();\r\n    }\r\n}\r\n\r\nimpl From\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    fn from(x: Goldilocks) -\u003e Self {\r\n        Self([x; WIDTH])\r\n    }\r\n}\r\n\r\nimpl Mul\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { mul(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Mul\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Goldilocks) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\nimpl Mul\u003cPackedGoldilocksAVX2\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX2;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedGoldilocksAVX2) -\u003e Self::Output {\r\n        Self::Output::from(self) * rhs\r\n    }\r\n}\r\nimpl MulAssign\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\nimpl MulAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl Neg for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        Self::new(unsafe { neg(self.get()) })\r\n    }\r\n}\r\n\r\nimpl Product for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for PackedGoldilocksAVX2 {\r\n    type PrimeSubfield = Goldilocks;\r\n\r\n    const ZERO: Self = Self([Goldilocks::ZERO; WIDTH]);\r\n    const ONE: Self = Self([Goldilocks::ONE; WIDTH]);\r\n    const TWO: Self = Self([Goldilocks::TWO; WIDTH]);\r\n    const NEG_ONE: Self = Self([Goldilocks::NEG_ONE; WIDTH]);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline]\r\n    fn square(\u0026self) -\u003e Self {\r\n        Self::new(unsafe { square(self.get()) })\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(Goldilocks::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\n// Degree of the smallest permutation polynomial for Goldilocks.\r\n//\r\n// As p - 1 = 2^32 * 3 * 5 * 17 * ... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 7.\r\nimpl InjectiveMonomial\u003c7\u003e for PackedGoldilocksAVX2 {}\r\n\r\nimpl PermutationMonomial\u003c7\u003e for PackedGoldilocksAVX2 {\r\n    /// In the field `Goldilocks`, `a^{1/7}` is equal to a^{10540996611094048183}.\r\n    ///\r\n    /// This follows from the calculation `7*10540996611094048183 = 4*(2^64 - 2**32) + 1 = 1 mod (p - 1)`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_10540996611094048183(*self)\r\n    }\r\n}\r\n\r\nimpl Algebra\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {}\r\n\r\nunsafe impl PackedValue for PackedGoldilocksAVX2 {\r\n    type Value = Goldilocks;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[Goldilocks]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026*slice.as_ptr().cast() }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [Goldilocks]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026mut *slice.as_mut_ptr().cast() }\r\n    }\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[Goldilocks] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Goldilocks] {\r\n        \u0026mut self.0[..]\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e Goldilocks\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n}\r\n\r\nunsafe impl PackedField for PackedGoldilocksAVX2 {\r\n    type Scalar = Goldilocks;\r\n}\r\n\r\nunsafe impl PackedFieldPow2 for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.get(), other.get());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e unsafe { interleave1(v0, v1) },\r\n            2 =\u003e unsafe { interleave2(v0, v1) },\r\n            4 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        (Self::new(res0), Self::new(res1))\r\n    }\r\n}\r\n\r\nimpl Sub\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { sub(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Sub\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Goldilocks) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\nimpl Sub\u003cPackedGoldilocksAVX2\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX2;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedGoldilocksAVX2) -\u003e Self::Output {\r\n        Self::Output::from(self) - rhs\r\n    }\r\n}\r\nimpl SubAssign\u003cSelf\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\nimpl SubAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for PackedGoldilocksAVX2 {\r\n    #[inline]\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cPackedGoldilocksAVX2\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedGoldilocksAVX2 {\r\n        PackedGoldilocksAVX2(rng.gen())\r\n    }\r\n}\r\n\r\n// Resources:\r\n// 1. Intel Intrinsics Guide for explanation of each intrinsic:\r\n//    https://software.intel.com/sites/landingpage/IntrinsicsGuide/\r\n// 2. uops.info lists micro-ops for each instruction: https://uops.info/table.html\r\n// 3. Intel optimization manual for introduction to x86 vector extensions and best practices:\r\n//    https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-optimization-reference-manual.html\r\n\r\n// Preliminary knowledge:\r\n// 1. Vector code usually avoids branching. Instead of branches, we can do input selection with\r\n//    _mm256_blendv_epi8 or similar instruction. If all we're doing is conditionally zeroing a\r\n//    vector element then _mm256_and_si256 or _mm256_andnot_si256 may be used and are cheaper.\r\n//\r\n// 2. AVX does not support addition with carry but 128-bit (2-word) addition can be easily\r\n//    emulated. The method recognizes that for a + b overflowed iff (a + b) \u003c a:\r\n//        i. res_lo = a_lo + b_lo\r\n//       ii. carry_mask = res_lo \u003c a_lo\r\n//      iii. res_hi = a_hi + b_hi - carry_mask\r\n//    Notice that carry_mask is subtracted, not added. This is because AVX comparison instructions\r\n//    return -1 (all bits 1) for true and 0 for false.\r\n//\r\n// 3. AVX does not have unsigned 64-bit comparisons. Those can be emulated with signed comparisons\r\n//    by recognizing that a \u003cu b iff a + (1 \u003c\u003c 63) \u003cs b + (1 \u003c\u003c 63), where the addition wraps around\r\n//    and the comparisons are unsigned and signed respectively. The shift function adds/subtracts\r\n//    1 \u003c\u003c 63 to enable this trick.\r\n//      Example: addition with carry.\r\n//        i. a_lo_s = shift(a_lo)\r\n//       ii. res_lo_s = a_lo_s + b_lo\r\n//      iii. carry_mask = res_lo_s \u003cs a_lo_s\r\n//       iv. res_lo = shift(res_lo_s)\r\n//        v. res_hi = a_hi + b_hi - carry_mask\r\n//    The suffix _s denotes a value that has been shifted by 1 \u003c\u003c 63. The result of addition is\r\n//    shifted if exactly one of the operands is shifted, as is the case on line ii. Line iii.\r\n//    performs a signed comparison res_lo_s \u003cs a_lo_s on shifted values to emulate unsigned\r\n//    comparison res_lo \u003cu a_lo on unshifted values. Finally, line iv. reverses the shift so the\r\n//    result can be returned.\r\n//      When performing a chain of calculations, we can often save instructions by letting the shift\r\n//    propagate through and only undoing it when necessary. For example, to compute the addition of\r\n//    three two-word (128-bit) numbers we can do:\r\n//        i. a_lo_s = shift(a_lo)\r\n//       ii. tmp_lo_s = a_lo_s + b_lo\r\n//      iii. tmp_carry_mask = tmp_lo_s \u003cs a_lo_s\r\n//       iv. tmp_hi = a_hi + b_hi - tmp_carry_mask\r\n//        v. res_lo_s = tmp_lo_s + c_lo\r\n//       vi. res_carry_mask = res_lo_s \u003cs tmp_lo_s\r\n//      vii. res_lo = shift(res_lo_s)\r\n//     viii. res_hi = tmp_hi + c_hi - res_carry_mask\r\n//    Notice that the above 3-value addition still only requires two calls to shift, just like our\r\n//    2-value addition.\r\n\r\nconst SIGN_BIT: __m256i = unsafe { transmute([i64::MIN; WIDTH]) };\r\nconst SHIFTED_FIELD_ORDER: __m256i =\r\n    unsafe { transmute([Goldilocks::ORDER_U64 ^ (i64::MIN as u64); WIDTH]) };\r\nconst EPSILON: __m256i = unsafe { transmute([Goldilocks::ORDER_U64.wrapping_neg(); WIDTH]) };\r\n\r\n/// Add 2^63 with overflow. Needed to emulate unsigned comparisons (see point 3. in\r\n/// packed_prime_field.rs).\r\n///  # Safety\r\n/// TODO\r\n#[inline]\r\npub unsafe fn shift(x: __m256i) -\u003e __m256i {\r\n    _mm256_xor_si256(x, SIGN_BIT)\r\n}\r\n\r\n/// Convert to canonical representation.\r\n/// The argument is assumed to be shifted by 1 \u003c\u003c 63 (i.e. x_s = x + 1\u003c\u003c63, where x is the field\r\n///   value). The returned value is similarly shifted by 1 \u003c\u003c 63 (i.e. we return y_s = y + (1\u003c\u003c63),\r\n///   where 0 \u003c= y \u003c FIELD_ORDER).\r\n#[inline]\r\nunsafe fn canonicalize_s(x_s: __m256i) -\u003e __m256i {\r\n    // If x \u003e= FIELD_ORDER then corresponding mask bits are all 0; otherwise all 1.\r\n    let mask = _mm256_cmpgt_epi64(SHIFTED_FIELD_ORDER, x_s);\r\n    // wrapback_amt is -FIELD_ORDER if mask is 0; otherwise 0.\r\n    let wrapback_amt = _mm256_andnot_si256(mask, EPSILON);\r\n    _mm256_add_epi64(x_s, wrapback_amt)\r\n}\r\n\r\n/// Addition u64 + u64 -\u003e u64. Assumes that x + y \u003c 2^64 + FIELD_ORDER. The second argument is\r\n/// pre-shifted by 1 \u003c\u003c 63. The result is similarly shifted.\r\n#[inline]\r\nunsafe fn add_no_double_overflow_64_64s_s(x: __m256i, y_s: __m256i) -\u003e __m256i {\r\n    let res_wrapped_s = _mm256_add_epi64(x, y_s);\r\n    let mask = _mm256_cmpgt_epi64(y_s, res_wrapped_s); // -1 if overflowed else 0.\r\n    let wrapback_amt = _mm256_srli_epi64::\u003c32\u003e(mask); // -FIELD_ORDER if overflowed else 0.\r\n    _mm256_add_epi64(res_wrapped_s, wrapback_amt)\r\n}\r\n\r\n#[inline]\r\nunsafe fn add(x: __m256i, y: __m256i) -\u003e __m256i {\r\n    let y_s = shift(y);\r\n    let res_s = add_no_double_overflow_64_64s_s(x, canonicalize_s(y_s));\r\n    shift(res_s)\r\n}\r\n\r\n#[inline]\r\nunsafe fn sub(x: __m256i, y: __m256i) -\u003e __m256i {\r\n    let mut y_s = shift(y);\r\n    y_s = canonicalize_s(y_s);\r\n    let x_s = shift(x);\r\n    let mask = _mm256_cmpgt_epi64(y_s, x_s); // -1 if sub will underflow (y \u003e x) else 0.\r\n    let wrapback_amt = _mm256_srli_epi64::\u003c32\u003e(mask); // -FIELD_ORDER if underflow else 0.\r\n    let res_wrapped = _mm256_sub_epi64(x_s, y_s);\r\n    _mm256_sub_epi64(res_wrapped, wrapback_amt)\r\n}\r\n\r\n#[inline]\r\nunsafe fn neg(y: __m256i) -\u003e __m256i {\r\n    let y_s = shift(y);\r\n    _mm256_sub_epi64(SHIFTED_FIELD_ORDER, canonicalize_s(y_s))\r\n}\r\n\r\n/// Full 64-bit by 64-bit multiplication. This emulated multiplication is 1.33x slower than the\r\n/// scalar instruction, but may be worth it if we want our data to live in vector registers.\r\n#[inline]\r\nunsafe fn mul64_64(x: __m256i, y: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want to move the high 32 bits to the low position. The multiplication instruction ignores\r\n    // the high 32 bits, so it's ok to just duplicate it into the low position. This duplication can\r\n    // be done on port 5; bitshifts run on ports 0 and 1, competing with multiplication.\r\n    //   This instruction is only provided for 32-bit floats, not integers. Idk why Intel makes the\r\n    // distinction; the casts are free and it guarantees that the exact bit pattern is preserved.\r\n    // Using a swizzle instruction of the wrong domain (float vs int) does not increase latency\r\n    // since Haswell.\r\n    let x_hi = _mm256_castps_si256(_mm256_movehdup_ps(_mm256_castsi256_ps(x)));\r\n    let y_hi = _mm256_castps_si256(_mm256_movehdup_ps(_mm256_castsi256_ps(y)));\r\n\r\n    // All four pairwise multiplications\r\n    let mul_ll = _mm256_mul_epu32(x, y);\r\n    let mul_lh = _mm256_mul_epu32(x, y_hi);\r\n    let mul_hl = _mm256_mul_epu32(x_hi, y);\r\n    let mul_hh = _mm256_mul_epu32(x_hi, y_hi);\r\n\r\n    // Bignum addition\r\n    // Extract high 32 bits of mul_ll and add to mul_hl. This cannot overflow.\r\n    let mul_ll_hi = _mm256_srli_epi64::\u003c32\u003e(mul_ll);\r\n    let t0 = _mm256_add_epi64(mul_hl, mul_ll_hi);\r\n    // Extract low 32 bits of t0 and add to mul_lh. Again, this cannot overflow.\r\n    // Also, extract high 32 bits of t0 and add to mul_hh.\r\n    let t0_lo = _mm256_and_si256(t0, EPSILON);\r\n    let t0_hi = _mm256_srli_epi64::\u003c32\u003e(t0);\r\n    let t1 = _mm256_add_epi64(mul_lh, t0_lo);\r\n    let t2 = _mm256_add_epi64(mul_hh, t0_hi);\r\n    // Lastly, extract the high 32 bits of t1 and add to t2.\r\n    let t1_hi = _mm256_srli_epi64::\u003c32\u003e(t1);\r\n    let res_hi = _mm256_add_epi64(t2, t1_hi);\r\n\r\n    // Form res_lo by combining the low half of mul_ll with the low half of t1 (shifted into high\r\n    // position).\r\n    let t1_lo = _mm256_castps_si256(_mm256_moveldup_ps(_mm256_castsi256_ps(t1)));\r\n    let res_lo = _mm256_blend_epi32::\u003c0xaa\u003e(mul_ll, t1_lo);\r\n\r\n    (res_hi, res_lo)\r\n}\r\n\r\n/// Full 64-bit squaring. This routine is 1.2x faster than the scalar instruction.\r\n#[inline]\r\nunsafe fn square64(x: __m256i) -\u003e (__m256i, __m256i) {\r\n    // Get high 32 bits of x. See comment in mul64_64_s.\r\n    let x_hi = _mm256_castps_si256(_mm256_movehdup_ps(_mm256_castsi256_ps(x)));\r\n\r\n    // All pairwise multiplications.\r\n    let mul_ll = _mm256_mul_epu32(x, x);\r\n    let mul_lh = _mm256_mul_epu32(x, x_hi);\r\n    let mul_hh = _mm256_mul_epu32(x_hi, x_hi);\r\n\r\n    // Bignum addition, but mul_lh is shifted by 33 bits (not 32).\r\n    let mul_ll_hi = _mm256_srli_epi64::\u003c33\u003e(mul_ll);\r\n    let t0 = _mm256_add_epi64(mul_lh, mul_ll_hi);\r\n    let t0_hi = _mm256_srli_epi64::\u003c31\u003e(t0);\r\n    let res_hi = _mm256_add_epi64(mul_hh, t0_hi);\r\n\r\n    // Form low result by adding the mul_ll and the low 31 bits of mul_lh (shifted to the high\r\n    // position).\r\n    let mul_lh_lo = _mm256_slli_epi64::\u003c33\u003e(mul_lh);\r\n    let res_lo = _mm256_add_epi64(mul_ll, mul_lh_lo);\r\n\r\n    (res_hi, res_lo)\r\n}\r\n\r\n/// Goldilocks addition of a \"small\" number. `x_s` is pre-shifted by 2**63. `y` is assumed to be \u003c=\r\n/// `0xffffffff00000000`. The result is shifted by 2**63.\r\n#[inline]\r\nunsafe fn add_small_64s_64_s(x_s: __m256i, y: __m256i) -\u003e __m256i {\r\n    let res_wrapped_s = _mm256_add_epi64(x_s, y);\r\n    // 32-bit compare is faster than 64-bit. It's safe as long as x \u003e res_wrapped iff x \u003e\u003e 32 \u003e\r\n    // res_wrapped \u003e\u003e 32. The case of x \u003e\u003e 32 \u003e res_wrapped \u003e\u003e 32 is trivial and so is \u003c. The case\r\n    // where x \u003e\u003e 32 = res_wrapped \u003e\u003e 32 remains. If x \u003e\u003e 32 = res_wrapped \u003e\u003e 32, then y \u003e\u003e 32 =\r\n    // 0xffffffff and the addition of the low 32 bits generated a carry. This can never occur if y\r\n    // \u003c= 0xffffffff00000000: if y \u003e\u003e 32 = 0xffffffff, then no carry can occur.\r\n    let mask = _mm256_cmpgt_epi32(x_s, res_wrapped_s); // -1 if overflowed else 0.\r\n                                                       // The mask contains 0xffffffff in the high 32 bits if wraparound occurred and 0 otherwise.\r\n    let wrapback_amt = _mm256_srli_epi64::\u003c32\u003e(mask); // -FIELD_ORDER if overflowed else 0.\r\n    _mm256_add_epi64(res_wrapped_s, wrapback_amt)\r\n}\r\n\r\n/// Goldilocks subtraction of a \"small\" number. `x_s` is pre-shifted by 2**63. `y` is assumed to be\r\n/// \u003c= `0xffffffff00000000`. The result is shifted by 2**63.\r\n#[inline]\r\nunsafe fn sub_small_64s_64_s(x_s: __m256i, y: __m256i) -\u003e __m256i {\r\n    let res_wrapped_s = _mm256_sub_epi64(x_s, y);\r\n    // 32-bit compare is faster than 64-bit. It's safe as long as res_wrapped \u003e x iff res_wrapped \u003e\u003e\r\n    // 32 \u003e x \u003e\u003e 32. The case of res_wrapped \u003e\u003e 32 \u003e x \u003e\u003e 32 is trivial and so is \u003c. The case where\r\n    // res_wrapped \u003e\u003e 32 = x \u003e\u003e 32 remains. If res_wrapped \u003e\u003e 32 = x \u003e\u003e 32, then y \u003e\u003e 32 =\r\n    // 0xffffffff and the subtraction of the low 32 bits generated a borrow. This can never occur if\r\n    // y \u003c= 0xffffffff00000000: if y \u003e\u003e 32 = 0xffffffff, then no borrow can occur.\r\n    let mask = _mm256_cmpgt_epi32(res_wrapped_s, x_s); // -1 if underflowed else 0.\r\n                                                       // The mask contains 0xffffffff in the high 32 bits if wraparound occurred and 0 otherwise.\r\n    let wrapback_amt = _mm256_srli_epi64::\u003c32\u003e(mask); // -FIELD_ORDER if underflowed else 0.\r\n    _mm256_sub_epi64(res_wrapped_s, wrapback_amt)\r\n}\r\n\r\n#[inline]\r\nunsafe fn reduce128(x: (__m256i, __m256i)) -\u003e __m256i {\r\n    let (hi0, lo0) = x;\r\n    let lo0_s = shift(lo0);\r\n    let hi_hi0 = _mm256_srli_epi64::\u003c32\u003e(hi0);\r\n    let lo1_s = sub_small_64s_64_s(lo0_s, hi_hi0);\r\n    let t1 = _mm256_mul_epu32(hi0, EPSILON);\r\n    let lo2_s = add_small_64s_64_s(lo1_s, t1);\r\n    shift(lo2_s)\r\n}\r\n\r\n/// Multiply two integers modulo FIELD_ORDER.\r\n#[inline]\r\nunsafe fn mul(x: __m256i, y: __m256i) -\u003e __m256i {\r\n    reduce128(mul64_64(x, y))\r\n}\r\n\r\n/// Square an integer modulo FIELD_ORDER.\r\n#[inline]\r\nunsafe fn square(x: __m256i) -\u003e __m256i {\r\n    reduce128(square64(x))\r\n}\r\n\r\n#[inline]\r\nunsafe fn interleave1(x: __m256i, y: __m256i) -\u003e (__m256i, __m256i) {\r\n    let a = _mm256_unpacklo_epi64(x, y);\r\n    let b = _mm256_unpackhi_epi64(x, y);\r\n    (a, b)\r\n}\r\n\r\n#[inline]\r\nunsafe fn interleave2(x: __m256i, y: __m256i) -\u003e (__m256i, __m256i) {\r\n    let y_lo = _mm256_castsi256_si128(y); // This has 0 cost.\r\n\r\n    // 1 places y_lo in the high half of x; 0 would place it in the lower half.\r\n    let a = _mm256_inserti128_si256::\u003c1\u003e(x, y_lo);\r\n    // NB: _mm256_permute2x128_si256 could be used here as well but _mm256_inserti128_si256 has\r\n    // lower latency on Zen 3 processors.\r\n\r\n    // Each nibble of the constant has the following semantics:\r\n    // 0 =\u003e src1[low 128 bits]\r\n    // 1 =\u003e src1[high 128 bits]\r\n    // 2 =\u003e src2[low 128 bits]\r\n    // 3 =\u003e src2[high 128 bits]\r\n    // The low (resp. high) nibble chooses the low (resp. high) 128 bits of the result.\r\n    let b = _mm256_permute2x128_si256::\u003c0x31\u003e(x, y);\r\n\r\n    (a, b)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::{Goldilocks, WIDTH};\r\n\r\n    const SPECIAL_VALS: [Goldilocks; WIDTH] = Goldilocks::new_array([\r\n        0xFFFF_FFFF_0000_0000,\r\n        0xFFFF_FFFF_FFFF_FFFF,\r\n        0x0000_0000_0000_0001,\r\n        0xFFFF_FFFF_0000_0001,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedGoldilocksAVX2,\r\n        crate::PackedGoldilocksAVX2::ZERO,\r\n        crate::PackedGoldilocksAVX2(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":36,"address":[],"length":0,"stats":{"Line":4539628424389459968}},{"line":39,"address":[],"length":0,"stats":{"Line":16933534598913065563}},{"line":40,"address":[],"length":0,"stats":{"Line":16933534598913065563}},{"line":47,"address":[],"length":0,"stats":{"Line":3026418949592974513}},{"line":48,"address":[],"length":0,"stats":{"Line":3026418949592974513}},{"line":54,"address":[],"length":0,"stats":{"Line":576460752303423690}},{"line":55,"address":[],"length":0,"stats":{"Line":576460752303423690}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":576460752303423495}},{"line":74,"address":[],"length":0,"stats":{"Line":576460752303423495}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":110,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":117,"address":[],"length":0,"stats":{"Line":4683743612465315935}},{"line":118,"address":[],"length":0,"stats":{"Line":4683743612465315935}},{"line":124,"address":[],"length":0,"stats":{"Line":3746994889972252988}},{"line":125,"address":[],"length":0,"stats":{"Line":3746994889972252988}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":9511602413006487632}},{"line":138,"address":[],"length":0,"stats":{"Line":9511602413006487632}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":1008806316530991213}},{"line":152,"address":[],"length":0,"stats":{"Line":1008806316530991213}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":173,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":177,"address":[],"length":0,"stats":{"Line":9151314442816847879}},{"line":178,"address":[],"length":0,"stats":{"Line":9151314442816847879}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":2377900603251621892}},{"line":222,"address":[],"length":0,"stats":{"Line":2377900603251621892}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":232,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":233,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":243,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":244,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":245,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":246,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":247,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":248,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":259,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":292,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":7205759403792793680}},{"line":363,"address":[],"length":0,"stats":{"Line":7205759403792793680}},{"line":371,"address":[],"length":0,"stats":{"Line":8718968878589281462}},{"line":373,"address":[],"length":0,"stats":{"Line":8718968878589281462}},{"line":375,"address":[],"length":0,"stats":{"Line":8718968878589281462}},{"line":376,"address":[],"length":0,"stats":{"Line":8718968878589281462}},{"line":382,"address":[],"length":0,"stats":{"Line":3026418949592973594}},{"line":383,"address":[],"length":0,"stats":{"Line":3026418949592973594}},{"line":384,"address":[],"length":0,"stats":{"Line":3026418949592973594}},{"line":385,"address":[],"length":0,"stats":{"Line":3026418949592973594}},{"line":386,"address":[],"length":0,"stats":{"Line":3026418949592973594}},{"line":390,"address":[],"length":0,"stats":{"Line":3026418949592973514}},{"line":391,"address":[],"length":0,"stats":{"Line":3026418949592973514}},{"line":392,"address":[],"length":0,"stats":{"Line":3026418949592973514}},{"line":393,"address":[],"length":0,"stats":{"Line":3026418949592973514}},{"line":397,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":398,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":399,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":400,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":401,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":402,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":403,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":404,"address":[],"length":0,"stats":{"Line":4683743612465316042}},{"line":408,"address":[],"length":0,"stats":{"Line":1008806316530991184}},{"line":409,"address":[],"length":0,"stats":{"Line":1008806316530991184}},{"line":410,"address":[],"length":0,"stats":{"Line":1008806316530991184}},{"line":416,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":424,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":425,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":428,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":429,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":430,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":431,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":435,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":436,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":439,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":440,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":441,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":442,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":444,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":445,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":449,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":450,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":452,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":457,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":459,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":462,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":463,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":464,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":467,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":468,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":469,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":470,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":474,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":475,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":477,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":483,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":484,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":490,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":492,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":493,"address":[],"length":0,"stats":{"Line":13835058055282163716}},{"line":499,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":500,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":506,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":508,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":509,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":513,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":514,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":515,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":516,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":517,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":518,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":519,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":520,"address":[],"length":0,"stats":{"Line":13835058055282164032}},{"line":525,"address":[],"length":0,"stats":{"Line":4683743612465316160}},{"line":526,"address":[],"length":0,"stats":{"Line":4683743612465316160}},{"line":531,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":532,"address":[],"length":0,"stats":{"Line":9151314442816848188}},{"line":536,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":537,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":538,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":539,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":543,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":544,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":547,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":557,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":559,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":128,"coverable":168},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx512","mds.rs"],"content":"use p3_mds::util::apply_circulant;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\n\r\nuse crate::x86_64_avx512::packing::PackedGoldilocksAVX512;\r\nuse crate::{\r\n    MdsMatrixGoldilocks, MATRIX_CIRC_MDS_12_SML_ROW, MATRIX_CIRC_MDS_16_SML_ROW,\r\n    MATRIX_CIRC_MDS_24_GOLDILOCKS, MATRIX_CIRC_MDS_8_SML_ROW,\r\n};\r\nconst fn convert_array\u003cconst N: usize\u003e(arr: [i64; N]) -\u003e [u64; N] {\r\n    let mut result: [u64; N] = [0; N];\r\n    let mut i = 0;\r\n    while i \u003c N {\r\n        result[i] = arr[i] as u64;\r\n        i += 1;\r\n    }\r\n    result\r\n}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX512; 8]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX512; 8]) -\u003e [PackedGoldilocksAVX512; 8] {\r\n        const MATRIX_CIRC_MDS_8_SML_ROW_U64: [u64; 8] = convert_array(MATRIX_CIRC_MDS_8_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_8_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX512; 8]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX512, 8\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX512; 12]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX512; 12]) -\u003e [PackedGoldilocksAVX512; 12] {\r\n        const MATRIX_CIRC_MDS_12_SML_ROW_U64: [u64; 12] = convert_array(MATRIX_CIRC_MDS_12_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_12_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX512; 12]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX512, 12\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX512; 16]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX512; 16]) -\u003e [PackedGoldilocksAVX512; 16] {\r\n        const MATRIX_CIRC_MDS_16_SML_ROW_U64: [u64; 16] = convert_array(MATRIX_CIRC_MDS_16_SML_ROW);\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_16_SML_ROW_U64, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX512; 16]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX512, 16\u003e for MdsMatrixGoldilocks {}\r\n\r\nimpl Permutation\u003c[PackedGoldilocksAVX512; 24]\u003e for MdsMatrixGoldilocks {\r\n    fn permute(\u0026self, input: [PackedGoldilocksAVX512; 24]) -\u003e [PackedGoldilocksAVX512; 24] {\r\n        apply_circulant(\u0026MATRIX_CIRC_MDS_24_GOLDILOCKS, input)\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [PackedGoldilocksAVX512; 24]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl MdsPermutation\u003cPackedGoldilocksAVX512, 24\u003e for MdsMatrixGoldilocks {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_poseidon::Poseidon;\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{Goldilocks, MdsMatrixGoldilocks, PackedGoldilocksAVX512};\r\n\r\n    #[test]\r\n    fn test_avx512_poseidon_width_8() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 8, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 8] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX512\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx512_poseidon_width_12() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 12, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 12] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX512\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx512_poseidon_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 16, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX512\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn test_avx512_poseidon_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n        type F = Goldilocks;\r\n        type Perm = Poseidon\u003cF, MdsMatrixGoldilocks, 24, 7\u003e;\r\n        let poseidon = Perm::new_from_rng(4, 22, MdsMatrixGoldilocks, \u0026mut rand::thread_rng());\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedGoldilocksAVX512\u003e::into);\r\n        poseidon.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":15,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx512","mod.rs"],"content":"mod mds;\r\nmod packing;\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","goldilocks","src","x86_64_avx512","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::*;\r\nuse core::fmt;\r\nuse core::fmt::{Debug, Formatter};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::exponentiation::exp_10540996611094048183;\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing, PrimeField64,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Goldilocks;\r\n\r\nconst WIDTH: usize = 8;\r\n/// AVX512 Goldilocks Field\r\n///\r\n/// Ideally `PackedGoldilocksAVX512` would wrap `__m512i`. Unfortunately, `__m512i` has an alignment\r\n/// of 64B, which would preclude us from casting `[Goldilocks; 8]` (alignment 8B) to\r\n/// `PackedGoldilocksAVX512`. We need to ensure that `PackedGoldilocksAVX512` has the same alignment as\r\n/// `Goldilocks`. Thus we wrap `[Goldilocks; 8]` and use the `new` and `get` methods to\r\n/// convert to and from `__m512i`.\r\n#[derive(Copy, Clone, PartialEq, Eq)]\r\n#[repr(transparent)]\r\npub struct PackedGoldilocksAVX512(pub [Goldilocks; WIDTH]);\r\n\r\nimpl PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn new(x: __m512i) -\u003e Self {\r\n        unsafe { transmute(x) }\r\n    }\r\n    #[inline]\r\n    fn get(\u0026self) -\u003e __m512i {\r\n        unsafe { transmute(*self) }\r\n    }\r\n}\r\n\r\nimpl Add\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { add(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Add\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Goldilocks) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\nimpl Add\u003cPackedGoldilocksAVX512\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX512;\r\n    #[inline]\r\n    fn add(self, rhs: Self::Output) -\u003e Self::Output {\r\n        Self::Output::from(self) + rhs\r\n    }\r\n}\r\nimpl AddAssign\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\nimpl AddAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl Debug for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        write!(f, \"({:?})\", self.get())\r\n    }\r\n}\r\n\r\nimpl Default for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        Self::ZERO\r\n    }\r\n}\r\n\r\nimpl Div\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Goldilocks) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\nimpl DivAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    #[allow(clippy::suspicious_op_assign_impl)]\r\n    #[inline]\r\n    fn div_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self *= rhs.inverse();\r\n    }\r\n}\r\n\r\nimpl From\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    fn from(x: Goldilocks) -\u003e Self {\r\n        Self([x; WIDTH])\r\n    }\r\n}\r\n\r\nimpl Mul\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { mul(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Mul\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Goldilocks) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\nimpl Mul\u003cPackedGoldilocksAVX512\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX512;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedGoldilocksAVX512) -\u003e Self::Output {\r\n        Self::Output::from(self) * rhs\r\n    }\r\n}\r\nimpl MulAssign\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\nimpl MulAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl Neg for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        Self::new(unsafe { neg(self.get()) })\r\n    }\r\n}\r\n\r\nimpl Product for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for PackedGoldilocksAVX512 {\r\n    type PrimeSubfield = Goldilocks;\r\n\r\n    const ZERO: Self = Self([Goldilocks::ZERO; WIDTH]);\r\n    const ONE: Self = Self([Goldilocks::ONE; WIDTH]);\r\n    const TWO: Self = Self([Goldilocks::TWO; WIDTH]);\r\n    const NEG_ONE: Self = Self([Goldilocks::NEG_ONE; WIDTH]);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline]\r\n    fn square(\u0026self) -\u003e Self {\r\n        Self::new(unsafe { square(self.get()) })\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(Goldilocks::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\nimpl Algebra\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {}\r\n\r\n// Degree of the smallest permutation polynomial for Goldilocks.\r\n//\r\n// As p - 1 = 2^32 * 3 * 5 * 17 * ... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 7.\r\nimpl InjectiveMonomial\u003c7\u003e for PackedGoldilocksAVX512 {}\r\n\r\nimpl PermutationMonomial\u003c7\u003e for PackedGoldilocksAVX512 {\r\n    /// In the field `Goldilocks`, `a^{1/7}` is equal to a^{10540996611094048183}.\r\n    ///\r\n    /// This follows from the calculation `7*10540996611094048183 = 4*(2^64 - 2**32) + 1 = 1 mod (p - 1)`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_10540996611094048183(*self)\r\n    }\r\n}\r\n\r\nunsafe impl PackedValue for PackedGoldilocksAVX512 {\r\n    type Value = Goldilocks;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[Goldilocks]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026*slice.as_ptr().cast() }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [Goldilocks]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe { \u0026mut *slice.as_mut_ptr().cast() }\r\n    }\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[Goldilocks] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Goldilocks] {\r\n        \u0026mut self.0[..]\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e Goldilocks\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n}\r\n\r\nunsafe impl PackedField for PackedGoldilocksAVX512 {\r\n    type Scalar = Goldilocks;\r\n}\r\n\r\nunsafe impl PackedFieldPow2 for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.get(), other.get());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e unsafe { interleave1(v0, v1) },\r\n            2 =\u003e unsafe { interleave2(v0, v1) },\r\n            4 =\u003e unsafe { interleave4(v0, v1) },\r\n            8 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        (Self::new(res0), Self::new(res1))\r\n    }\r\n}\r\n\r\nimpl Sub\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        Self::new(unsafe { sub(self.get(), rhs.get()) })\r\n    }\r\n}\r\nimpl Sub\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Goldilocks) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\nimpl Sub\u003cPackedGoldilocksAVX512\u003e for Goldilocks {\r\n    type Output = PackedGoldilocksAVX512;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedGoldilocksAVX512) -\u003e Self::Output {\r\n        Self::Output::from(self) - rhs\r\n    }\r\n}\r\nimpl SubAssign\u003cSelf\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\nimpl SubAssign\u003cGoldilocks\u003e for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Goldilocks) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for PackedGoldilocksAVX512 {\r\n    #[inline]\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cPackedGoldilocksAVX512\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedGoldilocksAVX512 {\r\n        PackedGoldilocksAVX512(rng.gen())\r\n    }\r\n}\r\n\r\nconst FIELD_ORDER: __m512i = unsafe { transmute([Goldilocks::ORDER_U64; WIDTH]) };\r\nconst EPSILON: __m512i = unsafe { transmute([Goldilocks::ORDER_U64.wrapping_neg(); WIDTH]) };\r\n\r\n#[inline]\r\nunsafe fn canonicalize(x: __m512i) -\u003e __m512i {\r\n    let mask = _mm512_cmpge_epu64_mask(x, FIELD_ORDER);\r\n    _mm512_mask_sub_epi64(x, mask, x, FIELD_ORDER)\r\n}\r\n\r\n#[inline]\r\nunsafe fn add_no_double_overflow_64_64(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    let res_wrapped = _mm512_add_epi64(x, y);\r\n    let mask = _mm512_cmplt_epu64_mask(res_wrapped, y); // mask set if add overflowed\r\n    _mm512_mask_sub_epi64(res_wrapped, mask, res_wrapped, FIELD_ORDER)\r\n}\r\n\r\n#[inline]\r\nunsafe fn sub_no_double_overflow_64_64(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    let mask = _mm512_cmplt_epu64_mask(x, y); // mask set if sub will underflow (x \u003c y)\r\n    let res_wrapped = _mm512_sub_epi64(x, y);\r\n    _mm512_mask_add_epi64(res_wrapped, mask, res_wrapped, FIELD_ORDER)\r\n}\r\n\r\n#[inline]\r\nunsafe fn add(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    add_no_double_overflow_64_64(x, canonicalize(y))\r\n}\r\n\r\n#[inline]\r\nunsafe fn sub(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    sub_no_double_overflow_64_64(x, canonicalize(y))\r\n}\r\n\r\n#[inline]\r\nunsafe fn neg(y: __m512i) -\u003e __m512i {\r\n    _mm512_sub_epi64(FIELD_ORDER, canonicalize(y))\r\n}\r\n\r\n#[allow(clippy::useless_transmute)]\r\nconst LO_32_BITS_MASK: __mmask16 = unsafe { transmute(0b0101010101010101u16) };\r\n\r\n#[inline]\r\nunsafe fn mul64_64(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want to move the high 32 bits to the low position. The multiplication instruction ignores\r\n    // the high 32 bits, so it's ok to just duplicate it into the low position. This duplication can\r\n    // be done on port 5; bitshifts run on port 0, competing with multiplication.\r\n    //   This instruction is only provided for 32-bit floats, not integers. Idk why Intel makes the\r\n    // distinction; the casts are free and it guarantees that the exact bit pattern is preserved.\r\n    // Using a swizzle instruction of the wrong domain (float vs int) does not increase latency\r\n    // since Haswell.\r\n    let x_hi = _mm512_castps_si512(_mm512_movehdup_ps(_mm512_castsi512_ps(x)));\r\n    let y_hi = _mm512_castps_si512(_mm512_movehdup_ps(_mm512_castsi512_ps(y)));\r\n\r\n    // All four pairwise multiplications\r\n    let mul_ll = _mm512_mul_epu32(x, y);\r\n    let mul_lh = _mm512_mul_epu32(x, y_hi);\r\n    let mul_hl = _mm512_mul_epu32(x_hi, y);\r\n    let mul_hh = _mm512_mul_epu32(x_hi, y_hi);\r\n\r\n    // Bignum addition\r\n    // Extract high 32 bits of mul_ll and add to mul_hl. This cannot overflow.\r\n    let mul_ll_hi = _mm512_srli_epi64::\u003c32\u003e(mul_ll);\r\n    let t0 = _mm512_add_epi64(mul_hl, mul_ll_hi);\r\n    // Extract low 32 bits of t0 and add to mul_lh. Again, this cannot overflow.\r\n    // Also, extract high 32 bits of t0 and add to mul_hh.\r\n    let t0_lo = _mm512_and_si512(t0, EPSILON);\r\n    let t0_hi = _mm512_srli_epi64::\u003c32\u003e(t0);\r\n    let t1 = _mm512_add_epi64(mul_lh, t0_lo);\r\n    let t2 = _mm512_add_epi64(mul_hh, t0_hi);\r\n    // Lastly, extract the high 32 bits of t1 and add to t2.\r\n    let t1_hi = _mm512_srli_epi64::\u003c32\u003e(t1);\r\n    let res_hi = _mm512_add_epi64(t2, t1_hi);\r\n\r\n    // Form res_lo by combining the low half of mul_ll with the low half of t1 (shifted into high\r\n    // position).\r\n    let t1_lo = _mm512_castps_si512(_mm512_moveldup_ps(_mm512_castsi512_ps(t1)));\r\n    let res_lo = _mm512_mask_blend_epi32(LO_32_BITS_MASK, t1_lo, mul_ll);\r\n\r\n    (res_hi, res_lo)\r\n}\r\n\r\n#[inline]\r\nunsafe fn square64(x: __m512i) -\u003e (__m512i, __m512i) {\r\n    // Get high 32 bits of x. See comment in mul64_64_s.\r\n    let x_hi = _mm512_castps_si512(_mm512_movehdup_ps(_mm512_castsi512_ps(x)));\r\n\r\n    // All pairwise multiplications.\r\n    let mul_ll = _mm512_mul_epu32(x, x);\r\n    let mul_lh = _mm512_mul_epu32(x, x_hi);\r\n    let mul_hh = _mm512_mul_epu32(x_hi, x_hi);\r\n\r\n    // Bignum addition, but mul_lh is shifted by 33 bits (not 32).\r\n    let mul_ll_hi = _mm512_srli_epi64::\u003c33\u003e(mul_ll);\r\n    let t0 = _mm512_add_epi64(mul_lh, mul_ll_hi);\r\n    let t0_hi = _mm512_srli_epi64::\u003c31\u003e(t0);\r\n    let res_hi = _mm512_add_epi64(mul_hh, t0_hi);\r\n\r\n    // Form low result by adding the mul_ll and the low 31 bits of mul_lh (shifted to the high\r\n    // position).\r\n    let mul_lh_lo = _mm512_slli_epi64::\u003c33\u003e(mul_lh);\r\n    let res_lo = _mm512_add_epi64(mul_ll, mul_lh_lo);\r\n\r\n    (res_hi, res_lo)\r\n}\r\n\r\n#[inline]\r\nunsafe fn reduce128(x: (__m512i, __m512i)) -\u003e __m512i {\r\n    let (hi0, lo0) = x;\r\n    let hi_hi0 = _mm512_srli_epi64::\u003c32\u003e(hi0);\r\n    let lo1 = sub_no_double_overflow_64_64(lo0, hi_hi0);\r\n    let t1 = _mm512_mul_epu32(hi0, EPSILON);\r\n    add_no_double_overflow_64_64(lo1, t1)\r\n}\r\n\r\n#[inline]\r\nunsafe fn mul(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    reduce128(mul64_64(x, y))\r\n}\r\n\r\n#[inline]\r\nunsafe fn square(x: __m512i) -\u003e __m512i {\r\n    reduce128(square64(x))\r\n}\r\n\r\n#[inline]\r\nunsafe fn interleave1(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    let a = _mm512_unpacklo_epi64(x, y);\r\n    let b = _mm512_unpackhi_epi64(x, y);\r\n    (a, b)\r\n}\r\n\r\nconst INTERLEAVE2_IDX_A: __m512i = unsafe {\r\n    transmute([\r\n        0o00u64, 0o01u64, 0o10u64, 0o11u64, 0o04u64, 0o05u64, 0o14u64, 0o15u64,\r\n    ])\r\n};\r\nconst INTERLEAVE2_IDX_B: __m512i = unsafe {\r\n    transmute([\r\n        0o02u64, 0o03u64, 0o12u64, 0o13u64, 0o06u64, 0o07u64, 0o16u64, 0o17u64,\r\n    ])\r\n};\r\n\r\n#[inline]\r\nunsafe fn interleave2(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    let a = _mm512_permutex2var_epi64(x, INTERLEAVE2_IDX_A, y);\r\n    let b = _mm512_permutex2var_epi64(x, INTERLEAVE2_IDX_B, y);\r\n    (a, b)\r\n}\r\n\r\n#[inline]\r\nunsafe fn interleave4(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    let a = _mm512_shuffle_i64x2::\u003c0x44\u003e(x, y);\r\n    let b = _mm512_shuffle_i64x2::\u003c0xee\u003e(x, y);\r\n    (a, b)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::{Goldilocks, WIDTH};\r\n\r\n    const SPECIAL_VALS: [Goldilocks; WIDTH] = Goldilocks::new_array([\r\n        0xFFFF_FFFF_0000_0001,\r\n        0xFFFF_FFFF_0000_0000,\r\n        0xFFFF_FFFE_FFFF_FFFF,\r\n        0xFFFF_FFFF_FFFF_FFFF,\r\n        0x0000_0000_0000_0000,\r\n        0x0000_0000_0000_0001,\r\n        0x0000_0000_0000_0002,\r\n        0x0FFF_FFFF_F000_0000,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedGoldilocksAVX512,\r\n        crate::PackedGoldilocksAVX512::ZERO,\r\n        crate::PackedGoldilocksAVX512(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":397,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":145},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","interpolation","src","lib.rs"],"content":"//! Tools for Lagrange interpolation.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{\r\n    batch_multiplicative_inverse, scale_vec, two_adic_coset_zerofier, ExtensionField, TwoAdicField,\r\n};\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::log2_strict_usize;\r\n\r\n/// Given evaluations of a batch of polynomials over the canonical power-of-two subgroup, evaluate\r\n/// the polynomials at `point`.\r\n///\r\n/// This assumes the point is not in the subgroup, otherwise the behavior is undefined.\r\npub fn interpolate_subgroup\u003cF, EF, Mat\u003e(subgroup_evals: \u0026Mat, point: EF) -\u003e Vec\u003cEF\u003e\r\nwhere\r\n    F: TwoAdicField,\r\n    EF: ExtensionField\u003cF\u003e + TwoAdicField,\r\n    Mat: Matrix\u003cF\u003e,\r\n{\r\n    interpolate_coset(subgroup_evals, F::ONE, point, None)\r\n}\r\n\r\n/// Given evaluations of a batch of polynomials over the given coset of the canonical power-of-two\r\n/// subgroup, evaluate the polynomials at `point`.\r\n///\r\n/// This assumes the point is not in the coset, otherwise the behavior is undefined.\r\n/// If available, reuse denominator diffs that is `1 / (x_i-z)` to avoid batch inversion.\r\npub fn interpolate_coset\u003cF, EF, Mat\u003e(\r\n    coset_evals: \u0026Mat,\r\n    shift: F,\r\n    point: EF,\r\n    diff_invs: Option\u003c\u0026[EF]\u003e,\r\n) -\u003e Vec\u003cEF\u003e\r\nwhere\r\n    F: TwoAdicField,\r\n    EF: ExtensionField\u003cF\u003e + TwoAdicField,\r\n    Mat: Matrix\u003cF\u003e,\r\n{\r\n    // Slight variation of this approach: https://hackmd.io/@vbuterin/barycentric_evaluation\r\n\r\n    let height = coset_evals.height();\r\n    let log_height = log2_strict_usize(height);\r\n\r\n    let g = F::two_adic_generator(log_height).powers().take(height);\r\n    let col_scale: Vec\u003c_\u003e = if let Some(diff_invs) = diff_invs {\r\n        g.zip(diff_invs)\r\n            .map(|(sg, \u0026diff_inv)| diff_inv * sg)\r\n            .collect()\r\n    } else {\r\n        let subgroup = g.collect::\u003cVec\u003c_\u003e\u003e();\r\n        let diffs: Vec\u003cEF\u003e = subgroup\r\n            .par_iter()\r\n            .map(|\u0026subgroup_i| point - subgroup_i * shift)\r\n            .collect();\r\n        let diff_invs = batch_multiplicative_inverse(\u0026diffs);\r\n        subgroup\r\n            .par_iter()\r\n            .zip(diff_invs)\r\n            .map(|(\u0026sg, diff_inv)| diff_inv * sg)\r\n            .collect()\r\n    };\r\n    let sum = coset_evals.columnwise_dot_product(\u0026col_scale);\r\n\r\n    let zerofier = two_adic_coset_zerofier::\u003cEF\u003e(log_height, shift.into(), point);\r\n\r\n    // In principle, height could be bigger than the characteristic of F.\r\n    let denominator = shift\r\n        .exp_u64(height as u64 - 1)\r\n        .mul_2exp_u64(log_height as u64);\r\n    scale_vec(zerofier * denominator.inverse(), sum)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n    use alloc::vec::Vec;\r\n\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_field::{batch_multiplicative_inverse, Field, PrimeCharacteristicRing};\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use p3_util::log2_strict_usize;\r\n\r\n    use crate::{interpolate_coset, interpolate_subgroup};\r\n\r\n    #[test]\r\n    fn test_interpolate_subgroup() {\r\n        // x^2 + 2 x + 3\r\n        type F = BabyBear;\r\n        let evals = [\r\n            6, 886605102, 1443543107, 708307799, 2, 556938009, 569722818, 1874680944,\r\n        ]\r\n        .map(F::from_u32);\r\n        let evals_mat = RowMajorMatrix::new(evals.to_vec(), 1);\r\n        let point = F::from_u16(100);\r\n        let result = interpolate_subgroup(\u0026evals_mat, point);\r\n        assert_eq!(result, vec![F::from_u16(10203)]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_interpolate_coset() {\r\n        // x^2 + 2 x + 3\r\n        type F = BabyBear;\r\n        let shift = F::GENERATOR;\r\n        let evals = [\r\n            1026, 129027310, 457985035, 994890337, 902, 1988942953, 1555278970, 913671254,\r\n        ]\r\n        .map(F::from_u32);\r\n        let evals_mat = RowMajorMatrix::new(evals.to_vec(), 1);\r\n        let point = F::from_u16(100);\r\n        let result = interpolate_coset(\u0026evals_mat, shift, point, None);\r\n        assert_eq!(result, vec![F::from_u16(10203)]);\r\n\r\n        use p3_field::TwoAdicField;\r\n        let n = evals.len();\r\n        let k = log2_strict_usize(n);\r\n\r\n        let denom: Vec\u003c_\u003e = F::two_adic_generator(k)\r\n            .shifted_powers(shift)\r\n            .take(n)\r\n            .map(|w| point - w)\r\n            .collect();\r\n\r\n        let denom = batch_multiplicative_inverse(\u0026denom);\r\n        let result = interpolate_coset(\u0026evals_mat, shift, point, Some(\u0026denom));\r\n        assert_eq!(result, vec![F::from_u16(10203)]);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":47,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":48,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":50,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":51,"address":[],"length":0,"stats":{"Line":9871890383196127478}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":5404319552844595200}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":59,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":1441151880758558768}},{"line":68,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":70,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":73,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":74,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":75,"address":[],"length":0,"stats":{"Line":15636497906230362194}},{"line":76,"address":[],"length":0,"stats":{"Line":15636497906230362194}}],"covered":21,"coverable":22},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","benches","bench_keccak.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, Criterion, Throughput};\r\nuse p3_field::PrimeCharacteristicRing;\r\nuse p3_keccak::{KeccakF, VECTOR_LEN};\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_symmetric::{CryptographicHasher, PaddingFreeSponge, Permutation, SerializingHasher32To64};\r\n\r\npub fn criterion_benchmark(c: \u0026mut Criterion) {\r\n    keccak_permutation(c);\r\n    keccak_u64_hash(c);\r\n    keccak_field_32_hash(c);\r\n}\r\n\r\npub fn keccak_permutation(c: \u0026mut Criterion) {\r\n    /// The rate is 136 bytes (per permutation), and our vectorized impl processes twice that.\r\n    const BYTES_PER_PERM: usize = 136 * VECTOR_LEN;\r\n\r\n    let mut group = c.benchmark_group(\"keccak permutation\");\r\n    let mut bytes: [[u64; VECTOR_LEN]; 25] = unsafe { core::mem::zeroed() };\r\n    group.throughput(Throughput::Bytes(BYTES_PER_PERM as u64));\r\n    group.bench_function(\"keccak permutation [[u64; VECTOR_LEN]; 25]\", |b| {\r\n        b.iter(|| KeccakF.permute_mut(black_box(\u0026mut bytes)))\r\n    });\r\n    group.finish();\r\n}\r\n\r\npub fn keccak_u64_hash(c: \u0026mut Criterion) {\r\n    const U64_PAIRS_PER_HASH: usize = 100;\r\n    const BYTES_PER_HASH: usize = size_of::\u003c[u64; VECTOR_LEN]\u003e() * U64_PAIRS_PER_HASH;\r\n    let input = vec![[0u64; VECTOR_LEN]; U64_PAIRS_PER_HASH];\r\n\r\n    type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\r\n    let u64_hash = U64Hash::new(KeccakF {});\r\n\r\n    let mut group = c.benchmark_group(\"keccak u64 hash\");\r\n    group.throughput(Throughput::Bytes(BYTES_PER_HASH as u64));\r\n    group.bench_function(\"keccak u64 hash_slice\", |b| {\r\n        b.iter(|| u64_hash.hash_slice(black_box(\u0026input)))\r\n    });\r\n    group.bench_function(\"keccak u64 hash_iter\", |b| {\r\n        b.iter(|| u64_hash.hash_iter(black_box(input.iter().copied())))\r\n    });\r\n    group.finish();\r\n}\r\n\r\npub fn keccak_field_32_hash(c: \u0026mut Criterion) {\r\n    type F = Mersenne31;\r\n    type P = [F; VECTOR_LEN];\r\n    const PACKED_ELEMS_PER_HASH: usize = 100;\r\n    const BYTES_PER_HASH: usize = size_of::\u003cP\u003e() * PACKED_ELEMS_PER_HASH;\r\n    let input = vec![[F::ZERO; VECTOR_LEN]; PACKED_ELEMS_PER_HASH];\r\n\r\n    type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\r\n    let u64_hash = U64Hash::new(KeccakF {});\r\n    type FieldHash = SerializingHasher32To64\u003cU64Hash\u003e;\r\n    let field_hash = FieldHash::new(u64_hash);\r\n\r\n    let mut group = c.benchmark_group(\"keccak field 32 hash\");\r\n    group.throughput(Throughput::Bytes(BYTES_PER_HASH as u64));\r\n    group.bench_function(\"keccak field 32 hash_slice\", |b| {\r\n        b.iter(|| {\r\n            \u003cFieldHash as CryptographicHasher\u003cP, [[u64; VECTOR_LEN]; 4]\u003e\u003e::hash_slice(\r\n                \u0026field_hash,\r\n                black_box(\u0026input),\r\n            )\r\n        })\r\n    });\r\n    group.bench_function(\"keccak field 32 hash_iter\", |b| {\r\n        b.iter(|| {\r\n            \u003cFieldHash as CryptographicHasher\u003cP, [[u64; VECTOR_LEN]; 4]\u003e\u003e::hash_iter(\r\n                \u0026field_hash,\r\n                black_box(input.iter().copied()),\r\n            )\r\n        })\r\n    });\r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(benches, criterion_benchmark);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","avx2.rs"],"content":"use core::arch::x86_64::{\r\n    __m256i, _mm256_add_epi64, _mm256_andnot_si256, _mm256_or_si256, _mm256_shuffle_epi8,\r\n    _mm256_slli_epi64, _mm256_srli_epi64, _mm256_xor_si256,\r\n};\r\nuse core::mem::transmute;\r\n\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\n\r\nuse crate::KeccakF;\r\n\r\npub const VECTOR_LEN: usize = 4;\r\n\r\nconst RC: [__m256i; 24] = unsafe {\r\n    transmute([\r\n        [1u64; 4],\r\n        [0x8082u64; 4],\r\n        [0x800000000000808au64; 4],\r\n        [0x8000000080008000u64; 4],\r\n        [0x808bu64; 4],\r\n        [0x80000001u64; 4],\r\n        [0x8000000080008081u64; 4],\r\n        [0x8000000000008009u64; 4],\r\n        [0x8au64; 4],\r\n        [0x88u64; 4],\r\n        [0x80008009u64; 4],\r\n        [0x8000000au64; 4],\r\n        [0x8000808bu64; 4],\r\n        [0x800000000000008bu64; 4],\r\n        [0x8000000000008089u64; 4],\r\n        [0x8000000000008003u64; 4],\r\n        [0x8000000000008002u64; 4],\r\n        [0x8000000000000080u64; 4],\r\n        [0x800au64; 4],\r\n        [0x800000008000000au64; 4],\r\n        [0x8000000080008081u64; 4],\r\n        [0x8000000000008080u64; 4],\r\n        [0x80000001u64; 4],\r\n        [0x8000000080008008u64; 4],\r\n    ])\r\n};\r\n\r\n#[inline(always)]\r\nfn form_matrix(buf: [__m256i; 25]) -\u003e [[__m256i; 5]; 5] {\r\n    unsafe { transmute(buf) }\r\n}\r\n\r\n#[inline(always)]\r\nfn flatten(mat: [[__m256i; 5]; 5]) -\u003e [__m256i; 25] {\r\n    unsafe { transmute(mat) }\r\n}\r\n\r\n#[inline(always)]\r\nfn rol_1(a: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let shl = _mm256_add_epi64(a, a);\r\n        let shr = _mm256_srli_epi64::\u003c63\u003e(a);\r\n        _mm256_or_si256(shl, shr)\r\n    }\r\n}\r\n\r\nconst ROL_8_CTRL: __m256i = unsafe {\r\n    transmute::\u003c[u8; 32], _\u003e([\r\n        0o07, 0o00, 0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o17, 0o10, 0o11, 0o12, 0o13, 0o14, 0o15,\r\n        0o16, 0o07, 0o00, 0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o17, 0o10, 0o11, 0o12, 0o13, 0o14,\r\n        0o15, 0o16,\r\n    ])\r\n};\r\n\r\n#[inline(always)]\r\nfn rol_8(a: __m256i) -\u003e __m256i {\r\n    unsafe { _mm256_shuffle_epi8(a, ROL_8_CTRL) }\r\n}\r\n\r\nconst ROL_56_CTRL: __m256i = unsafe {\r\n    transmute::\u003c[u8; 32], _\u003e([\r\n        0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o07, 0o00, 0o11, 0o12, 0o13, 0o14, 0o15, 0o16, 0o17,\r\n        0o10, 0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o07, 0o00, 0o11, 0o12, 0o13, 0o14, 0o15, 0o16,\r\n        0o17, 0o10,\r\n    ])\r\n};\r\n\r\n#[inline(always)]\r\nfn rol_56(a: __m256i) -\u003e __m256i {\r\n    unsafe { _mm256_shuffle_epi8(a, ROL_56_CTRL) }\r\n}\r\n\r\n#[inline(always)]\r\nfn rol\u003cconst SHL_AMT: i32, const SHR_AMT: i32\u003e(a: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let shl = _mm256_slli_epi64::\u003cSHL_AMT\u003e(a);\r\n        let shr = _mm256_srli_epi64::\u003cSHR_AMT\u003e(a);\r\n        _mm256_or_si256(shl, shr)\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn get_theta_parities(state: [[__m256i; 5]; 5]) -\u003e [__m256i; 5] {\r\n    unsafe {\r\n        let mut par0 = _mm256_xor_si256(state[0][0], state[1][0]);\r\n        let mut par1 = _mm256_xor_si256(state[0][1], state[1][1]);\r\n        let mut par2 = _mm256_xor_si256(state[0][2], state[1][2]);\r\n        let mut par3 = _mm256_xor_si256(state[0][3], state[1][3]);\r\n        let mut par4 = _mm256_xor_si256(state[0][4], state[1][4]);\r\n\r\n        par0 = _mm256_xor_si256(par0, state[2][0]);\r\n        par1 = _mm256_xor_si256(par1, state[2][1]);\r\n        par2 = _mm256_xor_si256(par2, state[2][2]);\r\n        par3 = _mm256_xor_si256(par3, state[2][3]);\r\n        par4 = _mm256_xor_si256(par4, state[2][4]);\r\n\r\n        par0 = _mm256_xor_si256(par0, state[3][0]);\r\n        par1 = _mm256_xor_si256(par1, state[3][1]);\r\n        par2 = _mm256_xor_si256(par2, state[3][2]);\r\n        par3 = _mm256_xor_si256(par3, state[3][3]);\r\n        par4 = _mm256_xor_si256(par4, state[3][4]);\r\n\r\n        par0 = _mm256_xor_si256(par0, state[4][0]);\r\n        par1 = _mm256_xor_si256(par1, state[4][1]);\r\n        par2 = _mm256_xor_si256(par2, state[4][2]);\r\n        par3 = _mm256_xor_si256(par3, state[4][3]);\r\n        par4 = _mm256_xor_si256(par4, state[4][4]);\r\n\r\n        [\r\n            _mm256_xor_si256(par4, rol_1(par1)),\r\n            _mm256_xor_si256(par0, rol_1(par2)),\r\n            _mm256_xor_si256(par1, rol_1(par3)),\r\n            _mm256_xor_si256(par2, rol_1(par4)),\r\n            _mm256_xor_si256(par3, rol_1(par0)),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn theta(state: [[__m256i; 5]; 5]) -\u003e [[__m256i; 5]; 5] {\r\n    let theta_parities = get_theta_parities(state);\r\n\r\n    unsafe {\r\n        [\r\n            [\r\n                _mm256_xor_si256(state[0][0], theta_parities[0]),\r\n                _mm256_xor_si256(state[0][1], theta_parities[1]),\r\n                _mm256_xor_si256(state[0][2], theta_parities[2]),\r\n                _mm256_xor_si256(state[0][3], theta_parities[3]),\r\n                _mm256_xor_si256(state[0][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm256_xor_si256(state[1][0], theta_parities[0]),\r\n                _mm256_xor_si256(state[1][1], theta_parities[1]),\r\n                _mm256_xor_si256(state[1][2], theta_parities[2]),\r\n                _mm256_xor_si256(state[1][3], theta_parities[3]),\r\n                _mm256_xor_si256(state[1][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm256_xor_si256(state[2][0], theta_parities[0]),\r\n                _mm256_xor_si256(state[2][1], theta_parities[1]),\r\n                _mm256_xor_si256(state[2][2], theta_parities[2]),\r\n                _mm256_xor_si256(state[2][3], theta_parities[3]),\r\n                _mm256_xor_si256(state[2][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm256_xor_si256(state[3][0], theta_parities[0]),\r\n                _mm256_xor_si256(state[3][1], theta_parities[1]),\r\n                _mm256_xor_si256(state[3][2], theta_parities[2]),\r\n                _mm256_xor_si256(state[3][3], theta_parities[3]),\r\n                _mm256_xor_si256(state[3][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm256_xor_si256(state[4][0], theta_parities[0]),\r\n                _mm256_xor_si256(state[4][1], theta_parities[1]),\r\n                _mm256_xor_si256(state[4][2], theta_parities[2]),\r\n                _mm256_xor_si256(state[4][3], theta_parities[3]),\r\n                _mm256_xor_si256(state[4][4], theta_parities[4]),\r\n            ],\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn rho(state: [[__m256i; 5]; 5]) -\u003e [[__m256i; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            rol_1(state[0][1]),\r\n            rol::\u003c62, { 64 - 62 }\u003e(state[0][2]),\r\n            rol::\u003c28, { 64 - 28 }\u003e(state[0][3]),\r\n            rol::\u003c27, { 64 - 27 }\u003e(state[0][4]),\r\n        ],\r\n        [\r\n            rol::\u003c36, { 64 - 36 }\u003e(state[1][0]),\r\n            rol::\u003c44, { 64 - 44 }\u003e(state[1][1]),\r\n            rol::\u003c6, { 64 - 6 }\u003e(state[1][2]),\r\n            rol::\u003c55, { 64 - 55 }\u003e(state[1][3]),\r\n            rol::\u003c20, { 64 - 20 }\u003e(state[1][4]),\r\n        ],\r\n        [\r\n            rol::\u003c3, { 64 - 3 }\u003e(state[2][0]),\r\n            rol::\u003c10, { 64 - 10 }\u003e(state[2][1]),\r\n            rol::\u003c43, { 64 - 43 }\u003e(state[2][2]),\r\n            rol::\u003c25, { 64 - 25 }\u003e(state[2][3]),\r\n            rol::\u003c39, { 64 - 39 }\u003e(state[2][4]),\r\n        ],\r\n        [\r\n            rol::\u003c41, { 64 - 41 }\u003e(state[3][0]),\r\n            rol::\u003c45, { 64 - 45 }\u003e(state[3][1]),\r\n            rol::\u003c15, { 64 - 15 }\u003e(state[3][2]),\r\n            rol::\u003c21, { 64 - 21 }\u003e(state[3][3]),\r\n            rol_8(state[3][4]),\r\n        ],\r\n        [\r\n            rol::\u003c18, { 64 - 18 }\u003e(state[4][0]),\r\n            rol::\u003c2, { 64 - 2 }\u003e(state[4][1]),\r\n            rol::\u003c61, { 64 - 61 }\u003e(state[4][2]),\r\n            rol_56(state[4][3]),\r\n            rol::\u003c14, { 64 - 14 }\u003e(state[4][4]),\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn pi(state: [[__m256i; 5]; 5]) -\u003e [[__m256i; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            state[1][1],\r\n            state[2][2],\r\n            state[3][3],\r\n            state[4][4],\r\n        ],\r\n        [\r\n            state[0][3],\r\n            state[1][4],\r\n            state[2][0],\r\n            state[3][1],\r\n            state[4][2],\r\n        ],\r\n        [\r\n            state[0][1],\r\n            state[1][2],\r\n            state[2][3],\r\n            state[3][4],\r\n            state[4][0],\r\n        ],\r\n        [\r\n            state[0][4],\r\n            state[1][0],\r\n            state[2][1],\r\n            state[3][2],\r\n            state[4][3],\r\n        ],\r\n        [\r\n            state[0][2],\r\n            state[1][3],\r\n            state[2][4],\r\n            state[3][0],\r\n            state[4][1],\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn chi_row(row: [__m256i; 5]) -\u003e [__m256i; 5] {\r\n    unsafe {\r\n        [\r\n            _mm256_xor_si256(row[0], _mm256_andnot_si256(row[1], row[2])),\r\n            _mm256_xor_si256(row[1], _mm256_andnot_si256(row[2], row[3])),\r\n            _mm256_xor_si256(row[2], _mm256_andnot_si256(row[3], row[4])),\r\n            _mm256_xor_si256(row[3], _mm256_andnot_si256(row[4], row[0])),\r\n            _mm256_xor_si256(row[4], _mm256_andnot_si256(row[0], row[1])),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn chi(state: [[__m256i; 5]; 5]) -\u003e [[__m256i; 5]; 5] {\r\n    [\r\n        chi_row(state[0]),\r\n        chi_row(state[1]),\r\n        chi_row(state[2]),\r\n        chi_row(state[3]),\r\n        chi_row(state[4]),\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn iota(i: usize, state: [[__m256i; 5]; 5]) -\u003e [[__m256i; 5]; 5] {\r\n    let mut res = state;\r\n    unsafe {\r\n        res[0][0] = _mm256_xor_si256(state[0][0], RC[i]);\r\n    }\r\n    res\r\n}\r\n\r\n#[inline(always)]\r\nfn round(i: usize, state: [__m256i; 25]) -\u003e [__m256i; 25] {\r\n    let mut state = form_matrix(state);\r\n    state = theta(state);\r\n    state = rho(state);\r\n    state = pi(state);\r\n    state = chi(state);\r\n    state = iota(i, state);\r\n    flatten(state)\r\n}\r\n\r\nfn keccak_perm(buf: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n    let mut state: [__m256i; 25] = unsafe { transmute(*buf) };\r\n    for i in 0..24 {\r\n        state = round(i, state);\r\n    }\r\n    *buf = unsafe { transmute::\u003c[__m256i; 25], [[u64; VECTOR_LEN]; 25]\u003e(state) };\r\n}\r\n\r\nimpl Permutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, state: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n        keccak_perm(state);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use tiny_keccak::keccakf;\r\n\r\n    use super::*;\r\n\r\n    const STATES: [[u64; 25]; 4] = [\r\n        [\r\n            0xc22c4c11dbedc46a,\r\n            0x317f74268c4f5cd0,\r\n            0x838719da5aa295b6,\r\n            0x9e9b17211985a3ba,\r\n            0x92927b963ce29d69,\r\n            0xf9a7169e38cc7216,\r\n            0x639a594d6fbfe341,\r\n            0x2335ebd8d15777bd,\r\n            0x44e1abc0d022823b,\r\n            0xb3657f9d16b36c13,\r\n            0x26d9217c32b3010a,\r\n            0x6e73d6e9c7e5bcc8,\r\n            0x400aa469d130a391,\r\n            0x1aa7c8a2cb97188a,\r\n            0xdc3084a09bd0a6e3,\r\n            0xbcfe3b656841baea,\r\n            0x325f41887c840166,\r\n            0x844656e313674bfe,\r\n            0xd63de8bad19d156c,\r\n            0x49ef0ac0ab52e147,\r\n            0x8b92ee811c654ca9,\r\n            0x42a9310fedf09bda,\r\n            0x182dbdac03a5358e,\r\n            0x3b4692ce58af8cb5,\r\n            0x534da610f01b8fb3,\r\n        ],\r\n        [\r\n            0x1c322ff4aea07d26,\r\n            0xbd67bde061c97612,\r\n            0x517565bd02ab410a,\r\n            0xb251273ddc12a725,\r\n            0x24f0979fe4f4fedc,\r\n            0xc32d063a64f0bf03,\r\n            0xd33c6709a7b103d2,\r\n            0xaf33a8224b5c8828,\r\n            0x6544ca066e997f1c,\r\n            0xd53ad41e39f06d68,\r\n            0x67695f6fb71d77d9,\r\n            0xd6378cf19ee510f2,\r\n            0x49472ea57abcbd08,\r\n            0xcf3739df1eefbbb4,\r\n            0x0fac1bf30e8ef101,\r\n            0x7ff04c9b90de0f27,\r\n            0xf3d63ec0e64cb2ab,\r\n            0x76388c05f377d4bd,\r\n            0x7886dd8f5b14ef5b,\r\n            0xb036d289ba24a513,\r\n            0x011e8fd6be65a408,\r\n            0x695e2d20848eec67,\r\n            0x31f9e80c5f45f8ee,\r\n            0xcdf873daf7a5fdeb,\r\n            0xfe98ff5bf28d560a,\r\n        ],\r\n        [\r\n            0xed7423c3e4cda469,\r\n            0x8bbbe52577993e33,\r\n            0x93182a78487f96db,\r\n            0x3c5209456d78dc73,\r\n            0x8b66bde37b967146,\r\n            0x226ae6e2148314fc,\r\n            0x302aed4f30cd2db9,\r\n            0x621a7c7751302084,\r\n            0x4054874254bc66cc,\r\n            0xb513327739d3c109,\r\n            0x0ae03189599dd81a,\r\n            0x457e6f324e512ed9,\r\n            0x3870ea63c7367728,\r\n            0xb08c7c0e401d2623,\r\n            0xa1316890c9bb3ac1,\r\n            0x0a313e02f34f6c7e,\r\n            0x7c1325754df4dbf5,\r\n            0x287e3d88240bedd2,\r\n            0xc7c0f3c5058290bb,\r\n            0x39471c62d065a4d1,\r\n            0x050d8ecb5c7911bf,\r\n            0x7a6cd7ca757186a7,\r\n            0xed14a51934a17895,\r\n            0x8a75418d7ffb98dd,\r\n            0x8096f8d803188d57,\r\n        ],\r\n        [\r\n            0x118d693606b316cd,\r\n            0xc2614f04c0dfca91,\r\n            0x5eb3da95450a214f,\r\n            0x193eb69a8198e724,\r\n            0xc24dea1c58e5fa6d,\r\n            0xcf8630adb771d47c,\r\n            0xe612253b23ade1df,\r\n            0x281b2b53f2d5fe61,\r\n            0x9a3f8fb149d7c419,\r\n            0x7ac1eeffbd426464,\r\n            0xb1bdb03caa7b20a3,\r\n            0x4e38a03b709d47d1,\r\n            0x35cafd22e9a91879,\r\n            0x26c9ae757c5b9f80,\r\n            0x9113b092720d90db,\r\n            0xeb504ed5104a0a09,\r\n            0x1405c220c45ee2b1,\r\n            0x8055d2c37b02472b,\r\n            0x545eeff9734b4b99,\r\n            0x79eb67721385dff8,\r\n            0x4133f750b0446360,\r\n            0x7167e6c1fd8ff59b,\r\n            0x576436ac7d46936e,\r\n            0x8db22fbb547d0826,\r\n            0xa855d775d64f0110,\r\n        ],\r\n    ];\r\n\r\n    #[allow(clippy::needless_range_loop)]\r\n    fn our_res() -\u003e [[u64; 25]; 4] {\r\n        let mut packed_result = [[0; 4]; 25];\r\n        for (i, packed_res) in packed_result.iter_mut().enumerate() {\r\n            *packed_res = [STATES[0][i], STATES[1][i], STATES[2][i], STATES[3][i]];\r\n        }\r\n\r\n        keccak_perm(\u0026mut packed_result);\r\n\r\n        let mut result = [[0; 25]; 4];\r\n        for (i, packed_res) in packed_result.iter_mut().enumerate() {\r\n            result[0][i] = packed_res[0];\r\n            result[1][i] = packed_res[1];\r\n            result[2][i] = packed_res[2];\r\n            result[3][i] = packed_res[3];\r\n        }\r\n        result\r\n    }\r\n\r\n    fn tiny_keccak_res() -\u003e [[u64; 25]; 4] {\r\n        let mut result = STATES;\r\n        keccakf(\u0026mut result[0]);\r\n        keccakf(\u0026mut result[1]);\r\n        keccakf(\u0026mut result[2]);\r\n        keccakf(\u0026mut result[3]);\r\n        result\r\n    }\r\n\r\n    #[test]\r\n    fn test_vs_tiny_keccak() {\r\n        let expected = tiny_keccak_res();\r\n        let computed = our_res();\r\n        assert_eq!(expected, computed);\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":44,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":48,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":49,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":53,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":55,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":56,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":57,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":70,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":71,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":83,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":84,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":88,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":90,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":91,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":92,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":97,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":99,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":100,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":101,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":102,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":103,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":105,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":106,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":107,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":108,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":109,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":111,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":112,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":113,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":114,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":115,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":117,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":118,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":119,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":120,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":121,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":124,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":125,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":126,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":127,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":128,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":134,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":135,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":140,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":141,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":142,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":143,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":144,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":147,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":148,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":149,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":150,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":151,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":154,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":155,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":156,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":157,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":158,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":161,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":162,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":163,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":164,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":165,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":168,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":169,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":170,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":171,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":172,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":179,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":182,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":183,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":184,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":185,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":186,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":189,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":190,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":191,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":192,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":193,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":196,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":197,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":198,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":199,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":200,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":203,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":204,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":205,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":206,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":207,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":210,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":211,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":212,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":213,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":214,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":220,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":223,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":224,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":225,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":226,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":227,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":230,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":231,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":232,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":233,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":234,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":237,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":238,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":239,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":240,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":241,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":244,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":245,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":246,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":247,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":248,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":251,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":252,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":253,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":254,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":255,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":261,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":264,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":265,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":266,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":267,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":268,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":274,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":276,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":277,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":278,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":279,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":280,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":285,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":286,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":288,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":290,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":294,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":295,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":296,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":297,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":298,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":299,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":300,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":301,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":304,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":305,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":306,"address":[],"length":0,"stats":{"Line":5260204364768739328}},{"line":307,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":309,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}}],"covered":150,"coverable":152},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","avx512.rs"],"content":"use core::arch::x86_64::{\r\n    __m512i, _mm512_rol_epi64, _mm512_set1_epi64, _mm512_ternarylogic_epi64, _mm512_xor_epi64,\r\n};\r\nuse core::mem::transmute;\r\n\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\n\r\nuse crate::KeccakF;\r\n\r\npub const VECTOR_LEN: usize = 8;\r\n\r\nconst RC: [u64; 24] = [\r\n    1u64,\r\n    0x8082u64,\r\n    0x800000000000808au64,\r\n    0x8000000080008000u64,\r\n    0x808bu64,\r\n    0x80000001u64,\r\n    0x8000000080008081u64,\r\n    0x8000000000008009u64,\r\n    0x8au64,\r\n    0x88u64,\r\n    0x80008009u64,\r\n    0x8000000au64,\r\n    0x8000808bu64,\r\n    0x800000000000008bu64,\r\n    0x8000000000008089u64,\r\n    0x8000000000008003u64,\r\n    0x8000000000008002u64,\r\n    0x8000000000000080u64,\r\n    0x800au64,\r\n    0x800000008000000au64,\r\n    0x8000000080008081u64,\r\n    0x8000000000008080u64,\r\n    0x80000001u64,\r\n    0x8000000080008008u64,\r\n];\r\n\r\n#[inline(always)]\r\nfn form_matrix(buf: [__m512i; 25]) -\u003e [[__m512i; 5]; 5] {\r\n    unsafe { transmute(buf) }\r\n}\r\n\r\n#[inline(always)]\r\nfn flatten(mat: [[__m512i; 5]; 5]) -\u003e [__m512i; 25] {\r\n    unsafe { transmute(mat) }\r\n}\r\n\r\n#[inline(always)]\r\nfn get_theta_parities(state: [[__m512i; 5]; 5]) -\u003e [(__m512i, __m512i); 5] {\r\n    unsafe {\r\n        let mut par0 =\r\n            _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(state[0][0], state[1][0], state[2][0]);\r\n        let mut par1 =\r\n            _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(state[0][1], state[1][1], state[2][1]);\r\n        let mut par2 =\r\n            _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(state[0][2], state[1][2], state[2][2]);\r\n        let mut par3 =\r\n            _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(state[0][3], state[1][3], state[2][3]);\r\n        let mut par4 =\r\n            _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(state[0][4], state[1][4], state[2][4]);\r\n\r\n        par0 = _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(par0, state[3][0], state[4][0]);\r\n        par1 = _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(par1, state[3][1], state[4][1]);\r\n        par2 = _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(par2, state[3][2], state[4][2]);\r\n        par3 = _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(par3, state[3][3], state[4][3]);\r\n        par4 = _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(par4, state[3][4], state[4][4]);\r\n\r\n        [\r\n            (par4, _mm512_rol_epi64::\u003c1\u003e(par1)),\r\n            (par0, _mm512_rol_epi64::\u003c1\u003e(par2)),\r\n            (par1, _mm512_rol_epi64::\u003c1\u003e(par3)),\r\n            (par2, _mm512_rol_epi64::\u003c1\u003e(par4)),\r\n            (par3, _mm512_rol_epi64::\u003c1\u003e(par0)),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn theta(state: [[__m512i; 5]; 5]) -\u003e [[__m512i; 5]; 5] {\r\n    let theta_parities = get_theta_parities(state);\r\n\r\n    unsafe {\r\n        [\r\n            [\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[0][0],\r\n                    theta_parities[0].0,\r\n                    theta_parities[0].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[0][1],\r\n                    theta_parities[1].0,\r\n                    theta_parities[1].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[0][2],\r\n                    theta_parities[2].0,\r\n                    theta_parities[2].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[0][3],\r\n                    theta_parities[3].0,\r\n                    theta_parities[3].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[0][4],\r\n                    theta_parities[4].0,\r\n                    theta_parities[4].1,\r\n                ),\r\n            ],\r\n            [\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[1][0],\r\n                    theta_parities[0].0,\r\n                    theta_parities[0].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[1][1],\r\n                    theta_parities[1].0,\r\n                    theta_parities[1].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[1][2],\r\n                    theta_parities[2].0,\r\n                    theta_parities[2].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[1][3],\r\n                    theta_parities[3].0,\r\n                    theta_parities[3].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[1][4],\r\n                    theta_parities[4].0,\r\n                    theta_parities[4].1,\r\n                ),\r\n            ],\r\n            [\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[2][0],\r\n                    theta_parities[0].0,\r\n                    theta_parities[0].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[2][1],\r\n                    theta_parities[1].0,\r\n                    theta_parities[1].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[2][2],\r\n                    theta_parities[2].0,\r\n                    theta_parities[2].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[2][3],\r\n                    theta_parities[3].0,\r\n                    theta_parities[3].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[2][4],\r\n                    theta_parities[4].0,\r\n                    theta_parities[4].1,\r\n                ),\r\n            ],\r\n            [\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[3][0],\r\n                    theta_parities[0].0,\r\n                    theta_parities[0].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[3][1],\r\n                    theta_parities[1].0,\r\n                    theta_parities[1].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[3][2],\r\n                    theta_parities[2].0,\r\n                    theta_parities[2].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[3][3],\r\n                    theta_parities[3].0,\r\n                    theta_parities[3].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[3][4],\r\n                    theta_parities[4].0,\r\n                    theta_parities[4].1,\r\n                ),\r\n            ],\r\n            [\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[4][0],\r\n                    theta_parities[0].0,\r\n                    theta_parities[0].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[4][1],\r\n                    theta_parities[1].0,\r\n                    theta_parities[1].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[4][2],\r\n                    theta_parities[2].0,\r\n                    theta_parities[2].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[4][3],\r\n                    theta_parities[3].0,\r\n                    theta_parities[3].1,\r\n                ),\r\n                _mm512_ternarylogic_epi64::\u003c0b10010110\u003e(\r\n                    state[4][4],\r\n                    theta_parities[4].0,\r\n                    theta_parities[4].1,\r\n                ),\r\n            ],\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn rho(state: [[__m512i; 5]; 5]) -\u003e [[__m512i; 5]; 5] {\r\n    unsafe {\r\n        [\r\n            [\r\n                state[0][0],\r\n                _mm512_rol_epi64::\u003c1\u003e(state[0][1]),\r\n                _mm512_rol_epi64::\u003c62\u003e(state[0][2]),\r\n                _mm512_rol_epi64::\u003c28\u003e(state[0][3]),\r\n                _mm512_rol_epi64::\u003c27\u003e(state[0][4]),\r\n            ],\r\n            [\r\n                _mm512_rol_epi64::\u003c36\u003e(state[1][0]),\r\n                _mm512_rol_epi64::\u003c44\u003e(state[1][1]),\r\n                _mm512_rol_epi64::\u003c6\u003e(state[1][2]),\r\n                _mm512_rol_epi64::\u003c55\u003e(state[1][3]),\r\n                _mm512_rol_epi64::\u003c20\u003e(state[1][4]),\r\n            ],\r\n            [\r\n                _mm512_rol_epi64::\u003c3\u003e(state[2][0]),\r\n                _mm512_rol_epi64::\u003c10\u003e(state[2][1]),\r\n                _mm512_rol_epi64::\u003c43\u003e(state[2][2]),\r\n                _mm512_rol_epi64::\u003c25\u003e(state[2][3]),\r\n                _mm512_rol_epi64::\u003c39\u003e(state[2][4]),\r\n            ],\r\n            [\r\n                _mm512_rol_epi64::\u003c41\u003e(state[3][0]),\r\n                _mm512_rol_epi64::\u003c45\u003e(state[3][1]),\r\n                _mm512_rol_epi64::\u003c15\u003e(state[3][2]),\r\n                _mm512_rol_epi64::\u003c21\u003e(state[3][3]),\r\n                _mm512_rol_epi64::\u003c8\u003e(state[3][4]),\r\n            ],\r\n            [\r\n                _mm512_rol_epi64::\u003c18\u003e(state[4][0]),\r\n                _mm512_rol_epi64::\u003c2\u003e(state[4][1]),\r\n                _mm512_rol_epi64::\u003c61\u003e(state[4][2]),\r\n                _mm512_rol_epi64::\u003c56\u003e(state[4][3]),\r\n                _mm512_rol_epi64::\u003c14\u003e(state[4][4]),\r\n            ],\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn pi(state: [[__m512i; 5]; 5]) -\u003e [[__m512i; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            state[1][1],\r\n            state[2][2],\r\n            state[3][3],\r\n            state[4][4],\r\n        ],\r\n        [\r\n            state[0][3],\r\n            state[1][4],\r\n            state[2][0],\r\n            state[3][1],\r\n            state[4][2],\r\n        ],\r\n        [\r\n            state[0][1],\r\n            state[1][2],\r\n            state[2][3],\r\n            state[3][4],\r\n            state[4][0],\r\n        ],\r\n        [\r\n            state[0][4],\r\n            state[1][0],\r\n            state[2][1],\r\n            state[3][2],\r\n            state[4][3],\r\n        ],\r\n        [\r\n            state[0][2],\r\n            state[1][3],\r\n            state[2][4],\r\n            state[3][0],\r\n            state[4][1],\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn chi_row(row: [__m512i; 5]) -\u003e [__m512i; 5] {\r\n    unsafe {\r\n        [\r\n            _mm512_ternarylogic_epi64::\u003c0b11010010\u003e(row[0], row[1], row[2]),\r\n            _mm512_ternarylogic_epi64::\u003c0b11010010\u003e(row[1], row[2], row[3]),\r\n            _mm512_ternarylogic_epi64::\u003c0b11010010\u003e(row[2], row[3], row[4]),\r\n            _mm512_ternarylogic_epi64::\u003c0b11010010\u003e(row[3], row[4], row[0]),\r\n            _mm512_ternarylogic_epi64::\u003c0b11010010\u003e(row[4], row[0], row[1]),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn chi(state: [[__m512i; 5]; 5]) -\u003e [[__m512i; 5]; 5] {\r\n    [\r\n        chi_row(state[0]),\r\n        chi_row(state[1]),\r\n        chi_row(state[2]),\r\n        chi_row(state[3]),\r\n        chi_row(state[4]),\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn iota(i: usize, state: [[__m512i; 5]; 5]) -\u003e [[__m512i; 5]; 5] {\r\n    let mut res = state;\r\n    unsafe {\r\n        res[0][0] = _mm512_xor_epi64(state[0][0], _mm512_set1_epi64(RC[i] as i64));\r\n    }\r\n    res\r\n}\r\n#[inline(always)]\r\nfn round(i: usize, state: [__m512i; 25]) -\u003e [__m512i; 25] {\r\n    let mut state = form_matrix(state);\r\n    state = theta(state);\r\n    state = rho(state);\r\n    state = pi(state);\r\n    state = chi(state);\r\n    state = iota(i, state);\r\n    flatten(state)\r\n}\r\n\r\nfn keccak_perm(buf: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n    let mut state: [__m512i; 25] = unsafe { transmute(*buf) };\r\n    for i in 0..24 {\r\n        state = round(i, state);\r\n    }\r\n    *buf = unsafe { transmute::\u003c[__m512i; 25], [[u64; VECTOR_LEN]; 25]\u003e(state) };\r\n}\r\n\r\nimpl Permutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, state: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n        keccak_perm(state);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use tiny_keccak::keccakf;\r\n\r\n    use super::*;\r\n\r\n    const STATES: [[u64; 25]; 8] = [\r\n        [\r\n            0xc22c4c11dbedc46a,\r\n            0x317f74268c4f5cd0,\r\n            0x838719da5aa295b6,\r\n            0x9e9b17211985a3ba,\r\n            0x92927b963ce29d69,\r\n            0xf9a7169e38cc7216,\r\n            0x639a594d6fbfe341,\r\n            0x2335ebd8d15777bd,\r\n            0x44e1abc0d022823b,\r\n            0xb3657f9d16b36c13,\r\n            0x26d9217c32b3010a,\r\n            0x6e73d6e9c7e5bcc8,\r\n            0x400aa469d130a391,\r\n            0x1aa7c8a2cb97188a,\r\n            0xdc3084a09bd0a6e3,\r\n            0xbcfe3b656841baea,\r\n            0x325f41887c840166,\r\n            0x844656e313674bfe,\r\n            0xd63de8bad19d156c,\r\n            0x49ef0ac0ab52e147,\r\n            0x8b92ee811c654ca9,\r\n            0x42a9310fedf09bda,\r\n            0x182dbdac03a5358e,\r\n            0x3b4692ce58af8cb5,\r\n            0x534da610f01b8fb3,\r\n        ],\r\n        [\r\n            0x1c322ff4aea07d26,\r\n            0xbd67bde061c97612,\r\n            0x517565bd02ab410a,\r\n            0xb251273ddc12a725,\r\n            0x24f0979fe4f4fedc,\r\n            0xc32d063a64f0bf03,\r\n            0xd33c6709a7b103d2,\r\n            0xaf33a8224b5c8828,\r\n            0x6544ca066e997f1c,\r\n            0xd53ad41e39f06d68,\r\n            0x67695f6fb71d77d9,\r\n            0xd6378cf19ee510f2,\r\n            0x49472ea57abcbd08,\r\n            0xcf3739df1eefbbb4,\r\n            0x0fac1bf30e8ef101,\r\n            0x7ff04c9b90de0f27,\r\n            0xf3d63ec0e64cb2ab,\r\n            0x76388c05f377d4bd,\r\n            0x7886dd8f5b14ef5b,\r\n            0xb036d289ba24a513,\r\n            0x011e8fd6be65a408,\r\n            0x695e2d20848eec67,\r\n            0x31f9e80c5f45f8ee,\r\n            0xcdf873daf7a5fdeb,\r\n            0xfe98ff5bf28d560a,\r\n        ],\r\n        [\r\n            0xed7423c3e4cda469,\r\n            0x8bbbe52577993e33,\r\n            0x93182a78487f96db,\r\n            0x3c5209456d78dc73,\r\n            0x8b66bde37b967146,\r\n            0x226ae6e2148314fc,\r\n            0x302aed4f30cd2db9,\r\n            0x621a7c7751302084,\r\n            0x4054874254bc66cc,\r\n            0xb513327739d3c109,\r\n            0x0ae03189599dd81a,\r\n            0x457e6f324e512ed9,\r\n            0x3870ea63c7367728,\r\n            0xb08c7c0e401d2623,\r\n            0xa1316890c9bb3ac1,\r\n            0x0a313e02f34f6c7e,\r\n            0x7c1325754df4dbf5,\r\n            0x287e3d88240bedd2,\r\n            0xc7c0f3c5058290bb,\r\n            0x39471c62d065a4d1,\r\n            0x050d8ecb5c7911bf,\r\n            0x7a6cd7ca757186a7,\r\n            0xed14a51934a17895,\r\n            0x8a75418d7ffb98dd,\r\n            0x8096f8d803188d57,\r\n        ],\r\n        [\r\n            0x118d693606b316cd,\r\n            0xc2614f04c0dfca91,\r\n            0x5eb3da95450a214f,\r\n            0x193eb69a8198e724,\r\n            0xc24dea1c58e5fa6d,\r\n            0xcf8630adb771d47c,\r\n            0xe612253b23ade1df,\r\n            0x281b2b53f2d5fe61,\r\n            0x9a3f8fb149d7c419,\r\n            0x7ac1eeffbd426464,\r\n            0xb1bdb03caa7b20a3,\r\n            0x4e38a03b709d47d1,\r\n            0x35cafd22e9a91879,\r\n            0x26c9ae757c5b9f80,\r\n            0x9113b092720d90db,\r\n            0xeb504ed5104a0a09,\r\n            0x1405c220c45ee2b1,\r\n            0x8055d2c37b02472b,\r\n            0x545eeff9734b4b99,\r\n            0x79eb67721385dff8,\r\n            0x4133f750b0446360,\r\n            0x7167e6c1fd8ff59b,\r\n            0x576436ac7d46936e,\r\n            0x8db22fbb547d0826,\r\n            0xa855d775d64f0110,\r\n        ],\r\n        [\r\n            0x3a7a076a7653164a,\r\n            0x831ec41826c9f433,\r\n            0xe741ec156d6cc2e8,\r\n            0x9d22d9b4c52d1fcd,\r\n            0x29378130bb66801f,\r\n            0x7cb8ed48278ca775,\r\n            0xda6eb5186ea6d93a,\r\n            0xcb1af159fddb7de9,\r\n            0x36fcc875105933ec,\r\n            0x769bcf74dfc5633e,\r\n            0x007493ff65d57f29,\r\n            0xf25df62693770de4,\r\n            0xa19106354a107435,\r\n            0x3e22d2a729a5cfc0,\r\n            0x1b668ba97bb34bda,\r\n            0x3431c9e512de7508,\r\n            0xaef52c95d26bee5c,\r\n            0xd469b70970274fac,\r\n            0xacb862720dc53c99,\r\n            0x5611b0fac5ee9c0e,\r\n            0xbd0c97dc9334b4d1,\r\n            0x60f5b3e10a84d18b,\r\n            0xcdc7ce6afa7bb654,\r\n            0xf9718de3fbd9912e,\r\n            0x52cf33b8bc689764,\r\n        ],\r\n        [\r\n            0x05bb9ba0620488de,\r\n            0x255c733bef224059,\r\n            0x836115d2296389ba,\r\n            0x0ab2167d49cb289f,\r\n            0x1e945f1edf1ae30f,\r\n            0x36af6f7dd549671a,\r\n            0xb916e7817d618a31,\r\n            0xacc5e1bc38255a26,\r\n            0x6e30e1996f6ff60d,\r\n            0x444d39f393a03988,\r\n            0x9be737f450a656d1,\r\n            0x54908135176000bb,\r\n            0x22dfe68128bbbd2a,\r\n            0x4538a20e8a41722f,\r\n            0x9300dad7d26702ac,\r\n            0x1ca0e4154cb8fa3c,\r\n            0xe79bd6461d454f8c,\r\n            0x97623f4622fc67f1,\r\n            0xdd34f7723269bec4,\r\n            0x095027718c687fe2,\r\n            0x765164adaf88f509,\r\n            0x10398b41075c534f,\r\n            0xe4f0b2a3dc53fa47,\r\n            0x47d683e87df22978,\r\n            0x977202dbb006d455,\r\n        ],\r\n        [\r\n            0x6de734e9ca9ddca9,\r\n            0x7cc622c3598980d0,\r\n            0x8c70c4f776592af9,\r\n            0x144bf613df515cce,\r\n            0xed86fd2c951c694d,\r\n            0x0a611f64e6cc71c3,\r\n            0xae4f84322fc5998a,\r\n            0xb816fc65939ab4a8,\r\n            0xa577b843b0abd02e,\r\n            0x2160c58bb6db9141,\r\n            0xc265e1147f5acd16,\r\n            0x2e92b214f27e458c,\r\n            0xa3a3ebcd6499c3cf,\r\n            0x7bc8a5d387a5ad1f,\r\n            0xf76dea4bb3417c7a,\r\n            0x6f4363ceac81fb57,\r\n            0x32b5083239511ab5,\r\n            0x9a0d5ab2ce107ca6,\r\n            0x096a14d0969929c3,\r\n            0x584c7db06dff5e95,\r\n            0x8c65e65adf7b69bc,\r\n            0x022d0d01ad78864c,\r\n            0x446e102a8d2bcc57,\r\n            0x2320241b97aadd47,\r\n            0x1f13645237109652,\r\n        ],\r\n        [\r\n            0xe3149e204e6a7aa5,\r\n            0x23897bedb6c59de2,\r\n            0x03f0745c35262f50,\r\n            0x8dcf451d452046ed,\r\n            0xfb287468366762a1,\r\n            0x78985371e9efbf92,\r\n            0x6666bed6730a6dec,\r\n            0xe8558e22c8470063,\r\n            0x21ef2a4bc19dee21,\r\n            0x1ee3471999a6b9d2,\r\n            0x4bf213b0fa5d9543,\r\n            0x58eb13d92e3e3ee0,\r\n            0xe846d822d8c8465f,\r\n            0x8d1651f1bbb16da3,\r\n            0x22ee8e86032c05f9,\r\n            0xcef6a50f4ffb4858,\r\n            0xfcbbb4a9a09bd82a,\r\n            0xa40a08af13eff462,\r\n            0x10dc2712bd87257e,\r\n            0xe62affc17fc01ee6,\r\n            0xecc888362afd5d4c,\r\n            0x8caf7e13b4c630bc,\r\n            0xa6cec6299e0ec6fb,\r\n            0xb876c1f8dd351df4,\r\n            0x9e8edc1e068c2f1c,\r\n        ],\r\n    ];\r\n\r\n    #[allow(clippy::needless_range_loop)]\r\n    fn our_res() -\u003e [[u64; 25]; 8] {\r\n        let mut packed_result = [[0; 8]; 25];\r\n        for (i, packed_res) in packed_result.iter_mut().enumerate() {\r\n            *packed_res = [\r\n                STATES[0][i],\r\n                STATES[1][i],\r\n                STATES[2][i],\r\n                STATES[3][i],\r\n                STATES[4][i],\r\n                STATES[5][i],\r\n                STATES[6][i],\r\n                STATES[7][i],\r\n            ];\r\n        }\r\n\r\n        keccak_perm(\u0026mut packed_result);\r\n\r\n        let mut result = [[0; 25]; 8];\r\n        for (i, packed_res) in packed_result.iter_mut().enumerate() {\r\n            result[0][i] = packed_res[0];\r\n            result[1][i] = packed_res[1];\r\n            result[2][i] = packed_res[2];\r\n            result[3][i] = packed_res[3];\r\n            result[4][i] = packed_res[4];\r\n            result[5][i] = packed_res[5];\r\n            result[6][i] = packed_res[6];\r\n            result[7][i] = packed_res[7];\r\n        }\r\n        result\r\n    }\r\n\r\n    fn tiny_keccak_res() -\u003e [[u64; 25]; 8] {\r\n        let mut result = STATES;\r\n        keccakf(\u0026mut result[0]);\r\n        keccakf(\u0026mut result[1]);\r\n        keccakf(\u0026mut result[2]);\r\n        keccakf(\u0026mut result[3]);\r\n        keccakf(\u0026mut result[4]);\r\n        keccakf(\u0026mut result[5]);\r\n        keccakf(\u0026mut result[6]);\r\n        keccakf(\u0026mut result[7]);\r\n        result\r\n    }\r\n\r\n    #[test]\r\n    fn test_vs_tiny_keccak() {\r\n        let expected = tiny_keccak_res();\r\n        let computed = our_res();\r\n        assert_eq!(expected, computed);\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":341,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":203},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","fallback.rs"],"content":"//! This module should be included only when none of the more target-specific implementations are\r\n//! available. It fills in a few things based on a pure Rust implementation of Keccak.\r\n\r\nuse core::mem::transmute;\r\n\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\n\r\nuse crate::KeccakF;\r\n\r\npub const VECTOR_LEN: usize = 1;\r\n\r\nimpl Permutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, input: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n        let input: \u0026mut [u64; 25] = unsafe { transmute(input) };\r\n        self.permute_mut(input);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","lib.rs"],"content":"//! The Keccak-f permutation, and hash functions built from it.\r\n\r\n#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nuse p3_symmetric::{CryptographicHasher, CryptographicPermutation, Permutation};\r\nuse tiny_keccak::{keccakf, Hasher, Keccak};\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub mod avx512;\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use avx512::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub mod avx2;\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use avx2::*;\r\n\r\n#[cfg(all(target_arch = \"x86_64\", not(target_feature = \"avx2\")))]\r\npub mod sse2;\r\n#[cfg(all(target_arch = \"x86_64\", not(target_feature = \"avx2\")))]\r\npub use sse2::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"aarch64\",\r\n    target_feature = \"neon\",\r\n    target_feature = \"sha3\"\r\n))]\r\npub mod neon;\r\n#[cfg(all(\r\n    target_arch = \"aarch64\",\r\n    target_feature = \"neon\",\r\n    target_feature = \"sha3\"\r\n))]\r\npub use neon::*;\r\n\r\n#[cfg(not(any(\r\n    all(\r\n        target_arch = \"aarch64\",\r\n        target_feature = \"neon\",\r\n        target_feature = \"sha3\",\r\n    ),\r\n    target_arch = \"x86_64\",\r\n)))]\r\nmod fallback;\r\n#[cfg(not(any(\r\n    all(\r\n        target_arch = \"aarch64\",\r\n        target_feature = \"neon\",\r\n        target_feature = \"sha3\",\r\n    ),\r\n    target_arch = \"x86_64\",\r\n)))]\r\npub use fallback::*;\r\n\r\n/// The Keccak-f permutation.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct KeccakF;\r\n\r\nimpl Permutation\u003c[u64; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, input: \u0026mut [u64; 25]) {\r\n        keccakf(input);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[u64; 25]\u003e for KeccakF {}\r\n\r\nimpl Permutation\u003c[u8; 200]\u003e for KeccakF {\r\n    fn permute(\u0026self, input_u8s: [u8; 200]) -\u003e [u8; 200] {\r\n        let mut state_u64s: [u64; 25] = core::array::from_fn(|i| {\r\n            u64::from_le_bytes(input_u8s[i * 8..][..8].try_into().unwrap())\r\n        });\r\n\r\n        keccakf(\u0026mut state_u64s);\r\n\r\n        core::array::from_fn(|i| {\r\n            let u64_limb = state_u64s[i / 8];\r\n            u64_limb.to_le_bytes()[i % 8]\r\n        })\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [u8; 200]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[u8; 200]\u003e for KeccakF {}\r\n\r\n/// The `Keccak` hash functions defined in\r\n/// [Keccak SHA3 submission](https://keccak.team/files/Keccak-submission-3.pdf).\r\n#[derive(Copy, Clone, Debug)]\r\npub struct Keccak256Hash;\r\n\r\nimpl CryptographicHasher\u003cu8, [u8; 32]\u003e for Keccak256Hash {\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = u8\u003e,\r\n    {\r\n        const BUFLEN: usize = 512; // Tweakable parameter; determined by experiment\r\n        let mut hasher = Keccak::v256();\r\n        p3_util::apply_to_chunks::\u003cBUFLEN, _, _\u003e(input, |buf| hasher.update(buf));\r\n\r\n        let mut output = [0u8; 32];\r\n        hasher.finalize(\u0026mut output);\r\n        output\r\n    }\r\n\r\n    fn hash_iter_slices\u003c'a, I\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = \u0026'a [u8]\u003e,\r\n    {\r\n        let mut hasher = Keccak::v256();\r\n        for chunk in input.into_iter() {\r\n            hasher.update(chunk);\r\n        }\r\n\r\n        let mut output = [0u8; 32];\r\n        hasher.finalize(\u0026mut output);\r\n        output\r\n    }\r\n}\r\n","traces":[{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":123,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":124,"address":[],"length":0,"stats":{"Line":18446744073709551607}},{"line":126,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":127,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":128,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":24},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","neon.rs"],"content":"use core::arch::aarch64::{uint64x2_t, vbcaxq_u64, veor3q_u64, veorq_u64, vrax1q_u64, vxarq_u64};\r\nuse core::mem::transmute;\r\n\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\n\r\nuse crate::KeccakF;\r\n\r\npub const VECTOR_LEN: usize = 2;\r\n\r\nconst RC: [uint64x2_t; 24] = unsafe {\r\n    transmute([\r\n        [1u64; 2],\r\n        [0x8082u64; 2],\r\n        [0x800000000000808au64; 2],\r\n        [0x8000000080008000u64; 2],\r\n        [0x808bu64; 2],\r\n        [0x80000001u64; 2],\r\n        [0x8000000080008081u64; 2],\r\n        [0x8000000000008009u64; 2],\r\n        [0x8au64; 2],\r\n        [0x88u64; 2],\r\n        [0x80008009u64; 2],\r\n        [0x8000000au64; 2],\r\n        [0x8000808bu64; 2],\r\n        [0x800000000000008bu64; 2],\r\n        [0x8000000000008089u64; 2],\r\n        [0x8000000000008003u64; 2],\r\n        [0x8000000000008002u64; 2],\r\n        [0x8000000000000080u64; 2],\r\n        [0x800au64; 2],\r\n        [0x800000008000000au64; 2],\r\n        [0x8000000080008081u64; 2],\r\n        [0x8000000000008080u64; 2],\r\n        [0x80000001u64; 2],\r\n        [0x8000000080008008u64; 2],\r\n    ])\r\n};\r\n\r\n#[inline(always)]\r\nfn form_matrix(buf: [uint64x2_t; 25]) -\u003e [[uint64x2_t; 5]; 5] {\r\n    unsafe { transmute(buf) }\r\n}\r\n\r\n#[inline(always)]\r\nfn flatten(mat: [[uint64x2_t; 5]; 5]) -\u003e [uint64x2_t; 25] {\r\n    unsafe { transmute(mat) }\r\n}\r\n\r\n#[inline(always)]\r\nfn get_theta_parities(state: [[uint64x2_t; 5]; 5]) -\u003e [uint64x2_t; 5] {\r\n    unsafe {\r\n        let mut par0 = veor3q_u64(state[0][0], state[1][0], state[2][0]);\r\n        let mut par1 = veor3q_u64(state[0][1], state[1][1], state[2][1]);\r\n        let mut par2 = veor3q_u64(state[0][2], state[1][2], state[2][2]);\r\n        let mut par3 = veor3q_u64(state[0][3], state[1][3], state[2][3]);\r\n        let mut par4 = veor3q_u64(state[0][4], state[1][4], state[2][4]);\r\n\r\n        par0 = veor3q_u64(par0, state[3][0], state[4][0]);\r\n        par1 = veor3q_u64(par1, state[3][1], state[4][1]);\r\n        par2 = veor3q_u64(par2, state[3][2], state[4][2]);\r\n        par3 = veor3q_u64(par3, state[3][3], state[4][3]);\r\n        par4 = veor3q_u64(par4, state[3][4], state[4][4]);\r\n\r\n        [\r\n            vrax1q_u64(par4, par1),\r\n            vrax1q_u64(par0, par2),\r\n            vrax1q_u64(par1, par3),\r\n            vrax1q_u64(par2, par4),\r\n            vrax1q_u64(par3, par0),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn theta_rho(state: [[uint64x2_t; 5]; 5]) -\u003e [[uint64x2_t; 5]; 5] {\r\n    let theta_parities = get_theta_parities(state);\r\n\r\n    unsafe {\r\n        [\r\n            [\r\n                veorq_u64(state[0][0], theta_parities[0]),\r\n                vxarq_u64::\u003c63\u003e(state[0][1], theta_parities[1]),\r\n                vxarq_u64::\u003c2\u003e(state[0][2], theta_parities[2]),\r\n                vxarq_u64::\u003c36\u003e(state[0][3], theta_parities[3]),\r\n                vxarq_u64::\u003c37\u003e(state[0][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                vxarq_u64::\u003c28\u003e(state[1][0], theta_parities[0]),\r\n                vxarq_u64::\u003c20\u003e(state[1][1], theta_parities[1]),\r\n                vxarq_u64::\u003c58\u003e(state[1][2], theta_parities[2]),\r\n                vxarq_u64::\u003c9\u003e(state[1][3], theta_parities[3]),\r\n                vxarq_u64::\u003c44\u003e(state[1][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                vxarq_u64::\u003c61\u003e(state[2][0], theta_parities[0]),\r\n                vxarq_u64::\u003c54\u003e(state[2][1], theta_parities[1]),\r\n                vxarq_u64::\u003c21\u003e(state[2][2], theta_parities[2]),\r\n                vxarq_u64::\u003c39\u003e(state[2][3], theta_parities[3]),\r\n                vxarq_u64::\u003c25\u003e(state[2][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                vxarq_u64::\u003c23\u003e(state[3][0], theta_parities[0]),\r\n                vxarq_u64::\u003c19\u003e(state[3][1], theta_parities[1]),\r\n                vxarq_u64::\u003c49\u003e(state[3][2], theta_parities[2]),\r\n                vxarq_u64::\u003c43\u003e(state[3][3], theta_parities[3]),\r\n                vxarq_u64::\u003c56\u003e(state[3][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                vxarq_u64::\u003c46\u003e(state[4][0], theta_parities[0]),\r\n                vxarq_u64::\u003c62\u003e(state[4][1], theta_parities[1]),\r\n                vxarq_u64::\u003c3\u003e(state[4][2], theta_parities[2]),\r\n                vxarq_u64::\u003c8\u003e(state[4][3], theta_parities[3]),\r\n                vxarq_u64::\u003c50\u003e(state[4][4], theta_parities[4]),\r\n            ],\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn pi(state: [[uint64x2_t; 5]; 5]) -\u003e [[uint64x2_t; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            state[1][1],\r\n            state[2][2],\r\n            state[3][3],\r\n            state[4][4],\r\n        ],\r\n        [\r\n            state[0][3],\r\n            state[1][4],\r\n            state[2][0],\r\n            state[3][1],\r\n            state[4][2],\r\n        ],\r\n        [\r\n            state[0][1],\r\n            state[1][2],\r\n            state[2][3],\r\n            state[3][4],\r\n            state[4][0],\r\n        ],\r\n        [\r\n            state[0][4],\r\n            state[1][0],\r\n            state[2][1],\r\n            state[3][2],\r\n            state[4][3],\r\n        ],\r\n        [\r\n            state[0][2],\r\n            state[1][3],\r\n            state[2][4],\r\n            state[3][0],\r\n            state[4][1],\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn chi_row(row: [uint64x2_t; 5]) -\u003e [uint64x2_t; 5] {\r\n    unsafe {\r\n        [\r\n            vbcaxq_u64(row[0], row[2], row[1]),\r\n            vbcaxq_u64(row[1], row[3], row[2]),\r\n            vbcaxq_u64(row[2], row[4], row[3]),\r\n            vbcaxq_u64(row[3], row[0], row[4]),\r\n            vbcaxq_u64(row[4], row[1], row[0]),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn chi(state: [[uint64x2_t; 5]; 5]) -\u003e [[uint64x2_t; 5]; 5] {\r\n    [\r\n        chi_row(state[0]),\r\n        chi_row(state[1]),\r\n        chi_row(state[2]),\r\n        chi_row(state[3]),\r\n        chi_row(state[4]),\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn iota(i: usize, state: [[uint64x2_t; 5]; 5]) -\u003e [[uint64x2_t; 5]; 5] {\r\n    let mut res = state;\r\n    unsafe {\r\n        res[0][0] = veorq_u64(state[0][0], RC[i]);\r\n    }\r\n    res\r\n}\r\n\r\n#[inline(always)]\r\nfn round(i: usize, state: [uint64x2_t; 25]) -\u003e [uint64x2_t; 25] {\r\n    let mut state = form_matrix(state);\r\n    state = theta_rho(state);\r\n    state = pi(state);\r\n    state = chi(state);\r\n    state = iota(i, state);\r\n    flatten(state)\r\n}\r\n\r\nfn keccak_perm(buf: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n    let mut state: [uint64x2_t; 25] = unsafe { transmute(*buf) };\r\n    for i in 0..24 {\r\n        state = round(i, state);\r\n    }\r\n    *buf = unsafe { transmute::\u003c[uint64x2_t; 25], [[u64; VECTOR_LEN]; 25]\u003e(state) };\r\n}\r\n\r\nimpl Permutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, state: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n        keccak_perm(state);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use tiny_keccak::keccakf;\r\n\r\n    use super::*;\r\n\r\n    const STATES: [[u64; 25]; 2] = [\r\n        [\r\n            0xc22c4c11dbedc46a,\r\n            0x317f74268c4f5cd0,\r\n            0x838719da5aa295b6,\r\n            0x9e9b17211985a3ba,\r\n            0x92927b963ce29d69,\r\n            0xf9a7169e38cc7216,\r\n            0x639a594d6fbfe341,\r\n            0x2335ebd8d15777bd,\r\n            0x44e1abc0d022823b,\r\n            0xb3657f9d16b36c13,\r\n            0x26d9217c32b3010a,\r\n            0x6e73d6e9c7e5bcc8,\r\n            0x400aa469d130a391,\r\n            0x1aa7c8a2cb97188a,\r\n            0xdc3084a09bd0a6e3,\r\n            0xbcfe3b656841baea,\r\n            0x325f41887c840166,\r\n            0x844656e313674bfe,\r\n            0xd63de8bad19d156c,\r\n            0x49ef0ac0ab52e147,\r\n            0x8b92ee811c654ca9,\r\n            0x42a9310fedf09bda,\r\n            0x182dbdac03a5358e,\r\n            0x3b4692ce58af8cb5,\r\n            0x534da610f01b8fb3,\r\n        ],\r\n        [\r\n            0x1c322ff4aea07d26,\r\n            0xbd67bde061c97612,\r\n            0x517565bd02ab410a,\r\n            0xb251273ddc12a725,\r\n            0x24f0979fe4f4fedc,\r\n            0xc32d063a64f0bf03,\r\n            0xd33c6709a7b103d2,\r\n            0xaf33a8224b5c8828,\r\n            0x6544ca066e997f1c,\r\n            0xd53ad41e39f06d68,\r\n            0x67695f6fb71d77d9,\r\n            0xd6378cf19ee510f2,\r\n            0x49472ea57abcbd08,\r\n            0xcf3739df1eefbbb4,\r\n            0x0fac1bf30e8ef101,\r\n            0x7ff04c9b90de0f27,\r\n            0xf3d63ec0e64cb2ab,\r\n            0x76388c05f377d4bd,\r\n            0x7886dd8f5b14ef5b,\r\n            0xb036d289ba24a513,\r\n            0x011e8fd6be65a408,\r\n            0x695e2d20848eec67,\r\n            0x31f9e80c5f45f8ee,\r\n            0xcdf873daf7a5fdeb,\r\n            0xfe98ff5bf28d560a,\r\n        ],\r\n    ];\r\n\r\n    #[allow(clippy::needless_range_loop)]\r\n    fn our_res() -\u003e [[u64; 25]; 2] {\r\n        let mut packed_result = [[0; 2]; 25];\r\n        for i in 0..25 {\r\n            packed_result[i] = [STATES[0][i], STATES[1][i]];\r\n        }\r\n\r\n        keccak_perm(\u0026mut packed_result);\r\n\r\n        let mut result = [[0; 25]; 2];\r\n        for i in 0..25 {\r\n            result[0][i] = packed_result[i][0];\r\n            result[1][i] = packed_result[i][1];\r\n        }\r\n        result\r\n    }\r\n\r\n    fn tiny_keccak_res() -\u003e [[u64; 25]; 2] {\r\n        let mut result = STATES;\r\n        keccakf(\u0026mut result[0]);\r\n        keccakf(\u0026mut result[1]);\r\n        result\r\n    }\r\n\r\n    #[test]\r\n    fn test_vs_tiny_keccak() {\r\n        let expected = tiny_keccak_res();\r\n        let computed = our_res();\r\n        assert_eq!(expected, computed);\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":96},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak","src","sse2.rs"],"content":"use core::arch::x86_64::{\r\n    __m128i, _mm_add_epi64, _mm_andnot_si128, _mm_or_si128, _mm_slli_epi64, _mm_srli_epi64,\r\n    _mm_xor_si128,\r\n};\r\nuse core::mem::transmute;\r\n\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\n\r\nuse crate::KeccakF;\r\n\r\npub const VECTOR_LEN: usize = 2;\r\n\r\nconst RC: [__m128i; 24] = unsafe {\r\n    transmute([\r\n        [1u64; 2],\r\n        [0x8082u64; 2],\r\n        [0x800000000000808au64; 2],\r\n        [0x8000000080008000u64; 2],\r\n        [0x808bu64; 2],\r\n        [0x80000001u64; 2],\r\n        [0x8000000080008081u64; 2],\r\n        [0x8000000000008009u64; 2],\r\n        [0x8au64; 2],\r\n        [0x88u64; 2],\r\n        [0x80008009u64; 2],\r\n        [0x8000000au64; 2],\r\n        [0x8000808bu64; 2],\r\n        [0x800000000000008bu64; 2],\r\n        [0x8000000000008089u64; 2],\r\n        [0x8000000000008003u64; 2],\r\n        [0x8000000000008002u64; 2],\r\n        [0x8000000000000080u64; 2],\r\n        [0x800au64; 2],\r\n        [0x800000008000000au64; 2],\r\n        [0x8000000080008081u64; 2],\r\n        [0x8000000000008080u64; 2],\r\n        [0x80000001u64; 2],\r\n        [0x8000000080008008u64; 2],\r\n    ])\r\n};\r\n\r\n#[inline(always)]\r\nfn form_matrix(buf: [__m128i; 25]) -\u003e [[__m128i; 5]; 5] {\r\n    unsafe { transmute(buf) }\r\n}\r\n\r\n#[inline(always)]\r\nfn flatten(mat: [[__m128i; 5]; 5]) -\u003e [__m128i; 25] {\r\n    unsafe { transmute(mat) }\r\n}\r\n\r\n#[inline(always)]\r\nfn rol_1(a: __m128i) -\u003e __m128i {\r\n    unsafe {\r\n        let shl = _mm_add_epi64(a, a);\r\n        let shr = _mm_srli_epi64::\u003c63\u003e(a);\r\n        _mm_or_si128(shl, shr)\r\n    }\r\n}\r\n\r\n#[cfg(target_feature = \"ssse3\")]\r\n#[inline(always)]\r\nfn rol_8(a: __m128i) -\u003e __m128i {\r\n    use core::arch::x86_64::_mm_shuffle_epi8;\r\n    const ROL_8_CTRL: __m128i = unsafe {\r\n        transmute::\u003c[u8; 16], _\u003e([\r\n            0o07, 0o00, 0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o17, 0o10, 0o11, 0o12, 0o13, 0o14,\r\n            0o15, 0o16,\r\n        ])\r\n    };\r\n    unsafe { _mm_shuffle_epi8(a, ROL_8_CTRL) }\r\n}\r\n\r\n#[cfg(not(target_feature = \"ssse3\"))]\r\n#[inline(always)]\r\nfn rol_8(a: __m128i) -\u003e __m128i {\r\n    rol::\u003c8, { 64 - 8 }\u003e(a)\r\n}\r\n\r\n#[cfg(target_feature = \"ssse3\")]\r\n#[inline(always)]\r\nfn rol_56(a: __m128i) -\u003e __m128i {\r\n    use core::arch::x86_64::_mm_shuffle_epi8;\r\n    const ROL_56_CTRL: __m128i = unsafe {\r\n        transmute::\u003c[u8; 16], _\u003e([\r\n            0o01, 0o02, 0o03, 0o04, 0o05, 0o06, 0o07, 0o00, 0o11, 0o12, 0o13, 0o14, 0o15, 0o16,\r\n            0o17, 0o10,\r\n        ])\r\n    };\r\n    unsafe { _mm_shuffle_epi8(a, ROL_56_CTRL) }\r\n}\r\n\r\n#[cfg(not(target_feature = \"ssse3\"))]\r\n#[inline(always)]\r\nfn rol_56(a: __m128i) -\u003e __m128i {\r\n    rol::\u003c56, { 64 - 56 }\u003e(a)\r\n}\r\n\r\n#[inline(always)]\r\nfn rol\u003cconst SHL_AMT: i32, const SHR_AMT: i32\u003e(a: __m128i) -\u003e __m128i {\r\n    unsafe {\r\n        let shl = _mm_slli_epi64::\u003cSHL_AMT\u003e(a);\r\n        let shr = _mm_srli_epi64::\u003cSHR_AMT\u003e(a);\r\n        _mm_or_si128(shl, shr)\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn get_theta_parities(state: [[__m128i; 5]; 5]) -\u003e [__m128i; 5] {\r\n    unsafe {\r\n        let mut par0 = _mm_xor_si128(state[0][0], state[1][0]);\r\n        let mut par1 = _mm_xor_si128(state[0][1], state[1][1]);\r\n        let mut par2 = _mm_xor_si128(state[0][2], state[1][2]);\r\n        let mut par3 = _mm_xor_si128(state[0][3], state[1][3]);\r\n        let mut par4 = _mm_xor_si128(state[0][4], state[1][4]);\r\n\r\n        par0 = _mm_xor_si128(par0, state[2][0]);\r\n        par1 = _mm_xor_si128(par1, state[2][1]);\r\n        par2 = _mm_xor_si128(par2, state[2][2]);\r\n        par3 = _mm_xor_si128(par3, state[2][3]);\r\n        par4 = _mm_xor_si128(par4, state[2][4]);\r\n\r\n        par0 = _mm_xor_si128(par0, state[3][0]);\r\n        par1 = _mm_xor_si128(par1, state[3][1]);\r\n        par2 = _mm_xor_si128(par2, state[3][2]);\r\n        par3 = _mm_xor_si128(par3, state[3][3]);\r\n        par4 = _mm_xor_si128(par4, state[3][4]);\r\n\r\n        par0 = _mm_xor_si128(par0, state[4][0]);\r\n        par1 = _mm_xor_si128(par1, state[4][1]);\r\n        par2 = _mm_xor_si128(par2, state[4][2]);\r\n        par3 = _mm_xor_si128(par3, state[4][3]);\r\n        par4 = _mm_xor_si128(par4, state[4][4]);\r\n\r\n        [\r\n            _mm_xor_si128(par4, rol_1(par1)),\r\n            _mm_xor_si128(par0, rol_1(par2)),\r\n            _mm_xor_si128(par1, rol_1(par3)),\r\n            _mm_xor_si128(par2, rol_1(par4)),\r\n            _mm_xor_si128(par3, rol_1(par0)),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn theta(state: [[__m128i; 5]; 5]) -\u003e [[__m128i; 5]; 5] {\r\n    let theta_parities = get_theta_parities(state);\r\n\r\n    unsafe {\r\n        [\r\n            [\r\n                _mm_xor_si128(state[0][0], theta_parities[0]),\r\n                _mm_xor_si128(state[0][1], theta_parities[1]),\r\n                _mm_xor_si128(state[0][2], theta_parities[2]),\r\n                _mm_xor_si128(state[0][3], theta_parities[3]),\r\n                _mm_xor_si128(state[0][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm_xor_si128(state[1][0], theta_parities[0]),\r\n                _mm_xor_si128(state[1][1], theta_parities[1]),\r\n                _mm_xor_si128(state[1][2], theta_parities[2]),\r\n                _mm_xor_si128(state[1][3], theta_parities[3]),\r\n                _mm_xor_si128(state[1][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm_xor_si128(state[2][0], theta_parities[0]),\r\n                _mm_xor_si128(state[2][1], theta_parities[1]),\r\n                _mm_xor_si128(state[2][2], theta_parities[2]),\r\n                _mm_xor_si128(state[2][3], theta_parities[3]),\r\n                _mm_xor_si128(state[2][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm_xor_si128(state[3][0], theta_parities[0]),\r\n                _mm_xor_si128(state[3][1], theta_parities[1]),\r\n                _mm_xor_si128(state[3][2], theta_parities[2]),\r\n                _mm_xor_si128(state[3][3], theta_parities[3]),\r\n                _mm_xor_si128(state[3][4], theta_parities[4]),\r\n            ],\r\n            [\r\n                _mm_xor_si128(state[4][0], theta_parities[0]),\r\n                _mm_xor_si128(state[4][1], theta_parities[1]),\r\n                _mm_xor_si128(state[4][2], theta_parities[2]),\r\n                _mm_xor_si128(state[4][3], theta_parities[3]),\r\n                _mm_xor_si128(state[4][4], theta_parities[4]),\r\n            ],\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn rho(state: [[__m128i; 5]; 5]) -\u003e [[__m128i; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            rol_1(state[0][1]),\r\n            rol::\u003c62, { 64 - 62 }\u003e(state[0][2]),\r\n            rol::\u003c28, { 64 - 28 }\u003e(state[0][3]),\r\n            rol::\u003c27, { 64 - 27 }\u003e(state[0][4]),\r\n        ],\r\n        [\r\n            rol::\u003c36, { 64 - 36 }\u003e(state[1][0]),\r\n            rol::\u003c44, { 64 - 44 }\u003e(state[1][1]),\r\n            rol::\u003c6, { 64 - 6 }\u003e(state[1][2]),\r\n            rol::\u003c55, { 64 - 55 }\u003e(state[1][3]),\r\n            rol::\u003c20, { 64 - 20 }\u003e(state[1][4]),\r\n        ],\r\n        [\r\n            rol::\u003c3, { 64 - 3 }\u003e(state[2][0]),\r\n            rol::\u003c10, { 64 - 10 }\u003e(state[2][1]),\r\n            rol::\u003c43, { 64 - 43 }\u003e(state[2][2]),\r\n            rol::\u003c25, { 64 - 25 }\u003e(state[2][3]),\r\n            rol::\u003c39, { 64 - 39 }\u003e(state[2][4]),\r\n        ],\r\n        [\r\n            rol::\u003c41, { 64 - 41 }\u003e(state[3][0]),\r\n            rol::\u003c45, { 64 - 45 }\u003e(state[3][1]),\r\n            rol::\u003c15, { 64 - 15 }\u003e(state[3][2]),\r\n            rol::\u003c21, { 64 - 21 }\u003e(state[3][3]),\r\n            rol_8(state[3][4]),\r\n        ],\r\n        [\r\n            rol::\u003c18, { 64 - 18 }\u003e(state[4][0]),\r\n            rol::\u003c2, { 64 - 2 }\u003e(state[4][1]),\r\n            rol::\u003c61, { 64 - 61 }\u003e(state[4][2]),\r\n            rol_56(state[4][3]),\r\n            rol::\u003c14, { 64 - 14 }\u003e(state[4][4]),\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn pi(state: [[__m128i; 5]; 5]) -\u003e [[__m128i; 5]; 5] {\r\n    [\r\n        [\r\n            state[0][0],\r\n            state[1][1],\r\n            state[2][2],\r\n            state[3][3],\r\n            state[4][4],\r\n        ],\r\n        [\r\n            state[0][3],\r\n            state[1][4],\r\n            state[2][0],\r\n            state[3][1],\r\n            state[4][2],\r\n        ],\r\n        [\r\n            state[0][1],\r\n            state[1][2],\r\n            state[2][3],\r\n            state[3][4],\r\n            state[4][0],\r\n        ],\r\n        [\r\n            state[0][4],\r\n            state[1][0],\r\n            state[2][1],\r\n            state[3][2],\r\n            state[4][3],\r\n        ],\r\n        [\r\n            state[0][2],\r\n            state[1][3],\r\n            state[2][4],\r\n            state[3][0],\r\n            state[4][1],\r\n        ],\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn chi_row(row: [__m128i; 5]) -\u003e [__m128i; 5] {\r\n    unsafe {\r\n        [\r\n            _mm_xor_si128(row[0], _mm_andnot_si128(row[1], row[2])),\r\n            _mm_xor_si128(row[1], _mm_andnot_si128(row[2], row[3])),\r\n            _mm_xor_si128(row[2], _mm_andnot_si128(row[3], row[4])),\r\n            _mm_xor_si128(row[3], _mm_andnot_si128(row[4], row[0])),\r\n            _mm_xor_si128(row[4], _mm_andnot_si128(row[0], row[1])),\r\n        ]\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn chi(state: [[__m128i; 5]; 5]) -\u003e [[__m128i; 5]; 5] {\r\n    [\r\n        chi_row(state[0]),\r\n        chi_row(state[1]),\r\n        chi_row(state[2]),\r\n        chi_row(state[3]),\r\n        chi_row(state[4]),\r\n    ]\r\n}\r\n\r\n#[inline(always)]\r\nfn iota(i: usize, state: [[__m128i; 5]; 5]) -\u003e [[__m128i; 5]; 5] {\r\n    let mut res = state;\r\n    unsafe {\r\n        res[0][0] = _mm_xor_si128(state[0][0], RC[i]);\r\n    }\r\n    res\r\n}\r\n\r\n#[inline(always)]\r\nfn round(i: usize, state: [__m128i; 25]) -\u003e [__m128i; 25] {\r\n    let mut state = form_matrix(state);\r\n    state = theta(state);\r\n    state = rho(state);\r\n    state = pi(state);\r\n    state = chi(state);\r\n    state = iota(i, state);\r\n    flatten(state)\r\n}\r\n\r\nfn keccak_perm(buf: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n    let mut state: [__m128i; 25] = unsafe { transmute(*buf) };\r\n    for i in 0..24 {\r\n        state = round(i, state);\r\n    }\r\n    *buf = unsafe { transmute::\u003c[__m128i; 25], [[u64; VECTOR_LEN]; 25]\u003e(state) };\r\n}\r\n\r\nimpl Permutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {\r\n    fn permute_mut(\u0026self, state: \u0026mut [[u64; VECTOR_LEN]; 25]) {\r\n        keccak_perm(state);\r\n    }\r\n}\r\n\r\nimpl CryptographicPermutation\u003c[[u64; VECTOR_LEN]; 25]\u003e for KeccakF {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use tiny_keccak::keccakf;\r\n\r\n    use super::*;\r\n\r\n    const STATES: [[u64; 25]; 2] = [\r\n        [\r\n            0xc22c4c11dbedc46a,\r\n            0x317f74268c4f5cd0,\r\n            0x838719da5aa295b6,\r\n            0x9e9b17211985a3ba,\r\n            0x92927b963ce29d69,\r\n            0xf9a7169e38cc7216,\r\n            0x639a594d6fbfe341,\r\n            0x2335ebd8d15777bd,\r\n            0x44e1abc0d022823b,\r\n            0xb3657f9d16b36c13,\r\n            0x26d9217c32b3010a,\r\n            0x6e73d6e9c7e5bcc8,\r\n            0x400aa469d130a391,\r\n            0x1aa7c8a2cb97188a,\r\n            0xdc3084a09bd0a6e3,\r\n            0xbcfe3b656841baea,\r\n            0x325f41887c840166,\r\n            0x844656e313674bfe,\r\n            0xd63de8bad19d156c,\r\n            0x49ef0ac0ab52e147,\r\n            0x8b92ee811c654ca9,\r\n            0x42a9310fedf09bda,\r\n            0x182dbdac03a5358e,\r\n            0x3b4692ce58af8cb5,\r\n            0x534da610f01b8fb3,\r\n        ],\r\n        [\r\n            0x1c322ff4aea07d26,\r\n            0xbd67bde061c97612,\r\n            0x517565bd02ab410a,\r\n            0xb251273ddc12a725,\r\n            0x24f0979fe4f4fedc,\r\n            0xc32d063a64f0bf03,\r\n            0xd33c6709a7b103d2,\r\n            0xaf33a8224b5c8828,\r\n            0x6544ca066e997f1c,\r\n            0xd53ad41e39f06d68,\r\n            0x67695f6fb71d77d9,\r\n            0xd6378cf19ee510f2,\r\n            0x49472ea57abcbd08,\r\n            0xcf3739df1eefbbb4,\r\n            0x0fac1bf30e8ef101,\r\n            0x7ff04c9b90de0f27,\r\n            0xf3d63ec0e64cb2ab,\r\n            0x76388c05f377d4bd,\r\n            0x7886dd8f5b14ef5b,\r\n            0xb036d289ba24a513,\r\n            0x011e8fd6be65a408,\r\n            0x695e2d20848eec67,\r\n            0x31f9e80c5f45f8ee,\r\n            0xcdf873daf7a5fdeb,\r\n            0xfe98ff5bf28d560a,\r\n        ],\r\n    ];\r\n\r\n    #[allow(clippy::needless_range_loop)]\r\n    fn our_res() -\u003e [[u64; 25]; 2] {\r\n        let mut packed_result = [[0; 2]; 25];\r\n        for i in 0..25 {\r\n            packed_result[i] = [STATES[0][i], STATES[1][i]];\r\n        }\r\n\r\n        keccak_perm(\u0026mut packed_result);\r\n\r\n        let mut result = [[0; 25]; 2];\r\n        for i in 0..25 {\r\n            result[0][i] = packed_result[i][0];\r\n            result[1][i] = packed_result[i][1];\r\n        }\r\n        result\r\n    }\r\n\r\n    fn tiny_keccak_res() -\u003e [[u64; 25]; 2] {\r\n        let mut result = STATES;\r\n        keccakf(\u0026mut result[0]);\r\n        keccakf(\u0026mut result[1]);\r\n        result\r\n    }\r\n\r\n    #[test]\r\n    fn test_vs_tiny_keccak() {\r\n        let expected = tiny_keccak_res();\r\n        let computed = our_res();\r\n        assert_eq!(expected, computed);\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":149},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_baby_bear_sha256.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_challenger::{HashChallenger, SerializingChallenger32};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_sha256::Sha256;\r\nuse p3_symmetric::{CompressionFunctionFromHasher, SerializingHasher32};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::random;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\n#[cfg(feature = \"parallel\")]\r\ntype Dft = p3_dft::Radix2DitParallel\u003cBabyBear\u003e;\r\n#[cfg(not(feature = \"parallel\"))]\r\ntype Dft = p3_dft::Radix2Bowers;\r\n\r\nconst NUM_HASHES: usize = 1_365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type ByteHash = Sha256;\r\n    type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let field_hash = FieldHash::new(Sha256);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n    let compress = MyCompress::new(byte_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_baby_bear_sha256_compress.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_challenger::{HashChallenger, SerializingChallenger32};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_sha256::{Sha256, Sha256Compress};\r\nuse p3_symmetric::SerializingHasher32;\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::random;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\n#[cfg(feature = \"parallel\")]\r\ntype Dft = p3_dft::Radix2DitParallel\u003cBabyBear\u003e;\r\n#[cfg(not(feature = \"parallel\"))]\r\ntype Dft = p3_dft::Radix2Bowers;\r\n\r\nconst NUM_HASHES: usize = 1_365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type ByteHash = Sha256;\r\n    type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let field_hash = FieldHash::new(byte_hash);\r\n\r\n    type MyCompress = Sha256Compress;\r\n    let compress = MyCompress {};\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs);\r\n\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_goldilocks_keccak.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_challenger::{HashChallenger, SerializingChallenger64};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_goldilocks::Goldilocks;\r\nuse p3_keccak::{Keccak256Hash, KeccakF};\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher64};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::random;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\nconst NUM_HASHES: usize = 1365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = Goldilocks;\r\n    type Challenge = BinomialExtensionField\u003cVal, 2\u003e;\r\n\r\n    type ByteHash = Keccak256Hash;\r\n    type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\r\n    type FieldHash = SerializingHasher64\u003cU64Hash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let u64_hash = U64Hash::new(KeccakF {});\r\n    let field_hash = FieldHash::new(u64_hash);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cU64Hash, 2, 4\u003e;\r\n    let compress = MyCompress::new(u64_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003c\r\n        [Val; p3_keccak::VECTOR_LEN],\r\n        [u64; p3_keccak::VECTOR_LEN],\r\n        FieldHash,\r\n        MyCompress,\r\n        4,\r\n    \u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = SerializingChallenger64\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_goldilocks_poseidon2.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_challenger::DuplexChallenger;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field::Field;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::{random, thread_rng};\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\nconst NUM_HASHES: usize = 1365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = Goldilocks;\r\n    type Challenge = BinomialExtensionField\u003cVal, 2\u003e;\r\n\r\n    type Perm = Poseidon2Goldilocks\u003c8\u003e;\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n\r\n    type MyHash = PaddingFreeSponge\u003cPerm, 8, 4, 4\u003e;\r\n    let hash = MyHash::new(perm.clone());\r\n\r\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 4, 8\u003e;\r\n    let compress = MyCompress::new(perm.clone());\r\n\r\n    type ValMmcs =\r\n        MerkleTreeMmcs\u003c\u003cVal as Field\u003e::Packing, \u003cVal as Field\u003e::Packing, MyHash, MyCompress, 4\u003e;\r\n    let val_mmcs = ValMmcs::new(hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = DuplexChallenger\u003cVal, Perm, 8, 4\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::new(perm.clone());\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::new(perm);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_goldilocks_sha256.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_challenger::{HashChallenger, SerializingChallenger64};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_goldilocks::Goldilocks;\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_sha256::Sha256;\r\nuse p3_symmetric::{CompressionFunctionFromHasher, SerializingHasher64};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::random;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\nconst NUM_HASHES: usize = 1365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = Goldilocks;\r\n    type Challenge = BinomialExtensionField\u003cVal, 2\u003e;\r\n\r\n    type ByteHash = Sha256;\r\n    type FieldHash = SerializingHasher64\u003cByteHash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let field_hash = FieldHash::new(byte_hash);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n    let compress = MyCompress::new(byte_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = SerializingChallenger64\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","examples","prove_m31_sha256.rs"],"content":"use std::fmt::Debug;\r\nuse std::marker::PhantomData;\r\n\r\nuse p3_challenger::{HashChallenger, SerializingChallenger32};\r\nuse p3_circle::CirclePcs;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::create_benchmark_fri_config;\r\nuse p3_keccak_air::{generate_trace_rows, KeccakAir};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_sha256::Sha256;\r\nuse p3_symmetric::{CompressionFunctionFromHasher, SerializingHasher32};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::random;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\nconst NUM_HASHES: usize = 1365;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = Mersenne31;\r\n    type Challenge = BinomialExtensionField\u003cVal, 3\u003e;\r\n\r\n    type ByteHash = Sha256;\r\n    type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let field_hash = FieldHash::new(Sha256);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n    let compress = MyCompress::new(byte_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let inputs = (0..NUM_HASHES).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(inputs, fri_config.log_blowup);\r\n\r\n    type Pcs = CirclePcs\u003cVal, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs {\r\n        mmcs: val_mmcs,\r\n        fri_config,\r\n        _phantom: PhantomData,\r\n    };\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026KeccakAir {}, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","air.rs"],"content":"use alloc::vec::Vec;\r\nuse core::borrow::Borrow;\r\n\r\nuse p3_air::utils::{andn, xor, xor3};\r\nuse p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_field::{PrimeCharacteristicRing, PrimeField64};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse rand::random;\r\n\r\nuse crate::columns::{KeccakCols, NUM_KECCAK_COLS};\r\nuse crate::constants::rc_value_bit;\r\nuse crate::round_flags::eval_round_flags;\r\nuse crate::{generate_trace_rows, BITS_PER_LIMB, NUM_ROUNDS, U64_LIMBS};\r\n\r\n/// Assumes the field size is at least 16 bits.\r\n#[derive(Debug)]\r\npub struct KeccakAir {}\r\n\r\nimpl KeccakAir {\r\n    pub fn generate_trace_rows\u003cF: PrimeField64\u003e(\r\n        \u0026self,\r\n        num_hashes: usize,\r\n        extra_capacity_bits: usize,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let inputs = (0..num_hashes).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        generate_trace_rows(inputs, extra_capacity_bits)\r\n    }\r\n}\r\n\r\nimpl\u003cF\u003e BaseAir\u003cF\u003e for KeccakAir {\r\n    fn width(\u0026self) -\u003e usize {\r\n        NUM_KECCAK_COLS\r\n    }\r\n}\r\n\r\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for KeccakAir {\r\n    #[inline]\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        eval_round_flags(builder);\r\n\r\n        let main = builder.main();\r\n        let (local, next) = (main.row_slice(0), main.row_slice(1));\r\n        let local: \u0026KeccakCols\u003cAB::Var\u003e = (*local).borrow();\r\n        let next: \u0026KeccakCols\u003cAB::Var\u003e = (*next).borrow();\r\n\r\n        let first_step = local.step_flags[0];\r\n        let final_step = local.step_flags[NUM_ROUNDS - 1];\r\n        let not_final_step = AB::Expr::ONE - final_step;\r\n\r\n        // If this is the first step, the input A must match the preimage.\r\n        for y in 0..5 {\r\n            for x in 0..5 {\r\n                for limb in 0..U64_LIMBS {\r\n                    builder\r\n                        .when(first_step)\r\n                        .assert_eq(local.preimage[y][x][limb], local.a[y][x][limb]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // If this is not the final step, the local and next preimages must match.\r\n        for y in 0..5 {\r\n            for x in 0..5 {\r\n                for limb in 0..U64_LIMBS {\r\n                    builder\r\n                        .when(not_final_step.clone())\r\n                        .when_transition()\r\n                        .assert_eq(local.preimage[y][x][limb], next.preimage[y][x][limb]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // The export flag must be 0 or 1.\r\n        builder.assert_bool(local.export);\r\n\r\n        // If this is not the final step, the export flag must be off.\r\n        builder\r\n            .when(not_final_step.clone())\r\n            .assert_zero(local.export);\r\n\r\n        // C'[x, z] = xor(C[x, z], C[x - 1, z], C[x + 1, z - 1]).\r\n        // Note that if all entries of C are boolean, the arithmetic generalization\r\n        // xor3 function only outputs 0, 1 and so this check also ensures that all\r\n        // entries of C'[x, z] are boolean.\r\n        for x in 0..5 {\r\n            for z in 0..64 {\r\n                // Check to ensure all entries of C are bools.\r\n                builder.assert_bool(local.c[x][z]);\r\n                let xor = xor3::\u003cAB::Expr\u003e(\r\n                    local.c[x][z].into(),\r\n                    local.c[(x + 4) % 5][z].into(),\r\n                    local.c[(x + 1) % 5][(z + 63) % 64].into(),\r\n                );\r\n                let c_prime = local.c_prime[x][z];\r\n                builder.assert_eq(c_prime, xor);\r\n            }\r\n        }\r\n\r\n        // Check that the input limbs are consistent with A' and D.\r\n        // A[x, y, z] = xor(A'[x, y, z], D[x, y, z])\r\n        //            = xor(A'[x, y, z], C[x - 1, z], C[x + 1, z - 1])\r\n        //            = xor(A'[x, y, z], C[x, z], C'[x, z]).\r\n        // The last step is valid based on the identity we checked above.\r\n        // It isn't required, but makes this check a bit cleaner.\r\n        // We also check that all entires of A' are bools.\r\n        // This has the side effect of also range checking the limbs of A.\r\n        for y in 0..5 {\r\n            for x in 0..5 {\r\n                let get_bit = |z| {\r\n                    let a_prime: AB::Var = local.a_prime[y][x][z];\r\n                    let c: AB::Var = local.c[x][z];\r\n                    let c_prime: AB::Var = local.c_prime[x][z];\r\n                    xor3::\u003cAB::Expr\u003e(a_prime.into(), c.into(), c_prime.into())\r\n                };\r\n\r\n                for limb in 0..U64_LIMBS {\r\n                    let a_limb = local.a[y][x][limb];\r\n                    let computed_limb = (limb * BITS_PER_LIMB..(limb + 1) * BITS_PER_LIMB)\r\n                        .rev()\r\n                        .fold(AB::Expr::ZERO, |acc, z| {\r\n                            // Check to ensure all entries of A' are bools.\r\n                            builder.assert_bool(local.a_prime[y][x][z]);\r\n                            acc.double() + get_bit(z)\r\n                        });\r\n                    builder.assert_eq(computed_limb, a_limb);\r\n                }\r\n            }\r\n        }\r\n\r\n        // xor_{i=0}^4 A'[x, i, z] = C'[x, z], so for each x, z,\r\n        // diff * (diff - 2) * (diff - 4) = 0, where\r\n        // diff = sum_{i=0}^4 A'[x, i, z] - C'[x, z]\r\n        for x in 0..5 {\r\n            for z in 0..64 {\r\n                let sum: AB::Expr = (0..5).map(|y| local.a_prime[y][x][z].into()).sum();\r\n                let diff = sum - local.c_prime[x][z];\r\n                // This should be slightly faster than from_canonical_u8(4) for some fields.\r\n                let four = AB::Expr::TWO.double();\r\n                builder.assert_zero(diff.clone() * (diff.clone() - AB::Expr::TWO) * (diff - four));\r\n            }\r\n        }\r\n\r\n        // A''[x, y] = xor(B[x, y], andn(B[x + 1, y], B[x + 2, y])).\r\n        // As B is a rotation of A', all entries must be bools and so\r\n        // this check also range checks A''.\r\n        for y in 0..5 {\r\n            for x in 0..5 {\r\n                let get_bit = |z| {\r\n                    let andn = andn::\u003cAB::Expr\u003e(\r\n                        local.b((x + 1) % 5, y, z).into(),\r\n                        local.b((x + 2) % 5, y, z).into(),\r\n                    );\r\n                    xor::\u003cAB::Expr\u003e(local.b(x, y, z).into(), andn)\r\n                };\r\n\r\n                for limb in 0..U64_LIMBS {\r\n                    let computed_limb = (limb * BITS_PER_LIMB..(limb + 1) * BITS_PER_LIMB)\r\n                        .rev()\r\n                        .fold(AB::Expr::ZERO, |acc, z| acc.double() + get_bit(z));\r\n                    builder.assert_eq(computed_limb, local.a_prime_prime[y][x][limb]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // A'''[0, 0] = A''[0, 0] XOR RC\r\n        for limb in 0..U64_LIMBS {\r\n            let computed_a_prime_prime_0_0_limb = (limb * BITS_PER_LIMB\r\n                ..(limb + 1) * BITS_PER_LIMB)\r\n                .rev()\r\n                .fold(AB::Expr::ZERO, |acc, z| {\r\n                    // Check to ensure the bits of A''[0, 0] are boolean.\r\n                    builder.assert_bool(local.a_prime_prime_0_0_bits[z]);\r\n                    acc.double() + local.a_prime_prime_0_0_bits[z]\r\n                });\r\n            let a_prime_prime_0_0_limb = local.a_prime_prime[0][0][limb];\r\n            builder.assert_eq(computed_a_prime_prime_0_0_limb, a_prime_prime_0_0_limb);\r\n        }\r\n\r\n        let get_xored_bit = |i| {\r\n            let mut rc_bit_i = AB::Expr::ZERO;\r\n            for r in 0..NUM_ROUNDS {\r\n                let this_round = local.step_flags[r];\r\n                let this_round_constant = AB::Expr::from_bool(rc_value_bit(r, i) != 0);\r\n                rc_bit_i += this_round * this_round_constant;\r\n            }\r\n\r\n            xor::\u003cAB::Expr\u003e(local.a_prime_prime_0_0_bits[i].into(), rc_bit_i)\r\n        };\r\n\r\n        for limb in 0..U64_LIMBS {\r\n            let a_prime_prime_prime_0_0_limb = local.a_prime_prime_prime_0_0_limbs[limb];\r\n            let computed_a_prime_prime_prime_0_0_limb = (limb * BITS_PER_LIMB\r\n                ..(limb + 1) * BITS_PER_LIMB)\r\n                .rev()\r\n                .fold(AB::Expr::ZERO, |acc, z| acc.double() + get_xored_bit(z));\r\n            builder.assert_eq(\r\n                computed_a_prime_prime_prime_0_0_limb,\r\n                a_prime_prime_prime_0_0_limb,\r\n            );\r\n        }\r\n\r\n        // Enforce that this round's output equals the next round's input.\r\n        for x in 0..5 {\r\n            for y in 0..5 {\r\n                for limb in 0..U64_LIMBS {\r\n                    let output = local.a_prime_prime_prime(y, x, limb);\r\n                    let input = next.a[y][x][limb];\r\n                    builder\r\n                        .when_transition()\r\n                        .when(not_final_step.clone())\r\n                        .assert_eq(output, input);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":99},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\r\nuse core::mem::{size_of, transmute};\r\n\r\nuse p3_util::indices_arr;\r\n\r\nuse crate::constants::R;\r\nuse crate::{NUM_ROUNDS, RATE_LIMBS, U64_LIMBS};\r\n\r\n/// Note: The ordering of each array is based on the input mapping. As the spec says,\r\n///\r\n/// \u003e The mapping between the bits of s and those of a is `s[w(5y + x) + z] = a[x][y][z]`.\r\n///\r\n/// Thus, for example, `a_prime` is stored in `y, x, z` order. This departs from the more common\r\n/// convention of `x, y, z` order, but it has the benefit that input lists map to AIR columns in a\r\n/// nicer way.\r\n#[derive(Debug)]\r\n#[repr(C)]\r\npub struct KeccakCols\u003cT\u003e {\r\n    /// The `i`th value is set to 1 if we are in the `i`th round, otherwise 0.\r\n    pub step_flags: [T; NUM_ROUNDS],\r\n\r\n    /// A register which indicates if a row should be exported, i.e. included in a multiset equality\r\n    /// argument. Should be 1 only for certain rows which are final steps, i.e. with\r\n    /// `step_flags[23] = 1`.\r\n    pub export: T,\r\n\r\n    /// Permutation inputs, stored in y-major order.\r\n    pub preimage: [[[T; U64_LIMBS]; 5]; 5],\r\n\r\n    pub a: [[[T; U64_LIMBS]; 5]; 5],\r\n\r\n    /// ```ignore\r\n    /// C[x] = xor(A[x, 0], A[x, 1], A[x, 2], A[x, 3], A[x, 4])\r\n    /// ```\r\n    pub c: [[T; 64]; 5],\r\n\r\n    /// ```ignore\r\n    /// C'[x, z] = xor(C[x, z], C[x - 1, z], C[x + 1, z - 1])\r\n    /// ```\r\n    pub c_prime: [[T; 64]; 5],\r\n\r\n    // Note: D is inlined, not stored in the witness.\r\n    /// ```ignore\r\n    /// A'[x, y] = xor(A[x, y], D[x])\r\n    ///          = xor(A[x, y], C[x - 1], ROT(C[x + 1], 1))\r\n    /// ```\r\n    pub a_prime: [[[T; 64]; 5]; 5],\r\n\r\n    /// ```ignore\r\n    /// A''[x, y] = xor(B[x, y], andn(B[x + 1, y], B[x + 2, y])).\r\n    /// ```\r\n    pub a_prime_prime: [[[T; U64_LIMBS]; 5]; 5],\r\n\r\n    /// The bits of `A''[0, 0]`.\r\n    pub a_prime_prime_0_0_bits: [T; 64],\r\n\r\n    /// ```ignore\r\n    /// A'''[0, 0, z] = A''[0, 0, z] ^ RC[k, z]\r\n    /// ```\r\n    pub a_prime_prime_prime_0_0_limbs: [T; U64_LIMBS],\r\n}\r\n\r\nimpl\u003cT: Copy\u003e KeccakCols\u003cT\u003e {\r\n    pub fn b(\u0026self, x: usize, y: usize, z: usize) -\u003e T {\r\n        debug_assert!(x \u003c 5);\r\n        debug_assert!(y \u003c 5);\r\n        debug_assert!(z \u003c 64);\r\n\r\n        // B is just a rotation of A', so these are aliases for A' registers.\r\n        // From the spec,\r\n        //     B[y, (2x + 3y) % 5] = ROT(A'[x, y], r[x, y])\r\n        // So,\r\n        //     B[x, y] = f((x + 3y) % 5, x)\r\n        // where f(a, b) = ROT(A'[a, b], r[a, b])\r\n        let a = (x + 3 * y) % 5;\r\n        let b = x;\r\n        let rot = R[a][b] as usize;\r\n        self.a_prime[b][a][(z + 64 - rot) % 64]\r\n    }\r\n\r\n    pub fn a_prime_prime_prime(\u0026self, y: usize, x: usize, limb: usize) -\u003e T {\r\n        debug_assert!(y \u003c 5);\r\n        debug_assert!(x \u003c 5);\r\n        debug_assert!(limb \u003c U64_LIMBS);\r\n\r\n        if y == 0 \u0026\u0026 x == 0 {\r\n            self.a_prime_prime_prime_0_0_limbs[limb]\r\n        } else {\r\n            self.a_prime_prime[y][x][limb]\r\n        }\r\n    }\r\n}\r\n\r\npub fn input_limb(i: usize) -\u003e usize {\r\n    debug_assert!(i \u003c RATE_LIMBS);\r\n\r\n    let i_u64 = i / U64_LIMBS;\r\n    let limb_index = i % U64_LIMBS;\r\n\r\n    // The 5x5 state is treated as y-major, as per the Keccak spec.\r\n    let y = i_u64 / 5;\r\n    let x = i_u64 % 5;\r\n\r\n    KECCAK_COL_MAP.preimage[y][x][limb_index]\r\n}\r\n\r\npub fn output_limb(i: usize) -\u003e usize {\r\n    debug_assert!(i \u003c RATE_LIMBS);\r\n\r\n    let i_u64 = i / U64_LIMBS;\r\n    let limb_index = i % U64_LIMBS;\r\n\r\n    // The 5x5 state is treated as y-major, as per the Keccak spec.\r\n    let y = i_u64 / 5;\r\n    let x = i_u64 % 5;\r\n\r\n    KECCAK_COL_MAP.a_prime_prime_prime(y, x, limb_index)\r\n}\r\n\r\npub const NUM_KECCAK_COLS: usize = size_of::\u003cKeccakCols\u003cu8\u003e\u003e();\r\npub(crate) const KECCAK_COL_MAP: KeccakCols\u003cusize\u003e = make_col_map();\r\n\r\nconst fn make_col_map() -\u003e KeccakCols\u003cusize\u003e {\r\n    let indices_arr = indices_arr::\u003cNUM_KECCAK_COLS\u003e();\r\n    unsafe { transmute::\u003c[usize; NUM_KECCAK_COLS], KeccakCols\u003cusize\u003e\u003e(indices_arr) }\r\n}\r\n\r\nimpl\u003cT\u003e Borrow\u003cKeccakCols\u003cT\u003e\u003e for [T] {\r\n    fn borrow(\u0026self) -\u003e \u0026KeccakCols\u003cT\u003e {\r\n        debug_assert_eq!(self.len(), NUM_KECCAK_COLS);\r\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cKeccakCols\u003cT\u003e\u003e() };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026shorts[0]\r\n    }\r\n}\r\n\r\nimpl\u003cT\u003e BorrowMut\u003cKeccakCols\u003cT\u003e\u003e for [T] {\r\n    fn borrow_mut(\u0026mut self) -\u003e \u0026mut KeccakCols\u003cT\u003e {\r\n        debug_assert_eq!(self.len(), NUM_KECCAK_COLS);\r\n        let (prefix, shorts, suffix) = unsafe { self.align_to_mut::\u003cKeccakCols\u003cT\u003e\u003e() };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026mut shorts[0]\r\n    }\r\n}\r\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":46},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","constants.rs"],"content":"pub(crate) const R: [[u8; 5]; 5] = [\r\n    [0, 36, 3, 41, 18],\r\n    [1, 44, 10, 45, 2],\r\n    [62, 6, 43, 15, 61],\r\n    [28, 55, 25, 21, 56],\r\n    [27, 20, 39, 8, 14],\r\n];\r\n\r\npub const RC: [u64; 24] = [\r\n    0x0000000000000001,\r\n    0x0000000000008082,\r\n    0x800000000000808A,\r\n    0x8000000080008000,\r\n    0x000000000000808B,\r\n    0x0000000080000001,\r\n    0x8000000080008081,\r\n    0x8000000000008009,\r\n    0x000000000000008A,\r\n    0x0000000000000088,\r\n    0x0000000080008009,\r\n    0x000000008000000A,\r\n    0x000000008000808B,\r\n    0x800000000000008B,\r\n    0x8000000000008089,\r\n    0x8000000000008003,\r\n    0x8000000000008002,\r\n    0x8000000000000080,\r\n    0x000000000000800A,\r\n    0x800000008000000A,\r\n    0x8000000080008081,\r\n    0x8000000000008080,\r\n    0x0000000080000001,\r\n    0x8000000080008008,\r\n];\r\n\r\nconst RC_BITS: [[u8; 64]; 24] = [\r\n    [\r\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n    [\r\n        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 0,\r\n    ],\r\n    [\r\n        0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        0, 0, 0, 1,\r\n    ],\r\n];\r\n\r\npub(crate) const fn rc_value_bit(round: usize, bit_index: usize) -\u003e u8 {\r\n    RC_BITS[round][bit_index]\r\n}\r\n","traces":[{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","generation.rs"],"content":"use alloc::vec::Vec;\r\nuse core::array;\r\nuse core::mem::transmute;\r\n\r\nuse p3_air::utils::{u64_to_16_bit_limbs, u64_to_bits_le};\r\nuse p3_field::PrimeField64;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_maybe_rayon::iter::repeat;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse tracing::instrument;\r\n\r\nuse crate::columns::{KeccakCols, NUM_KECCAK_COLS};\r\nuse crate::{NUM_ROUNDS, R, RC, U64_LIMBS};\r\n\r\n// TODO: Take generic iterable\r\n#[instrument(name = \"generate Keccak trace\", skip_all)]\r\npub fn generate_trace_rows\u003cF: PrimeField64\u003e(\r\n    inputs: Vec\u003c[u64; 25]\u003e,\r\n    extra_capacity_bits: usize,\r\n) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    let num_rows = (inputs.len() * NUM_ROUNDS).next_power_of_two();\r\n    let trace_length = num_rows * NUM_KECCAK_COLS;\r\n\r\n    // We allocate extra_capacity_bits now as this will be needed by the dft.\r\n    let mut long_trace = F::zero_vec(trace_length \u003c\u003c extra_capacity_bits);\r\n    long_trace.truncate(trace_length);\r\n\r\n    let mut trace = RowMajorMatrix::new(long_trace, NUM_KECCAK_COLS);\r\n    let (prefix, rows, suffix) = unsafe { trace.values.align_to_mut::\u003cKeccakCols\u003cF\u003e\u003e() };\r\n    assert!(prefix.is_empty(), \"Alignment should match\");\r\n    assert!(suffix.is_empty(), \"Alignment should match\");\r\n    assert_eq!(rows.len(), num_rows);\r\n\r\n    let num_padding_inputs = num_rows.div_ceil(NUM_ROUNDS) - inputs.len();\r\n    let padded_inputs = inputs\r\n        .into_par_iter()\r\n        .chain(repeat([0; 25]).take(num_padding_inputs));\r\n\r\n    rows.par_chunks_mut(NUM_ROUNDS)\r\n        .zip(padded_inputs)\r\n        .for_each(|(row, input)| {\r\n            generate_trace_rows_for_perm(row, input);\r\n        });\r\n\r\n    trace\r\n}\r\n\r\n/// `rows` will normally consist of 24 rows, with an exception for the final row.\r\nfn generate_trace_rows_for_perm\u003cF: PrimeField64\u003e(rows: \u0026mut [KeccakCols\u003cF\u003e], input: [u64; 25]) {\r\n    let mut current_state: [[u64; 5]; 5] = unsafe { transmute(input) };\r\n\r\n    let initial_state: [[[F; 4]; 5]; 5] =\r\n        array::from_fn(|y| array::from_fn(|x| u64_to_16_bit_limbs(current_state[x][y])));\r\n\r\n    // Populate the round input for the first round.\r\n    rows[0].a = initial_state;\r\n    rows[0].preimage = initial_state;\r\n\r\n    generate_trace_row_for_round(\u0026mut rows[0], 0, \u0026mut current_state);\r\n\r\n    for round in 1..rows.len() {\r\n        rows[round].preimage = initial_state;\r\n\r\n        // Copy previous row's output to next row's input.\r\n        for y in 0..5 {\r\n            for x in 0..5 {\r\n                for limb in 0..U64_LIMBS {\r\n                    rows[round].a[y][x][limb] = rows[round - 1].a_prime_prime_prime(y, x, limb);\r\n                }\r\n            }\r\n        }\r\n\r\n        generate_trace_row_for_round(\u0026mut rows[round], round, \u0026mut current_state);\r\n    }\r\n}\r\n\r\nfn generate_trace_row_for_round\u003cF: PrimeField64\u003e(\r\n    row: \u0026mut KeccakCols\u003cF\u003e,\r\n    round: usize,\r\n    current_state: \u0026mut [[u64; 5]; 5],\r\n) {\r\n    row.step_flags[round] = F::ONE;\r\n\r\n    // Populate C[x] = xor(A[x, 0], A[x, 1], A[x, 2], A[x, 3], A[x, 4]).\r\n    let state_c: [u64; 5] = current_state.map(|row| row.iter().fold(0, |acc, y| acc ^ y));\r\n    for (x, elem) in state_c.iter().enumerate() {\r\n        row.c[x] = u64_to_bits_le(*elem);\r\n    }\r\n\r\n    // Populate C'[x, z] = xor(C[x, z], C[x - 1, z], C[x + 1, z - 1]).\r\n    let state_c_prime: [u64; 5] =\r\n        array::from_fn(|x| state_c[x] ^ state_c[(x + 4) % 5] ^ state_c[(x + 1) % 5].rotate_left(1));\r\n    for (x, elem) in state_c_prime.iter().enumerate() {\r\n        row.c_prime[x] = u64_to_bits_le(*elem);\r\n    }\r\n\r\n    // Populate A'. To avoid shifting indices, we rewrite\r\n    //     A'[x, y, z] = xor(A[x, y, z], C[x - 1, z], C[x + 1, z - 1])\r\n    // as\r\n    //     A'[x, y, z] = xor(A[x, y, z], C[x, z], C'[x, z]).\r\n    *current_state =\r\n        array::from_fn(|i| array::from_fn(|j| current_state[i][j] ^ state_c[i] ^ state_c_prime[i]));\r\n    for (x, x_row) in current_state.iter().enumerate() {\r\n        for (y, elem) in x_row.iter().enumerate() {\r\n            row.a_prime[y][x] = u64_to_bits_le(*elem);\r\n        }\r\n    }\r\n\r\n    // Rotate the current state to get the B array.\r\n    *current_state = array::from_fn(|i| {\r\n        array::from_fn(|j| {\r\n            let new_i = (i + 3 * j) % 5;\r\n            let new_j = i;\r\n            current_state[new_i][new_j].rotate_left(R[new_i][new_j] as u32)\r\n        })\r\n    });\r\n\r\n    // Populate A''.\r\n    // A''[x, y] = xor(B[x, y], andn(B[x + 1, y], B[x + 2, y])).\r\n    *current_state = array::from_fn(|i| {\r\n        array::from_fn(|j| {\r\n            current_state[i][j] ^ ((!current_state[(i + 1) % 5][j]) \u0026 current_state[(i + 2) % 5][j])\r\n        })\r\n    });\r\n    for (x, x_row) in current_state.iter().enumerate() {\r\n        for (y, elem) in x_row.iter().enumerate() {\r\n            row.a_prime_prime[y][x] = u64_to_16_bit_limbs(*elem);\r\n        }\r\n    }\r\n\r\n    row.a_prime_prime_0_0_bits = u64_to_bits_le(current_state[0][0]);\r\n\r\n    // A''[0, 0] is additionally xor'd with RC.\r\n    current_state[0][0] ^= RC[round];\r\n\r\n    row.a_prime_prime_prime_0_0_limbs = u64_to_16_bit_limbs(current_state[0][0]);\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":59},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","lib.rs"],"content":"//! An AIR for the Keccak-f permutation. Assumes the field size is between 2^16 and 2^32.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod air;\r\nmod columns;\r\nmod constants;\r\nmod generation;\r\nmod round_flags;\r\n\r\npub use air::*;\r\npub use columns::*;\r\npub use constants::*;\r\npub use generation::*;\r\n\r\npub const NUM_ROUNDS: usize = 24;\r\nconst BITS_PER_LIMB: usize = 16;\r\npub const U64_LIMBS: usize = 64 / BITS_PER_LIMB;\r\nconst RATE_BITS: usize = 1088;\r\nconst RATE_LIMBS: usize = RATE_BITS / BITS_PER_LIMB;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","keccak-air","src","round_flags.rs"],"content":"use core::borrow::Borrow;\r\n\r\nuse p3_air::AirBuilder;\r\nuse p3_matrix::Matrix;\r\n\r\nuse crate::columns::KeccakCols;\r\nuse crate::NUM_ROUNDS;\r\n\r\n#[inline]\r\npub(crate) fn eval_round_flags\u003cAB: AirBuilder\u003e(builder: \u0026mut AB) {\r\n    let main = builder.main();\r\n    let (local, next) = (main.row_slice(0), main.row_slice(1));\r\n    let local: \u0026KeccakCols\u003cAB::Var\u003e = (*local).borrow();\r\n    let next: \u0026KeccakCols\u003cAB::Var\u003e = (*next).borrow();\r\n\r\n    // Initially, the first step flag should be 1 while the others should be 0.\r\n    builder.when_first_row().assert_one(local.step_flags[0]);\r\n    for i in 1..NUM_ROUNDS {\r\n        builder.when_first_row().assert_zero(local.step_flags[i]);\r\n    }\r\n\r\n    for i in 0..NUM_ROUNDS {\r\n        let current_round_flag = local.step_flags[i];\r\n        let next_round_flag = next.step_flags[(i + 1) % NUM_ROUNDS];\r\n        builder\r\n            .when_transition()\r\n            .assert_eq(next_round_flag, current_round_flag);\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0}},{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":13,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","benches","bench_field.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BatchSize, Criterion};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_add_latency, benchmark_add_throughput, benchmark_inv, benchmark_iter_sum,\r\n    benchmark_mul_latency, benchmark_mul_throughput, benchmark_sub_latency,\r\n    benchmark_sub_throughput,\r\n};\r\nuse p3_koala_bear::KoalaBear;\r\n\r\ntype F = KoalaBear;\r\n\r\nfn bench_field(c: \u0026mut Criterion) {\r\n    let name = \"KoalaBear\";\r\n    const REPS: usize = 1000;\r\n    benchmark_inv::\u003cF\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 4, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 8, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 12, REPS\u003e(c, name);\r\n\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const L_REPS: usize = 10 * REPS;\r\n    benchmark_add_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_add_throughput::\u003cF, REPS\u003e(c, name);\r\n    benchmark_sub_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_sub_throughput::\u003cF, REPS\u003e(c, name);\r\n\r\n    c.bench_function(\"3rd_root\", |b| {\r\n        b.iter_batched(\r\n            rand::random::\u003cF\u003e,\r\n            |x| x.exp_u64(1420470955),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\nfn bench_packedfield(c: \u0026mut Criterion) {\r\n    let name = type_name::\u003c\u003cF as Field\u003e::Packing\u003e().to_string();\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const REPS: usize = 100;\r\n    const L_REPS: usize = 10 * REPS;\r\n\r\n    benchmark_add_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_add_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_sub_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_sub_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n    benchmark_mul_latency::\u003c\u003cF as Field\u003e::Packing, L_REPS\u003e(c, \u0026name);\r\n    benchmark_mul_throughput::\u003c\u003cF as Field\u003e::Packing, REPS\u003e(c, \u0026name);\r\n}\r\n\r\ncriterion_group!(koala_bear_arithmetic, bench_field, bench_packedfield);\r\ncriterion_main!(koala_bear_arithmetic);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","aarch64_neon","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","aarch64_neon","packing.rs"],"content":"use core::arch::aarch64::{int32x4_t, uint32x4_t};\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersNeon, PackedMontyField31Neon};\r\n\r\nuse crate::KoalaBearParameters;\r\n\r\nconst WIDTH: usize = 4;\r\n\r\nimpl MontyParametersNeon for KoalaBearParameters {\r\n    const PACKED_P: uint32x4_t = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7f000001; WIDTH]) };\r\n    // This MU is the same 0x88000001 as elsewhere, just interpreted as an `i32`.\r\n    const PACKED_MU: int32x4_t = unsafe { transmute::\u003c[i32; WIDTH], _\u003e([-0x7effffff; WIDTH]) };\r\n}\r\n\r\npub type PackedKoalaBearNeon = PackedMontyField31Neon\u003cKoalaBearParameters\u003e;\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::KoalaBear;\r\n\r\n    const SPECIAL_VALS: [KoalaBear; WIDTH] =\r\n        KoalaBear::new_array([0x00000000, 0x00000001, 0x00000002, 0x7f000000]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedKoalaBearNeon,\r\n        crate::PackedKoalaBearNeon::ZERO,\r\n        p3_monty_31::PackedMontyField31Neon::\u003ccrate::KoalaBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","aarch64_neon","poseidon2.rs"],"content":"//! Eventually this will hold a vectorized Neon implementation of Poseidon2 for PackedKoalaBearNeon\r\n//! Currently this is essentially a placeholder to allow compilation and testing on Neon devices.\r\n//!\r\n//! Converting the AVX2/AVX512 code across to Neon is on the TODO list.\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{KoalaBear, PackedKoalaBearNeon, Poseidon2KoalaBear};\r\n\r\n    type F = KoalaBear;\r\n    type Perm16 = Poseidon2KoalaBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2KoalaBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedKoalaBearNeon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedKoalaBearNeon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","extension.rs"],"content":"#[cfg(test)]\r\nmod test_quartic_extension {\r\n    use alloc::format;\r\n\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field::{PrimeCharacteristicRing, Serializable};\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::KoalaBear;\r\n\r\n    type F = KoalaBear;\r\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\r\n\r\n    test_field!(super::EF);\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n\r\n    #[test]\r\n    fn display() {\r\n        assert_eq!(format!(\"{}\", EF::ZERO), \"0\");\r\n        assert_eq!(format!(\"{}\", EF::ONE), \"1\");\r\n        assert_eq!(format!(\"{}\", EF::TWO), \"2\");\r\n\r\n        assert_eq!(\r\n            format!(\r\n                \"{}\",\r\n                EF::deserialize_slice(\u0026[F::TWO, F::ONE, F::ZERO, F::TWO])\r\n            ),\r\n            \"2 + X + 2 X^3\"\r\n        );\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","koala_bear.rs"],"content":"use p3_field::exponentiation::exp_1420470955;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_monty_31::{\r\n    BarrettParameters, BinomialExtensionData, FieldParameters, MontyField31, MontyParameters,\r\n    PackedMontyParameters, RelativelyPrimePower, TwoAdicData,\r\n};\r\n\r\n/// The prime field `2^31 - 2^24 + 1`, a.k.a. the Koala Bear field.\r\npub type KoalaBear = MontyField31\u003cKoalaBearParameters\u003e;\r\n\r\n#[derive(Copy, Clone, Default, Debug, Eq, Hash, PartialEq)]\r\npub struct KoalaBearParameters;\r\n\r\nimpl MontyParameters for KoalaBearParameters {\r\n    /// The KoalaBear prime: 2^31 - 2^24 + 1\r\n    /// This is a 31-bit prime with the highest possible two adicity if we additionally demand that\r\n    /// the cube map (x -\u003e x^3) is an automorphism of the multiplicative group.\r\n    /// It's not unique, as there is one other option with equal 2 adicity: 2^30 + 2^27 + 2^24 + 1.\r\n    /// There is also one 29-bit prime with higher two adicity which might be appropriate for some applications: 2^29 - 2^26 + 1.\r\n    const PRIME: u32 = 0x7f000001;\r\n\r\n    const MONTY_BITS: u32 = 32;\r\n    const MONTY_MU: u32 = 0x81000001;\r\n}\r\n\r\nimpl PackedMontyParameters for KoalaBearParameters {}\r\n\r\nimpl BarrettParameters for KoalaBearParameters {}\r\n\r\nimpl FieldParameters for KoalaBearParameters {\r\n    const MONTY_GEN: KoalaBear = KoalaBear::new(3);\r\n\r\n    fn try_inverse\u003cF: Field\u003e(p1: F) -\u003e Option\u003cF\u003e {\r\n        if p1.is_zero() {\r\n            return None;\r\n        }\r\n\r\n        // From Fermat's little theorem, in a prime field `F_p`, the inverse of `a` is `a^(p-2)`.\r\n        // Here p-2 = 2130706431 = 1111110111111111111111111111111_2\r\n        // Uses 29 Squares + 7 Multiplications =\u003e 36 Operations total.\r\n\r\n        let p10 = p1.square();\r\n        let p11 = p10 * p1;\r\n        let p1100 = p11.exp_power_of_2(2);\r\n        let p1111 = p1100 * p11;\r\n        let p110000 = p1100.exp_power_of_2(2);\r\n        let p111111 = p110000 * p1111;\r\n        let p1111110000 = p111111.exp_power_of_2(4);\r\n        let p1111111111 = p1111110000 * p1111;\r\n        let p11111101111 = p1111111111 * p1111110000;\r\n        let p111111011110000000000 = p11111101111.exp_power_of_2(10);\r\n        let p111111011111111111111 = p111111011110000000000 * p1111111111;\r\n        let p1111110111111111111110000000000 = p111111011111111111111.exp_power_of_2(10);\r\n        let p1111110111111111111111111111111 = p1111110111111111111110000000000 * p1111111111;\r\n\r\n        Some(p1111110111111111111111111111111)\r\n    }\r\n}\r\n\r\nimpl RelativelyPrimePower\u003c3\u003e for KoalaBearParameters {\r\n    /// In the field `KoalaBear`, `a^{1/3}` is equal to a^{1420470955}.\r\n    ///\r\n    /// This follows from the calculation `3 * 1420470955 = 2*(2^31 - 2^24) + 1 = 1 mod (p - 1)`.\r\n    fn exp_root_d\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R {\r\n        // We use a custom addition chain.\r\n        // This could possibly be further optimised.\r\n        exp_1420470955(val)\r\n    }\r\n}\r\n\r\nimpl TwoAdicData for KoalaBearParameters {\r\n    const TWO_ADICITY: usize = 24;\r\n\r\n    type ArrayLike = \u0026'static [KoalaBear];\r\n\r\n    const TWO_ADIC_GENERATORS: Self::ArrayLike = \u0026KoalaBear::new_array([\r\n        0x1, 0x7f000000, 0x7e010002, 0x6832fe4a, 0x8dbd69c, 0xa28f031, 0x5c4a5b99, 0x29b75a80,\r\n        0x17668b8a, 0x27ad539b, 0x334d48c7, 0x7744959c, 0x768fc6fa, 0x303964b2, 0x3e687d4d,\r\n        0x45a60e61, 0x6e2f4d7a, 0x163bd499, 0x6c4a8a45, 0x143ef899, 0x514ddcad, 0x484ef19b,\r\n        0x205d63c3, 0x68e7dd49, 0x6ac49f88,\r\n    ]);\r\n\r\n    const ROOTS_8: Self::ArrayLike =\r\n        \u0026KoalaBear::new_array([0x1, 0x6832fe4a, 0x7e010002, 0x174e3650]);\r\n    const INV_ROOTS_8: Self::ArrayLike =\r\n        \u0026KoalaBear::new_array([0x1, 0x67b1c9b1, 0xfeffff, 0x16cd01b7]);\r\n\r\n    const ROOTS_16: Self::ArrayLike = \u0026KoalaBear::new_array([\r\n        0x1, 0x8dbd69c, 0x6832fe4a, 0x27ae21e2, 0x7e010002, 0x3a89a025, 0x174e3650, 0x27dfce22,\r\n    ]);\r\n    const INV_ROOTS_16: Self::ArrayLike = \u0026KoalaBear::new_array([\r\n        0x1, 0x572031df, 0x67b1c9b1, 0x44765fdc, 0xfeffff, 0x5751de1f, 0x16cd01b7, 0x76242965,\r\n    ]);\r\n}\r\n\r\nimpl BinomialExtensionData\u003c4\u003e for KoalaBearParameters {\r\n    const W: KoalaBear = KoalaBear::new(3);\r\n    const DTH_ROOT: KoalaBear = KoalaBear::new(2113994754);\r\n    const EXT_GENERATOR: [KoalaBear; 4] = KoalaBear::new_array([2, 1, 0, 0]);\r\n    const EXT_TWO_ADICITY: usize = 26;\r\n\r\n    type ArrayLike = [[KoalaBear; 4]; 2];\r\n\r\n    const TWO_ADIC_EXTENSION_GENERATORS: Self::ArrayLike =\r\n        KoalaBear::new_2d_array([[0, 0, 1759267465, 0], [0, 0, 0, 777715144]]);\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field::{InjectiveMonomial, PermutationMonomial, PrimeField64, TwoAdicField};\r\n    use p3_field_testing::{\r\n        test_field, test_field_dft, test_prime_field, test_prime_field_32, test_prime_field_64,\r\n        test_two_adic_field,\r\n    };\r\n\r\n    use super::*;\r\n\r\n    type F = KoalaBear;\r\n\r\n    #[test]\r\n    fn test_koala_bear_two_adicity_generators() {\r\n        let base = KoalaBear::from_u32(0x6ac49f88);\r\n        for bits in 0..=KoalaBear::TWO_ADICITY {\r\n            assert_eq!(\r\n                KoalaBear::two_adic_generator(bits),\r\n                base.exp_power_of_2(KoalaBear::TWO_ADICITY - bits)\r\n            );\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_koala_bear() {\r\n        let f = F::from_u32(100);\r\n        assert_eq!(f.as_canonical_u64(), 100);\r\n\r\n        let f_1 = F::ONE;\r\n        let f_2 = F::TWO;\r\n        let f_p_minus_1 = F::NEG_ONE;\r\n        let f_p_minus_2 = F::NEG_ONE + F::NEG_ONE;\r\n        let m1 = F::from_u32(0x34167c58);\r\n        let m2 = F::from_u32(0x61f3207b);\r\n        let expected_prod = F::from_u32(0x54b46b81);\r\n        assert_eq!(m1 * m2, expected_prod);\r\n\r\n        assert_eq!(m1.injective_exp_n().injective_exp_root_n(), m1);\r\n        assert_eq!(m2.injective_exp_n().injective_exp_root_n(), m2);\r\n        assert_eq!(f_2.injective_exp_n().injective_exp_root_n(), f_2);\r\n\r\n        let f_serialized = serde_json::to_string(\u0026f).unwrap();\r\n        let f_deserialized: F = serde_json::from_str(\u0026f_serialized).unwrap();\r\n        assert_eq!(f, f_deserialized);\r\n\r\n        let f_1_serialized = serde_json::to_string(\u0026f_1).unwrap();\r\n        let f_1_deserialized: F = serde_json::from_str(\u0026f_1_serialized).unwrap();\r\n        let f_1_serialized_again = serde_json::to_string(\u0026f_1_deserialized).unwrap();\r\n        let f_1_deserialized_again: F = serde_json::from_str(\u0026f_1_serialized_again).unwrap();\r\n        assert_eq!(f_1, f_1_deserialized);\r\n        assert_eq!(f_1, f_1_deserialized_again);\r\n\r\n        let f_2_serialized = serde_json::to_string(\u0026f_2).unwrap();\r\n        let f_2_deserialized: F = serde_json::from_str(\u0026f_2_serialized).unwrap();\r\n        assert_eq!(f_2, f_2_deserialized);\r\n\r\n        let f_p_minus_1_serialized = serde_json::to_string(\u0026f_p_minus_1).unwrap();\r\n        let f_p_minus_1_deserialized: F = serde_json::from_str(\u0026f_p_minus_1_serialized).unwrap();\r\n        assert_eq!(f_p_minus_1, f_p_minus_1_deserialized);\r\n\r\n        let f_p_minus_2_serialized = serde_json::to_string(\u0026f_p_minus_2).unwrap();\r\n        let f_p_minus_2_deserialized: F = serde_json::from_str(\u0026f_p_minus_2_serialized).unwrap();\r\n        assert_eq!(f_p_minus_2, f_p_minus_2_deserialized);\r\n\r\n        let m1_serialized = serde_json::to_string(\u0026m1).unwrap();\r\n        let m1_deserialized: F = serde_json::from_str(\u0026m1_serialized).unwrap();\r\n        assert_eq!(m1, m1_deserialized);\r\n\r\n        let m2_serialized = serde_json::to_string(\u0026m2).unwrap();\r\n        let m2_deserialized: F = serde_json::from_str(\u0026m2_serialized).unwrap();\r\n        assert_eq!(m2, m2_deserialized);\r\n    }\r\n\r\n    test_field!(crate::KoalaBear);\r\n    test_two_adic_field!(crate::KoalaBear);\r\n\r\n    test_field_dft!(radix2dit, crate::KoalaBear, p3_dft::Radix2Dit\u003c_\u003e);\r\n    test_field_dft!(bowers, crate::KoalaBear, p3_dft::Radix2Bowers);\r\n    test_field_dft!(\r\n        parallel,\r\n        crate::KoalaBear,\r\n        p3_dft::Radix2DitParallel::\u003ccrate::KoalaBear\u003e\r\n    );\r\n    test_field_dft!(\r\n        recur_dft,\r\n        crate::KoalaBear,\r\n        p3_monty_31::dft::RecursiveDft\u003c_\u003e\r\n    );\r\n    test_prime_field!(crate::KoalaBear);\r\n    test_prime_field_64!(crate::KoalaBear);\r\n    test_prime_field_32!(crate::KoalaBear);\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":34,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927945}},{"line":42,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":43,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":44,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":45,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":46,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":47,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":48,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":49,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":50,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":51,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":52,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":53,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":54,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":56,"address":[],"length":0,"stats":{"Line":5692549928996306935}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}}],"covered":19,"coverable":19},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","lib.rs"],"content":"#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nextern crate alloc;\r\n\r\nmod extension;\r\nmod koala_bear;\r\nmod poseidon2;\r\n\r\npub use koala_bear::*;\r\npub use poseidon2::*;\r\n\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\nmod aarch64_neon;\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub use aarch64_neon::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\nmod x86_64_avx2;\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use x86_64_avx2::*;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\nmod x86_64_avx512;\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use x86_64_avx512::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","poseidon2.rs"],"content":"//! Implementation of Poseidon2, see: https://eprint.iacr.org/2023/323\r\n//!\r\n//! For the diffusion matrix, 1 + Diag(V), we perform a search to find an optimized\r\n//! vector V composed of elements with efficient multiplication algorithms in AVX2/AVX512/NEON.\r\n//!\r\n//! This leads to using small values (e.g. 1, 2, 3, 4) where multiplication is implemented using addition\r\n//! and inverse powers of 2 where it is possible to avoid monty reductions.\r\n//! Additionally, for technical reasons, having the first entry be -2 is useful.\r\n//!\r\n//! Optimized Diagonal for KoalaBear16:\r\n//! [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24]\r\n//! Optimized Diagonal for KoalaBear24:\r\n//! [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24, -1/2^8, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^9, -1/2^24]\r\n//! See poseidon2\\src\\diffusion.rs for information on how to double check these matrices in Sage.\r\n\r\nuse p3_field::{Algebra, Field, PrimeCharacteristicRing, PrimeField32};\r\nuse p3_monty_31::{\r\n    GenericPoseidon2LinearLayersMonty31, InternalLayerBaseParameters, InternalLayerParameters,\r\n    MontyField31, Poseidon2ExternalLayerMonty31, Poseidon2InternalLayerMonty31,\r\n};\r\nuse p3_poseidon2::Poseidon2;\r\n\r\nuse crate::{KoalaBear, KoalaBearParameters};\r\n\r\npub type Poseidon2InternalLayerKoalaBear\u003cconst WIDTH: usize\u003e =\r\n    Poseidon2InternalLayerMonty31\u003cKoalaBearParameters, WIDTH, KoalaBearInternalLayerParameters\u003e;\r\n\r\npub type Poseidon2ExternalLayerKoalaBear\u003cconst WIDTH: usize\u003e =\r\n    Poseidon2ExternalLayerMonty31\u003cKoalaBearParameters, WIDTH\u003e;\r\n\r\n/// Degree of the chosen permutation polynomial for KoalaBear, used as the Poseidon2 S-Box.\r\n///\r\n/// As p - 1 = 127 * 2^{24} we have a lot of choice in degree D satisfying gcd(p - 1, D) = 1.\r\n/// Experimentation suggests that the optimal choice is the smallest available one, namely 3.\r\nconst KOALABEAR_S_BOX_DEGREE: u64 = 3;\r\n\r\n/// An implementation of the Poseidon2 hash function specialised to run on the current architecture.\r\n///\r\n/// It acts on arrays of the form either `[KoalaBear::Packing; WIDTH]` or `[KoalaBear; WIDTH]`. For speed purposes,\r\n/// wherever possible, input arrays should of the form `[KoalaBear::Packing; WIDTH]`.\r\npub type Poseidon2KoalaBear\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    KoalaBear,\r\n    Poseidon2ExternalLayerKoalaBear\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerKoalaBear\u003cWIDTH\u003e,\r\n    WIDTH,\r\n    KOALABEAR_S_BOX_DEGREE,\r\n\u003e;\r\n\r\n/// An implementation of the matrix multiplications in the internal and external layers of Poseidon2.\r\n///\r\n/// This can act on `[A; WIDTH]` for any ring implementing `Algebra\u003cBabyBear\u003e`.\r\n/// If you have either `[KoalaBear::Packing; WIDTH]` or `[KoalaBear; WIDTH]` it will be much faster\r\n/// to use `Poseidon2KoalaBear\u003cWIDTH\u003e` instead of building a Poseidon2 permutation using this.\r\npub type GenericPoseidon2LinearLayersKoalaBear =\r\n    GenericPoseidon2LinearLayersMonty31\u003cKoalaBearParameters, KoalaBearInternalLayerParameters\u003e;\r\n\r\n// In order to use KoalaBear::new_array we need to convert our vector to a vector of u32's.\r\n// To do this we make use of the fact that KoalaBear::ORDER_U32 - 1 = 127 * 2^24 so for 0 \u003c= n \u003c= 24:\r\n// -1/2^n = (KoalaBear::ORDER_U32 - 1) \u003e\u003e n\r\n// 1/2^n = -(-1/2^n) = KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e n)\r\n\r\n/// The vector [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24]\r\n/// saved as an array of KoalaBear elements.\r\nconst INTERNAL_DIAG_MONTY_16: [KoalaBear; 16] = KoalaBear::new_array([\r\n    KoalaBear::ORDER_U32 - 2,\r\n    1,\r\n    2,\r\n    (KoalaBear::ORDER_U32 + 1) \u003e\u003e 1,\r\n    3,\r\n    4,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 1,\r\n    KoalaBear::ORDER_U32 - 3,\r\n    KoalaBear::ORDER_U32 - 4,\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 8),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 3),\r\n    KoalaBear::ORDER_U32 - 127,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 8,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 3,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 4,\r\n    127,\r\n]);\r\n\r\n/// The vector [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24, -1/2^8, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^9, -1/2^24]\r\n/// saved as an array of KoalaBear elements.\r\nconst INTERNAL_DIAG_MONTY_24: [KoalaBear; 24] = KoalaBear::new_array([\r\n    KoalaBear::ORDER_U32 - 2,\r\n    1,\r\n    2,\r\n    (KoalaBear::ORDER_U32 + 1) \u003e\u003e 1,\r\n    3,\r\n    4,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 1,\r\n    KoalaBear::ORDER_U32 - 3,\r\n    KoalaBear::ORDER_U32 - 4,\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 8),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 2),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 3),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 4),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 5),\r\n    KoalaBear::ORDER_U32 - ((KoalaBear::ORDER_U32 - 1) \u003e\u003e 6),\r\n    KoalaBear::ORDER_U32 - 127,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 8,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 3,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 4,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 5,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 6,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 7,\r\n    (KoalaBear::ORDER_U32 - 1) \u003e\u003e 9,\r\n    127,\r\n]);\r\n\r\n/// Contains data needed to define the internal layers of the Poseidon2 permutation.\r\n#[derive(Debug, Clone, Default)]\r\npub struct KoalaBearInternalLayerParameters;\r\n\r\nimpl InternalLayerBaseParameters\u003cKoalaBearParameters, 16\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [MontyField31\u003cKoalaBearParameters\u003e; 15];\r\n\r\n    const INTERNAL_DIAG_MONTY: [MontyField31\u003cKoalaBearParameters\u003e; 16] = INTERNAL_DIAG_MONTY_16;\r\n\r\n    /// Perform the internal matrix multiplication: s -\u003e (1 + Diag(V))s.\r\n    /// We ignore `state[0]` as it is handled separately.\r\n    fn internal_layer_mat_mul(\r\n        state: \u0026mut [MontyField31\u003cKoalaBearParameters\u003e; 16],\r\n        sum: MontyField31\u003cKoalaBearParameters\u003e,\r\n    ) {\r\n        // The diagonal matrix is defined by the vector:\r\n        // V = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24]\r\n        state[1] += sum;\r\n        state[2] = state[2].double() + sum;\r\n        state[3] = state[3].halve() + sum;\r\n        state[4] = sum + state[4].double() + state[4];\r\n        state[5] = sum + state[5].double().double();\r\n        state[6] = sum - state[6].halve();\r\n        state[7] = sum - (state[7].double() + state[7]);\r\n        state[8] = sum - state[8].double().double();\r\n        state[9] = state[9].mul_2exp_neg_n(8);\r\n        state[9] += sum;\r\n        state[10] = state[10].mul_2exp_neg_n(3);\r\n        state[10] += sum;\r\n        state[11] = state[11].mul_2exp_neg_n(24);\r\n        state[11] += sum;\r\n        state[12] = state[12].mul_2exp_neg_n(8);\r\n        state[12] = sum - state[12];\r\n        state[13] = state[13].mul_2exp_neg_n(3);\r\n        state[13] = sum - state[13];\r\n        state[14] = state[14].mul_2exp_neg_n(4);\r\n        state[14] = sum - state[14];\r\n        state[15] = state[15].mul_2exp_neg_n(24);\r\n        state[15] = sum - state[15];\r\n    }\r\n\r\n    fn generic_internal_linear_layer\u003cA: Algebra\u003cKoalaBear\u003e\u003e(state: \u0026mut [A; 16]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use multiplication.\r\n        // This could probably be improved slightly by making use of the\r\n        // mul_2exp_u64 and div_2exp_u64 but this would involve porting div_2exp_u64 to PrimeCharacteristicRing.\r\n        state\r\n            .iter_mut()\r\n            .zip(INTERNAL_DIAG_MONTY_16)\r\n            .skip(3)\r\n            .for_each(|(val, diag_elem)| {\r\n                *val = full_sum.clone() + val.clone() * diag_elem;\r\n            });\r\n    }\r\n}\r\n\r\nimpl InternalLayerBaseParameters\u003cKoalaBearParameters, 24\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [MontyField31\u003cKoalaBearParameters\u003e; 23];\r\n\r\n    const INTERNAL_DIAG_MONTY: [MontyField31\u003cKoalaBearParameters\u003e; 24] = INTERNAL_DIAG_MONTY_24;\r\n\r\n    /// Perform the internal matrix multiplication: s -\u003e (1 + Diag(V))s.\r\n    /// We ignore `state[0]` as it is handled separately.\r\n    fn internal_layer_mat_mul(\r\n        state: \u0026mut [MontyField31\u003cKoalaBearParameters\u003e; 24],\r\n        sum: MontyField31\u003cKoalaBearParameters\u003e,\r\n    ) {\r\n        // The diagonal matrix is defined by the vector:\r\n        // V = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24, -1/2^8, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^9, -1/2^24]\r\n        state[1] += sum;\r\n        state[2] = state[2].double() + sum;\r\n        state[3] = state[3].halve() + sum;\r\n        state[4] = sum + state[4].double() + state[4];\r\n        state[5] = sum + state[5].double().double();\r\n        state[6] = sum - state[6].halve();\r\n        state[7] = sum - (state[7].double() + state[7]);\r\n        state[8] = sum - state[8].double().double();\r\n        state[9] = state[9].mul_2exp_neg_n(8);\r\n        state[9] += sum;\r\n        state[10] = state[10].mul_2exp_neg_n(2);\r\n        state[10] += sum;\r\n        state[11] = state[11].mul_2exp_neg_n(3);\r\n        state[11] += sum;\r\n        state[12] = state[12].mul_2exp_neg_n(4);\r\n        state[12] += sum;\r\n        state[13] = state[13].mul_2exp_neg_n(5);\r\n        state[13] += sum;\r\n        state[14] = state[14].mul_2exp_neg_n(6);\r\n        state[14] += sum;\r\n        state[15] = state[15].mul_2exp_neg_n(24);\r\n        state[15] += sum;\r\n        state[16] = state[16].mul_2exp_neg_n(8);\r\n        state[16] = sum - state[16];\r\n        state[17] = state[17].mul_2exp_neg_n(3);\r\n        state[17] = sum - state[17];\r\n        state[18] = state[18].mul_2exp_neg_n(4);\r\n        state[18] = sum - state[18];\r\n        state[19] = state[19].mul_2exp_neg_n(5);\r\n        state[19] = sum - state[19];\r\n        state[20] = state[20].mul_2exp_neg_n(6);\r\n        state[20] = sum - state[20];\r\n        state[21] = state[21].mul_2exp_neg_n(7);\r\n        state[21] = sum - state[21];\r\n        state[22] = state[22].mul_2exp_neg_n(9);\r\n        state[22] = sum - state[22];\r\n        state[23] = state[23].mul_2exp_neg_n(24);\r\n        state[23] = sum - state[23];\r\n    }\r\n\r\n    fn generic_internal_linear_layer\u003cA: Algebra\u003cKoalaBear\u003e\u003e(state: \u0026mut [A; 24]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use multiplication.\r\n        // This could probably be improved slightly by making use of the\r\n        // mul_2exp_u64 and div_2exp_u64 but this would involve porting div_2exp_u64 to PrimeCharacteristicRing.\r\n        state\r\n            .iter_mut()\r\n            .zip(INTERNAL_DIAG_MONTY_24)\r\n            .skip(3)\r\n            .for_each(|(val, diag_elem)| {\r\n                *val = full_sum.clone() + val.clone() * diag_elem;\r\n            });\r\n    }\r\n}\r\n\r\nimpl InternalLayerParameters\u003cKoalaBearParameters, 16\u003e for KoalaBearInternalLayerParameters {}\r\nimpl InternalLayerParameters\u003cKoalaBearParameters, 24\u003e for KoalaBearInternalLayerParameters {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::{Rng, SeedableRng};\r\n    use rand_xoshiro::Xoroshiro128Plus;\r\n\r\n    use super::*;\r\n\r\n    type F = KoalaBear;\r\n\r\n    // We need to make some round constants. We use Xoroshiro128Plus for this as we can easily match this PRNG in sage.\r\n    // See: https://github.com/0xPolygonZero/hash-constants for the sage code used to create all these tests.\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(16)\r\n    /// vector([KB.random_element() for t in range(16)]).\r\n    #[test]\r\n    fn test_poseidon2_width_16_random() {\r\n        let mut input: [F; 16] = KoalaBear::new_array([\r\n            894848333, 1437655012, 1200606629, 1690012884, 71131202, 1749206695, 1717947831,\r\n            120589055, 19776022, 42382981, 1831865506, 724844064, 171220207, 1299207443, 227047920,\r\n            1783754913,\r\n        ]);\r\n\r\n        let expected: [F; 16] = KoalaBear::new_array([\r\n            652590279, 1200629963, 1013089423, 1840372851, 19101828, 561050015, 1714865585,\r\n            994637181, 498949829, 729884572, 1957973925, 263012103, 535029297, 2121808603,\r\n            964663675, 1473622080,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2KoalaBear::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(24)\r\n    /// vector([KB.random_element() for t in range(24)]).\r\n    #[test]\r\n    fn test_poseidon2_width_24_random() {\r\n        let mut input: [F; 24] = KoalaBear::new_array([\r\n            886409618, 1327899896, 1902407911, 591953491, 648428576, 1844789031, 1198336108,\r\n            355597330, 1799586834, 59617783, 790334801, 1968791836, 559272107, 31054313,\r\n            1042221543, 474748436, 135686258, 263665994, 1962340735, 1741539604, 2026927696,\r\n            449439011, 1131357108, 50869465,\r\n        ]);\r\n\r\n        let expected: [F; 24] = KoalaBear::new_array([\r\n            3825456, 486989921, 613714063, 282152282, 1027154688, 1171655681, 879344953,\r\n            1090688809, 1960721991, 1604199242, 1329947150, 1535171244, 781646521, 1156559780,\r\n            1875690339, 368140677, 457503063, 304208551, 1919757655, 835116474, 1293372648,\r\n            1254825008, 810923913, 1773631109,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2KoalaBear::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test the generic internal layer against the optimized internal layer\r\n    /// for a random input of width 16.\r\n    #[test]\r\n    fn test_generic_internal_linear_layer_16() {\r\n        let mut rng = rand::thread_rng();\r\n        let mut input1: [F; 16] = rng.gen();\r\n        let mut input2 = input1;\r\n\r\n        let part_sum: F = input1[1..].iter().cloned().sum();\r\n        let full_sum = part_sum + input1[0];\r\n\r\n        input1[0] = part_sum - input1[0];\r\n\r\n        KoalaBearInternalLayerParameters::internal_layer_mat_mul(\u0026mut input1, full_sum);\r\n        KoalaBearInternalLayerParameters::generic_internal_linear_layer(\u0026mut input2);\r\n\r\n        assert_eq!(input1, input2);\r\n    }\r\n\r\n    /// Test the generic internal layer against the optimized internal layer\r\n    /// for a random input of width 16.\r\n    #[test]\r\n    fn test_generic_internal_linear_layer_24() {\r\n        let mut rng = rand::thread_rng();\r\n        let mut input1: [F; 24] = rng.gen();\r\n        let mut input2 = input1;\r\n\r\n        let part_sum: F = input1[1..].iter().cloned().sum();\r\n        let full_sum = part_sum + input1[0];\r\n\r\n        input1[0] = part_sum - input1[0];\r\n\r\n        KoalaBearInternalLayerParameters::internal_layer_mat_mul(\u0026mut input1, full_sum);\r\n        KoalaBearInternalLayerParameters::generic_internal_linear_layer(\u0026mut input2);\r\n\r\n        assert_eq!(input1, input2);\r\n    }\r\n}\r\n","traces":[{"line":123,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":129,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":130,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":131,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":132,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":133,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":134,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":135,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":136,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":137,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":138,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":139,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":140,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":141,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":142,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":143,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":144,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":145,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":146,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":147,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":148,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":149,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":150,"address":[],"length":0,"stats":{"Line":2954361355555045376}},{"line":153,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":154,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":158,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":159,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":160,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":165,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":167,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":169,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":170,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":182,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":188,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":189,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":190,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":191,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":192,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":193,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":194,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":195,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":196,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":197,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":198,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":199,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":200,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":201,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":202,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":203,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":204,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":205,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":206,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":207,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":208,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":209,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":210,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":211,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":212,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":213,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":214,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":215,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":216,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":217,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":218,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":219,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":220,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":221,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":222,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":223,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":224,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":225,"address":[],"length":0,"stats":{"Line":3386706919782612992}},{"line":228,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":229,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":235,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":240,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":242,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":244,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":245,"address":[],"length":0,"stats":{"Line":1513209474796486656}}],"covered":82,"coverable":82},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx2","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx2","packing.rs"],"content":"use core::arch::x86_64::__m256i;\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersAVX2, PackedMontyField31AVX2};\r\n\r\nuse crate::KoalaBearParameters;\r\n\r\npub type PackedKoalaBearAVX2 = PackedMontyField31AVX2\u003cKoalaBearParameters\u003e;\r\n\r\nconst WIDTH: usize = 8;\r\n\r\nimpl MontyParametersAVX2 for KoalaBearParameters {\r\n    const PACKED_P: __m256i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7f000001; WIDTH]) };\r\n    const PACKED_MU: __m256i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x81000001; WIDTH]) };\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::KoalaBear;\r\n\r\n    const SPECIAL_VALS: [KoalaBear; WIDTH] = KoalaBear::new_array([\r\n        0x00000000, 0x00000001, 0x7f000000, 0x7effffff, 0x3f800000, 0x0ffffffe, 0x68000003,\r\n        0x70000002,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedKoalaBearAVX2,\r\n        crate::PackedKoalaBearAVX2::ZERO,\r\n        p3_monty_31::PackedMontyField31AVX2::\u003ccrate::KoalaBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx2","poseidon2.rs"],"content":"use core::arch::x86_64::{self, __m256i};\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{\r\n    mul_2exp_neg_n_avx2, mul_2exp_neg_two_adicity_avx2, mul_neg_2exp_neg_n_avx2,\r\n    mul_neg_2exp_neg_two_adicity_avx2, InternalLayerParametersAVX2,\r\n};\r\n\r\nuse crate::{KoalaBearInternalLayerParameters, KoalaBearParameters};\r\n\r\n// Godbolt file showing that these all compile to the expected instructions. (Potentially plus a few memory ops):\r\n// https://godbolt.org/z/xK91MKsdd\r\n\r\n// We reimplement multiplication by +/- 2^{-8} here as there is an extra trick we can do specifically in the KoalaBear case.\r\n// This lets us replace a left shift by _mm256_bslli_epi128 which can be performed on Port 5. This takes a small amount\r\n// of pressure off Ports 0, 1.\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by 2**{-8}.\r\n/// This is specialised to the KoalaBear prime which allows us to replace a\r\n/// shifts by a twiddle.\r\n/// # Safety\r\n///\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\nunsafe fn mul_2exp_neg_8(input: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpsrld      hi, val, 8\r\n    //      vpmaddubsw  lo, val, [r; 8]\r\n    //      vpslldq     lo, lo, 2\r\n    //      vpsubd      t, hi, lo\r\n    // throughput: 1.333\r\n    // latency: 7\r\n    unsafe {\r\n        const ONE_TWENTY_SEVEN: __m256i = unsafe { transmute([127; 8]) }; // P = r*2^j + 1 = 127 * 2^24 + 1\r\n        let hi = x86_64::_mm256_srli_epi32::\u003c8\u003e(input);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of odd_factor is \u003c 2^7, _mm256_maddubs_epi16\r\n        // performs an element wise multiplication of odd_factor with\r\n        // the bottom 8 bits of input interpreted as an unsigned integer\r\n        // Thus lo contains r*x_lo.\r\n        let lo = x86_64::_mm256_maddubs_epi16(input, ONE_TWENTY_SEVEN);\r\n\r\n        // As the high 16 bits of each 32 bit word are all 0\r\n        // we don't need to worry about shifting the high bits of one\r\n        // word into the low bits of another. Thus we can use\r\n        // _mm256_bslli_epi128 which can run on Port 5 as it is classed as\r\n        // a swizzle operation.\r\n        let lo_shft = x86_64::_mm256_bslli_epi128::\u003c2\u003e(lo);\r\n        x86_64::_mm256_sub_epi32(hi, lo_shft)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by 2**{-8}.\r\n/// This is specialised to the KoalaBear prime which allows us to replace a\r\n/// shift by a twiddle.\r\n/// # Safety\r\n///\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\nunsafe fn mul_neg_2exp_neg_8(input: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpsrld      hi, val, 8\r\n    //      vpmaddubsw  lo, val, [r; 8]\r\n    //      vpslldq     lo, lo, 2\r\n    //      vpsubd      t, lo, hi\r\n    // throughput: 1.333\r\n    // latency: 7\r\n    unsafe {\r\n        const ONE_TWENTY_SEVEN: __m256i = unsafe { transmute([127; 8]) }; // P = r*2^j + 1 = 127 * 2^24 + 1\r\n        let hi = x86_64::_mm256_srli_epi32::\u003c8\u003e(input);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of odd_factor is \u003c 2^7, _mm256_maddubs_epi16\r\n        // performs an element wise multiplication of odd_factor with\r\n        // the bottom 8 bits of input interpreted as an unsigned integer\r\n        // Thus lo contains r*x_lo.\r\n        let lo = x86_64::_mm256_maddubs_epi16(input, ONE_TWENTY_SEVEN);\r\n\r\n        // As the high 16 bits of each 32 bit word are all 0\r\n        // we don't need to worry about shifting the high bits of one\r\n        // word into the low bits of another. Thus we can use\r\n        // _mm256_bslli_epi128 which can run on Port 5 as it is classed as\r\n        // a swizzle operation.\r\n        let lo_shft = x86_64::_mm256_bslli_epi128::\u003c2\u003e(lo);\r\n        x86_64::_mm256_sub_epi32(lo_shft, hi)\r\n    }\r\n}\r\n\r\nimpl InternalLayerParametersAVX2\u003cKoalaBearParameters, 16\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [__m256i; 15];\r\n\r\n    /// For the KoalaBear field and width 16 we multiply by the diagonal matrix:\r\n    ///\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24]\r\n    /// The first 9 entries are handled elsewhere, this function handles all the positive/negative inverse powers of two.\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m256i; 15]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // input[8]-\u003e sum + input[8]/2^8\r\n        input[8] = mul_2exp_neg_8(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2^3\r\n        input[9] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 3, 21\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2^24\r\n        input[10] = mul_2exp_neg_two_adicity_avx2::\u003cKoalaBearParameters, 24, 7\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum - input[11]/2^8\r\n        input[11] = mul_neg_2exp_neg_8(input[11]);\r\n\r\n        // input[12] -\u003e sum - input[12]/2^3\r\n        input[12] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 3, 21\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum - input[13]/2^4\r\n        input[13] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 4, 20\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum - input[14]/2^24\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx2::\u003cKoalaBearParameters, 24, 7\u003e(input[14]);\r\n    }\r\n}\r\n\r\nimpl InternalLayerParametersAVX2\u003cKoalaBearParameters, 24\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [__m256i; 23];\r\n\r\n    /// For the KoalaBear field and width 1246 we multiply by the diagonal matrix:\r\n    ///\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24, -1/2^8, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^9, -1/2^24]\r\n    /// The first 9 entries are handled elsewhere, this function handles all the positive/negative inverse powers of two.\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum, the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m256i; 23]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // input[8] -\u003e sum + input[8]/2^8\r\n        input[8] = mul_2exp_neg_8(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2^2\r\n        input[9] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 2, 22\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2^3\r\n        input[10] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 3, 21\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2^4\r\n        input[11] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 4, 20\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum + input[12]/2^5\r\n        input[12] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 5, 19\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum + input[13]/2^6\r\n        input[13] = mul_2exp_neg_n_avx2::\u003cKoalaBearParameters, 6, 18\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum + input[14]/2^24\r\n        input[14] = mul_2exp_neg_two_adicity_avx2::\u003cKoalaBearParameters, 24, 7\u003e(input[14]);\r\n\r\n        // input[15] -\u003e sum - input[15]/2^8\r\n        input[15] = mul_neg_2exp_neg_8(input[15]);\r\n\r\n        // input[16] -\u003e sum - input[16]/2^3\r\n        input[16] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 3, 21\u003e(input[16]);\r\n\r\n        // input[17] -\u003e sum - input[17]/2^4\r\n        input[17] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 4, 20\u003e(input[17]);\r\n\r\n        // input[18] -\u003e sum - input[18]/2^5\r\n        input[18] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 5, 19\u003e(input[18]);\r\n\r\n        // input[19] -\u003e sum - input[19]/2^6\r\n        input[19] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 6, 18\u003e(input[19]);\r\n\r\n        // input[20] -\u003e sum - input[20]/2^7\r\n        input[20] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 7, 17\u003e(input[20]);\r\n\r\n        // input[21] -\u003e sum - input[21]/2^9\r\n        input[21] = mul_neg_2exp_neg_n_avx2::\u003cKoalaBearParameters, 9, 15\u003e(input[21]);\r\n\r\n        // input[22] -\u003e sum - input[22]/2^24\r\n        input[22] = mul_neg_2exp_neg_two_adicity_avx2::\u003cKoalaBearParameters, 24, 7\u003e(input[22]);\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{KoalaBear, PackedKoalaBearAVX2, Poseidon2KoalaBear};\r\n\r\n    type F = KoalaBear;\r\n    type Perm16 = Poseidon2KoalaBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2KoalaBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedKoalaBearAVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedKoalaBearAVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":36,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":43,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":50,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":51,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":63,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":73,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":80,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":87,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":88,"address":[],"length":0,"stats":{"Line":3098476543630901248}},{"line":103,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":109,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":112,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":115,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":118,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":121,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":124,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":127,"address":[],"length":0,"stats":{"Line":1441151880758558720}},{"line":142,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":148,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":151,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":154,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":157,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":160,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":163,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":166,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":169,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":172,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":175,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":178,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":181,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":184,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":187,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":190,"address":[],"length":0,"stats":{"Line":1657324662872342528}}],"covered":34,"coverable":34},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx512","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx512","packing.rs"],"content":"use core::arch::x86_64::__m512i;\r\nuse core::mem::transmute;\r\n\r\nuse p3_monty_31::{MontyParametersAVX512, PackedMontyField31AVX512};\r\n\r\nuse crate::KoalaBearParameters;\r\n\r\npub type PackedKoalaBearAVX512 = PackedMontyField31AVX512\u003cKoalaBearParameters\u003e;\r\n\r\nconst WIDTH: usize = 16;\r\n\r\nimpl MontyParametersAVX512 for KoalaBearParameters {\r\n    const PACKED_P: __m512i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7f000001; WIDTH]) };\r\n    const PACKED_MU: __m512i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x81000001; WIDTH]) };\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::WIDTH;\r\n    use crate::KoalaBear;\r\n\r\n    const SPECIAL_VALS: [KoalaBear; WIDTH] = KoalaBear::new_array([\r\n        0x00000000, 0x00000001, 0x78000000, 0x77ffffff, 0x3c000000, 0x0ffffffe, 0x68000003,\r\n        0x70000002, 0x00000000, 0x00000001, 0x78000000, 0x77ffffff, 0x3c000000, 0x0ffffffe,\r\n        0x68000003, 0x70000002,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedKoalaBearAVX512,\r\n        crate::PackedKoalaBearAVX512::ZERO,\r\n        p3_monty_31::PackedMontyField31AVX512::\u003ccrate::KoalaBearParameters\u003e(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","koala-bear","src","x86_64_avx512","poseidon2.rs"],"content":"use core::arch::x86_64::__m512i;\r\n\r\nuse p3_monty_31::{\r\n    mul_neg_2exp_neg_8_avx512, mul_neg_2exp_neg_n_avx512, mul_neg_2exp_neg_two_adicity_avx512,\r\n    InternalLayerParametersAVX512,\r\n};\r\n\r\nuse crate::{KoalaBearInternalLayerParameters, KoalaBearParameters};\r\n\r\nimpl InternalLayerParametersAVX512\u003cKoalaBearParameters, 16\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [__m512i; 15];\r\n\r\n    /// For the KoalaBear field and width 16 we multiply by the diagonal matrix:\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/8, 1/2^24, -1/2^8, -1/8, -1/16, -1/2^24].\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m512i; 15]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // This following 3 muls (from input[8] to input[10]) output the negative of what we want.\r\n        // This will be handled in add_sum.\r\n\r\n        // input[8]-\u003e sum + input[8]/2^8\r\n        input[8] = mul_neg_2exp_neg_8_avx512::\u003cKoalaBearParameters, 16\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2^3\r\n        input[9] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 3, 21\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2^24\r\n        input[10] = mul_neg_2exp_neg_two_adicity_avx512::\u003cKoalaBearParameters, 24, 7\u003e(input[10]);\r\n\r\n        // The remaining muls output the correct value again.\r\n\r\n        // input[11] -\u003e sum - input[11]/2^8\r\n        input[11] = mul_neg_2exp_neg_8_avx512::\u003cKoalaBearParameters, 16\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum - input[12]/2^3\r\n        input[12] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 3, 21\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum - input[13]/2^4\r\n        input[13] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 4, 20\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum - input[14]/2^24\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx512::\u003cKoalaBearParameters, 24, 7\u003e(input[14]);\r\n    }\r\n\r\n    /// There are 3 positive inverse powers of two after the 4: 1/2^8, 1/8, 1/2^24,\r\n    const NUM_POS: usize = 3;\r\n}\r\n\r\nimpl InternalLayerParametersAVX512\u003cKoalaBearParameters, 24\u003e for KoalaBearInternalLayerParameters {\r\n    type ArrayLike = [__m512i; 23];\r\n\r\n    /// For the KoalaBear field and width 24 we multiply by the diagonal matrix:\r\n    /// D = [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4, 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24, -1/2^8, -1/8, -1/16, -1/32, -1/64, -1/2^7, -1/2^9, -1/2^24]\r\n    /// The inputs must be in canonical form, otherwise the result is undefined.\r\n    /// Even when the inputs are in canonical form, we make no guarantees on the output except that, provided\r\n    /// the output is piped directly into add_sum, the vector will be modified such that x[i] = D[i]*x[i] + sum.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut [__m512i; 23]) {\r\n        // As far as we know this is optimal in that it need the fewest instructions to perform all of these\r\n        // multiplications. (Note that -1, 0 are not allowed on the diagonal for technical reasons).\r\n        // If there exist other number b for which x*b mod P can be computed quickly this diagonal can be updated.\r\n\r\n        // This following 7 muls (from input[8] to input[14]) output the negative of what we want.\r\n        // This will be handled in add_sum.\r\n\r\n        // input[8] -\u003e sum + input[8]/2^8\r\n        input[8] = mul_neg_2exp_neg_8_avx512::\u003cKoalaBearParameters, 16\u003e(input[8]);\r\n\r\n        // input[9] -\u003e sum + input[9]/2^2\r\n        input[9] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 2, 22\u003e(input[9]);\r\n\r\n        // input[10] -\u003e sum + input[10]/2^3\r\n        input[10] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 3, 21\u003e(input[10]);\r\n\r\n        // input[11] -\u003e sum + input[11]/2^4\r\n        input[11] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 4, 20\u003e(input[11]);\r\n\r\n        // input[12] -\u003e sum + input[12]/2^5\r\n        input[12] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 5, 19\u003e(input[12]);\r\n\r\n        // input[13] -\u003e sum + input[13]/2^6\r\n        input[13] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 6, 18\u003e(input[13]);\r\n\r\n        // input[14] -\u003e sum + input[14]/2^24\r\n        input[14] = mul_neg_2exp_neg_two_adicity_avx512::\u003cKoalaBearParameters, 24, 7\u003e(input[14]);\r\n\r\n        // The remaining muls output the correct value again.\r\n\r\n        // input[15] -\u003e sum - input[15]/2^8\r\n        input[15] = mul_neg_2exp_neg_8_avx512::\u003cKoalaBearParameters, 16\u003e(input[15]);\r\n\r\n        // input[16] -\u003e sum - input[16]/2^3\r\n        input[16] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 3, 21\u003e(input[16]);\r\n\r\n        // input[17] -\u003e sum - input[17]/2^4\r\n        input[17] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 4, 20\u003e(input[17]);\r\n\r\n        // input[18] -\u003e sum - input[18]/2^5\r\n        input[18] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 5, 19\u003e(input[18]);\r\n\r\n        // input[19] -\u003e sum - input[19]/2^6\r\n        input[19] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 6, 18\u003e(input[19]);\r\n\r\n        // input[20] -\u003e sum - input[20]/2^7\r\n        input[20] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 7, 17\u003e(input[20]);\r\n\r\n        // input[21] -\u003e sum - input[21]/2^9\r\n        input[21] = mul_neg_2exp_neg_n_avx512::\u003cKoalaBearParameters, 9, 15\u003e(input[21]);\r\n\r\n        // input[22] -\u003e sum - input[22]/2^24\r\n        input[22] = mul_neg_2exp_neg_two_adicity_avx512::\u003cKoalaBearParameters, 24, 7\u003e(input[22]);\r\n    }\r\n\r\n    /// There are 7 positive inverse powers of two after the 4: 1/2^8, 1/4, 1/8, 1/16, 1/32, 1/64, 1/2^24;\r\n    const NUM_POS: usize = 7;\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use crate::{KoalaBear, PackedKoalaBearAVX512, Poseidon2KoalaBear};\r\n\r\n    type F = KoalaBear;\r\n    type Perm16 = Poseidon2KoalaBear\u003c16\u003e;\r\n    type Perm24 = Poseidon2KoalaBear\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedKoalaBearAVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedKoalaBearAVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":24},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","benches","columnwise_dot_product.rs"],"content":"use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\r\nuse p3_baby_bear::BabyBear;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse rand::SeedableRng;\r\nuse rand_chacha::ChaChaRng;\r\n\r\nfn columnwise_dot_product(c: \u0026mut Criterion) {\r\n    let mut rng = ChaChaRng::seed_from_u64(0);\r\n\r\n    type F = BabyBear;\r\n    type EF = BinomialExtensionField\u003cF, 4\u003e;\r\n    let log_rows = 16;\r\n\r\n    c.benchmark_group(\"babybear\")\r\n        .sample_size(10)\r\n        .bench_function(\"columnwise_dot_product\", |b| {\r\n            b.iter_batched(\r\n                || {\r\n                    (\r\n                        RowMajorMatrix::\u003cF\u003e::rand_nonzero(\u0026mut rng, 1 \u003c\u003c log_rows, 1 \u003c\u003c 12),\r\n                        RowMajorMatrix::\u003cEF\u003e::rand_nonzero(\u0026mut rng, 1 \u003c\u003c log_rows, 1).values,\r\n                    )\r\n                },\r\n                |(m, v)| m.columnwise_dot_product(\u0026v),\r\n                BatchSize::PerIteration,\r\n            );\r\n        });\r\n}\r\n\r\ncriterion_group!(benches, columnwise_dot_product);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","benches","transpose_benchmark.rs"],"content":"use criterion::{criterion_group, criterion_main, BenchmarkGroup, Criterion, Throughput};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse rand::thread_rng;\r\n\r\nfn transpose_benchmark(c: \u0026mut Criterion) {\r\n    const SMALL_DIMS: [(usize, usize); 4] = [(4, 4), (8, 8), (10, 10), (12, 12)];\r\n    const LARGE_DIMS: [(usize, usize); 4] = [(20, 8), (21, 8), (22, 8), (23, 8)];\r\n\r\n    let inner = |g: \u0026mut BenchmarkGroup\u003c_\u003e, dims: \u0026[(usize, usize)]| {\r\n        let mut rng = thread_rng();\r\n        for (lg_nrows, lg_ncols) in dims {\r\n            let nrows = 1 \u003c\u003c lg_nrows;\r\n            let ncols = 1 \u003c\u003c lg_ncols;\r\n            let mut matrix1 = RowMajorMatrix::\u003cu32\u003e::rand(\u0026mut rng, nrows, ncols);\r\n            let mut matrix2 = RowMajorMatrix::default(nrows, ncols);\r\n\r\n            let name = format!(\"2^{lg_nrows} x 2^{lg_ncols}\");\r\n            g.throughput(Throughput::Bytes(\r\n                (nrows * ncols * core::mem::size_of::\u003cu32\u003e()) as u64,\r\n            ));\r\n            g.bench_function(\u0026name, |b| b.iter(|| matrix1.transpose_into(\u0026mut matrix2)));\r\n\r\n            if nrows != ncols {\r\n                let matrix2 = RowMajorMatrix::rand(\u0026mut rng, ncols, nrows);\r\n                let name = format!(\"2^{lg_ncols} x 2^{lg_nrows}\");\r\n                g.throughput(Throughput::Bytes(\r\n                    (nrows * ncols * core::mem::size_of::\u003cu32\u003e()) as u64,\r\n                ));\r\n                g.bench_function(\u0026name, |b| b.iter(|| matrix2.transpose_into(\u0026mut matrix1)));\r\n            }\r\n        }\r\n    };\r\n\r\n    let mut g = c.benchmark_group(\"transpose\");\r\n    inner(\u0026mut g, \u0026SMALL_DIMS);\r\n    g.sample_size(10);\r\n    inner(\u0026mut g, \u0026LARGE_DIMS);\r\n}\r\n\r\ncriterion_group!(benches, transpose_benchmark);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","bitrev.rs"],"content":"use p3_util::{log2_strict_usize, reverse_bits_len};\r\n\r\nuse crate::dense::{DenseMatrix, DenseStorage, RowMajorMatrix};\r\nuse crate::row_index_mapped::{RowIndexMap, RowIndexMappedView};\r\nuse crate::util::reverse_matrix_index_bits;\r\nuse crate::Matrix;\r\n\r\n/// A matrix whose row indices are possibly bit-reversed, enabling easily switching\r\n/// between orderings. Pretty much just either `RowMajorMatrix` or\r\n/// `BitReversedMatrixView\u003cRowMajorMatrix\u003e`.\r\npub trait BitReversableMatrix\u003cT: Send + Sync\u003e: Matrix\u003cT\u003e {\r\n    type BitRev: BitReversableMatrix\u003cT\u003e;\r\n    fn bit_reverse_rows(self) -\u003e Self::BitRev;\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct BitReversalPerm {\r\n    log_height: usize,\r\n}\r\n\r\nimpl BitReversalPerm {\r\n    /// Assumes the inner matrix height is a power of two; panics otherwise.\r\n    pub fn new_view\u003cT: Send + Sync, Inner: Matrix\u003cT\u003e\u003e(\r\n        inner: Inner,\r\n    ) -\u003e BitReversedMatrixView\u003cInner\u003e {\r\n        RowIndexMappedView {\r\n            index_map: Self {\r\n                log_height: log2_strict_usize(inner.height()),\r\n            },\r\n            inner,\r\n        }\r\n    }\r\n}\r\n\r\nimpl RowIndexMap for BitReversalPerm {\r\n    fn height(\u0026self) -\u003e usize {\r\n        1 \u003c\u003c self.log_height\r\n    }\r\n    fn map_row_index(\u0026self, r: usize) -\u003e usize {\r\n        reverse_bits_len(r, self.log_height)\r\n    }\r\n    // This might not be more efficient than the lazy generic impl\r\n    // if we have a nested view.\r\n    fn to_row_major_matrix\u003cT: Clone + Send + Sync, Inner: Matrix\u003cT\u003e\u003e(\r\n        \u0026self,\r\n        inner: Inner,\r\n    ) -\u003e RowMajorMatrix\u003cT\u003e {\r\n        let mut inner = inner.to_row_major_matrix();\r\n        reverse_matrix_index_bits(\u0026mut inner);\r\n        inner\r\n    }\r\n}\r\n\r\npub type BitReversedMatrixView\u003cInner\u003e = RowIndexMappedView\u003cBitReversalPerm, Inner\u003e;\r\n\r\nimpl\u003cT: Clone + Send + Sync, S: DenseStorage\u003cT\u003e\u003e BitReversableMatrix\u003cT\u003e\r\n    for BitReversedMatrixView\u003cDenseMatrix\u003cT, S\u003e\u003e\r\n{\r\n    type BitRev = DenseMatrix\u003cT, S\u003e;\r\n    fn bit_reverse_rows(self) -\u003e Self::BitRev {\r\n        self.inner\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Send + Sync, S: DenseStorage\u003cT\u003e\u003e BitReversableMatrix\u003cT\u003e for DenseMatrix\u003cT, S\u003e {\r\n    type BitRev = BitReversedMatrixView\u003cDenseMatrix\u003cT, S\u003e\u003e;\r\n    fn bit_reverse_rows(self) -\u003e Self::BitRev {\r\n        BitReversalPerm::new_view(self)\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":12610078956637388800}},{"line":27,"address":[],"length":0,"stats":{"Line":12610078956637388800}},{"line":36,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":37,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":39,"address":[],"length":0,"stats":{"Line":7133701809754865689}},{"line":40,"address":[],"length":0,"stats":{"Line":7133701809754865689}},{"line":44,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":48,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":49,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":50,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":60,"address":[],"length":0,"stats":{"Line":14987979559889010700}},{"line":61,"address":[],"length":0,"stats":{"Line":14987979559889010700}},{"line":67,"address":[],"length":0,"stats":{"Line":8214565720323784704}},{"line":68,"address":[],"length":0,"stats":{"Line":8214565720323784704}}],"covered":14,"coverable":14},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","dense.rs"],"content":"use alloc::borrow::Cow;\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::borrow::{Borrow, BorrowMut};\r\nuse core::marker::PhantomData;\r\nuse core::ops::Deref;\r\nuse core::{iter, slice};\r\n\r\nuse p3_field::{scale_slice_in_place, ExtensionField, Field, PackedValue};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::instrument;\r\n\r\nuse crate::Matrix;\r\n\r\n/// A dense matrix stored in row-major form.\r\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]\r\npub struct DenseMatrix\u003cT, V = Vec\u003cT\u003e\u003e {\r\n    pub values: V,\r\n    pub width: usize,\r\n    _phantom: PhantomData\u003cT\u003e,\r\n}\r\n\r\npub type RowMajorMatrix\u003cT\u003e = DenseMatrix\u003cT, Vec\u003cT\u003e\u003e;\r\npub type RowMajorMatrixView\u003c'a, T\u003e = DenseMatrix\u003cT, \u0026'a [T]\u003e;\r\npub type RowMajorMatrixViewMut\u003c'a, T\u003e = DenseMatrix\u003cT, \u0026'a mut [T]\u003e;\r\npub type RowMajorMatrixCow\u003c'a, T\u003e = DenseMatrix\u003cT, Cow\u003c'a, [T]\u003e\u003e;\r\n\r\npub trait DenseStorage\u003cT\u003e: Borrow\u003c[T]\u003e + Send + Sync {\r\n    fn to_vec(self) -\u003e Vec\u003cT\u003e;\r\n}\r\n// Cow doesn't impl IntoOwned so we can't blanket it\r\nimpl\u003cT: Clone + Send + Sync\u003e DenseStorage\u003cT\u003e for Vec\u003cT\u003e {\r\n    fn to_vec(self) -\u003e Vec\u003cT\u003e {\r\n        self\r\n    }\r\n}\r\nimpl\u003cT: Clone + Send + Sync\u003e DenseStorage\u003cT\u003e for \u0026[T] {\r\n    fn to_vec(self) -\u003e Vec\u003cT\u003e {\r\n        \u003c[T]\u003e::to_vec(self)\r\n    }\r\n}\r\nimpl\u003cT: Clone + Send + Sync\u003e DenseStorage\u003cT\u003e for \u0026mut [T] {\r\n    fn to_vec(self) -\u003e Vec\u003cT\u003e {\r\n        \u003c[T]\u003e::to_vec(self)\r\n    }\r\n}\r\nimpl\u003cT: Clone + Send + Sync\u003e DenseStorage\u003cT\u003e for Cow\u003c'_, [T]\u003e {\r\n    fn to_vec(self) -\u003e Vec\u003cT\u003e {\r\n        self.into_owned()\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Send + Sync + Default\u003e DenseMatrix\u003cT\u003e {\r\n    /// Create a new dense matrix of the given dimensions, backed by a `Vec`, and filled with\r\n    /// default values.\r\n    #[must_use]\r\n    pub fn default(width: usize, height: usize) -\u003e Self {\r\n        Self::new(vec![T::default(); width * height], width)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Send + Sync, S: DenseStorage\u003cT\u003e\u003e DenseMatrix\u003cT, S\u003e {\r\n    #[must_use]\r\n    pub fn new(values: S, width: usize) -\u003e Self {\r\n        debug_assert!(width == 0 || values.borrow().len() % width == 0);\r\n        Self {\r\n            values,\r\n            width,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn new_row(values: S) -\u003e Self {\r\n        let width = values.borrow().len();\r\n        Self::new(values, width)\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn new_col(values: S) -\u003e Self {\r\n        Self::new(values, 1)\r\n    }\r\n\r\n    pub fn as_view(\u0026self) -\u003e RowMajorMatrixView\u003c'_, T\u003e {\r\n        RowMajorMatrixView::new(self.values.borrow(), self.width)\r\n    }\r\n\r\n    pub fn as_view_mut(\u0026mut self) -\u003e RowMajorMatrixViewMut\u003c'_, T\u003e\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        RowMajorMatrixViewMut::new(self.values.borrow_mut(), self.width)\r\n    }\r\n\r\n    pub fn copy_from\u003cS2\u003e(\u0026mut self, source: \u0026DenseMatrix\u003cT, S2\u003e)\r\n    where\r\n        T: Copy,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n        S2: DenseStorage\u003cT\u003e,\r\n    {\r\n        assert_eq!(self.dimensions(), source.dimensions());\r\n        // Equivalent to:\r\n        // self.values.borrow_mut().copy_from_slice(source.values.borrow());\r\n        self.par_rows_mut()\r\n            .zip(source.par_row_slices())\r\n            .for_each(|(dst, src)| {\r\n                dst.copy_from_slice(src);\r\n            });\r\n    }\r\n\r\n    pub fn flatten_to_base\u003cF: Field\u003e(\u0026self) -\u003e RowMajorMatrix\u003cF\u003e\r\n    where\r\n        T: ExtensionField\u003cF\u003e,\r\n    {\r\n        let width = self.width * T::DIMENSION;\r\n        let values = self\r\n            .values\r\n            .borrow()\r\n            .iter()\r\n            .flat_map(|x| x.serialize_as_slice().iter().copied())\r\n            .collect();\r\n        RowMajorMatrix::new(values, width)\r\n    }\r\n\r\n    pub fn row_slices(\u0026self) -\u003e impl Iterator\u003cItem = \u0026[T]\u003e {\r\n        self.values.borrow().chunks_exact(self.width)\r\n    }\r\n\r\n    pub fn par_row_slices(\u0026self) -\u003e impl IndexedParallelIterator\u003cItem = \u0026[T]\u003e\r\n    where\r\n        T: Sync,\r\n    {\r\n        self.values.borrow().par_chunks_exact(self.width)\r\n    }\r\n\r\n    pub fn row_mut(\u0026mut self, r: usize) -\u003e \u0026mut [T]\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        \u0026mut self.values.borrow_mut()[r * self.width..(r + 1) * self.width]\r\n    }\r\n\r\n    pub fn rows_mut(\u0026mut self) -\u003e impl Iterator\u003cItem = \u0026mut [T]\u003e\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        self.values.borrow_mut().chunks_exact_mut(self.width)\r\n    }\r\n\r\n    pub fn par_rows_mut\u003c'a\u003e(\u0026'a mut self) -\u003e impl IndexedParallelIterator\u003cItem = \u0026'a mut [T]\u003e\r\n    where\r\n        T: 'a + Send,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        self.values.borrow_mut().par_chunks_exact_mut(self.width)\r\n    }\r\n\r\n    pub fn horizontally_packed_row_mut\u003cP\u003e(\u0026mut self, r: usize) -\u003e (\u0026mut [P], \u0026mut [T])\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        P::pack_slice_with_suffix_mut(self.row_mut(r))\r\n    }\r\n\r\n    pub fn scale_row(\u0026mut self, r: usize, scale: T)\r\n    where\r\n        T: Field,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        scale_slice_in_place(scale, self.row_mut(r));\r\n    }\r\n\r\n    pub fn scale(\u0026mut self, scale: T)\r\n    where\r\n        T: Field,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        scale_slice_in_place(scale, self.values.borrow_mut());\r\n    }\r\n\r\n    pub fn split_rows(\u0026self, r: usize) -\u003e (RowMajorMatrixView\u003cT\u003e, RowMajorMatrixView\u003cT\u003e) {\r\n        let (lo, hi) = self.values.borrow().split_at(r * self.width);\r\n        (\r\n            DenseMatrix::new(lo, self.width),\r\n            DenseMatrix::new(hi, self.width),\r\n        )\r\n    }\r\n\r\n    pub fn split_rows_mut(\r\n        \u0026mut self,\r\n        r: usize,\r\n    ) -\u003e (RowMajorMatrixViewMut\u003cT\u003e, RowMajorMatrixViewMut\u003cT\u003e)\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        let (lo, hi) = self.values.borrow_mut().split_at_mut(r * self.width);\r\n        (\r\n            DenseMatrix::new(lo, self.width),\r\n            DenseMatrix::new(hi, self.width),\r\n        )\r\n    }\r\n\r\n    pub fn par_row_chunks(\r\n        \u0026self,\r\n        chunk_rows: usize,\r\n    ) -\u003e impl IndexedParallelIterator\u003cItem = RowMajorMatrixView\u003cT\u003e\u003e\r\n    where\r\n        T: Send,\r\n    {\r\n        self.values\r\n            .borrow()\r\n            .par_chunks(self.width * chunk_rows)\r\n            .map(|slice| RowMajorMatrixView::new(slice, self.width))\r\n    }\r\n\r\n    pub fn par_row_chunks_exact(\r\n        \u0026self,\r\n        chunk_rows: usize,\r\n    ) -\u003e impl IndexedParallelIterator\u003cItem = RowMajorMatrixView\u003cT\u003e\u003e\r\n    where\r\n        T: Send,\r\n    {\r\n        self.values\r\n            .borrow()\r\n            .par_chunks_exact(self.width * chunk_rows)\r\n            .map(|slice| RowMajorMatrixView::new(slice, self.width))\r\n    }\r\n\r\n    pub fn par_row_chunks_mut(\r\n        \u0026mut self,\r\n        chunk_rows: usize,\r\n    ) -\u003e impl IndexedParallelIterator\u003cItem = RowMajorMatrixViewMut\u003cT\u003e\u003e\r\n    where\r\n        T: Send,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        self.values\r\n            .borrow_mut()\r\n            .par_chunks_mut(self.width * chunk_rows)\r\n            .map(|slice| RowMajorMatrixViewMut::new(slice, self.width))\r\n    }\r\n\r\n    pub fn row_chunks_exact_mut(\r\n        \u0026mut self,\r\n        chunk_rows: usize,\r\n    ) -\u003e impl Iterator\u003cItem = RowMajorMatrixViewMut\u003cT\u003e\u003e\r\n    where\r\n        T: Send,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        self.values\r\n            .borrow_mut()\r\n            .chunks_exact_mut(self.width * chunk_rows)\r\n            .map(|slice| RowMajorMatrixViewMut::new(slice, self.width))\r\n    }\r\n\r\n    pub fn par_row_chunks_exact_mut(\r\n        \u0026mut self,\r\n        chunk_rows: usize,\r\n    ) -\u003e impl IndexedParallelIterator\u003cItem = RowMajorMatrixViewMut\u003cT\u003e\u003e\r\n    where\r\n        T: Send,\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        self.values\r\n            .borrow_mut()\r\n            .par_chunks_exact_mut(self.width * chunk_rows)\r\n            .map(|slice| RowMajorMatrixViewMut::new(slice, self.width))\r\n    }\r\n\r\n    pub fn row_pair_mut(\u0026mut self, row_1: usize, row_2: usize) -\u003e (\u0026mut [T], \u0026mut [T])\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n    {\r\n        debug_assert_ne!(row_1, row_2);\r\n        let start_1 = row_1 * self.width;\r\n        let start_2 = row_2 * self.width;\r\n        let (lo, hi) = self.values.borrow_mut().split_at_mut(start_2);\r\n        (\u0026mut lo[start_1..][..self.width], \u0026mut hi[..self.width])\r\n    }\r\n\r\n    #[allow(clippy::type_complexity)]\r\n    pub fn packed_row_pair_mut\u003cP\u003e(\r\n        \u0026mut self,\r\n        row_1: usize,\r\n        row_2: usize,\r\n    ) -\u003e ((\u0026mut [P], \u0026mut [T]), (\u0026mut [P], \u0026mut [T]))\r\n    where\r\n        S: BorrowMut\u003c[T]\u003e,\r\n        P: PackedValue\u003cValue = T\u003e,\r\n    {\r\n        let (slice_1, slice_2) = self.row_pair_mut(row_1, row_2);\r\n        (\r\n            P::pack_slice_with_suffix_mut(slice_1),\r\n            P::pack_slice_with_suffix_mut(slice_2),\r\n        )\r\n    }\r\n\r\n    /// Append zeros to the \"end\" of the given matrix, except that the matrix is in bit-reversed order,\r\n    /// so in actuality we're interleaving zero rows.\r\n    #[instrument(level = \"debug\", skip_all)]\r\n    pub fn bit_reversed_zero_pad(self, added_bits: usize) -\u003e RowMajorMatrix\u003cT\u003e\r\n    where\r\n        T: Field,\r\n    {\r\n        if added_bits == 0 {\r\n            return self.to_row_major_matrix();\r\n        }\r\n\r\n        // This is equivalent to:\r\n        //     reverse_matrix_index_bits(mat);\r\n        //     mat\r\n        //         .values\r\n        //         .resize(mat.values.len() \u003c\u003c added_bits, F::ZERO);\r\n        //     reverse_matrix_index_bits(mat);\r\n        // But rather than implement it with bit reversals, we directly construct the resulting matrix,\r\n        // whose rows are zero except for rows whose low `added_bits` bits are zero.\r\n\r\n        let w = self.width;\r\n        let mut padded =\r\n            RowMajorMatrix::new(T::zero_vec(self.values.borrow().len() \u003c\u003c added_bits), w);\r\n        padded\r\n            .par_row_chunks_exact_mut(1 \u003c\u003c added_bits)\r\n            .zip(self.par_row_slices())\r\n            .for_each(|(mut ch, r)| ch.row_mut(0).copy_from_slice(r));\r\n\r\n        padded\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Send + Sync, S: DenseStorage\u003cT\u003e\u003e Matrix\u003cT\u003e for DenseMatrix\u003cT, S\u003e {\r\n    #[inline]\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.width\r\n    }\r\n\r\n    #[inline]\r\n    fn height(\u0026self) -\u003e usize {\r\n        if self.width == 0 {\r\n            0\r\n        } else {\r\n            self.values.borrow().len() / self.width\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        self.values.borrow()[r * self.width + c].clone()\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = iter::Cloned\u003cslice::Iter\u003c'a, T\u003e\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    #[inline]\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        self.values.borrow()[r * self.width..(r + 1) * self.width]\r\n            .iter()\r\n            .cloned()\r\n    }\r\n\r\n    #[inline]\r\n    fn row_slice(\u0026self, r: usize) -\u003e impl Deref\u003cTarget = [T]\u003e {\r\n        \u0026self.values.borrow()[r * self.width..(r + 1) * self.width]\r\n    }\r\n\r\n    fn to_row_major_matrix(self) -\u003e RowMajorMatrix\u003cT\u003e\r\n    where\r\n        Self: Sized,\r\n        T: Clone,\r\n    {\r\n        RowMajorMatrix::new(self.values.to_vec(), self.width)\r\n    }\r\n\r\n    #[inline]\r\n    fn horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e (\r\n        impl Iterator\u003cItem = P\u003e + Send + Sync,\r\n        impl Iterator\u003cItem = T\u003e + Send + Sync,\r\n    )\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + 'a,\r\n    {\r\n        let buf = \u0026self.values.borrow()[r * self.width..(r + 1) * self.width];\r\n        let (packed, sfx) = P::pack_slice_with_suffix(buf);\r\n        (packed.iter().cloned(), sfx.iter().cloned())\r\n    }\r\n\r\n    #[inline]\r\n    fn padded_horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e impl Iterator\u003cItem = P\u003e + Send + Sync\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + Default + 'a,\r\n    {\r\n        let buf = \u0026self.values.borrow()[r * self.width..(r + 1) * self.width];\r\n        let (packed, sfx) = P::pack_slice_with_suffix(buf);\r\n        packed.iter().cloned().chain(iter::once(P::from_fn(|i| {\r\n            sfx.get(i).cloned().unwrap_or_default()\r\n        })))\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Default + Send + Sync\u003e DenseMatrix\u003cT, Vec\u003cT\u003e\u003e {\r\n    pub fn as_cow\u003c'a\u003e(self) -\u003e RowMajorMatrixCow\u003c'a, T\u003e {\r\n        RowMajorMatrixCow::new(Cow::Owned(self.values), self.width)\r\n    }\r\n\r\n    pub fn rand\u003cR: Rng\u003e(rng: \u0026mut R, rows: usize, cols: usize) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003cT\u003e,\r\n    {\r\n        let values = rng.sample_iter(Standard).take(rows * cols).collect();\r\n        Self::new(values, cols)\r\n    }\r\n\r\n    pub fn rand_nonzero\u003cR: Rng\u003e(rng: \u0026mut R, rows: usize, cols: usize) -\u003e Self\r\n    where\r\n        T: Field,\r\n        Standard: Distribution\u003cT\u003e,\r\n    {\r\n        let values = rng\r\n            .sample_iter(Standard)\r\n            .filter(|x| !x.is_zero())\r\n            .take(rows * cols)\r\n            .collect();\r\n        Self::new(values, cols)\r\n    }\r\n\r\n    pub fn pad_to_height(\u0026mut self, new_height: usize, fill: T) {\r\n        assert!(new_height \u003e= self.height());\r\n        self.values.resize(self.width * new_height, fill);\r\n    }\r\n}\r\n\r\nimpl\u003cT: Copy + Default + Send + Sync\u003e DenseMatrix\u003cT, Vec\u003cT\u003e\u003e {\r\n    pub fn transpose(\u0026self) -\u003e Self {\r\n        let nelts = self.height() * self.width();\r\n        let mut values = vec![T::default(); nelts];\r\n        transpose::transpose(\u0026self.values, \u0026mut values, self.width(), self.height());\r\n        Self::new(values, self.height())\r\n    }\r\n\r\n    pub fn transpose_into(\u0026self, other: \u0026mut Self) {\r\n        assert_eq!(self.height(), other.width());\r\n        assert_eq!(other.height(), self.width());\r\n        transpose::transpose(\u0026self.values, \u0026mut other.values, self.width(), self.height());\r\n    }\r\n}\r\n\r\nimpl\u003c'a, T: Clone + Default + Send + Sync\u003e DenseMatrix\u003cT, \u0026'a [T]\u003e {\r\n    pub fn as_cow(self) -\u003e RowMajorMatrixCow\u003c'a, T\u003e {\r\n        RowMajorMatrixCow::new(Cow::Borrowed(self.values), self.width)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_transpose_square_matrix() {\r\n        const START_INDEX: usize = 1;\r\n        const VALUE_LEN: usize = 9;\r\n        const WIDTH: usize = 3;\r\n        const HEIGHT: usize = 3;\r\n\r\n        let matrix_values = (START_INDEX..=VALUE_LEN).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let matrix = RowMajorMatrix::new(matrix_values, WIDTH);\r\n        let transposed = matrix.transpose();\r\n        let should_be_transposed_values = vec![1, 4, 7, 2, 5, 8, 3, 6, 9];\r\n        let should_be_transposed = RowMajorMatrix::new(should_be_transposed_values, HEIGHT);\r\n        assert_eq!(transposed, should_be_transposed);\r\n    }\r\n\r\n    #[test]\r\n    fn test_transpose_row_matrix() {\r\n        const START_INDEX: usize = 1;\r\n        const VALUE_LEN: usize = 30;\r\n        const WIDTH: usize = 1;\r\n        const HEIGHT: usize = 30;\r\n\r\n        let matrix_values = (START_INDEX..=VALUE_LEN).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let matrix = RowMajorMatrix::new(matrix_values.clone(), WIDTH);\r\n        let transposed = matrix.transpose();\r\n        let should_be_transposed = RowMajorMatrix::new(matrix_values, HEIGHT);\r\n        assert_eq!(transposed, should_be_transposed);\r\n    }\r\n\r\n    #[test]\r\n    fn test_transpose_rectangular_matrix() {\r\n        const START_INDEX: usize = 1;\r\n        const VALUE_LEN: usize = 30;\r\n        const WIDTH: usize = 5;\r\n        const HEIGHT: usize = 6;\r\n\r\n        let matrix_values = (START_INDEX..=VALUE_LEN).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let matrix = RowMajorMatrix::new(matrix_values, WIDTH);\r\n        let transposed = matrix.transpose();\r\n        let should_be_transposed_values = vec![\r\n            1, 6, 11, 16, 21, 26, 2, 7, 12, 17, 22, 27, 3, 8, 13, 18, 23, 28, 4, 9, 14, 19, 24, 29,\r\n            5, 10, 15, 20, 25, 30,\r\n        ];\r\n        let should_be_transposed = RowMajorMatrix::new(should_be_transposed_values, HEIGHT);\r\n        assert_eq!(transposed, should_be_transposed);\r\n    }\r\n\r\n    #[test]\r\n    fn test_transpose_larger_rectangular_matrix() {\r\n        const START_INDEX: usize = 1;\r\n        const VALUE_LEN: usize = 131072; // 512 * 256\r\n        const WIDTH: usize = 256;\r\n        const HEIGHT: usize = 512;\r\n\r\n        let matrix_values = (START_INDEX..=VALUE_LEN).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let matrix = RowMajorMatrix::new(matrix_values, WIDTH);\r\n        let transposed = matrix.clone().transpose();\r\n\r\n        assert_eq!(transposed.width(), HEIGHT);\r\n        assert_eq!(transposed.height(), WIDTH);\r\n\r\n        for col_index in 0..WIDTH {\r\n            for row_index in 0..HEIGHT {\r\n                assert_eq!(\r\n                    matrix.values[row_index * WIDTH + col_index],\r\n                    transposed.values[col_index * HEIGHT + row_index]\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_transpose_very_large_rectangular_matrix() {\r\n        const START_INDEX: usize = 1;\r\n        const VALUE_LEN: usize = 1048576; // 512 * 256\r\n        const WIDTH: usize = 1024;\r\n        const HEIGHT: usize = 1024;\r\n\r\n        let matrix_values = (START_INDEX..=VALUE_LEN).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let matrix = RowMajorMatrix::new(matrix_values, WIDTH);\r\n        let transposed = matrix.clone().transpose();\r\n\r\n        assert_eq!(transposed.width(), HEIGHT);\r\n        assert_eq!(transposed.height(), WIDTH);\r\n\r\n        for col_index in 0..WIDTH {\r\n            for row_index in 0..HEIGHT {\r\n                assert_eq!(\r\n                    matrix.values[row_index * WIDTH + col_index],\r\n                    transposed.values[col_index * HEIGHT + row_index]\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":8070450532247928924}},{"line":37,"address":[],"length":0,"stats":{"Line":8070450532247928924}},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113787131}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113787131}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":61,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":67,"address":[],"length":0,"stats":{"Line":7710162562058289235}},{"line":68,"address":[],"length":0,"stats":{"Line":4395513236313604189}},{"line":77,"address":[],"length":0,"stats":{"Line":4035225266123964432}},{"line":78,"address":[],"length":0,"stats":{"Line":4035225266123964432}},{"line":79,"address":[],"length":0,"stats":{"Line":4035225266123964432}},{"line":83,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":84,"address":[],"length":0,"stats":{"Line":4971973988617027584}},{"line":87,"address":[],"length":0,"stats":{"Line":5044031582654955518}},{"line":88,"address":[],"length":0,"stats":{"Line":5044031582654955518}},{"line":91,"address":[],"length":0,"stats":{"Line":16068843470457929997}},{"line":95,"address":[],"length":0,"stats":{"Line":16068843470457929997}},{"line":98,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":104,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":109,"address":[],"length":0,"stats":{"Line":720575940379279367}},{"line":110,"address":[],"length":0,"stats":{"Line":360287970189639687}},{"line":114,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":118,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":119,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":120,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":123,"address":[],"length":0,"stats":{"Line":11889503016258109452}},{"line":125,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":2522015791327477772}},{"line":136,"address":[],"length":0,"stats":{"Line":2522015791327477772}},{"line":139,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":143,"address":[],"length":0,"stats":{"Line":1657324662872342528}},{"line":146,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":150,"address":[],"length":0,"stats":{"Line":5548434740920451072}},{"line":153,"address":[],"length":0,"stats":{"Line":13763000461244235777}},{"line":158,"address":[],"length":0,"stats":{"Line":13763000461244235777}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":174,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":177,"address":[],"length":0,"stats":{"Line":10448351135499551122}},{"line":182,"address":[],"length":0,"stats":{"Line":10448351135499551122}},{"line":185,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":186,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":188,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":189,"address":[],"length":0,"stats":{"Line":16068843470457929729}},{"line":193,"address":[],"length":0,"stats":{"Line":15924728282382074648}},{"line":200,"address":[],"length":0,"stats":{"Line":15924728282382074648}},{"line":202,"address":[],"length":0,"stats":{"Line":15924728282382074648}},{"line":203,"address":[],"length":0,"stats":{"Line":15924728282382074648}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":12249790986447749120}},{"line":227,"address":[],"length":0,"stats":{"Line":12249790986447749120}},{"line":229,"address":[],"length":0,"stats":{"Line":12249790986447749120}},{"line":230,"address":[],"length":0,"stats":{"Line":792633534417207706}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":1873497444986126398}},{"line":269,"address":[],"length":0,"stats":{"Line":1873497444986126398}},{"line":271,"address":[],"length":0,"stats":{"Line":1873497444986126398}},{"line":272,"address":[],"length":0,"stats":{"Line":17221764975064776951}},{"line":275,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":279,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":280,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":281,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":282,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":283,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":287,"address":[],"length":0,"stats":{"Line":17293822569102704699}},{"line":296,"address":[],"length":0,"stats":{"Line":17293822569102704699}},{"line":298,"address":[],"length":0,"stats":{"Line":17293822569102704699}},{"line":299,"address":[],"length":0,"stats":{"Line":17293822569102704699}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":2017612633061982308}},{"line":338,"address":[],"length":0,"stats":{"Line":2017612633061982308}},{"line":342,"address":[],"length":0,"stats":{"Line":15780613094306218162}},{"line":343,"address":[],"length":0,"stats":{"Line":15780613094306218162}},{"line":344,"address":[],"length":0,"stats":{"Line":918}},{"line":346,"address":[],"length":0,"stats":{"Line":15780613094306218081}},{"line":351,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":352,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":361,"address":[],"length":0,"stats":{"Line":3458764513820540923}},{"line":362,"address":[],"length":0,"stats":{"Line":3458764513820540923}},{"line":368,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":369,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":372,"address":[],"length":0,"stats":{"Line":8286623314361712686}},{"line":377,"address":[],"length":0,"stats":{"Line":8286623314361712686}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":5692549928996307046}},{"line":406,"address":[],"length":0,"stats":{"Line":5692549928996307046}},{"line":407,"address":[],"length":0,"stats":{"Line":5692549928996307046}},{"line":408,"address":[],"length":0,"stats":{"Line":5116089176692885708}},{"line":409,"address":[],"length":0,"stats":{"Line":17870283321406130278}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":144115188075855879}},{"line":423,"address":[],"length":0,"stats":{"Line":144115188075855879}},{"line":424,"address":[],"length":0,"stats":{"Line":144115188075855879}},{"line":427,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":432,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":433,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":434,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":435,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":437,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":440,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":441,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":442,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":447,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":448,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":449,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":450,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":451,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":463,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":106,"coverable":145},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","extension.rs"],"content":"use alloc::vec::Vec;\r\nuse core::iter;\r\nuse core::marker::PhantomData;\r\nuse core::ops::Deref;\r\n\r\nuse p3_field::{ExtensionField, Field};\r\n\r\nuse crate::Matrix;\r\n\r\n/// Flattens a matrix of extension field elements to one of base field elements. The flattening is\r\n/// done horizontally, resulting in a wider matrix.\r\n#[derive(Debug)]\r\npub struct FlatMatrixView\u003cF, EF, Inner\u003e(Inner, PhantomData\u003c(F, EF)\u003e);\r\n\r\nimpl\u003cF, EF, Inner\u003e FlatMatrixView\u003cF, EF, Inner\u003e {\r\n    pub fn new(inner: Inner) -\u003e Self {\r\n        Self(inner, PhantomData)\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, Inner\u003e Deref for FlatMatrixView\u003cF, EF, Inner\u003e {\r\n    type Target = Inner;\r\n\r\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\r\n        \u0026self.0\r\n    }\r\n}\r\n\r\nimpl\u003cF, EF, Inner\u003e Matrix\u003cF\u003e for FlatMatrixView\u003cF, EF, Inner\u003e\r\nwhere\r\n    F: Field,\r\n    EF: ExtensionField\u003cF\u003e,\r\n    Inner: Matrix\u003cEF\u003e,\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.0.width() * EF::DIMENSION\r\n    }\r\n\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.0.height()\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = FlatIter\u003cF, Inner::Row\u003c'a\u003e\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        FlatIter {\r\n            inner: self.0.row(r).peekable(),\r\n            idx: 0,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    fn row_slice(\u0026self, r: usize) -\u003e impl Deref\u003cTarget = [F]\u003e {\r\n        self.0\r\n            .row_slice(r)\r\n            .iter()\r\n            .flat_map(|val| val.serialize_as_slice())\r\n            .copied()\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n    }\r\n}\r\n\r\npub struct FlatIter\u003cF, I: Iterator\u003e {\r\n    inner: iter::Peekable\u003cI\u003e,\r\n    idx: usize,\r\n    _phantom: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF, EF, I\u003e Iterator for FlatIter\u003cF, I\u003e\r\nwhere\r\n    F: Field,\r\n    EF: ExtensionField\u003cF\u003e,\r\n    I: Iterator\u003cItem = EF\u003e,\r\n{\r\n    type Item = F;\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        if self.idx == EF::DIMENSION {\r\n            self.idx = 0;\r\n            self.inner.next();\r\n        }\r\n        let value = self.inner.peek()?.serialize_as_slice()[self.idx];\r\n        self.idx += 1;\r\n        Some(value)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n\r\n    use p3_field::extension::Complex;\r\n    use p3_field::{PrimeCharacteristicRing, Serializable};\r\n    use p3_mersenne_31::Mersenne31;\r\n\r\n    use super::*;\r\n    use crate::dense::RowMajorMatrix;\r\n    type F = Mersenne31;\r\n    type EF = Complex\u003cMersenne31\u003e;\r\n\r\n    #[test]\r\n    fn flat_matrix() {\r\n        let values = vec![\r\n            EF::deserialize_fn(|i| F::from_u8(i as u8 + 10)),\r\n            EF::deserialize_fn(|i| F::from_u8(i as u8 + 20)),\r\n            EF::deserialize_fn(|i| F::from_u8(i as u8 + 30)),\r\n            EF::deserialize_fn(|i| F::from_u8(i as u8 + 40)),\r\n        ];\r\n        let ext = RowMajorMatrix::\u003cEF\u003e::new(values, 2);\r\n        let flat = FlatMatrixView::\u003cF, EF, _\u003e::new(ext);\r\n        assert_eq!(\u0026*flat.row_slice(0), \u0026[10, 11, 20, 21].map(F::from_u8));\r\n        assert_eq!(\u0026*flat.row_slice(1), \u0026[30, 31, 40, 41].map(F::from_u8));\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":11601272640106397908}},{"line":17,"address":[],"length":0,"stats":{"Line":11601272640106397908}},{"line":24,"address":[],"length":0,"stats":{"Line":11529215046068469777}},{"line":25,"address":[],"length":0,"stats":{"Line":11529215046068469777}},{"line":35,"address":[],"length":0,"stats":{"Line":16357073846609641496}},{"line":36,"address":[],"length":0,"stats":{"Line":16357073846609641496}},{"line":39,"address":[],"length":0,"stats":{"Line":7926335344172073050}},{"line":40,"address":[],"length":0,"stats":{"Line":7926335344172073050}},{"line":48,"address":[],"length":0,"stats":{"Line":17726168133330272309}},{"line":50,"address":[],"length":0,"stats":{"Line":17726168133330272309}},{"line":56,"address":[],"length":0,"stats":{"Line":10520408729537478870}},{"line":57,"address":[],"length":0,"stats":{"Line":10520408729537478870}},{"line":58,"address":[],"length":0,"stats":{"Line":10520408729537478870}},{"line":60,"address":[],"length":0,"stats":{"Line":4611686018427388534}},{"line":79,"address":[],"length":0,"stats":{"Line":18302628885633695853}},{"line":80,"address":[],"length":0,"stats":{"Line":16861477004875137336}},{"line":81,"address":[],"length":0,"stats":{"Line":17005592192950993099}},{"line":82,"address":[],"length":0,"stats":{"Line":17005592192950993099}},{"line":84,"address":[],"length":0,"stats":{"Line":18158513697557840089}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}}],"covered":19,"coverable":21},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","horizontally_truncated.rs"],"content":"use core::iter::Take;\r\nuse core::marker::PhantomData;\r\n\r\nuse crate::Matrix;\r\n\r\npub struct HorizontallyTruncated\u003cT, Inner\u003e {\r\n    inner: Inner,\r\n    truncated_width: usize,\r\n    _phantom: PhantomData\u003cT\u003e,\r\n}\r\n\r\nimpl\u003cT, Inner: Matrix\u003cT\u003e\u003e HorizontallyTruncated\u003cT, Inner\u003e\r\nwhere\r\n    T: Send + Sync,\r\n{\r\n    pub fn new(inner: Inner, truncated_width: usize) -\u003e Self {\r\n        assert!(truncated_width \u003c= inner.width());\r\n        Self {\r\n            inner,\r\n            truncated_width,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT, Inner\u003e Matrix\u003cT\u003e for HorizontallyTruncated\u003cT, Inner\u003e\r\nwhere\r\n    T: Send + Sync,\r\n    Inner: Matrix\u003cT\u003e,\r\n{\r\n    #[inline(always)]\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.truncated_width\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.inner.height()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        debug_assert!(c \u003c self.truncated_width);\r\n        self.inner.get(c, r)\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = Take\u003cInner::Row\u003c'a\u003e\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    #[inline(always)]\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        self.inner.row(r).take(self.truncated_width)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","lib.rs"],"content":"//! Matrix library.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::vec::Vec;\r\nuse core::fmt::{Debug, Display, Formatter};\r\nuse core::ops::Deref;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_field::{\r\n    dot_product, ExtensionField, Field, PackedFieldExtension, PackedValue, PrimeCharacteristicRing,\r\n    Serializable,\r\n};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse strided::{VerticallyStridedMatrixView, VerticallyStridedRowIndexMap};\r\nuse tracing::instrument;\r\n\r\nuse crate::dense::RowMajorMatrix;\r\n\r\npub mod bitrev;\r\npub mod dense;\r\npub mod extension;\r\npub mod horizontally_truncated;\r\npub mod mul;\r\npub mod row_index_mapped;\r\npub mod sparse;\r\npub mod stack;\r\npub mod strided;\r\npub mod util;\r\n\r\n#[derive(Copy, Clone, PartialEq, Eq)]\r\npub struct Dimensions {\r\n    pub width: usize,\r\n    pub height: usize,\r\n}\r\n\r\nimpl Debug for Dimensions {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\r\n        write!(f, \"{}x{}\", self.width, self.height)\r\n    }\r\n}\r\n\r\nimpl Display for Dimensions {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\r\n        write!(f, \"{}x{}\", self.width, self.height)\r\n    }\r\n}\r\n\r\npub trait Matrix\u003cT: Send + Sync\u003e: Send + Sync {\r\n    fn width(\u0026self) -\u003e usize;\r\n    fn height(\u0026self) -\u003e usize;\r\n\r\n    fn dimensions(\u0026self) -\u003e Dimensions {\r\n        Dimensions {\r\n            width: self.width(),\r\n            height: self.height(),\r\n        }\r\n    }\r\n\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        self.row(r).nth(c).unwrap()\r\n    }\r\n\r\n    type Row\u003c'a\u003e: Iterator\u003cItem = T\u003e + Send + Sync\r\n    where\r\n        Self: 'a;\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e;\r\n\r\n    fn rows(\u0026self) -\u003e impl Iterator\u003cItem = Self::Row\u003c'_\u003e\u003e {\r\n        (0..self.height()).map(move |r| self.row(r))\r\n    }\r\n\r\n    fn par_rows(\u0026self) -\u003e impl IndexedParallelIterator\u003cItem = Self::Row\u003c'_\u003e\u003e {\r\n        (0..self.height()).into_par_iter().map(move |r| self.row(r))\r\n    }\r\n\r\n    // Opaque return type implicitly captures \u0026'_ self\r\n    fn row_slice(\u0026self, r: usize) -\u003e impl Deref\u003cTarget = [T]\u003e {\r\n        self.row(r).collect_vec()\r\n    }\r\n\r\n    fn first_row(\u0026self) -\u003e Self::Row\u003c'_\u003e {\r\n        self.row(0)\r\n    }\r\n\r\n    fn last_row(\u0026self) -\u003e Self::Row\u003c'_\u003e {\r\n        self.row(self.height() - 1)\r\n    }\r\n\r\n    fn to_row_major_matrix(self) -\u003e RowMajorMatrix\u003cT\u003e\r\n    where\r\n        Self: Sized,\r\n        T: Clone,\r\n    {\r\n        RowMajorMatrix::new(\r\n            (0..self.height()).flat_map(|r| self.row(r)).collect(),\r\n            self.width(),\r\n        )\r\n    }\r\n\r\n    fn horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e (\r\n        impl Iterator\u003cItem = P\u003e + Send + Sync,\r\n        impl Iterator\u003cItem = T\u003e + Send + Sync,\r\n    )\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + 'a,\r\n    {\r\n        let num_packed = self.width() / P::WIDTH;\r\n        let packed = (0..num_packed).map(move |c| P::from_fn(|i| self.get(r, P::WIDTH * c + i)));\r\n        let sfx = (num_packed * P::WIDTH..self.width()).map(move |c| self.get(r, c));\r\n        (packed, sfx)\r\n    }\r\n\r\n    /// Zero padded.\r\n    fn padded_horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e impl Iterator\u003cItem = P\u003e + Send + Sync\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + Default + 'a,\r\n    {\r\n        let mut row_iter = self.row(r);\r\n        let num_elems = self.width().div_ceil(P::WIDTH);\r\n        // array::from_fn currently always calls in order, but it's not clear whether that's guaranteed.\r\n        (0..num_elems).map(move |_| P::from_fn(|_| row_iter.next().unwrap_or_default()))\r\n    }\r\n\r\n    fn par_horizontally_packed_rows\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n    ) -\u003e impl IndexedParallelIterator\u003c\r\n        Item = (\r\n            impl Iterator\u003cItem = P\u003e + Send + Sync,\r\n            impl Iterator\u003cItem = T\u003e + Send + Sync,\r\n        ),\r\n    \u003e\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + 'a,\r\n    {\r\n        (0..self.height())\r\n            .into_par_iter()\r\n            .map(|r| self.horizontally_packed_row(r))\r\n    }\r\n\r\n    fn par_padded_horizontally_packed_rows\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n    ) -\u003e impl IndexedParallelIterator\u003cItem = impl Iterator\u003cItem = P\u003e + Send + Sync\u003e\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + Default + 'a,\r\n    {\r\n        (0..self.height())\r\n            .into_par_iter()\r\n            .map(|r| self.padded_horizontally_packed_row(r))\r\n    }\r\n\r\n    /// Pack together a collection of adjacent rows from the matrix.\r\n    ///\r\n    /// Returns an iterator whose i'th element is packing of the i'th element of the\r\n    /// rows r through r + P::WIDTH - 1. If we exceed the height of the matrix,\r\n    /// wrap around and include initial rows.\r\n    #[inline]\r\n    fn vertically_packed_row\u003cP\u003e(\u0026self, r: usize) -\u003e impl Iterator\u003cItem = P\u003e\r\n    where\r\n        T: Copy,\r\n        P: PackedValue\u003cValue = T\u003e,\r\n    {\r\n        let rows = (0..(P::WIDTH))\r\n            .map(|c| self.row_slice((r + c) % self.height()))\r\n            .collect_vec();\r\n        (0..self.width()).map(move |c| P::from_fn(|i| rows[i][c]))\r\n    }\r\n\r\n    /// Pack together a collection of rows and \"next\" rows from the matrix.\r\n    ///\r\n    /// Returns a vector corresponding to 2 packed rows. The i'th element of the first\r\n    /// row contains the packing of the i'th element of the rows r through r + P::WIDTH - 1.\r\n    /// The i'th element of the second row contains the packing of the i'th element of the\r\n    /// rows r + step through r + step + P::WIDTH - 1. If at some point we exceed the\r\n    /// height of the matrix, wrap around and include initial rows.\r\n    #[inline]\r\n    fn vertically_packed_row_pair\u003cP\u003e(\u0026self, r: usize, step: usize) -\u003e Vec\u003cP\u003e\r\n    where\r\n        T: Copy,\r\n        P: PackedValue\u003cValue = T\u003e,\r\n    {\r\n        // Whilst it would appear that this can be replaced by two calls to vertically_packed_row\r\n        // tests seem to indicate that combining them in the same function is slightly faster.\r\n        // It's probably allowing the compiler to make some optimizations on the fly.\r\n\r\n        let rows = (0..P::WIDTH)\r\n            .map(|c| self.row_slice((r + c) % self.height()))\r\n            .collect_vec();\r\n\r\n        let next_rows = (0..P::WIDTH)\r\n            .map(|c| self.row_slice((r + c + step) % self.height()))\r\n            .collect_vec();\r\n\r\n        (0..self.width())\r\n            .map(|c| P::from_fn(|i| rows[i][c]))\r\n            .chain((0..self.width()).map(|c| P::from_fn(|i| next_rows[i][c])))\r\n            .collect_vec()\r\n    }\r\n\r\n    fn vertically_strided(self, stride: usize, offset: usize) -\u003e VerticallyStridedMatrixView\u003cSelf\u003e\r\n    where\r\n        Self: Sized,\r\n    {\r\n        VerticallyStridedRowIndexMap::new_view(self, stride, offset)\r\n    }\r\n\r\n    /// Compute Mv, aka premultiply this matrix by the given vector,\r\n    /// aka scale each row by the corresponding entry in `v` and take the sum across rows.\r\n    /// `v` can be a vector of extension elements.\r\n    #[instrument(level = \"debug\", skip_all, fields(dims = %self.dimensions()))]\r\n    fn columnwise_dot_product\u003cEF\u003e(\u0026self, v: \u0026[EF]) -\u003e Vec\u003cEF\u003e\r\n    where\r\n        T: Field,\r\n        EF: ExtensionField\u003cT\u003e,\r\n    {\r\n        let packed_width = self.width().div_ceil(T::Packing::WIDTH);\r\n\r\n        let packed_result = self\r\n            .par_padded_horizontally_packed_rows::\u003cT::Packing\u003e()\r\n            .zip(v)\r\n            .par_fold_reduce(\r\n                || EF::ExtensionPacking::zero_vec(packed_width),\r\n                |mut acc, (row, \u0026scale)| {\r\n                    let scale = EF::ExtensionPacking::deserialize_fn(|i| {\r\n                        T::Packing::from(scale.serialize_as_slice()[i])\r\n                    });\r\n                    izip!(\u0026mut acc, row).for_each(|(l, r)| *l += scale * r);\r\n                    acc\r\n                },\r\n                |mut acc_l, acc_r| {\r\n                    izip!(\u0026mut acc_l, acc_r).for_each(|(l, r)| *l += r);\r\n                    acc_l\r\n                },\r\n            );\r\n\r\n        packed_result\r\n            .into_iter()\r\n            .flat_map(|p| {\r\n                (0..T::Packing::WIDTH)\r\n                    .map(move |i| EF::deserialize_fn(|j| p.serialize_as_slice()[j].as_slice()[i]))\r\n            })\r\n            .take(self.width())\r\n            .collect()\r\n    }\r\n\r\n    /// Multiply this matrix by the vector of powers of `base`, which is an extension element.\r\n    fn dot_ext_powers\u003cEF\u003e(\u0026self, base: EF) -\u003e impl IndexedParallelIterator\u003cItem = EF\u003e\r\n    where\r\n        T: Field,\r\n        EF: ExtensionField\u003cT\u003e,\r\n    {\r\n        let powers_packed = EF::ExtensionPacking::packed_ext_powers(base)\r\n            .take(self.width().next_multiple_of(T::Packing::WIDTH))\r\n            .collect_vec();\r\n        self.par_padded_horizontally_packed_rows::\u003cT::Packing\u003e()\r\n            .map(move |row_packed| {\r\n                let packed_sum_of_packed: EF::ExtensionPacking =\r\n                    dot_product(powers_packed.iter().copied(), row_packed);\r\n                let sum_of_packed: EF = EF::deserialize_fn(|i| {\r\n                    packed_sum_of_packed.serialize_as_slice()[i]\r\n                        .as_slice()\r\n                        .iter()\r\n                        .copied()\r\n                        .sum()\r\n                });\r\n                sum_of_packed\r\n            })\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec::Vec;\r\n    use alloc::{format, vec};\r\n\r\n    use itertools::izip;\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_field::extension::BinomialExtensionField;\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use rand::thread_rng;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_columnwise_dot_product() {\r\n        type F = BabyBear;\r\n        type EF = BinomialExtensionField\u003cBabyBear, 4\u003e;\r\n\r\n        let m = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c 8, 1 \u003c\u003c 4);\r\n        let v = RowMajorMatrix::\u003cEF\u003e::rand(\u0026mut thread_rng(), 1 \u003c\u003c 8, 1).values;\r\n\r\n        let mut expected = vec![EF::ZERO; m.width()];\r\n        for (row, \u0026scale) in izip!(m.rows(), \u0026v) {\r\n            for (l, r) in izip!(\u0026mut expected, row) {\r\n                *l += scale * r;\r\n            }\r\n        }\r\n\r\n        assert_eq!(m.columnwise_dot_product(\u0026v), expected);\r\n    }\r\n\r\n    // Mock implementation for testing purposes\r\n    struct MockMatrix {\r\n        data: Vec\u003cVec\u003cu32\u003e\u003e,\r\n        width: usize,\r\n        height: usize,\r\n    }\r\n\r\n    impl Matrix\u003cu32\u003e for MockMatrix {\r\n        type Row\u003c'a\u003e = alloc::vec::IntoIter\u003cu32\u003e;\r\n\r\n        fn width(\u0026self) -\u003e usize {\r\n            self.width\r\n        }\r\n\r\n        fn height(\u0026self) -\u003e usize {\r\n            self.height\r\n        }\r\n\r\n        fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n            self.data[r].clone().into_iter()\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_dimensions() {\r\n        let dims = Dimensions {\r\n            width: 3,\r\n            height: 5,\r\n        };\r\n        assert_eq!(dims.width, 3);\r\n        assert_eq!(dims.height, 5);\r\n        assert_eq!(format!(\"{:?}\", dims), \"3x5\");\r\n        assert_eq!(format!(\"{}\", dims), \"3x5\");\r\n    }\r\n\r\n    #[test]\r\n    fn test_mock_matrix_dimensions() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n        assert_eq!(matrix.width(), 3);\r\n        assert_eq!(matrix.height(), 3);\r\n        assert_eq!(\r\n            matrix.dimensions(),\r\n            Dimensions {\r\n                width: 3,\r\n                height: 3\r\n            }\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_first_row() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n        let mut first_row = matrix.first_row();\r\n        assert_eq!(first_row.next(), Some(1));\r\n        assert_eq!(first_row.next(), Some(2));\r\n        assert_eq!(first_row.next(), Some(3));\r\n    }\r\n\r\n    #[test]\r\n    fn test_last_row() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n        let mut last_row = matrix.last_row();\r\n        assert_eq!(last_row.next(), Some(7));\r\n        assert_eq!(last_row.next(), Some(8));\r\n        assert_eq!(last_row.next(), Some(9));\r\n    }\r\n\r\n    #[test]\r\n    fn test_row_slice() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n        let row_slice = matrix.row_slice(1);\r\n        assert_eq!(row_slice.deref(), \u0026[4, 5, 6]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_to_row_major_matrix() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2], vec![3, 4]],\r\n            width: 2,\r\n            height: 2,\r\n        };\r\n        let row_major = matrix.to_row_major_matrix();\r\n        assert_eq!(row_major.values, vec![1, 2, 3, 4]);\r\n        assert_eq!(row_major.width, 2);\r\n    }\r\n\r\n    #[test]\r\n    fn test_matrix_get() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n        assert_eq!(matrix.get(0, 0), 1);\r\n        assert_eq!(matrix.get(1, 2), 6);\r\n        assert_eq!(matrix.get(2, 1), 8);\r\n    }\r\n\r\n    #[test]\r\n    fn test_matrix_row_iteration() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n\r\n        let mut row_iter = matrix.row(1);\r\n        assert_eq!(row_iter.next(), Some(4));\r\n        assert_eq!(row_iter.next(), Some(5));\r\n        assert_eq!(row_iter.next(), Some(6));\r\n        assert_eq!(row_iter.next(), None);\r\n    }\r\n\r\n    #[test]\r\n    fn test_matrix_rows() {\r\n        let matrix = MockMatrix {\r\n            data: vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]],\r\n            width: 3,\r\n            height: 3,\r\n        };\r\n\r\n        let all_rows: Vec\u003cVec\u003cu32\u003e\u003e = matrix.rows().map(|row| row.collect()).collect();\r\n        assert_eq!(all_rows, vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]);\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":55,"address":[],"length":0,"stats":{"Line":6413125869375586361}},{"line":57,"address":[],"length":0,"stats":{"Line":6413125869375586361}},{"line":58,"address":[],"length":0,"stats":{"Line":6413125869375586361}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":63,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":18374686479671623682}},{"line":73,"address":[],"length":0,"stats":{"Line":10880696699727118405}},{"line":76,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":77,"address":[],"length":0,"stats":{"Line":2882303761517117588}},{"line":81,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":82,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":85,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":86,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":99,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":4755801206503243774}},{"line":160,"address":[],"length":0,"stats":{"Line":4755801206503243774}},{"line":162,"address":[],"length":0,"stats":{"Line":15204152342002794615}},{"line":171,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":176,"address":[],"length":0,"stats":{"Line":8574853690513424431}},{"line":177,"address":[],"length":0,"stats":{"Line":12465963768561533199}},{"line":179,"address":[],"length":0,"stats":{"Line":18014398509481984734}},{"line":190,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":200,"address":[],"length":0,"stats":{"Line":1441151880758558732}},{"line":203,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":204,"address":[],"length":0,"stats":{"Line":1441151880758558853}},{"line":207,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":208,"address":[],"length":0,"stats":{"Line":3170534137668829521}},{"line":209,"address":[],"length":0,"stats":{"Line":3170534137668830532}},{"line":213,"address":[],"length":0,"stats":{"Line":1585267068834414594}},{"line":217,"address":[],"length":0,"stats":{"Line":1585267068834414594}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":2738188573441261599}},{"line":236,"address":[],"length":0,"stats":{"Line":15204152342002794497}},{"line":237,"address":[],"length":0,"stats":{"Line":6269010681299730434}},{"line":238,"address":[],"length":0,"stats":{"Line":9511602413006487553}},{"line":240,"address":[],"length":0,"stats":{"Line":6413125869375586652}},{"line":241,"address":[],"length":0,"stats":{"Line":15204152342002794497}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":11745387828182253569}},{"line":252,"address":[],"length":0,"stats":{"Line":11745387828182253569}},{"line":253,"address":[],"length":0,"stats":{"Line":1080863910568919033}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":2594073385365405731}},{"line":265,"address":[],"length":0,"stats":{"Line":2594073385365405731}},{"line":266,"address":[],"length":0,"stats":{"Line":2594073385365405731}},{"line":268,"address":[],"length":0,"stats":{"Line":2594073385365405731}},{"line":269,"address":[],"length":0,"stats":{"Line":15564440312192435898}},{"line":270,"address":[],"length":0,"stats":{"Line":12970366926827030167}},{"line":271,"address":[],"length":0,"stats":{"Line":12970366926827030167}},{"line":272,"address":[],"length":0,"stats":{"Line":2594073385365408162}},{"line":273,"address":[],"length":0,"stats":{"Line":8070450532247929611}},{"line":274,"address":[],"length":0,"stats":{"Line":8070450532247929611}},{"line":275,"address":[],"length":0,"stats":{"Line":8070450532247929611}},{"line":276,"address":[],"length":0,"stats":{"Line":8070450532247929611}},{"line":277,"address":[],"length":0,"stats":{"Line":8070450532247929611}},{"line":279,"address":[],"length":0,"stats":{"Line":12970366926827030167}}],"covered":62,"coverable":82},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","mul.rs"],"content":"use p3_field::{add_scaled_slice_in_place, Field};\r\nuse p3_maybe_rayon::prelude::*;\r\n\r\nuse crate::dense::RowMajorMatrix;\r\nuse crate::sparse::CsrMatrix;\r\nuse crate::Matrix;\r\n\r\n/// Compute `C = A * B`, where `A` in a CSR matrix and `B` is a dense matrix.\r\n///\r\n/// # Panics\r\n/// Panics if dimensions of input matrices don't match.\r\npub fn mul_csr_dense\u003cF, B\u003e(a: \u0026CsrMatrix\u003cF\u003e, b: \u0026B) -\u003e RowMajorMatrix\u003cF\u003e\r\nwhere\r\n    F: Field,\r\n    B: Matrix\u003cF\u003e + Sync,\r\n{\r\n    assert_eq!(a.width(), b.height(), \"A, B dimensions don't match\");\r\n    let c_width = b.width();\r\n\r\n    let c_values = (0..a.height())\r\n        .into_par_iter()\r\n        .flat_map(|a_row_idx| {\r\n            let mut c_row = F::zero_vec(c_width);\r\n            for \u0026(a_col_idx, a_val) in a.sparse_row(a_row_idx) {\r\n                add_scaled_slice_in_place(\u0026mut c_row, b.row(a_col_idx), a_val);\r\n            }\r\n            c_row\r\n        })\r\n        .collect();\r\n\r\n    RowMajorMatrix::new(c_values, c_width)\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","row_index_mapped.rs"],"content":"use core::ops::Deref;\r\n\r\nuse p3_field::PackedValue;\r\n\r\nuse crate::dense::RowMajorMatrix;\r\nuse crate::Matrix;\r\n\r\n/// A RowIndexMap remaps row indices, and can change the height.\r\npub trait RowIndexMap: Send + Sync {\r\n    fn height(\u0026self) -\u003e usize;\r\n    fn map_row_index(\u0026self, r: usize) -\u003e usize;\r\n\r\n    /// Permutations can optionally provide an optimized method to\r\n    /// convert to dense form.\r\n    fn to_row_major_matrix\u003cT: Clone + Send + Sync, Inner: Matrix\u003cT\u003e\u003e(\r\n        \u0026self,\r\n        inner: Inner,\r\n    ) -\u003e RowMajorMatrix\u003cT\u003e {\r\n        RowMajorMatrix::new(\r\n            (0..self.height())\r\n                .flat_map(|r| inner.row(self.map_row_index(r)))\r\n                .collect(),\r\n            inner.width(),\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Copy, Clone, Debug)]\r\npub struct RowIndexMappedView\u003cIndexMap, Inner\u003e {\r\n    pub index_map: IndexMap,\r\n    pub inner: Inner,\r\n}\r\n\r\nimpl\u003cT: Send + Sync, IndexMap: RowIndexMap, Inner: Matrix\u003cT\u003e\u003e Matrix\u003cT\u003e\r\n    for RowIndexMappedView\u003cIndexMap, Inner\u003e\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.inner.width()\r\n    }\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.index_map.height()\r\n    }\r\n\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        self.inner.get(self.index_map.map_row_index(r), c)\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = Inner::Row\u003c'a\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    // Override these methods so we use the potentially optimized inner methods instead of defaults.\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        self.inner.row(self.index_map.map_row_index(r))\r\n    }\r\n\r\n    fn row_slice(\u0026self, r: usize) -\u003e impl Deref\u003cTarget = [T]\u003e {\r\n        self.inner.row_slice(self.index_map.map_row_index(r))\r\n    }\r\n\r\n    fn to_row_major_matrix(self) -\u003e RowMajorMatrix\u003cT\u003e\r\n    where\r\n        Self: Sized,\r\n        T: Clone,\r\n    {\r\n        // Use Perm's optimized permutation routine, if it has one.\r\n        self.index_map.to_row_major_matrix(self.inner)\r\n    }\r\n\r\n    fn horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e (\r\n        impl Iterator\u003cItem = P\u003e + Send + Sync,\r\n        impl Iterator\u003cItem = T\u003e + Send + Sync,\r\n    )\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + 'a,\r\n    {\r\n        self.inner\r\n            .horizontally_packed_row(self.index_map.map_row_index(r))\r\n    }\r\n\r\n    fn padded_horizontally_packed_row\u003c'a, P\u003e(\r\n        \u0026'a self,\r\n        r: usize,\r\n    ) -\u003e impl Iterator\u003cItem = P\u003e + Send + Sync\r\n    where\r\n        P: PackedValue\u003cValue = T\u003e,\r\n        T: Clone + Default + 'a,\r\n    {\r\n        self.inner\r\n            .padded_horizontally_packed_row(self.index_map.map_row_index(r))\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":20,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":21,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":22,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":23,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":37,"address":[],"length":0,"stats":{"Line":15924728282382073872}},{"line":38,"address":[],"length":0,"stats":{"Line":15924728282382073872}},{"line":40,"address":[],"length":0,"stats":{"Line":17293822569102704643}},{"line":41,"address":[],"length":0,"stats":{"Line":17293822569102704643}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":56,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":59,"address":[],"length":0,"stats":{"Line":2305843009213693988}},{"line":60,"address":[],"length":0,"stats":{"Line":2305843009213693988}},{"line":63,"address":[],"length":0,"stats":{"Line":14771806777775227525}},{"line":69,"address":[],"length":0,"stats":{"Line":14771806777775227525}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":7421932185906577411}},{"line":95,"address":[],"length":0,"stats":{"Line":7421932185906577411}},{"line":96,"address":[],"length":0,"stats":{"Line":7421932185906577411}}],"covered":18,"coverable":23},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","sparse.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::iter;\r\nuse core::ops::Range;\r\n\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Matrix;\r\n\r\n/// A sparse matrix stored in the compressed sparse row format.\r\n#[derive(Debug)]\r\npub struct CsrMatrix\u003cT\u003e {\r\n    width: usize,\r\n\r\n    /// A list of `(col, coefficient)` pairs.\r\n    nonzero_values: Vec\u003c(usize, T)\u003e,\r\n\r\n    /// Indices of `nonzero_values`. The `i`th index here indicates the first index belonging to the\r\n    /// `i`th row.\r\n    row_indices: Vec\u003cusize\u003e,\r\n}\r\n\r\nimpl\u003cT: Clone + Default + Send + Sync\u003e CsrMatrix\u003cT\u003e {\r\n    fn row_index_range(\u0026self, r: usize) -\u003e Range\u003cusize\u003e {\r\n        debug_assert!(r \u003c self.height());\r\n        self.row_indices[r]..self.row_indices[r + 1]\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn sparse_row(\u0026self, r: usize) -\u003e \u0026[(usize, T)] {\r\n        \u0026self.nonzero_values[self.row_index_range(r)]\r\n    }\r\n\r\n    pub fn sparse_row_mut(\u0026mut self, r: usize) -\u003e \u0026mut [(usize, T)] {\r\n        let range = self.row_index_range(r);\r\n        \u0026mut self.nonzero_values[range]\r\n    }\r\n\r\n    pub fn rand_fixed_row_weight\u003cR: Rng\u003e(\r\n        rng: \u0026mut R,\r\n        rows: usize,\r\n        cols: usize,\r\n        row_weight: usize,\r\n    ) -\u003e Self\r\n    where\r\n        T: Default,\r\n        Standard: Distribution\u003cT\u003e,\r\n    {\r\n        let nonzero_values = iter::repeat_with(|| (rng.gen_range(0..cols), rng.gen()))\r\n            .take(rows * row_weight)\r\n            .collect();\r\n        let row_indices = (0..=rows).map(|r| r * row_weight).collect();\r\n        Self {\r\n            width: cols,\r\n            nonzero_values,\r\n            row_indices,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Clone + Default + Send + Sync\u003e Matrix\u003cT\u003e for CsrMatrix\u003cT\u003e {\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.width\r\n    }\r\n\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.row_indices.len() - 1\r\n    }\r\n\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        self.sparse_row(r)\r\n            .iter()\r\n            .find(|(col, _)| *col == c)\r\n            .map(|(_, val)| val.clone())\r\n            .unwrap_or_default()\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = \u003cVec\u003cT\u003e as IntoIterator\u003e::IntoIter\r\n    where\r\n        Self: 'a;\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        let mut row = vec![T::default(); self.width()];\r\n        for (c, v) in self.sparse_row(r) {\r\n            row[*c] = v.clone();\r\n        }\r\n        row.into_iter()\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","stack.rs"],"content":"use core::iter::Chain;\r\nuse core::ops::Deref;\r\n\r\nuse crate::Matrix;\r\n\r\n/// A combination of two matrices, stacked together vertically.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct VerticalPair\u003cFirst, Second\u003e {\r\n    pub first: First,\r\n    pub second: Second,\r\n}\r\n\r\n/// A combination of two matrices, stacked together horizontally.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct HorizontalPair\u003cFirst, Second\u003e {\r\n    pub first: First,\r\n    pub second: Second,\r\n}\r\n\r\nimpl\u003cFirst, Second\u003e VerticalPair\u003cFirst, Second\u003e {\r\n    pub fn new\u003cT\u003e(first: First, second: Second) -\u003e Self\r\n    where\r\n        T: Send + Sync,\r\n        First: Matrix\u003cT\u003e,\r\n        Second: Matrix\u003cT\u003e,\r\n    {\r\n        assert_eq!(first.width(), second.width());\r\n        Self { first, second }\r\n    }\r\n}\r\n\r\nimpl\u003cFirst, Second\u003e HorizontalPair\u003cFirst, Second\u003e {\r\n    pub fn new\u003cT\u003e(first: First, second: Second) -\u003e Self\r\n    where\r\n        T: Send + Sync,\r\n        First: Matrix\u003cT\u003e,\r\n        Second: Matrix\u003cT\u003e,\r\n    {\r\n        assert_eq!(first.height(), second.height());\r\n        Self { first, second }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Send + Sync, First: Matrix\u003cT\u003e, Second: Matrix\u003cT\u003e\u003e Matrix\u003cT\u003e\r\n    for VerticalPair\u003cFirst, Second\u003e\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.first.width()\r\n    }\r\n\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.first.height() + self.second.height()\r\n    }\r\n\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        if r \u003c self.first.height() {\r\n            self.first.get(r, c)\r\n        } else {\r\n            self.second.get(r - self.first.height(), c)\r\n        }\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = EitherRow\u003cFirst::Row\u003c'a\u003e, Second::Row\u003c'a\u003e\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        if r \u003c self.first.height() {\r\n            EitherRow::Left(self.first.row(r))\r\n        } else {\r\n            EitherRow::Right(self.second.row(r - self.first.height()))\r\n        }\r\n    }\r\n\r\n    fn row_slice(\u0026self, r: usize) -\u003e impl Deref\u003cTarget = [T]\u003e {\r\n        if r \u003c self.first.height() {\r\n            EitherRow::Left(self.first.row_slice(r))\r\n        } else {\r\n            EitherRow::Right(self.second.row_slice(r - self.first.height()))\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Send + Sync, First: Matrix\u003cT\u003e, Second: Matrix\u003cT\u003e\u003e Matrix\u003cT\u003e\r\n    for HorizontalPair\u003cFirst, Second\u003e\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.first.width() + self.second.width()\r\n    }\r\n\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.first.height()\r\n    }\r\n\r\n    fn get(\u0026self, r: usize, c: usize) -\u003e T {\r\n        if c \u003c self.first.width() {\r\n            self.first.get(r, c)\r\n        } else {\r\n            self.second.get(r, c - self.first.width())\r\n        }\r\n    }\r\n\r\n    type Row\u003c'a\u003e\r\n        = Chain\u003cFirst::Row\u003c'a\u003e, Second::Row\u003c'a\u003e\u003e\r\n    where\r\n        Self: 'a;\r\n\r\n    fn row(\u0026self, r: usize) -\u003e Self::Row\u003c'_\u003e {\r\n        self.first.row(r).chain(self.second.row(r))\r\n    }\r\n}\r\n\r\n/// We use this to wrap both the row iterator and the row slice.\r\n#[derive(Debug)]\r\npub enum EitherRow\u003cL, R\u003e {\r\n    Left(L),\r\n    Right(R),\r\n}\r\n\r\nimpl\u003cT, L, R\u003e Iterator for EitherRow\u003cL, R\u003e\r\nwhere\r\n    L: Iterator\u003cItem = T\u003e,\r\n    R: Iterator\u003cItem = T\u003e,\r\n{\r\n    type Item = T;\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        match self {\r\n            EitherRow::Left(l) =\u003e l.next(),\r\n            EitherRow::Right(r) =\u003e r.next(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT, L, R\u003e Deref for EitherRow\u003cL, R\u003e\r\nwhere\r\n    L: Deref\u003cTarget = [T]\u003e,\r\n    R: Deref\u003cTarget = [T]\u003e,\r\n{\r\n    type Target = [T];\r\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\r\n        match self {\r\n            EitherRow::Left(l) =\u003e l,\r\n            EitherRow::Right(r) =\u003e r,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":11240984669916758020}},{"line":27,"address":[],"length":0,"stats":{"Line":11240984669916758020}},{"line":33,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":39,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4035225266123964423}},{"line":77,"address":[],"length":0,"stats":{"Line":4035225266123964423}},{"line":78,"address":[],"length":0,"stats":{"Line":11240984669916758031}},{"line":80,"address":[],"length":0,"stats":{"Line":1369094286720630783}},{"line":88,"address":[],"length":0,"stats":{"Line":2882303761517117441}},{"line":89,"address":[],"length":0,"stats":{"Line":2882303761517117441}},{"line":92,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":93,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":110,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":17726168133330272349}},{"line":143,"address":[],"length":0,"stats":{"Line":17726168133330272349}},{"line":144,"address":[],"length":0,"stats":{"Line":1369094286720630783}},{"line":145,"address":[],"length":0,"stats":{"Line":14339461213547659866}}],"covered":18,"coverable":38},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","strided.rs"],"content":"use crate::row_index_mapped::{RowIndexMap, RowIndexMappedView};\r\nuse crate::Matrix;\r\n\r\n#[derive(Debug)]\r\npub struct VerticallyStridedRowIndexMap {\r\n    // Store our height\r\n    height: usize,\r\n    stride: usize,\r\n    offset: usize,\r\n}\r\n\r\npub type VerticallyStridedMatrixView\u003cInner\u003e =\r\n    RowIndexMappedView\u003cVerticallyStridedRowIndexMap, Inner\u003e;\r\n\r\nimpl VerticallyStridedRowIndexMap {\r\n    pub fn new_view\u003cT: Send + Sync, Inner: Matrix\u003cT\u003e\u003e(\r\n        inner: Inner,\r\n        stride: usize,\r\n        offset: usize,\r\n    ) -\u003e VerticallyStridedMatrixView\u003cInner\u003e {\r\n        let h = inner.height();\r\n        let full_strides = h / stride;\r\n        let remainder = h % stride;\r\n        let final_stride = offset \u003c remainder;\r\n        let height = full_strides + final_stride as usize;\r\n        RowIndexMappedView {\r\n            index_map: Self {\r\n                height,\r\n                stride,\r\n                offset,\r\n            },\r\n            inner,\r\n        }\r\n    }\r\n}\r\n\r\nimpl RowIndexMap for VerticallyStridedRowIndexMap {\r\n    fn height(\u0026self) -\u003e usize {\r\n        self.height\r\n    }\r\n    fn map_row_index(\u0026self, r: usize) -\u003e usize {\r\n        r * self.stride + self.offset\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":21,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":22,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":23,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":24,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":25,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":27,"address":[],"length":0,"stats":{"Line":1585267068834415189}},{"line":38,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":39,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":41,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":42,"address":[],"length":0,"stats":{"Line":648518346341351424}}],"covered":11,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","matrix","src","util.rs"],"content":"use core::borrow::BorrowMut;\r\n\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_strict_usize, reverse_bits_len};\r\nuse tracing::instrument;\r\n\r\nuse crate::dense::{DenseMatrix, DenseStorage, RowMajorMatrix};\r\nuse crate::Matrix;\r\n\r\n#[instrument(level = \"debug\", skip_all)]\r\npub fn reverse_matrix_index_bits\u003c'a, F, S\u003e(mat: \u0026mut DenseMatrix\u003cF, S\u003e)\r\nwhere\r\n    F: Clone + Send + Sync + 'a,\r\n    S: DenseStorage\u003cF\u003e + BorrowMut\u003c[F]\u003e,\r\n{\r\n    let w = mat.width();\r\n    let h = mat.height();\r\n    let log_h = log2_strict_usize(h);\r\n    let values = mat.values.borrow_mut().as_mut_ptr() as usize;\r\n\r\n    (0..h).into_par_iter().for_each(|i| {\r\n        let values = values as *mut F;\r\n        let j = reverse_bits_len(i, log_h);\r\n        if i \u003c j {\r\n            unsafe { swap_rows_raw(values, w, i, j) };\r\n        }\r\n    });\r\n}\r\n\r\n/// Assumes `i \u003c j`.\r\npub fn swap_rows\u003cF: Clone + Send + Sync\u003e(mat: \u0026mut RowMajorMatrix\u003cF\u003e, i: usize, j: usize) {\r\n    let w = mat.width();\r\n    let (upper, lower) = mat.values.split_at_mut(j * w);\r\n    let row_i = \u0026mut upper[i * w..(i + 1) * w];\r\n    let row_j = \u0026mut lower[..w];\r\n    row_i.swap_with_slice(row_j);\r\n}\r\n\r\n/// Assumes `i \u003c j`.\r\n///\r\n/// SAFETY: The caller must ensure `i \u003c j \u003c h`, where `h` is the height of the matrix.\r\npub(crate) unsafe fn swap_rows_raw\u003cF\u003e(mat: *mut F, w: usize, i: usize, j: usize) {\r\n    let row_i = core::slice::from_raw_parts_mut(mat.add(i * w), w);\r\n    let row_j = core::slice::from_raw_parts_mut(mat.add(j * w), w);\r\n    row_i.swap_with_slice(row_j);\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":3170534137668829926}},{"line":22,"address":[],"length":0,"stats":{"Line":3170534137668829926}},{"line":23,"address":[],"length":0,"stats":{"Line":3170534137668829926}},{"line":24,"address":[],"length":0,"stats":{"Line":17870283321406130088}},{"line":25,"address":[],"length":0,"stats":{"Line":14699749183737300162}},{"line":31,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":32,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":33,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":34,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":35,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":36,"address":[],"length":0,"stats":{"Line":16429131440647569416}},{"line":42,"address":[],"length":0,"stats":{"Line":16933534598913065093}},{"line":43,"address":[],"length":0,"stats":{"Line":16933534598913065093}},{"line":44,"address":[],"length":0,"stats":{"Line":16933534598913065093}},{"line":45,"address":[],"length":0,"stats":{"Line":16933534598913065093}}],"covered":15,"coverable":19},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","maybe-rayon","src","lib.rs"],"content":"#[cfg(feature = \"parallel\")]\r\npub mod prelude {\r\n    pub use rayon::prelude::*;\r\n    pub use rayon::{current_num_threads, join};\r\n\r\n    pub trait SharedExt: ParallelIterator {\r\n        fn par_fold_reduce\u003cAcc, Id, F, R\u003e(self, identity: Id, fold_op: F, reduce_op: R) -\u003e Acc\r\n        where\r\n            Acc: Send,\r\n            Id: Fn() -\u003e Acc + Sync + Send,\r\n            F: Fn(Acc, Self::Item) -\u003e Acc + Sync + Send,\r\n            R: Fn(Acc, Acc) -\u003e Acc + Sync + Send;\r\n    }\r\n\r\n    impl\u003cI: ParallelIterator\u003e SharedExt for I {\r\n        #[inline]\r\n        fn par_fold_reduce\u003cAcc, Id, F, R\u003e(self, identity: Id, fold_op: F, reduce_op: R) -\u003e Acc\r\n        where\r\n            Acc: Send,\r\n            Id: Fn() -\u003e Acc + Sync + Send,\r\n            F: Fn(Acc, Self::Item) -\u003e Acc + Sync + Send,\r\n            R: Fn(Acc, Acc) -\u003e Acc + Sync + Send,\r\n        {\r\n            self.fold(\u0026identity, fold_op).reduce(\u0026identity, reduce_op)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(feature = \"parallel\")]\r\npub mod iter {\r\n    pub use rayon::iter::repeat;\r\n}\r\n\r\n#[cfg(not(feature = \"parallel\"))]\r\nmod serial;\r\n\r\n#[cfg(not(feature = \"parallel\"))]\r\npub mod prelude {\r\n    pub use core::iter::{\r\n        ExactSizeIterator as IndexedParallelIterator, Iterator as ParallelIterator,\r\n    };\r\n\r\n    pub use super::serial::*;\r\n\r\n    pub trait SharedExt: ParallelIterator {\r\n        fn par_fold_reduce\u003cAcc, Id, F, R\u003e(self, identity: Id, fold_op: F, reduce_op: R) -\u003e Acc\r\n        where\r\n            Acc: Send,\r\n            Id: Fn() -\u003e Acc + Sync + Send,\r\n            F: Fn(Acc, Self::Item) -\u003e Acc + Sync + Send,\r\n            R: Fn(Acc, Acc) -\u003e Acc + Sync + Send;\r\n    }\r\n\r\n    impl\u003cI: ParallelIterator\u003e SharedExt for I {\r\n        #[inline]\r\n        fn par_fold_reduce\u003cAcc, Id, F, R\u003e(self, identity: Id, fold_op: F, _reduce_op: R) -\u003e Acc\r\n        where\r\n            Acc: Send,\r\n            Id: Fn() -\u003e Acc + Sync + Send,\r\n            F: Fn(Acc, Self::Item) -\u003e Acc + Sync + Send,\r\n            R: Fn(Acc, Acc) -\u003e Acc + Sync + Send,\r\n        {\r\n            self.fold(identity(), fold_op)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(not(feature = \"parallel\"))]\r\npub mod iter {\r\n    pub use core::iter::repeat;\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":2738188573441265662}},{"line":63,"address":[],"length":0,"stats":{"Line":2738188573441265662}}],"covered":2,"coverable":3},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","maybe-rayon","src","serial.rs"],"content":"use core::iter::FlatMap;\r\nuse core::slice::{\r\n    Chunks, ChunksExact, ChunksExactMut, ChunksMut, RChunks, RChunksExact, RChunksExactMut,\r\n    RChunksMut, Split, SplitMut, Windows,\r\n};\r\n\r\npub trait IntoParallelIterator {\r\n    type Iter: Iterator\u003cItem = Self::Item\u003e;\r\n    type Item: Send;\r\n\r\n    fn into_par_iter(self) -\u003e Self::Iter;\r\n}\r\nimpl\u003cT: IntoIterator\u003e IntoParallelIterator for T\r\nwhere\r\n    T::Item: Send,\r\n{\r\n    type Iter = T::IntoIter;\r\n    type Item = T::Item;\r\n\r\n    fn into_par_iter(self) -\u003e Self::Iter {\r\n        self.into_iter()\r\n    }\r\n}\r\n\r\npub trait IntoParallelRefIterator\u003c'data\u003e {\r\n    type Iter: Iterator\u003cItem = Self::Item\u003e;\r\n    type Item: Send + 'data;\r\n\r\n    fn par_iter(\u0026'data self) -\u003e Self::Iter;\r\n}\r\n\r\nimpl\u003c'data, I: 'data + ?Sized\u003e IntoParallelRefIterator\u003c'data\u003e for I\r\nwhere\r\n    \u0026'data I: IntoParallelIterator,\r\n{\r\n    type Iter = \u003c\u0026'data I as IntoParallelIterator\u003e::Iter;\r\n    type Item = \u003c\u0026'data I as IntoParallelIterator\u003e::Item;\r\n\r\n    fn par_iter(\u0026'data self) -\u003e Self::Iter {\r\n        self.into_par_iter()\r\n    }\r\n}\r\n\r\npub trait IntoParallelRefMutIterator\u003c'data\u003e {\r\n    type Iter: Iterator\u003cItem = Self::Item\u003e;\r\n    type Item: Send + 'data;\r\n\r\n    fn par_iter_mut(\u0026'data mut self) -\u003e Self::Iter;\r\n}\r\n\r\nimpl\u003c'data, I: 'data + ?Sized\u003e IntoParallelRefMutIterator\u003c'data\u003e for I\r\nwhere\r\n    \u0026'data mut I: IntoParallelIterator,\r\n{\r\n    type Iter = \u003c\u0026'data mut I as IntoParallelIterator\u003e::Iter;\r\n    type Item = \u003c\u0026'data mut I as IntoParallelIterator\u003e::Item;\r\n\r\n    fn par_iter_mut(\u0026'data mut self) -\u003e Self::Iter {\r\n        self.into_par_iter()\r\n    }\r\n}\r\n\r\npub trait ParallelSlice\u003cT: Sync\u003e {\r\n    /// Returns a plain slice, which is used to implement the rest of the\r\n    /// parallel methods.\r\n    fn as_parallel_slice(\u0026self) -\u003e \u0026[T];\r\n\r\n    fn par_split\u003cP\u003e(\u0026self, separator: P) -\u003e Split\u003c'_, T, P\u003e\r\n    where\r\n        P: Fn(\u0026T) -\u003e bool + Sync + Send,\r\n    {\r\n        self.as_parallel_slice().split(separator)\r\n    }\r\n\r\n    fn par_windows(\u0026self, window_size: usize) -\u003e Windows\u003c'_, T\u003e {\r\n        self.as_parallel_slice().windows(window_size)\r\n    }\r\n\r\n    fn par_chunks(\u0026self, chunk_size: usize) -\u003e Chunks\u003c'_, T\u003e {\r\n        self.as_parallel_slice().chunks(chunk_size)\r\n    }\r\n\r\n    fn par_chunks_exact(\u0026self, chunk_size: usize) -\u003e ChunksExact\u003c'_, T\u003e {\r\n        self.as_parallel_slice().chunks_exact(chunk_size)\r\n    }\r\n\r\n    fn par_rchunks(\u0026self, chunk_size: usize) -\u003e RChunks\u003c'_, T\u003e {\r\n        self.as_parallel_slice().rchunks(chunk_size)\r\n    }\r\n\r\n    fn par_rchunks_exact(\u0026self, chunk_size: usize) -\u003e RChunksExact\u003c'_, T\u003e {\r\n        self.as_parallel_slice().rchunks_exact(chunk_size)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Sync\u003e ParallelSlice\u003cT\u003e for [T] {\r\n    #[inline]\r\n    fn as_parallel_slice(\u0026self) -\u003e \u0026[T] {\r\n        self\r\n    }\r\n}\r\n\r\npub trait ParallelSliceMut\u003cT: Send\u003e {\r\n    /// Returns a plain mutable slice, which is used to implement the rest of\r\n    /// the parallel methods.\r\n    fn as_parallel_slice_mut(\u0026mut self) -\u003e \u0026mut [T];\r\n\r\n    fn par_split_mut\u003cP\u003e(\u0026mut self, separator: P) -\u003e SplitMut\u003c'_, T, P\u003e\r\n    where\r\n        P: Fn(\u0026T) -\u003e bool + Sync + Send,\r\n    {\r\n        self.as_parallel_slice_mut().split_mut(separator)\r\n    }\r\n\r\n    fn par_chunks_mut(\u0026mut self, chunk_size: usize) -\u003e ChunksMut\u003c'_, T\u003e {\r\n        self.as_parallel_slice_mut().chunks_mut(chunk_size)\r\n    }\r\n\r\n    fn par_chunks_exact_mut(\u0026mut self, chunk_size: usize) -\u003e ChunksExactMut\u003c'_, T\u003e {\r\n        self.as_parallel_slice_mut().chunks_exact_mut(chunk_size)\r\n    }\r\n\r\n    fn par_rchunks_mut(\u0026mut self, chunk_size: usize) -\u003e RChunksMut\u003c'_, T\u003e {\r\n        self.as_parallel_slice_mut().rchunks_mut(chunk_size)\r\n    }\r\n\r\n    fn par_rchunks_exact_mut(\u0026mut self, chunk_size: usize) -\u003e RChunksExactMut\u003c'_, T\u003e {\r\n        self.as_parallel_slice_mut().rchunks_exact_mut(chunk_size)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Send\u003e ParallelSliceMut\u003cT\u003e for [T] {\r\n    #[inline]\r\n    fn as_parallel_slice_mut(\u0026mut self) -\u003e \u0026mut [T] {\r\n        self\r\n    }\r\n}\r\n\r\npub trait ParIterExt: Iterator {\r\n    fn find_any\u003cP\u003e(self, predicate: P) -\u003e Option\u003cSelf::Item\u003e\r\n    where\r\n        P: Fn(\u0026Self::Item) -\u003e bool + Sync + Send;\r\n\r\n    fn flat_map_iter\u003cU, F\u003e(self, map_op: F) -\u003e FlatMap\u003cSelf, U, F\u003e\r\n    where\r\n        Self: Sized,\r\n        U: IntoIterator,\r\n        F: Fn(Self::Item) -\u003e U;\r\n}\r\n\r\nimpl\u003cT: Iterator\u003e ParIterExt for T {\r\n    fn find_any\u003cP\u003e(mut self, predicate: P) -\u003e Option\u003cSelf::Item\u003e\r\n    where\r\n        P: Fn(\u0026Self::Item) -\u003e bool + Sync + Send,\r\n    {\r\n        self.find(predicate)\r\n    }\r\n\r\n    fn flat_map_iter\u003cU, F\u003e(self, map_op: F) -\u003e FlatMap\u003cSelf, U, F\u003e\r\n    where\r\n        Self: Sized,\r\n        U: IntoIterator,\r\n        F: Fn(Self::Item) -\u003e U,\r\n    {\r\n        self.flat_map(map_op)\r\n    }\r\n}\r\n\r\npub fn join\u003cA, B, RA, RB\u003e(oper_a: A, oper_b: B) -\u003e (RA, RB)\r\nwhere\r\n    A: FnOnce() -\u003e RA,\r\n    B: FnOnce() -\u003e RB,\r\n{\r\n    let result_a = oper_a();\r\n    let result_b = oper_b();\r\n    (result_a, result_b)\r\n}\r\n\r\npub fn current_num_threads() -\u003e usize {\r\n    1\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":10088063165309926162}},{"line":21,"address":[],"length":0,"stats":{"Line":10088063165309926162}},{"line":39,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":40,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":58,"address":[],"length":0,"stats":{"Line":1513209474796486657}},{"line":59,"address":[],"length":0,"stats":{"Line":1513209474796486657}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":9007199254740992063}},{"line":80,"address":[],"length":0,"stats":{"Line":9007199254740992063}},{"line":83,"address":[],"length":0,"stats":{"Line":15348267530078650413}},{"line":84,"address":[],"length":0,"stats":{"Line":15348267530078650413}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":15708555500268290046}},{"line":99,"address":[],"length":0,"stats":{"Line":15708555500268290046}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":15636497906230362110}},{"line":116,"address":[],"length":0,"stats":{"Line":15636497906230362110}},{"line":119,"address":[],"length":0,"stats":{"Line":17293822569102704666}},{"line":120,"address":[],"length":0,"stats":{"Line":17293822569102704666}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":1585267068834414588}},{"line":135,"address":[],"length":0,"stats":{"Line":1585267068834414588}},{"line":152,"address":[],"length":0,"stats":{"Line":8142508126285856768}},{"line":156,"address":[],"length":0,"stats":{"Line":8142508126285856768}},{"line":159,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":165,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":180,"address":[],"length":0,"stats":{"Line":6701356245527298048}}],"covered":24,"coverable":42},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","benches","mds.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::{BabyBear, MdsMatrixBabyBear};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_goldilocks::{Goldilocks, MdsMatrixGoldilocks};\r\nuse p3_mds::coset_mds::CosetMds;\r\nuse p3_mds::integrated_coset_mds::IntegratedCosetMds;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::{MdsMatrixMersenne31, Mersenne31};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{thread_rng, Rng};\r\n\r\nfn bench_all_mds(c: \u0026mut Criterion) {\r\n    bench_mds::\u003cBabyBear, IntegratedCosetMds\u003cBabyBear, 16\u003e, 16\u003e(c);\r\n    bench_mds::\u003c\u003cBabyBear as Field\u003e::Packing, IntegratedCosetMds\u003cBabyBear, 16\u003e, 16\u003e(c);\r\n    bench_mds::\u003cBabyBear, CosetMds\u003cBabyBear, 16\u003e, 16\u003e(c);\r\n    bench_mds::\u003c\u003cBabyBear as Field\u003e::Packing, CosetMds\u003cBabyBear, 16\u003e, 16\u003e(c);\r\n\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 8\u003e(c);\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 12\u003e(c);\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 16\u003e(c);\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 24\u003e(c);\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 32\u003e(c);\r\n    bench_mds::\u003cBabyBear, MdsMatrixBabyBear, 64\u003e(c);\r\n\r\n    bench_mds::\u003cGoldilocks, MdsMatrixGoldilocks, 8\u003e(c);\r\n    bench_mds::\u003cGoldilocks, MdsMatrixGoldilocks, 12\u003e(c);\r\n    bench_mds::\u003cGoldilocks, MdsMatrixGoldilocks, 16\u003e(c);\r\n    bench_mds::\u003cGoldilocks, MdsMatrixGoldilocks, 32\u003e(c);\r\n    bench_mds::\u003cGoldilocks, MdsMatrixGoldilocks, 64\u003e(c);\r\n\r\n    bench_mds::\u003cMersenne31, MdsMatrixMersenne31, 8\u003e(c);\r\n    bench_mds::\u003cMersenne31, MdsMatrixMersenne31, 12\u003e(c);\r\n    bench_mds::\u003cMersenne31, MdsMatrixMersenne31, 16\u003e(c);\r\n    bench_mds::\u003cMersenne31, MdsMatrixMersenne31, 32\u003e(c);\r\n    bench_mds::\u003cMersenne31, MdsMatrixMersenne31, 64\u003e(c);\r\n}\r\n\r\nfn bench_mds\u003cR, Mds, const WIDTH: usize\u003e(c: \u0026mut Criterion)\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n    Standard: Distribution\u003cR\u003e,\r\n    Mds: MdsPermutation\u003cR, WIDTH\u003e + Default,\r\n{\r\n    let mds = Mds::default();\r\n\r\n    let mut rng = thread_rng();\r\n    let input = rng.gen::\u003c[R; WIDTH]\u003e();\r\n    let id = BenchmarkId::new(type_name::\u003cMds\u003e(), WIDTH);\r\n    c.bench_with_input(id, \u0026input, |b, input| b.iter(|| mds.permute(input.clone())));\r\n}\r\n\r\ncriterion_group!(benches, bench_all_mds);\r\ncriterion_main!(benches);\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","butterflies.rs"],"content":"use p3_field::{Algebra, Field};\r\n\r\n/// DIT butterfly.\r\n#[inline]\r\npub(crate) fn dit_butterfly\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    idx_1: usize,\r\n    idx_2: usize,\r\n    twiddle: F,\r\n) {\r\n    let val_1 = values[idx_1].clone();\r\n    let val_2 = values[idx_2].clone() * twiddle;\r\n    values[idx_1] = val_1.clone() + val_2.clone();\r\n    values[idx_2] = val_1 - val_2;\r\n}\r\n\r\n/// DIF butterfly.\r\n#[inline]\r\npub(crate) fn dif_butterfly\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    idx_1: usize,\r\n    idx_2: usize,\r\n    twiddle: F,\r\n) {\r\n    let val_1 = values[idx_1].clone();\r\n    let val_2 = values[idx_2].clone();\r\n    values[idx_1] = val_1.clone() + val_2.clone();\r\n    values[idx_2] = (val_1 - val_2) * twiddle;\r\n}\r\n\r\n/// Butterfly with twiddle factor 1 (works in either DIT or DIF).\r\n#[inline]\r\npub(crate) fn twiddle_free_butterfly\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    idx_1: usize,\r\n    idx_2: usize,\r\n) {\r\n    let val_1 = values[idx_1].clone();\r\n    let val_2 = values[idx_2].clone();\r\n    values[idx_1] = val_1.clone() + val_2.clone();\r\n    values[idx_2] = val_1 - val_2;\r\n}\r\n","traces":[{"line":5,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":11,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":12,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":13,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":14,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":19,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":25,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":26,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":27,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":28,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":33,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":38,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":39,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":40,"address":[],"length":0,"stats":{"Line":2089670227099910144}},{"line":41,"address":[],"length":0,"stats":{"Line":2089670227099910144}}],"covered":15,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","coset_mds.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::{Algebra, Field, TwoAdicField};\r\nuse p3_symmetric::Permutation;\r\nuse p3_util::{log2_strict_usize, reverse_slice_index_bits};\r\n\r\nuse crate::butterflies::{dif_butterfly, dit_butterfly, twiddle_free_butterfly};\r\nuse crate::MdsPermutation;\r\n\r\n/// A Reed-Solomon based MDS permutation.\r\n///\r\n/// An MDS permutation which works by interpreting the input as evaluations of a polynomial over a\r\n/// power-of-two subgroup, and computing evaluations over a coset of that subgroup. This can be\r\n/// viewed as returning the parity elements of a systematic Reed-Solomon code. Since Reed-Solomon\r\n/// codes are MDS, this is an MDS permutation.\r\n#[derive(Clone, Debug)]\r\npub struct CosetMds\u003cF, const N: usize\u003e {\r\n    fft_twiddles: Vec\u003cF\u003e,\r\n    ifft_twiddles: Vec\u003cF\u003e,\r\n    weights: [F; N],\r\n}\r\n\r\nimpl\u003cF, const N: usize\u003e Default for CosetMds\u003cF, N\u003e\r\nwhere\r\n    F: TwoAdicField,\r\n{\r\n    fn default() -\u003e Self {\r\n        let log_n = log2_strict_usize(N);\r\n\r\n        let root = F::two_adic_generator(log_n);\r\n        let root_inv = root.inverse();\r\n        let mut fft_twiddles: Vec\u003cF\u003e = root.powers().take(N / 2).collect();\r\n        let mut ifft_twiddles: Vec\u003cF\u003e = root_inv.powers().take(N / 2).collect();\r\n        reverse_slice_index_bits(\u0026mut fft_twiddles);\r\n        reverse_slice_index_bits(\u0026mut ifft_twiddles);\r\n\r\n        let shift = F::GENERATOR;\r\n        let mut weights: [F; N] = shift\r\n            .powers()\r\n            .take(N)\r\n            .collect::\u003cVec\u003c_\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n        reverse_slice_index_bits(\u0026mut weights);\r\n        Self {\r\n            fft_twiddles,\r\n            ifft_twiddles,\r\n            weights,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: TwoAdicField, A: Algebra\u003cF\u003e, const N: usize\u003e Permutation\u003c[A; N]\u003e for CosetMds\u003cF, N\u003e {\r\n    fn permute(\u0026self, mut input: [A; N]) -\u003e [A; N] {\r\n        self.permute_mut(\u0026mut input);\r\n        input\r\n    }\r\n\r\n    fn permute_mut(\u0026self, values: \u0026mut [A; N]) {\r\n        // Inverse DFT, except we skip bit reversal and rescaling by 1/N.\r\n        bowers_g_t(values, \u0026self.ifft_twiddles);\r\n\r\n        // Multiply by powers of the coset shift (see default coset LDE impl for an explanation)\r\n        for (value, weight) in values.iter_mut().zip(self.weights) {\r\n            *value = value.clone() * weight;\r\n        }\r\n\r\n        // DFT, assuming bit-reversed input.\r\n        bowers_g(values, \u0026self.fft_twiddles);\r\n    }\r\n}\r\n\r\nimpl\u003cF: TwoAdicField, A: Algebra\u003cF\u003e, const N: usize\u003e MdsPermutation\u003cA, N\u003e for CosetMds\u003cF, N\u003e {}\r\n\r\n/// Executes the Bowers G network. This is like a DFT, except it assumes the input is in\r\n/// bit-reversed order.\r\n#[inline]\r\nfn bowers_g\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(values: \u0026mut [A; N], twiddles: \u0026[F]) {\r\n    let log_n = log2_strict_usize(N);\r\n    for log_half_block_size in 0..log_n {\r\n        bowers_g_layer(values, log_half_block_size, twiddles);\r\n    }\r\n}\r\n\r\n/// Executes the Bowers G^T network. This is like an inverse DFT, except we skip rescaling by\r\n/// `1/N`, and the output is bit-reversed.\r\n#[inline]\r\nfn bowers_g_t\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(values: \u0026mut [A; N], twiddles: \u0026[F]) {\r\n    let log_n = log2_strict_usize(N);\r\n    for log_half_block_size in (0..log_n).rev() {\r\n        bowers_g_t_layer(values, log_half_block_size, twiddles);\r\n    }\r\n}\r\n\r\n/// One layer of a Bowers G network. Equivalent to `bowers_g_t_layer` except for the butterfly.\r\n#[inline]\r\nfn bowers_g_layer\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    log_half_block_size: usize,\r\n    twiddles: \u0026[F],\r\n) {\r\n    let log_block_size = log_half_block_size + 1;\r\n    let half_block_size = 1 \u003c\u003c log_half_block_size;\r\n    let num_blocks = N \u003e\u003e log_block_size;\r\n\r\n    // Unroll first iteration with a twiddle factor of 1.\r\n    for hi in 0..half_block_size {\r\n        let lo = hi + half_block_size;\r\n        twiddle_free_butterfly(values, hi, lo);\r\n    }\r\n\r\n    for (block, \u0026twiddle) in (1..num_blocks).zip(\u0026twiddles[1..]) {\r\n        let block_start = block \u003c\u003c log_block_size;\r\n        for hi in block_start..block_start + half_block_size {\r\n            let lo = hi + half_block_size;\r\n            dif_butterfly(values, hi, lo, twiddle);\r\n        }\r\n    }\r\n}\r\n\r\n/// One layer of a Bowers G^T network. Equivalent to `bowers_g_layer` except for the butterfly.\r\n#[inline]\r\nfn bowers_g_t_layer\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    log_half_block_size: usize,\r\n    twiddles: \u0026[F],\r\n) {\r\n    let log_block_size = log_half_block_size + 1;\r\n    let half_block_size = 1 \u003c\u003c log_half_block_size;\r\n    let num_blocks = N \u003e\u003e log_block_size;\r\n\r\n    // Unroll first iteration with a twiddle factor of 1.\r\n    for hi in 0..half_block_size {\r\n        let lo = hi + half_block_size;\r\n        twiddle_free_butterfly(values, hi, lo);\r\n    }\r\n\r\n    for (block, \u0026twiddle) in (1..num_blocks).zip(\u0026twiddles[1..]) {\r\n        let block_start = block \u003c\u003c log_block_size;\r\n        for hi in block_start..block_start + half_block_size {\r\n            let lo = hi + half_block_size;\r\n            dit_butterfly(values, hi, lo, twiddle);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_dft::{NaiveDft, TwoAdicSubgroupDft};\r\n    use p3_field::{Field, PrimeCharacteristicRing};\r\n    use p3_symmetric::Permutation;\r\n    use rand::{thread_rng, Rng};\r\n\r\n    use crate::coset_mds::CosetMds;\r\n\r\n    #[test]\r\n    fn matches_naive() {\r\n        type F = BabyBear;\r\n        const N: usize = 8;\r\n\r\n        let mut rng = thread_rng();\r\n        let mut arr: [F; N] = rng.gen();\r\n\r\n        let shift = F::GENERATOR;\r\n        let mut coset_lde_naive = NaiveDft.coset_lde(arr.to_vec(), 0, shift);\r\n        coset_lde_naive\r\n            .iter_mut()\r\n            .for_each(|x| *x *= F::from_u8(N as u8));\r\n        CosetMds::default().permute_mut(\u0026mut arr);\r\n        assert_eq!(coset_lde_naive, arr);\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":35,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":64,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":65,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":69,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":78,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":80,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":90,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":91,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":97,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":102,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":107,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":108,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":109,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":112,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":115,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":116,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":123,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":128,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":129,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":130,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":133,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":134,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":135,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":138,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":139,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":141,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":142,"address":[],"length":0,"stats":{"Line":360287970189639680}}],"covered":49,"coverable":52},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","integrated_coset_mds.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::{Algebra, Field, Powers, TwoAdicField};\r\nuse p3_symmetric::Permutation;\r\nuse p3_util::{log2_strict_usize, reverse_slice_index_bits};\r\n\r\nuse crate::butterflies::{dif_butterfly, dit_butterfly, twiddle_free_butterfly};\r\nuse crate::MdsPermutation;\r\n\r\n/// Like `CosetMds`, with a few differences:\r\n/// - (Bit reversed, a la Bowers) DIF + DIT rather than DIT + DIF\r\n/// - We skip bit reversals of the inputs and outputs\r\n/// - We don't weight by `1/N`, since this doesn't affect the MDS property\r\n/// - We integrate the coset shifts into the DIF's twiddle factors\r\n#[derive(Clone, Debug)]\r\npub struct IntegratedCosetMds\u003cF, const N: usize\u003e {\r\n    ifft_twiddles: Vec\u003cF\u003e,\r\n    fft_twiddles: Vec\u003cVec\u003cF\u003e\u003e,\r\n}\r\n\r\nimpl\u003cF: TwoAdicField, const N: usize\u003e Default for IntegratedCosetMds\u003cF, N\u003e {\r\n    fn default() -\u003e Self {\r\n        let log_n = log2_strict_usize(N);\r\n        let root = F::two_adic_generator(log_n);\r\n        let root_inv = root.inverse();\r\n        let coset_shift = F::GENERATOR;\r\n\r\n        let mut ifft_twiddles: Vec\u003cF\u003e = root_inv.powers().take(N / 2).collect();\r\n        reverse_slice_index_bits(\u0026mut ifft_twiddles);\r\n\r\n        let fft_twiddles: Vec\u003cVec\u003cF\u003e\u003e = (0..log_n)\r\n            .map(|layer| {\r\n                let shift_power = coset_shift.exp_power_of_2(layer);\r\n                let powers = Powers {\r\n                    base: root.exp_power_of_2(layer),\r\n                    current: shift_power,\r\n                };\r\n                let mut twiddles: Vec\u003c_\u003e = powers.take(N \u003e\u003e (layer + 1)).collect();\r\n                reverse_slice_index_bits(\u0026mut twiddles);\r\n                twiddles\r\n            })\r\n            .collect();\r\n\r\n        Self {\r\n            ifft_twiddles,\r\n            fft_twiddles,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e Permutation\u003c[A; N]\u003e for IntegratedCosetMds\u003cF, N\u003e {\r\n    fn permute(\u0026self, mut input: [A; N]) -\u003e [A; N] {\r\n        self.permute_mut(\u0026mut input);\r\n        input\r\n    }\r\n\r\n    fn permute_mut(\u0026self, values: \u0026mut [A; N]) {\r\n        let log_n = log2_strict_usize(N);\r\n\r\n        // Bit-reversed DIF, aka Bowers G\r\n        for layer in 0..log_n {\r\n            bowers_g_layer(values, layer, \u0026self.ifft_twiddles);\r\n        }\r\n\r\n        // Bit-reversed DIT, aka Bowers G^T\r\n        for layer in (0..log_n).rev() {\r\n            bowers_g_t_layer(values, layer, \u0026self.fft_twiddles[layer]);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e MdsPermutation\u003cA, N\u003e for IntegratedCosetMds\u003cF, N\u003e {}\r\n\r\n#[inline]\r\nfn bowers_g_layer\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    log_half_block_size: usize,\r\n    twiddles: \u0026[F],\r\n) {\r\n    let log_block_size = log_half_block_size + 1;\r\n    let half_block_size = 1 \u003c\u003c log_half_block_size;\r\n    let num_blocks = N \u003e\u003e log_block_size;\r\n\r\n    // Unroll first iteration with a twiddle factor of 1.\r\n    for hi in 0..half_block_size {\r\n        let lo = hi + half_block_size;\r\n        twiddle_free_butterfly(values, hi, lo);\r\n    }\r\n\r\n    for (block, \u0026twiddle) in (1..num_blocks).zip(\u0026twiddles[1..]) {\r\n        let block_start = block \u003c\u003c log_block_size;\r\n        for hi in block_start..block_start + half_block_size {\r\n            let lo = hi + half_block_size;\r\n            dif_butterfly(values, hi, lo, twiddle);\r\n        }\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn bowers_g_t_layer\u003cF: Field, A: Algebra\u003cF\u003e, const N: usize\u003e(\r\n    values: \u0026mut [A; N],\r\n    log_half_block_size: usize,\r\n    twiddles: \u0026[F],\r\n) {\r\n    let log_block_size = log_half_block_size + 1;\r\n    let half_block_size = 1 \u003c\u003c log_half_block_size;\r\n    let num_blocks = N \u003e\u003e log_block_size;\r\n\r\n    for (block, \u0026twiddle) in (0..num_blocks).zip(twiddles) {\r\n        let block_start = block \u003c\u003c log_block_size;\r\n        for hi in block_start..block_start + half_block_size {\r\n            let lo = hi + half_block_size;\r\n            dit_butterfly(values, hi, lo, twiddle);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_baby_bear::BabyBear;\r\n    use p3_dft::{NaiveDft, TwoAdicSubgroupDft};\r\n    use p3_field::{Field, PrimeCharacteristicRing};\r\n    use p3_symmetric::Permutation;\r\n    use p3_util::reverse_slice_index_bits;\r\n    use rand::{thread_rng, Rng};\r\n\r\n    use crate::integrated_coset_mds::IntegratedCosetMds;\r\n\r\n    type F = BabyBear;\r\n    const N: usize = 16;\r\n\r\n    #[test]\r\n    fn matches_naive() {\r\n        let mut rng = thread_rng();\r\n        let mut arr: [F; N] = rng.gen();\r\n\r\n        let mut arr_rev = arr.to_vec();\r\n        reverse_slice_index_bits(\u0026mut arr_rev);\r\n\r\n        let shift = F::GENERATOR;\r\n        let mut coset_lde_naive = NaiveDft.coset_lde(arr_rev, 0, shift);\r\n        reverse_slice_index_bits(\u0026mut coset_lde_naive);\r\n        coset_lde_naive\r\n            .iter_mut()\r\n            .for_each(|x| *x *= F::from_u8(N as u8));\r\n        IntegratedCosetMds::default().permute_mut(\u0026mut arr);\r\n        assert_eq!(coset_lde_naive, arr);\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":23,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":32,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":35,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":38,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":40,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":58,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":61,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":66,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":85,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":86,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":87,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":90,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":91,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":92,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":93,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":94,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":100,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":109,"address":[],"length":0,"stats":{"Line":1369094286720630784}},{"line":110,"address":[],"length":0,"stats":{"Line":1080863910568919040}},{"line":111,"address":[],"length":0,"stats":{"Line":5692549928996306944}},{"line":112,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}}],"covered":43,"coverable":46},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","karatsuba_convolution.rs"],"content":"//! Calculate the convolution of two vectors using a Karatsuba-style\r\n//! decomposition and the CRT.\r\n//!\r\n//! This is not a new idea, but we did have the pleasure of\r\n//! reinventing it independently. Some references:\r\n//! - `\u003chttps://cr.yp.to/lineartime/multapps-20080515.pdf\u003e`\r\n//! - `\u003chttps://2.com/23/convolution/\u003e`\r\n//!\r\n//! Given a vector v \\in F^N, let v(x) \\in F[x] denote the polynomial\r\n//! v_0 + v_1 x + ... + v_{N - 1} x^{N - 1}.  Then w is equal to the\r\n//! convolution v * u if and only if w(x) = v(x)u(x) mod x^N - 1.\r\n//! Additionally, define the negacyclic convolution by w(x) = v(x)u(x)\r\n//! mod x^N + 1.  Using the Chinese remainder theorem we can compute\r\n//! w(x) as\r\n//!     w(x) = 1/2 (w_0(x) + w_1(x)) + x^{N/2}/2 (w_0(x) - w_1(x))\r\n//! where\r\n//!     w_0 = v(x)u(x) mod x^{N/2} - 1\r\n//!     w_1 = v(x)u(x) mod x^{N/2} + 1\r\n//!\r\n//! To compute w_0 and w_1 we first compute\r\n//!                  v_0(x) = v(x) mod x^{N/2} - 1\r\n//!                  v_1(x) = v(x) mod x^{N/2} + 1\r\n//!                  u_0(x) = u(x) mod x^{N/2} - 1\r\n//!                  u_1(x) = u(x) mod x^{N/2} + 1\r\n//!\r\n//! Now w_0 is the convolution of v_0 and u_0 which we can compute\r\n//! recursively.  For w_1 we compute the negacyclic convolution\r\n//! v_1(x)u_1(x) mod x^{N/2} + 1 using Karatsuba.\r\n//!\r\n//! There are 2 possible approaches to applying Karatsuba which mirror\r\n//! the DIT vs DIF approaches to FFT's, the left/right decomposition\r\n//! or the even/odd decomposition. The latter seems to have fewer\r\n//! operations and so it is the one implemented below, though it does\r\n//! require a bit more data manipulation. It works as follows:\r\n//!\r\n//! Define the even v_e and odd v_o parts so that v(x) = (v_e(x^2) + x v_o(x^2)).\r\n//! Then v(x)u(x)\r\n//!    = (v_e(x^2)u_e(x^2) + x^2 v_o(x^2)u_o(x^2))\r\n//!      + x ((v_e(x^2) + v_o(x^2))(u_e(x^2) + u_o(x^2))\r\n//!            - (v_e(x^2)u_e(x^2) + v_o(x^2)u_o(x^2)))\r\n//! This reduces the problem to 3 negacyclic convolutions of size N/2 which\r\n//! can be computed recursively.\r\n//!\r\n//! Of course, for small sizes we just explicitly write out the O(n^2)\r\n//! approach.\r\n\r\nuse core::ops::{Add, AddAssign, Neg, ShrAssign, Sub, SubAssign};\r\n\r\n/// This trait collects the operations needed by `Convolve` below.\r\n///\r\n/// TODO: Think of a better name for this.\r\npub trait RngElt:\r\n    Add\u003cOutput = Self\u003e\r\n    + AddAssign\r\n    + Copy\r\n    + Default\r\n    + Neg\u003cOutput = Self\u003e\r\n    + ShrAssign\u003cu32\u003e\r\n    + Sub\u003cOutput = Self\u003e\r\n    + SubAssign\r\n{\r\n}\r\n\r\nimpl RngElt for i64 {}\r\nimpl RngElt for i128 {}\r\n\r\n/// Template function to perform convolution of vectors.\r\n///\r\n/// Roughly speaking, for a convolution of size `N`, it should be\r\n/// possible to add `N` elements of type `T` without overflowing, and\r\n/// similarly for `U`. Then multiplication via `Self::mul` should\r\n/// produce an element of type `V` which will not overflow after about\r\n/// `N` additions (this is an over-estimate).\r\n///\r\n/// For example usage, see `{mersenne-31,baby-bear,goldilocks}/src/mds.rs`.\r\n///\r\n/// NB: In practice, one of the parameters to the convolution will be\r\n/// constant (the MDS matrix). After inspecting Godbolt output, it\r\n/// seems that the compiler does indeed generate single constants as\r\n/// inputs to the multiplication, rather than doing all that\r\n/// arithmetic on the constant values every time. Note however that,\r\n/// for MDS matrices with large entries (N \u003e= 24), these compile-time\r\n/// generated constants will be about N times bigger than they need to\r\n/// be in principle, which could be a potential avenue for some minor\r\n/// improvements.\r\n///\r\n/// NB: If primitive multiplications are still the bottleneck, a\r\n/// further possibility would be to find an MDS matrix some of whose\r\n/// entries are powers of 2. Then the multiplication can be replaced\r\n/// with a shift, which on most architectures has better throughput\r\n/// and latency, and is issued on different ports (1*p06) to\r\n/// multiplication (1*p1).\r\npub trait Convolve\u003cF, T: RngElt, U: RngElt, V: RngElt\u003e {\r\n    /// Given an input element, retrieve the corresponding internal\r\n    /// element that will be used in calculations.\r\n    fn read(input: F) -\u003e T;\r\n\r\n    /// Given input vectors `lhs` and `rhs`, calculate their dot\r\n    /// product. The result can be reduced with respect to the modulus\r\n    /// (of `F`), but it must have the same lower 10 bits as the dot\r\n    /// product if all inputs are considered integers. See\r\n    /// `monty-31/src/mds.rs::barrett_red_monty31()` for an example\r\n    /// of how this can be implemented in practice.\r\n    fn parity_dot\u003cconst N: usize\u003e(lhs: [T; N], rhs: [U; N]) -\u003e V;\r\n\r\n    /// Convert an internal element of type `V` back into an external\r\n    /// element.\r\n    fn reduce(z: V) -\u003e F;\r\n\r\n    /// Convolve `lhs` and `rhs`.\r\n    ///\r\n    /// The parameter `conv` should be the function in this trait that\r\n    /// corresponds to length `N`.\r\n    #[inline(always)]\r\n    fn apply\u003cconst N: usize, C: Fn([T; N], [U; N], \u0026mut [V])\u003e(\r\n        lhs: [F; N],\r\n        rhs: [U; N],\r\n        conv: C,\r\n    ) -\u003e [F; N] {\r\n        let lhs = lhs.map(Self::read);\r\n        let mut output = [V::default(); N];\r\n        conv(lhs, rhs, \u0026mut output);\r\n        output.map(Self::reduce)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv3(lhs: [T; 3], rhs: [U; 3], output: \u0026mut [V]) {\r\n        output[0] = Self::parity_dot(lhs, [rhs[0], rhs[2], rhs[1]]);\r\n        output[1] = Self::parity_dot(lhs, [rhs[1], rhs[0], rhs[2]]);\r\n        output[2] = Self::parity_dot(lhs, [rhs[2], rhs[1], rhs[0]]);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv3(lhs: [T; 3], rhs: [U; 3], output: \u0026mut [V]) {\r\n        output[0] = Self::parity_dot(lhs, [rhs[0], -rhs[2], -rhs[1]]);\r\n        output[1] = Self::parity_dot(lhs, [rhs[1], rhs[0], -rhs[2]]);\r\n        output[2] = Self::parity_dot(lhs, [rhs[2], rhs[1], rhs[0]]);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv4(lhs: [T; 4], rhs: [U; 4], output: \u0026mut [V]) {\r\n        // NB: This is just explicitly implementing\r\n        // conv_n_recursive::\u003c4, 2, _, _\u003e(lhs, rhs, output, Self::conv2, Self::negacyclic_conv2)\r\n        let u_p = [lhs[0] + lhs[2], lhs[1] + lhs[3]];\r\n        let u_m = [lhs[0] - lhs[2], lhs[1] - lhs[3]];\r\n        let v_p = [rhs[0] + rhs[2], rhs[1] + rhs[3]];\r\n        let v_m = [rhs[0] - rhs[2], rhs[1] - rhs[3]];\r\n\r\n        output[0] = Self::parity_dot(u_m, [v_m[0], -v_m[1]]);\r\n        output[1] = Self::parity_dot(u_m, [v_m[1], v_m[0]]);\r\n        output[2] = Self::parity_dot(u_p, v_p);\r\n        output[3] = Self::parity_dot(u_p, [v_p[1], v_p[0]]);\r\n\r\n        output[0] += output[2];\r\n        output[1] += output[3];\r\n\r\n        output[0] \u003e\u003e= 1;\r\n        output[1] \u003e\u003e= 1;\r\n\r\n        output[2] -= output[0];\r\n        output[3] -= output[1];\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv4(lhs: [T; 4], rhs: [U; 4], output: \u0026mut [V]) {\r\n        output[0] = Self::parity_dot(lhs, [rhs[0], -rhs[3], -rhs[2], -rhs[1]]);\r\n        output[1] = Self::parity_dot(lhs, [rhs[1], rhs[0], -rhs[3], -rhs[2]]);\r\n        output[2] = Self::parity_dot(lhs, [rhs[2], rhs[1], rhs[0], -rhs[3]]);\r\n        output[3] = Self::parity_dot(lhs, [rhs[3], rhs[2], rhs[1], rhs[0]]);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv6(lhs: [T; 6], rhs: [U; 6], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c6, 3, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv3,\r\n            Self::negacyclic_conv3,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv6(lhs: [T; 6], rhs: [U; 6], output: \u0026mut [V]) {\r\n        negacyclic_conv_n_recursive::\u003c6, 3, T, U, V, _\u003e(lhs, rhs, output, Self::negacyclic_conv3)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv8(lhs: [T; 8], rhs: [U; 8], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c8, 4, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv4,\r\n            Self::negacyclic_conv4,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv8(lhs: [T; 8], rhs: [U; 8], output: \u0026mut [V]) {\r\n        negacyclic_conv_n_recursive::\u003c8, 4, T, U, V, _\u003e(lhs, rhs, output, Self::negacyclic_conv4)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv12(lhs: [T; 12], rhs: [U; 12], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c12, 6, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv6,\r\n            Self::negacyclic_conv6,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv12(lhs: [T; 12], rhs: [U; 12], output: \u0026mut [V]) {\r\n        negacyclic_conv_n_recursive::\u003c12, 6, T, U, V, _\u003e(lhs, rhs, output, Self::negacyclic_conv6)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv16(lhs: [T; 16], rhs: [U; 16], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c16, 8, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv8,\r\n            Self::negacyclic_conv8,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv16(lhs: [T; 16], rhs: [U; 16], output: \u0026mut [V]) {\r\n        negacyclic_conv_n_recursive::\u003c16, 8, T, U, V, _\u003e(lhs, rhs, output, Self::negacyclic_conv8)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv24(lhs: [T; 24], rhs: [U; 24], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c24, 12, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv12,\r\n            Self::negacyclic_conv12,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv32(lhs: [T; 32], rhs: [U; 32], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c32, 16, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv16,\r\n            Self::negacyclic_conv16,\r\n        )\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn negacyclic_conv32(lhs: [T; 32], rhs: [U; 32], output: \u0026mut [V]) {\r\n        negacyclic_conv_n_recursive::\u003c32, 16, T, U, V, _\u003e(lhs, rhs, output, Self::negacyclic_conv16)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn conv64(lhs: [T; 64], rhs: [U; 64], output: \u0026mut [V]) {\r\n        conv_n_recursive::\u003c64, 32, T, U, V, _, _\u003e(\r\n            lhs,\r\n            rhs,\r\n            output,\r\n            Self::conv32,\r\n            Self::negacyclic_conv32,\r\n        )\r\n    }\r\n}\r\n\r\n/// Compute output(x) = lhs(x)rhs(x) mod x^N - 1.\r\n/// Do this recursively using a convolution and negacyclic convolution of size HALF_N = N/2.\r\n#[inline(always)]\r\nfn conv_n_recursive\u003cconst N: usize, const HALF_N: usize, T, U, V, C, NC\u003e(\r\n    lhs: [T; N],\r\n    rhs: [U; N],\r\n    output: \u0026mut [V],\r\n    inner_conv: C,\r\n    inner_negacyclic_conv: NC,\r\n) where\r\n    T: RngElt,\r\n    U: RngElt,\r\n    V: RngElt,\r\n    C: Fn([T; HALF_N], [U; HALF_N], \u0026mut [V]),\r\n    NC: Fn([T; HALF_N], [U; HALF_N], \u0026mut [V]),\r\n{\r\n    debug_assert_eq!(2 * HALF_N, N);\r\n    // NB: The compiler is smart enough not to initialise these arrays.\r\n    let mut lhs_pos = [T::default(); HALF_N]; // lhs_pos = lhs(x) mod x^{N/2} - 1\r\n    let mut lhs_neg = [T::default(); HALF_N]; // lhs_neg = lhs(x) mod x^{N/2} + 1\r\n    let mut rhs_pos = [U::default(); HALF_N]; // rhs_pos = rhs(x) mod x^{N/2} - 1\r\n    let mut rhs_neg = [U::default(); HALF_N]; // rhs_neg = rhs(x) mod x^{N/2} + 1\r\n\r\n    for i in 0..HALF_N {\r\n        let s = lhs[i];\r\n        let t = lhs[i + HALF_N];\r\n\r\n        lhs_pos[i] = s + t;\r\n        lhs_neg[i] = s - t;\r\n\r\n        let s = rhs[i];\r\n        let t = rhs[i + HALF_N];\r\n\r\n        rhs_pos[i] = s + t;\r\n        rhs_neg[i] = s - t;\r\n    }\r\n\r\n    let (left, right) = output.split_at_mut(HALF_N);\r\n\r\n    // left = w1 = lhs(x)rhs(x) mod x^{N/2} + 1\r\n    inner_negacyclic_conv(lhs_neg, rhs_neg, left);\r\n\r\n    // right = w0 = lhs(x)rhs(x) mod x^{N/2} - 1\r\n    inner_conv(lhs_pos, rhs_pos, right);\r\n\r\n    for i in 0..HALF_N {\r\n        left[i] += right[i]; // w_0 + w_1\r\n        left[i] \u003e\u003e= 1; // (w_0 + w_1)/2\r\n        right[i] -= left[i]; // (w_0 - w_1)/2\r\n    }\r\n}\r\n\r\n/// Compute output(x) = lhs(x)rhs(x) mod x^N + 1.\r\n/// Do this recursively using three negacyclic convolutions of size HALF_N = N/2.\r\n#[inline(always)]\r\nfn negacyclic_conv_n_recursive\u003cconst N: usize, const HALF_N: usize, T, U, V, NC\u003e(\r\n    lhs: [T; N],\r\n    rhs: [U; N],\r\n    output: \u0026mut [V],\r\n    inner_negacyclic_conv: NC,\r\n) where\r\n    T: RngElt,\r\n    U: RngElt,\r\n    V: RngElt,\r\n    NC: Fn([T; HALF_N], [U; HALF_N], \u0026mut [V]),\r\n{\r\n    debug_assert_eq!(2 * HALF_N, N);\r\n    // NB: The compiler is smart enough not to initialise these arrays.\r\n    let mut lhs_even = [T::default(); HALF_N];\r\n    let mut lhs_odd = [T::default(); HALF_N];\r\n    let mut lhs_sum = [T::default(); HALF_N];\r\n    let mut rhs_even = [U::default(); HALF_N];\r\n    let mut rhs_odd = [U::default(); HALF_N];\r\n    let mut rhs_sum = [U::default(); HALF_N];\r\n\r\n    for i in 0..HALF_N {\r\n        let s = lhs[2 * i];\r\n        let t = lhs[2 * i + 1];\r\n        lhs_even[i] = s;\r\n        lhs_odd[i] = t;\r\n        lhs_sum[i] = s + t;\r\n\r\n        let s = rhs[2 * i];\r\n        let t = rhs[2 * i + 1];\r\n        rhs_even[i] = s;\r\n        rhs_odd[i] = t;\r\n        rhs_sum[i] = s + t;\r\n    }\r\n\r\n    let mut even_s_conv = [V::default(); HALF_N];\r\n    let (left, right) = output.split_at_mut(HALF_N);\r\n\r\n    // Recursively compute the size N/2 negacyclic convolutions of\r\n    // the even parts, odd parts, and sums.\r\n    inner_negacyclic_conv(lhs_even, rhs_even, \u0026mut even_s_conv);\r\n    inner_negacyclic_conv(lhs_odd, rhs_odd, left);\r\n    inner_negacyclic_conv(lhs_sum, rhs_sum, right);\r\n\r\n    // Adjust so that the correct values are in right and\r\n    // even_s_conv respectively:\r\n    right[0] -= even_s_conv[0] + left[0];\r\n    even_s_conv[0] -= left[HALF_N - 1];\r\n\r\n    for i in 1..HALF_N {\r\n        right[i] -= even_s_conv[i] + left[i];\r\n        even_s_conv[i] += left[i - 1];\r\n    }\r\n\r\n    // Interleave even_s_conv and right in the output:\r\n    for i in 0..HALF_N {\r\n        output[2 * i] = even_s_conv[i];\r\n        output[2 * i + 1] = output[i + HALF_N];\r\n    }\r\n}\r\n","traces":[{"line":115,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":120,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":121,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":122,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":123,"address":[],"length":0,"stats":{"Line":12105675798371893252}},{"line":127,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":128,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":129,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":130,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":134,"address":[],"length":0,"stats":{"Line":10448351135499550721}},{"line":135,"address":[],"length":0,"stats":{"Line":10448351135499550721}},{"line":136,"address":[],"length":0,"stats":{"Line":10448351135499550721}},{"line":137,"address":[],"length":0,"stats":{"Line":10448351135499550721}},{"line":141,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":144,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":145,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":146,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":147,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":149,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":150,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":151,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":152,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":154,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":155,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":157,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":158,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":160,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":161,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":165,"address":[],"length":0,"stats":{"Line":1080863910568919051}},{"line":166,"address":[],"length":0,"stats":{"Line":1080863910568919051}},{"line":167,"address":[],"length":0,"stats":{"Line":1080863910568919051}},{"line":168,"address":[],"length":0,"stats":{"Line":1080863910568919051}},{"line":169,"address":[],"length":0,"stats":{"Line":1080863910568919051}},{"line":173,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":175,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":176,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":177,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":178,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":179,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":184,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":185,"address":[],"length":0,"stats":{"Line":7277816997830721536}},{"line":189,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":191,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":192,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":193,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":194,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":195,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":200,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":201,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":205,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":207,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":208,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":209,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":210,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":211,"address":[],"length":0,"stats":{"Line":7061644215716937728}},{"line":216,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":217,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":221,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":223,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":224,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":225,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":226,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":227,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":232,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":233,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":237,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":239,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":240,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":241,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":242,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":243,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":248,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":250,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":251,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":252,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":253,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":254,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":259,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":260,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":264,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":266,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":267,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":268,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":269,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":270,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":278,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":291,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":293,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":294,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":295,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":296,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":298,"address":[],"length":0,"stats":{"Line":13835058055282163707}},{"line":299,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":300,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":302,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":303,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":305,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":306,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":308,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":309,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":13835058055282163708}},{"line":321,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":322,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":323,"address":[],"length":0,"stats":{"Line":17798225727368200190}},{"line":330,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":341,"address":[],"length":0,"stats":{"Line":7638104968020361217}},{"line":343,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":344,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":345,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":346,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":347,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":348,"address":[],"length":0,"stats":{"Line":13042424520864956417}},{"line":350,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":351,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":352,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":353,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":354,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":355,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":357,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":358,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":359,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":360,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":361,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":12177733392409821185}},{"line":379,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":380,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":384,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":385,"address":[],"length":0,"stats":{"Line":12754194144713244672}},{"line":386,"address":[],"length":0,"stats":{"Line":12754194144713244672}}],"covered":129,"coverable":139},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","lib.rs"],"content":"//! A library dealing with maximum distance separable transformations.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nuse p3_symmetric::Permutation;\r\n\r\nmod butterflies;\r\npub mod coset_mds;\r\npub mod integrated_coset_mds;\r\npub mod karatsuba_convolution;\r\npub mod util;\r\n\r\npub trait MdsPermutation\u003cT: Clone, const WIDTH: usize\u003e: Permutation\u003c[T; WIDTH]\u003e {}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mds","src","util.rs"],"content":"use alloc::vec::Vec;\r\nuse core::array;\r\nuse core::ops::{AddAssign, Mul};\r\n\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::{PrimeCharacteristicRing, TwoAdicField};\r\n\r\n// NB: These are all MDS for M31, BabyBear and Goldilocks\r\n// const MATRIX_CIRC_MDS_8_2EXP: [u64; 8] = [1, 1, 2, 1, 8, 32, 4, 256];\r\n// const MATRIX_CIRC_MDS_8_SML: [u64; 8] = [4, 1, 2, 9, 10, 5, 1, 1];\r\n// Much smaller: [1, 1, -1, 2, 3, 8, 2, -3] but need to deal with the -ve's\r\n\r\n// const MATRIX_CIRC_MDS_12_2EXP: [u64; 12] = [1, 1, 2, 1, 8, 32, 2, 256, 4096, 8, 65536, 1024];\r\n// const MATRIX_CIRC_MDS_12_SML: [u64; 12] = [9, 7, 4, 1, 16, 2, 256, 128, 3, 32, 1, 1];\r\n// const MATRIX_CIRC_MDS_12_SML: [u64; 12] = [1, 1, 2, 1, 8, 9, 10, 7, 5, 9, 4, 10];\r\n\r\n// Trying to maximise the # of 1's in the vector.\r\n// Not clear exactly what we should be optimising here but that seems reasonable.\r\n// const MATRIX_CIRC_MDS_16_SML: [u64; 16] =\r\n//   [1, 1, 51, 1, 11, 17, 2, 1, 101, 63, 15, 2, 67, 22, 13, 3];\r\n// 1, 1, 51, 52, 11, 63, 1, 2, 1, 2, 15, 67, 2, 22, 13, 3\r\n// [1, 1, 2, 1, 8, 32, 2, 65, 77, 8, 91, 31, 3, 65, 32, 7];\r\n\r\n/// This will throw an error if N = 0 but it's hard to imagine this case coming up.\r\n#[inline(always)]\r\npub fn dot_product\u003cT, const N: usize\u003e(u: [T; N], v: [T; N]) -\u003e T\r\nwhere\r\n    T: Copy + AddAssign + Mul\u003cOutput = T\u003e,\r\n{\r\n    debug_assert_ne!(N, 0);\r\n    let mut dp = u[0] * v[0];\r\n    for i in 1..N {\r\n        dp += u[i] * v[i];\r\n    }\r\n    dp\r\n}\r\n\r\n/// Given the first row `circ_matrix` of an NxN circulant matrix, say\r\n/// C, return the product `C*input`.\r\n///\r\n/// NB: This function is a naive implementation of the n\r\n/// evaluation. It is a placeholder until we have FFT implementations\r\n/// for all combinations of field and size.\r\npub fn apply_circulant\u003cR: PrimeCharacteristicRing, const N: usize\u003e(\r\n    circ_matrix: \u0026[u64; N],\r\n    input: [R; N],\r\n) -\u003e [R; N] {\r\n    let mut matrix: [R; N] = circ_matrix.map(R::from_u64);\r\n\r\n    let mut output = array::from_fn(|_| R::ZERO);\r\n    for out_i in output.iter_mut().take(N - 1) {\r\n        *out_i = R::dot_product(\u0026matrix, \u0026input);\r\n        matrix.rotate_right(1);\r\n    }\r\n    output[N - 1] = R::dot_product(\u0026matrix, \u0026input);\r\n    output\r\n}\r\n\r\n/// Given the first row of a circulant matrix, return the first column.\r\n///\r\n/// For example if, `v = [0, 1, 2, 3, 4, 5]` then `output = [0, 5, 4, 3, 2, 1]`,\r\n/// i.e. the first element is the same and the other elements are reversed.\r\n///\r\n/// This is useful to prepare a circulant matrix for input to an FFT\r\n/// algorithm, which expects the first column of the matrix rather\r\n/// than the first row (as we normally store them).\r\n///\r\n/// NB: The algorithm is inefficient but simple enough that this\r\n/// function can be declared `const`, and that is the intended context\r\n/// for use.\r\npub const fn first_row_to_first_col\u003cconst N: usize, T: Copy\u003e(v: \u0026[T; N]) -\u003e [T; N] {\r\n    // Can do this to get a simple Default value. Might be better ways?\r\n    let mut output = [v[0]; N];\r\n    let mut i = 1;\r\n    loop {\r\n        if i \u003e= N {\r\n            break;\r\n        }\r\n        output[i] = v[N - i];\r\n        i += 1;\r\n    }\r\n    output\r\n}\r\n\r\n/// Use the convolution theorem to calculate the product of the given\r\n/// circulant matrix and the given vector.\r\n///\r\n/// The circulant matrix must be specified by its first *column*, not its first row. If you have\r\n/// the row as an array, you can obtain the column with `first_row_to_first_col()`.\r\n#[inline]\r\npub fn apply_circulant_fft\u003cF: TwoAdicField, const N: usize, FFT: TwoAdicSubgroupDft\u003cF\u003e\u003e(\r\n    fft: FFT,\r\n    column: [u64; N],\r\n    input: \u0026[F; N],\r\n) -\u003e [F; N] {\r\n    let column = column.map(F::from_u64).to_vec();\r\n    let matrix = fft.dft(column);\r\n    let input = fft.dft(input.to_vec());\r\n\r\n    // point-wise product\r\n    let product = matrix\r\n        .iter()\r\n        .zip(input)\r\n        .map(|(\u0026x, y)| x * y)\r\n        .collect::\u003cVec\u003c_\u003e\u003e();\r\n\r\n    let output = fft.idft(product);\r\n    output.try_into().unwrap()\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::first_row_to_first_col;\r\n\r\n    #[test]\r\n    fn rotation() {\r\n        let input = [0, 1, 2, 3, 4, 5];\r\n        let output = [0, 5, 4, 3, 2, 1];\r\n\r\n        assert_eq!(first_row_to_first_col(\u0026input), output);\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":1585267068834414599}},{"line":30,"address":[],"length":0,"stats":{"Line":1585267068834414599}},{"line":31,"address":[],"length":0,"stats":{"Line":1585267068834414599}},{"line":32,"address":[],"length":0,"stats":{"Line":16285016252571713552}},{"line":33,"address":[],"length":0,"stats":{"Line":4899916394579099651}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":48,"address":[],"length":0,"stats":{"Line":11457157452030541824}},{"line":50,"address":[],"length":0,"stats":{"Line":12538021362599460863}},{"line":51,"address":[],"length":0,"stats":{"Line":8142508126285856766}},{"line":52,"address":[],"length":0,"stats":{"Line":7566047373982433279}},{"line":53,"address":[],"length":0,"stats":{"Line":7566047373982433279}},{"line":55,"address":[],"length":0,"stats":{"Line":11457157452030541830}},{"line":56,"address":[],"length":0,"stats":{"Line":11457157452030541830}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":80,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":91,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":7205759403792793601}},{"line":107,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":30,"coverable":32},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","merkle-tree","benches","merkle_tree.rs"],"content":"use std::any::type_name;\r\n\r\nuse criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_blake3::Blake3;\r\nuse p3_commit::Mmcs;\r\nuse p3_field::{Field, PackedField, PackedValue};\r\nuse p3_keccak::Keccak256Hash;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_mds::integrated_coset_mds::IntegratedCosetMds;\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_rescue::Rescue;\r\nuse p3_symmetric::{\r\n    CompressionFunctionFromHasher, CryptographicHasher, PaddingFreeSponge,\r\n    PseudoCompressionFunction, SerializingHasher32, TruncatedPermutation,\r\n};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::thread_rng;\r\nuse serde::de::DeserializeOwned;\r\nuse serde::Serialize;\r\n\r\nfn bench_merkle_trees(criterion: \u0026mut Criterion) {\r\n    bench_bb_poseidon2(criterion);\r\n    bench_bb_rescue(criterion);\r\n    bench_bb_blake3(criterion);\r\n    bench_bb_keccak(criterion);\r\n}\r\n\r\nfn bench_bb_poseidon2(criterion: \u0026mut Criterion) {\r\n    type F = BabyBear;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n\r\n    type H = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    let h = H::new(perm.clone());\r\n\r\n    type C = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n    let c = C::new(perm);\r\n\r\n    bench_mmcs::\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, H, C, 8\u003e(\r\n        criterion,\r\n        h.clone(),\r\n        c.clone(),\r\n    );\r\n    bench_merkle_tree::\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, H, C, 8\u003e(criterion, h, c);\r\n}\r\n\r\nfn bench_bb_rescue(criterion: \u0026mut Criterion) {\r\n    type F = BabyBear;\r\n\r\n    type Mds = IntegratedCosetMds\u003cF, 16\u003e;\r\n    let mds = Mds::default();\r\n\r\n    type Perm = Rescue\u003cF, Mds, 16, 7\u003e;\r\n    let round_constants = Perm::get_round_constants_from_rng(8, \u0026mut thread_rng());\r\n    let perm = Perm::new(8, round_constants, mds);\r\n\r\n    type H = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    let h = H::new(perm.clone());\r\n\r\n    type C = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n    let c = C::new(perm);\r\n\r\n    bench_mmcs::\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, H, C, 8\u003e(\r\n        criterion,\r\n        h.clone(),\r\n        c.clone(),\r\n    );\r\n    bench_merkle_tree::\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, H, C, 8\u003e(criterion, h, c);\r\n}\r\n\r\nfn bench_bb_blake3(criterion: \u0026mut Criterion) {\r\n    type F = BabyBear;\r\n\r\n    type H = SerializingHasher32\u003cBlake3\u003e;\r\n    let h = H::new(Blake3 {});\r\n\r\n    type C = CompressionFunctionFromHasher\u003cBlake3, 2, 32\u003e;\r\n    let b = Blake3 {};\r\n    let c = C::new(b);\r\n\r\n    bench_mmcs::\u003cF, u8, H, C, 32\u003e(criterion, h, c.clone());\r\n    bench_merkle_tree::\u003cF, u8, H, C, 32\u003e(criterion, h, c);\r\n}\r\n\r\nfn bench_bb_keccak(criterion: \u0026mut Criterion) {\r\n    type F = BabyBear;\r\n\r\n    type H = SerializingHasher32\u003cKeccak256Hash\u003e;\r\n    let k = Keccak256Hash {};\r\n    let h = H::new(k);\r\n\r\n    type C = CompressionFunctionFromHasher\u003cKeccak256Hash, 2, 32\u003e;\r\n    let c = C::new(k);\r\n\r\n    bench_mmcs::\u003cF, u8, H, C, 32\u003e(criterion, h, c.clone());\r\n    bench_merkle_tree::\u003cF, u8, H, C, 32\u003e(criterion, h, c);\r\n}\r\n\r\nfn bench_merkle_tree\u003cP, PW, H, C, const DIGEST_ELEMS: usize\u003e(criterion: \u0026mut Criterion, h: H, c: C)\r\nwhere\r\n    P: PackedField,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Scalar, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    C: PseudoCompressionFunction\u003c[PW::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n    [PW::Value; DIGEST_ELEMS]: Serialize + DeserializeOwned,\r\n    Standard: Distribution\u003cP::Scalar\u003e,\r\n{\r\n    const ROWS: usize = 1 \u003c\u003c 15;\r\n    const COLS: usize = 135;\r\n\r\n    let matrix = RowMajorMatrix::\u003cP::Scalar\u003e::rand(\u0026mut thread_rng(), ROWS, COLS);\r\n    let dims = matrix.dimensions();\r\n    let leaves = vec![matrix];\r\n\r\n    let name = format!(\r\n        \"MerkleTree::\u003c{}, {}\u003e::new\",\r\n        type_name::\u003cH\u003e(),\r\n        type_name::\u003cC\u003e()\r\n    );\r\n    let params = BenchmarkId::from_parameter(dims);\r\n\r\n    let mut group = criterion.benchmark_group(name);\r\n    group.sample_size(10);\r\n\r\n    let mmcs = MerkleTreeMmcs::\u003cP, PW, H, C, DIGEST_ELEMS\u003e::new(h, c);\r\n    group.bench_with_input(params, \u0026leaves, |b, input| {\r\n        b.iter(|| mmcs.commit(input.clone()))\r\n    });\r\n}\r\n\r\nfn bench_mmcs\u003cP, PW, H, C, const DIGEST_ELEMS: usize\u003e(criterion: \u0026mut Criterion, h: H, c: C)\r\nwhere\r\n    P: PackedField,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Scalar, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    C: PseudoCompressionFunction\u003c[PW::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n    [PW::Value; DIGEST_ELEMS]: Serialize + DeserializeOwned,\r\n    Standard: Distribution\u003cP::Scalar\u003e,\r\n{\r\n    const ROWS: usize = 1 \u003c\u003c 15;\r\n    const COLS: usize = 135;\r\n\r\n    let matrix_1 = RowMajorMatrix::\u003cP::Scalar\u003e::rand(\u0026mut thread_rng(), ROWS + 1, COLS);\r\n    let matrix_2 = RowMajorMatrix::\u003cP::Scalar\u003e::rand(\u0026mut thread_rng(), ROWS / 2 + 1, COLS);\r\n    let dims = vec![matrix_1.dimensions(), matrix_2.dimensions()];\r\n    let leaves = vec![matrix_1, matrix_2];\r\n\r\n    let name = format!(\r\n        \"MerkleTreeMmcs::\u003c{}, {}\u003e::new\",\r\n        type_name::\u003cH\u003e(),\r\n        type_name::\u003cC\u003e()\r\n    );\r\n    let params = BenchmarkId::from_parameter(format!(\"{:?}\", dims));\r\n\r\n    let mut group = criterion.benchmark_group(name);\r\n    group.sample_size(10);\r\n\r\n    let mmcs = MerkleTreeMmcs::\u003cP, PW, H, C, DIGEST_ELEMS\u003e::new(h, c);\r\n    group.bench_with_input(params, \u0026leaves, |b, input| {\r\n        b.iter(|| mmcs.commit(input.clone()))\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_merkle_trees);\r\ncriterion_main!(benches);\r\n","traces":[{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":25},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","merkle-tree","src","hiding_mmcs.rs"],"content":"use alloc::vec::Vec;\r\nuse core::cell::RefCell;\r\n\r\nuse itertools::Itertools;\r\nuse p3_commit::Mmcs;\r\nuse p3_field::PackedValue;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::stack::HorizontalPair;\r\nuse p3_matrix::{Dimensions, Matrix};\r\nuse p3_symmetric::{CryptographicHasher, Hash, PseudoCompressionFunction};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::de::DeserializeOwned;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::{MerkleTree, MerkleTreeError, MerkleTreeMmcs};\r\n\r\n/// A vector commitment scheme backed by a `MerkleTree`.\r\n///\r\n/// This is similar to `MerkleTreeMmcs`, but each leaf is \"salted\" with random elements. This is\r\n/// done to turn the Merkle tree into a hiding commitment. See e.g. Section 3 of\r\n/// [Interactive Oracle Proofs](https://eprint.iacr.org/2016/116).\r\n///\r\n/// `SALT_ELEMS` should be set such that the product of `SALT_ELEMS` with the size of the value\r\n/// (`P::Value`) is at least the target security parameter.\r\n///\r\n/// `R` should be an appropriately seeded cryptographically secure pseudorandom number generator\r\n/// (CSPRNG). Something like `ThreadRng` may work, although it relies on the operating system to\r\n/// provide sufficient entropy.\r\n///\r\n/// Generics:\r\n/// - `P`: a leaf value\r\n/// - `PW`: an element of a digest\r\n/// - `H`: the leaf hasher\r\n/// - `C`: the digest compression function\r\n/// - `R`: a random number generator for blinding leaves\r\n#[derive(Clone, Debug)]\r\npub struct MerkleTreeHidingMmcs\u003cP, PW, H, C, R, const DIGEST_ELEMS: usize, const SALT_ELEMS: usize\u003e\r\n{\r\n    inner: MerkleTreeMmcs\u003cP, PW, H, C, DIGEST_ELEMS\u003e,\r\n    rng: RefCell\u003cR\u003e,\r\n}\r\n\r\nimpl\u003cP, PW, H, C, R, const DIGEST_ELEMS: usize, const SALT_ELEMS: usize\u003e\r\n    MerkleTreeHidingMmcs\u003cP, PW, H, C, R, DIGEST_ELEMS, SALT_ELEMS\u003e\r\n{\r\n    pub fn new(hash: H, compress: C, rng: R) -\u003e Self {\r\n        let inner = MerkleTreeMmcs::new(hash, compress);\r\n        Self {\r\n            inner,\r\n            rng: rng.into(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cP, PW, H, C, R, const DIGEST_ELEMS: usize, const SALT_ELEMS: usize\u003e Mmcs\u003cP::Value\u003e\r\n    for MerkleTreeHidingMmcs\u003cP, PW, H, C, R, DIGEST_ELEMS, SALT_ELEMS\u003e\r\nwhere\r\n    P: PackedValue,\r\n    P::Value: Serialize + DeserializeOwned,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Value, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    C: PseudoCompressionFunction\u003c[PW::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n    R: Rng + Clone,\r\n    PW::Value: Eq,\r\n    [PW::Value; DIGEST_ELEMS]: Serialize + for\u003c'de\u003e Deserialize\u003c'de\u003e,\r\n    Standard: Distribution\u003cP::Value\u003e,\r\n{\r\n    type ProverData\u003cM\u003e =\r\n        MerkleTree\u003cP::Value, PW::Value, HorizontalPair\u003cM, RowMajorMatrix\u003cP::Value\u003e\u003e, DIGEST_ELEMS\u003e;\r\n    type Commitment = Hash\u003cP::Value, PW::Value, DIGEST_ELEMS\u003e;\r\n    /// The first item is salts; the second is the usual Merkle proof (sibling digests).\r\n    type Proof = (Vec\u003cVec\u003cP::Value\u003e\u003e, Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e);\r\n    type Error = MerkleTreeError;\r\n\r\n    fn commit\u003cM: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        inputs: Vec\u003cM\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData\u003cM\u003e) {\r\n        let salted_inputs = inputs\r\n            .into_iter()\r\n            .map(|mat| {\r\n                let salts =\r\n                    RowMajorMatrix::rand(\u0026mut *self.rng.borrow_mut(), mat.height(), SALT_ELEMS);\r\n                HorizontalPair::new(mat, salts)\r\n            })\r\n            .collect();\r\n        self.inner.commit(salted_inputs)\r\n    }\r\n\r\n    fn open_batch\u003cM: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        index: usize,\r\n        prover_data: \u0026Self::ProverData\u003cM\u003e,\r\n    ) -\u003e (\r\n        Vec\u003cVec\u003cP::Value\u003e\u003e,\r\n        (Vec\u003cVec\u003cP::Value\u003e\u003e, Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e),\r\n    ) {\r\n        let (salted_openings, siblings) = self.inner.open_batch(index, prover_data);\r\n        let (openings, salts): (Vec\u003c_\u003e, Vec\u003c_\u003e) = salted_openings\r\n            .into_iter()\r\n            .map(|row| {\r\n                let (a, b) = row.split_at(row.len() - SALT_ELEMS);\r\n                (a.to_vec(), b.to_vec())\r\n            })\r\n            .unzip();\r\n        (openings, (salts, siblings))\r\n    }\r\n\r\n    fn get_matrices\u003c'a, M: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData\u003cM\u003e,\r\n    ) -\u003e Vec\u003c\u0026'a M\u003e {\r\n        prover_data.leaves.iter().map(|mat| \u0026mat.first).collect()\r\n    }\r\n\r\n    fn verify_batch(\r\n        \u0026self,\r\n        commit: \u0026Self::Commitment,\r\n        dimensions: \u0026[Dimensions],\r\n        index: usize,\r\n        opened_values: \u0026[Vec\u003cP::Value\u003e],\r\n        proof: \u0026Self::Proof,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        let (salts, siblings) = proof;\r\n\r\n        let opened_salted_values = opened_values\r\n            .iter()\r\n            .zip(salts.iter())\r\n            .map(|(opened, salt)| opened.iter().chain(salt.iter()).copied().collect_vec())\r\n            .collect_vec();\r\n\r\n        self.inner\r\n            .verify_batch(commit, dimensions, index, \u0026opened_salted_values, siblings)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n\r\n    use itertools::Itertools;\r\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\n    use p3_commit::Mmcs;\r\n    use p3_field::{Field, PrimeCharacteristicRing};\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use p3_matrix::Matrix;\r\n    use p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\r\n    use rand::prelude::*;\r\n\r\n    use super::MerkleTreeHidingMmcs;\r\n    use crate::MerkleTreeError;\r\n\r\n    type F = BabyBear;\r\n    const SALT_ELEMS: usize = 4;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n    type MyMmcs = MerkleTreeHidingMmcs\u003c\r\n        \u003cF as Field\u003e::Packing,\r\n        \u003cF as Field\u003e::Packing,\r\n        MyHash,\r\n        MyCompress,\r\n        ThreadRng,\r\n        8,\r\n        SALT_ELEMS,\r\n    \u003e;\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mismatched_heights() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress, thread_rng());\r\n\r\n        // attempt to commit to a mat with 8 rows and a mat with 7 rows. this should panic.\r\n        let large_mat = RowMajorMatrix::new([1, 2, 3, 4, 5, 6, 7, 8].map(F::from_u8).to_vec(), 1);\r\n        let small_mat = RowMajorMatrix::new([1, 2, 3, 4, 5, 6, 7].map(F::from_u8).to_vec(), 1);\r\n        let _ = mmcs.commit(vec![large_mat, small_mat]);\r\n    }\r\n\r\n    #[test]\r\n    fn different_widths() -\u003e Result\u003c(), MerkleTreeError\u003e {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress, thread_rng());\r\n\r\n        // 10 mats with 32 rows where the ith mat has i + 1 cols\r\n        let mats = (0..10)\r\n            .map(|i| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 32, i + 1))\r\n            .collect_vec();\r\n        let dims = mats.iter().map(|m| m.dimensions()).collect_vec();\r\n\r\n        let (commit, prover_data) = mmcs.commit(mats);\r\n        let (opened_values, proof) = mmcs.open_batch(17, \u0026prover_data);\r\n        mmcs.verify_batch(\u0026commit, \u0026dims, 17, \u0026opened_values, \u0026proof)\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":84,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":87,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":88,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":89,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":95,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":107,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":108,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":129,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":131,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":133,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":134,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":137,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":138,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":24,"coverable":26},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","merkle-tree","src","lib.rs"],"content":"#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod hiding_mmcs;\r\nmod merkle_tree;\r\nmod mmcs;\r\n\r\npub use hiding_mmcs::*;\r\npub use merkle_tree::*;\r\npub use mmcs::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","merkle-tree","src","merkle_tree.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::array;\r\nuse core::cmp::Reverse;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::PackedValue;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_symmetric::{CryptographicHasher, Hash, PseudoCompressionFunction};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::instrument;\r\n\r\n/// A binary Merkle tree for packed data. It has leaves of type `F` and digests of type\r\n/// `[W; DIGEST_ELEMS]`.\r\n///\r\n/// This generally shouldn't be used directly. If you're using a Merkle tree as an MMCS,\r\n/// see `MerkleTreeMmcs`.\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct MerkleTree\u003cF, W, M, const DIGEST_ELEMS: usize\u003e {\r\n    pub(crate) leaves: Vec\u003cM\u003e,\r\n    // Enable serialization for this type whenever the underlying array type supports it (len 1-32).\r\n    #[serde(bound(serialize = \"[W; DIGEST_ELEMS]: Serialize\"))]\r\n    // Enable deserialization for this type whenever the underlying array type supports it (len 1-32).\r\n    #[serde(bound(deserialize = \"[W; DIGEST_ELEMS]: Deserialize\u003c'de\u003e\"))]\r\n    pub(crate) digest_layers: Vec\u003cVec\u003c[W; DIGEST_ELEMS]\u003e\u003e,\r\n    _phantom: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF: Clone + Send + Sync, W: Clone, M: Matrix\u003cF\u003e, const DIGEST_ELEMS: usize\u003e\r\n    MerkleTree\u003cF, W, M, DIGEST_ELEMS\u003e\r\n{\r\n    /// Matrix heights need not be powers of two. However, if the heights of two given matrices\r\n    /// round up to the same power of two, they must be equal.\r\n    #[instrument(name = \"build merkle tree\", level = \"debug\", skip_all,\r\n                 fields(dimensions = alloc::format!(\"{:?}\", leaves.iter().map(|l| l.dimensions()).collect::\u003cVec\u003c_\u003e\u003e())))]\r\n    pub fn new\u003cP, PW, H, C\u003e(h: \u0026H, c: \u0026C, leaves: Vec\u003cM\u003e) -\u003e Self\r\n    where\r\n        P: PackedValue\u003cValue = F\u003e,\r\n        PW: PackedValue\u003cValue = W\u003e,\r\n        H: CryptographicHasher\u003cF, [W; DIGEST_ELEMS]\u003e,\r\n        H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n        H: Sync,\r\n        C: PseudoCompressionFunction\u003c[W; DIGEST_ELEMS], 2\u003e,\r\n        C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n        C: Sync,\r\n    {\r\n        assert!(!leaves.is_empty(), \"No matrices given?\");\r\n\r\n        assert_eq!(P::WIDTH, PW::WIDTH, \"Packing widths must match\");\r\n\r\n        let mut leaves_largest_first = leaves\r\n            .iter()\r\n            .sorted_by_key(|l| Reverse(l.height()))\r\n            .peekable();\r\n\r\n        // check height property\r\n        assert!(\r\n            leaves_largest_first\r\n                .clone()\r\n                .map(|m| m.height())\r\n                .tuple_windows()\r\n                .all(|(curr, next)| curr == next\r\n                    || curr.next_power_of_two() != next.next_power_of_two()),\r\n            \"matrix heights that round up to the same power of two must be equal\"\r\n        );\r\n\r\n        let max_height = leaves_largest_first.peek().unwrap().height();\r\n        let tallest_matrices = leaves_largest_first\r\n            .peeking_take_while(|m| m.height() == max_height)\r\n            .collect_vec();\r\n\r\n        let mut digest_layers = vec![first_digest_layer::\u003cP, PW, H, M, DIGEST_ELEMS\u003e(\r\n            h,\r\n            tallest_matrices,\r\n        )];\r\n        loop {\r\n            let prev_layer = digest_layers.last().unwrap().as_slice();\r\n            if prev_layer.len() == 1 {\r\n                break;\r\n            }\r\n            let next_layer_len = (prev_layer.len() / 2).next_power_of_two();\r\n\r\n            // The matrices that get injected at this layer.\r\n            let matrices_to_inject = leaves_largest_first\r\n                .peeking_take_while(|m| m.height().next_power_of_two() == next_layer_len)\r\n                .collect_vec();\r\n\r\n            let next_digests = compress_and_inject::\u003cP, PW, H, C, M, DIGEST_ELEMS\u003e(\r\n                prev_layer,\r\n                matrices_to_inject,\r\n                h,\r\n                c,\r\n            );\r\n            digest_layers.push(next_digests);\r\n        }\r\n\r\n        Self {\r\n            leaves,\r\n            digest_layers,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    pub fn root(\u0026self) -\u003e Hash\u003cF, W, DIGEST_ELEMS\u003e\r\n    where\r\n        W: Copy,\r\n    {\r\n        self.digest_layers.last().unwrap()[0].into()\r\n    }\r\n}\r\n\r\n#[instrument(name = \"first digest layer\", level = \"debug\", skip_all)]\r\nfn first_digest_layer\u003cP, PW, H, M, const DIGEST_ELEMS: usize\u003e(\r\n    h: \u0026H,\r\n    tallest_matrices: Vec\u003c\u0026M\u003e,\r\n) -\u003e Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e\r\nwhere\r\n    P: PackedValue,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Value, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    M: Matrix\u003cP::Value\u003e,\r\n{\r\n    let width = PW::WIDTH;\r\n    let max_height = tallest_matrices[0].height();\r\n    // we always want to return an even number of digests, except when it's the root.\r\n    let max_height_padded = if max_height == 1 {\r\n        1\r\n    } else {\r\n        max_height + max_height % 2\r\n    };\r\n\r\n    let default_digest: [PW::Value; DIGEST_ELEMS] = [PW::Value::default(); DIGEST_ELEMS];\r\n    let mut digests = vec![default_digest; max_height_padded];\r\n\r\n    digests[0..max_height]\r\n        .par_chunks_exact_mut(width)\r\n        .enumerate()\r\n        .for_each(|(i, digests_chunk)| {\r\n            let first_row = i * width;\r\n            let packed_digest: [PW; DIGEST_ELEMS] = h.hash_iter(\r\n                tallest_matrices\r\n                    .iter()\r\n                    .flat_map(|m| m.vertically_packed_row(first_row)),\r\n            );\r\n            for (dst, src) in digests_chunk.iter_mut().zip(unpack_array(packed_digest)) {\r\n                *dst = src;\r\n            }\r\n        });\r\n\r\n    // If our packing width did not divide max_height, fall back to single-threaded scalar code\r\n    // for the last bit.\r\n    #[allow(clippy::needless_range_loop)]\r\n    for i in (max_height / width * width)..max_height {\r\n        digests[i] = h.hash_iter(tallest_matrices.iter().flat_map(|m| m.row(i)));\r\n    }\r\n\r\n    // Everything has been initialized so we can safely cast.\r\n    digests\r\n}\r\n\r\n/// Compress `n` digests from the previous layer into `n/2` digests, while potentially mixing in\r\n/// some leaf data, if there are input matrices with (padded) height `n/2`.\r\nfn compress_and_inject\u003cP, PW, H, C, M, const DIGEST_ELEMS: usize\u003e(\r\n    prev_layer: \u0026[[PW::Value; DIGEST_ELEMS]],\r\n    matrices_to_inject: Vec\u003c\u0026M\u003e,\r\n    h: \u0026H,\r\n    c: \u0026C,\r\n) -\u003e Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e\r\nwhere\r\n    P: PackedValue,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Value, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    C: PseudoCompressionFunction\u003c[PW::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n    M: Matrix\u003cP::Value\u003e,\r\n{\r\n    if matrices_to_inject.is_empty() {\r\n        return compress::\u003cPW, C, DIGEST_ELEMS\u003e(prev_layer, c);\r\n    }\r\n\r\n    let width = PW::WIDTH;\r\n    let next_len = matrices_to_inject[0].height();\r\n    // We always want to return an even number of digests, except when it's the root.\r\n    let next_len_padded = if prev_layer.len() == 2 {\r\n        1\r\n    } else {\r\n        (prev_layer.len() / 2 + 1) \u0026 !1\r\n    };\r\n\r\n    let default_digest: [PW::Value; DIGEST_ELEMS] = [PW::Value::default(); DIGEST_ELEMS];\r\n    let mut next_digests = vec![default_digest; next_len_padded];\r\n    next_digests[0..next_len]\r\n        .par_chunks_exact_mut(width)\r\n        .enumerate()\r\n        .for_each(|(i, digests_chunk)| {\r\n            let first_row = i * width;\r\n            let left = array::from_fn(|j| PW::from_fn(|k| prev_layer[2 * (first_row + k)][j]));\r\n            let right = array::from_fn(|j| PW::from_fn(|k| prev_layer[2 * (first_row + k) + 1][j]));\r\n            let mut packed_digest = c.compress([left, right]);\r\n            let tallest_digest = h.hash_iter(\r\n                matrices_to_inject\r\n                    .iter()\r\n                    .flat_map(|m| m.vertically_packed_row(first_row)),\r\n            );\r\n            packed_digest = c.compress([packed_digest, tallest_digest]);\r\n            for (dst, src) in digests_chunk.iter_mut().zip(unpack_array(packed_digest)) {\r\n                *dst = src;\r\n            }\r\n        });\r\n\r\n    // If our packing width did not divide next_len, fall back to single-threaded scalar code\r\n    // for the last bit.\r\n    for i in (next_len / width * width)..next_len {\r\n        let left = prev_layer[2 * i];\r\n        let right = prev_layer[2 * i + 1];\r\n        let digest = c.compress([left, right]);\r\n        let rows_digest = h.hash_iter(matrices_to_inject.iter().flat_map(|m| m.row(i)));\r\n        next_digests[i] = c.compress([digest, rows_digest]);\r\n    }\r\n\r\n    // At this point, we've exceeded the height of the matrices to inject, so we continue the\r\n    // process above except with default_digest in place of an input digest.\r\n    // We only need go as far as half the length of the previous layer.\r\n    for i in next_len..(prev_layer.len() / 2) {\r\n        let left = prev_layer[2 * i];\r\n        let right = prev_layer[2 * i + 1];\r\n        let digest = c.compress([left, right]);\r\n        next_digests[i] = c.compress([digest, default_digest]);\r\n    }\r\n\r\n    next_digests\r\n}\r\n\r\n/// Compress `n` digests from the previous layer into `n/2` digests.\r\nfn compress\u003cP, C, const DIGEST_ELEMS: usize\u003e(\r\n    prev_layer: \u0026[[P::Value; DIGEST_ELEMS]],\r\n    c: \u0026C,\r\n) -\u003e Vec\u003c[P::Value; DIGEST_ELEMS]\u003e\r\nwhere\r\n    P: PackedValue,\r\n    C: PseudoCompressionFunction\u003c[P::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[P; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n{\r\n    let width = P::WIDTH;\r\n    // Always return an even number of digests, except when it's the root.\r\n    let next_len_padded = if prev_layer.len() == 2 {\r\n        1\r\n    } else {\r\n        (prev_layer.len() / 2 + 1) \u0026 !1\r\n    };\r\n    let next_len = prev_layer.len() / 2;\r\n\r\n    let default_digest: [P::Value; DIGEST_ELEMS] = [P::Value::default(); DIGEST_ELEMS];\r\n    let mut next_digests = vec![default_digest; next_len_padded];\r\n\r\n    next_digests[0..next_len]\r\n        .par_chunks_exact_mut(width)\r\n        .enumerate()\r\n        .for_each(|(i, digests_chunk)| {\r\n            let first_row = i * width;\r\n            let left = array::from_fn(|j| P::from_fn(|k| prev_layer[2 * (first_row + k)][j]));\r\n            let right = array::from_fn(|j| P::from_fn(|k| prev_layer[2 * (first_row + k) + 1][j]));\r\n            let packed_digest = c.compress([left, right]);\r\n            for (dst, src) in digests_chunk.iter_mut().zip(unpack_array(packed_digest)) {\r\n                *dst = src;\r\n            }\r\n        });\r\n\r\n    // If our packing width did not divide next_len, fall back to single-threaded scalar code\r\n    // for the last bit.\r\n    for i in (next_len / width * width)..next_len {\r\n        let left = prev_layer[2 * i];\r\n        let right = prev_layer[2 * i + 1];\r\n        next_digests[i] = c.compress([left, right]);\r\n    }\r\n\r\n    // Everything has been initialized so we can safely cast.\r\n    next_digests\r\n}\r\n\r\n/// Converts a packed array `[P; N]` into its underlying `P::WIDTH` scalar arrays.\r\n#[inline]\r\nfn unpack_array\u003cP: PackedValue, const N: usize\u003e(\r\n    packed_digest: [P; N],\r\n) -\u003e impl Iterator\u003cItem = [P::Value; N]\u003e {\r\n    (0..P::WIDTH).map(move |j| packed_digest.map(|p| p.as_slice()[j]))\r\n}\r\n","traces":[{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":8791026472627208191}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":11024811887802974207}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":4395513236313604095}},{"line":65,"address":[],"length":0,"stats":{"Line":4971973988617027582}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":9511602413006487551}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":2161727821137838079}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":111,"address":[],"length":0,"stats":{"Line":16285016252571713537}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":9367487224930631739}},{"line":144,"address":[],"length":0,"stats":{"Line":9367487224930631739}},{"line":145,"address":[],"length":0,"stats":{"Line":9367487224930631739}},{"line":146,"address":[],"length":0,"stats":{"Line":9367487224930631739}},{"line":147,"address":[],"length":0,"stats":{"Line":9367487224930631739}},{"line":148,"address":[],"length":0,"stats":{"Line":5476377146882524530}},{"line":150,"address":[],"length":0,"stats":{"Line":13690942867206307927}},{"line":151,"address":[],"length":0,"stats":{"Line":2161727821137838094}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":2089670227099910301}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":17798225727368200191}},{"line":185,"address":[],"length":0,"stats":{"Line":17798225727368200191}},{"line":186,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":189,"address":[],"length":0,"stats":{"Line":432345564227567615}},{"line":190,"address":[],"length":0,"stats":{"Line":432345564227567615}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":195,"address":[],"length":0,"stats":{"Line":360287970189639679}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":204,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":205,"address":[],"length":0,"stats":{"Line":13979173243358026944}},{"line":206,"address":[],"length":0,"stats":{"Line":13979173243358022261}},{"line":207,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":208,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":209,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":210,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":211,"address":[],"length":0,"stats":{"Line":4611686018427387901}},{"line":213,"address":[],"length":0,"stats":{"Line":648518346341351423}},{"line":214,"address":[],"length":0,"stats":{"Line":11024811887802974205}},{"line":215,"address":[],"length":0,"stats":{"Line":5188146770730811391}},{"line":221,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":222,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":223,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":224,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":225,"address":[],"length":0,"stats":{"Line":5620492334958379080}},{"line":226,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":232,"address":[],"length":0,"stats":{"Line":8358680908399640575}},{"line":233,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":234,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":235,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":236,"address":[],"length":0,"stats":{"Line":3963167672086036480}},{"line":239,"address":[],"length":0,"stats":{"Line":432345564227567615}},{"line":243,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":253,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":255,"address":[],"length":0,"stats":{"Line":16285016252571713534}},{"line":256,"address":[],"length":0,"stats":{"Line":16140901064495857673}},{"line":258,"address":[],"length":0,"stats":{"Line":11024811887802974207}},{"line":260,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":262,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":263,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":265,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":266,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":268,"address":[],"length":0,"stats":{"Line":3819052484010180605}},{"line":269,"address":[],"length":0,"stats":{"Line":4899916394579099646}},{"line":270,"address":[],"length":0,"stats":{"Line":6341068275337661135}},{"line":271,"address":[],"length":0,"stats":{"Line":6341068275337665857}},{"line":272,"address":[],"length":0,"stats":{"Line":4899916394579099646}},{"line":273,"address":[],"length":0,"stats":{"Line":2882303761517117504}},{"line":274,"address":[],"length":0,"stats":{"Line":8214565720323784737}},{"line":280,"address":[],"length":0,"stats":{"Line":14051230837395947523}},{"line":281,"address":[],"length":0,"stats":{"Line":16789419410837209090}},{"line":282,"address":[],"length":0,"stats":{"Line":16789419410837209090}},{"line":283,"address":[],"length":0,"stats":{"Line":16789419410837209090}},{"line":287,"address":[],"length":0,"stats":{"Line":17365880163140632575}},{"line":292,"address":[],"length":0,"stats":{"Line":14915921965851082778}},{"line":295,"address":[],"length":0,"stats":{"Line":2305843009213695947}}],"covered":72,"coverable":112},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","merkle-tree","src","mmcs.rs"],"content":"use alloc::vec::Vec;\r\nuse core::cmp::Reverse;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::Itertools;\r\nuse p3_commit::Mmcs;\r\nuse p3_field::PackedValue;\r\nuse p3_matrix::{Dimensions, Matrix};\r\nuse p3_symmetric::{CryptographicHasher, Hash, PseudoCompressionFunction};\r\nuse p3_util::log2_ceil_usize;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::MerkleTree;\r\nuse crate::MerkleTreeError::{EmptyBatch, RootMismatch, WrongBatchSize, WrongHeight};\r\n\r\n/// A vector commitment scheme backed by a `MerkleTree`.\r\n///\r\n/// Generics:\r\n/// - `P`: a leaf value\r\n/// - `PW`: an element of a digest\r\n/// - `H`: the leaf hasher\r\n/// - `C`: the digest compression function\r\n#[derive(Copy, Clone, Debug)]\r\npub struct MerkleTreeMmcs\u003cP, PW, H, C, const DIGEST_ELEMS: usize\u003e {\r\n    hash: H,\r\n    compress: C,\r\n    _phantom: PhantomData\u003c(P, PW)\u003e,\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum MerkleTreeError {\r\n    WrongBatchSize,\r\n    WrongWidth,\r\n    WrongHeight {\r\n        max_height: usize,\r\n        num_siblings: usize,\r\n    },\r\n    RootMismatch,\r\n    EmptyBatch,\r\n}\r\n\r\nimpl\u003cP, PW, H, C, const DIGEST_ELEMS: usize\u003e MerkleTreeMmcs\u003cP, PW, H, C, DIGEST_ELEMS\u003e {\r\n    pub const fn new(hash: H, compress: C) -\u003e Self {\r\n        Self {\r\n            hash,\r\n            compress,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cP, PW, H, C, const DIGEST_ELEMS: usize\u003e Mmcs\u003cP::Value\u003e\r\n    for MerkleTreeMmcs\u003cP, PW, H, C, DIGEST_ELEMS\u003e\r\nwhere\r\n    P: PackedValue,\r\n    PW: PackedValue,\r\n    H: CryptographicHasher\u003cP::Value, [PW::Value; DIGEST_ELEMS]\u003e,\r\n    H: CryptographicHasher\u003cP, [PW; DIGEST_ELEMS]\u003e,\r\n    H: Sync,\r\n    C: PseudoCompressionFunction\u003c[PW::Value; DIGEST_ELEMS], 2\u003e,\r\n    C: PseudoCompressionFunction\u003c[PW; DIGEST_ELEMS], 2\u003e,\r\n    C: Sync,\r\n    PW::Value: Eq,\r\n    [PW::Value; DIGEST_ELEMS]: Serialize + for\u003c'de\u003e Deserialize\u003c'de\u003e,\r\n{\r\n    type ProverData\u003cM\u003e = MerkleTree\u003cP::Value, PW::Value, M, DIGEST_ELEMS\u003e;\r\n    type Commitment = Hash\u003cP::Value, PW::Value, DIGEST_ELEMS\u003e;\r\n    type Proof = Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e;\r\n    type Error = MerkleTreeError;\r\n\r\n    fn commit\u003cM: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        inputs: Vec\u003cM\u003e,\r\n    ) -\u003e (Self::Commitment, Self::ProverData\u003cM\u003e) {\r\n        let tree = MerkleTree::new::\u003cP, PW, H, C\u003e(\u0026self.hash, \u0026self.compress, inputs);\r\n        let root = tree.root();\r\n        (root, tree)\r\n    }\r\n\r\n    fn open_batch\u003cM: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        index: usize,\r\n        prover_data: \u0026MerkleTree\u003cP::Value, PW::Value, M, DIGEST_ELEMS\u003e,\r\n    ) -\u003e (Vec\u003cVec\u003cP::Value\u003e\u003e, Vec\u003c[PW::Value; DIGEST_ELEMS]\u003e) {\r\n        let max_height = self.get_max_height(prover_data);\r\n        let log_max_height = log2_ceil_usize(max_height);\r\n\r\n        let openings = prover_data\r\n            .leaves\r\n            .iter()\r\n            .map(|matrix| {\r\n                let log2_height = log2_ceil_usize(matrix.height());\r\n                let bits_reduced = log_max_height - log2_height;\r\n                let reduced_index = index \u003e\u003e bits_reduced;\r\n                matrix.row(reduced_index).collect()\r\n            })\r\n            .collect_vec();\r\n\r\n        let proof: Vec\u003c_\u003e = (0..log_max_height)\r\n            .map(|i| prover_data.digest_layers[i][(index \u003e\u003e i) ^ 1])\r\n            .collect();\r\n\r\n        (openings, proof)\r\n    }\r\n\r\n    fn get_matrices\u003c'a, M: Matrix\u003cP::Value\u003e\u003e(\r\n        \u0026self,\r\n        prover_data: \u0026'a Self::ProverData\u003cM\u003e,\r\n    ) -\u003e Vec\u003c\u0026'a M\u003e {\r\n        prover_data.leaves.iter().collect()\r\n    }\r\n\r\n    fn verify_batch(\r\n        \u0026self,\r\n        commit: \u0026Self::Commitment,\r\n        dimensions: \u0026[Dimensions],\r\n        mut index: usize,\r\n        opened_values: \u0026[Vec\u003cP::Value\u003e],\r\n        proof: \u0026Self::Proof,\r\n    ) -\u003e Result\u003c(), Self::Error\u003e {\r\n        // Check that the openings have the correct shape.\r\n        if dimensions.len() != opened_values.len() {\r\n            return Err(WrongBatchSize);\r\n        }\r\n\r\n        // TODO: Disabled for now since TwoAdicFriPcs and CirclePcs currently pass 0 for width.\r\n        // for (dims, opened_vals) in dimensions.iter().zip(opened_values) {\r\n        //     if opened_vals.len() != dims.width {\r\n        //         return Err(WrongWidth);\r\n        //     }\r\n        // }\r\n\r\n        // TODO: Disabled for now, CirclePcs sometimes passes a height that's off by 1 bit.\r\n        let Some(max_height) = dimensions.iter().map(|dim| dim.height).max() else {\r\n            // dimensions is empty\r\n            return Err(EmptyBatch);\r\n        };\r\n        let log_max_height = log2_ceil_usize(max_height);\r\n        if proof.len() != log_max_height {\r\n            return Err(WrongHeight {\r\n                max_height,\r\n                num_siblings: proof.len(),\r\n            });\r\n        }\r\n\r\n        let mut heights_tallest_first = dimensions\r\n            .iter()\r\n            .enumerate()\r\n            .sorted_by_key(|(_, dims)| Reverse(dims.height))\r\n            .peekable();\r\n\r\n        let Some(mut curr_height_padded) = heights_tallest_first\r\n            .peek()\r\n            .map(|x| x.1.height.next_power_of_two())\r\n        else {\r\n            // dimensions is empty\r\n            return Err(EmptyBatch);\r\n        };\r\n\r\n        let mut root = self.hash.hash_iter_slices(\r\n            heights_tallest_first\r\n                .peeking_take_while(|(_, dims)| {\r\n                    dims.height.next_power_of_two() == curr_height_padded\r\n                })\r\n                .map(|(i, _)| opened_values[i].as_slice()),\r\n        );\r\n\r\n        for \u0026sibling in proof.iter() {\r\n            let (left, right) = if index \u0026 1 == 0 {\r\n                (root, sibling)\r\n            } else {\r\n                (sibling, root)\r\n            };\r\n\r\n            root = self.compress.compress([left, right]);\r\n            index \u003e\u003e= 1;\r\n            curr_height_padded \u003e\u003e= 1;\r\n\r\n            let next_height = heights_tallest_first\r\n                .peek()\r\n                .map(|(_, dims)| dims.height)\r\n                .filter(|h| h.next_power_of_two() == curr_height_padded);\r\n            if let Some(next_height) = next_height {\r\n                let next_height_openings_digest = self.hash.hash_iter_slices(\r\n                    heights_tallest_first\r\n                        .peeking_take_while(|(_, dims)| dims.height == next_height)\r\n                        .map(|(i, _)| opened_values[i].as_slice()),\r\n                );\r\n\r\n                root = self.compress.compress([root, next_height_openings_digest]);\r\n            }\r\n        }\r\n\r\n        if commit == \u0026root {\r\n            Ok(())\r\n        } else {\r\n            Err(RootMismatch)\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n\r\n    use itertools::Itertools;\r\n    use p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\n    use p3_commit::Mmcs;\r\n    use p3_field::{Field, PrimeCharacteristicRing};\r\n    use p3_matrix::dense::RowMajorMatrix;\r\n    use p3_matrix::{Dimensions, Matrix};\r\n    use p3_symmetric::{\r\n        CryptographicHasher, PaddingFreeSponge, PseudoCompressionFunction, TruncatedPermutation,\r\n    };\r\n    use rand::thread_rng;\r\n\r\n    use super::MerkleTreeMmcs;\r\n\r\n    type F = BabyBear;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n    type MyMmcs =\r\n        MerkleTreeMmcs\u003c\u003cF as Field\u003e::Packing, \u003cF as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\r\n\r\n    #[test]\r\n    fn commit_single_1x8() {\r\n        let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash.clone(), compress.clone());\r\n\r\n        // v = [2, 1, 2, 2, 0, 0, 1, 0]\r\n        let v = vec![\r\n            F::TWO,\r\n            F::ONE,\r\n            F::TWO,\r\n            F::TWO,\r\n            F::ZERO,\r\n            F::ZERO,\r\n            F::ONE,\r\n            F::ZERO,\r\n        ];\r\n        let (commit, _) = mmcs.commit_vec(v.clone());\r\n\r\n        let expected_result = compress.compress([\r\n            compress.compress([\r\n                compress.compress([hash.hash_item(v[0]), hash.hash_item(v[1])]),\r\n                compress.compress([hash.hash_item(v[2]), hash.hash_item(v[3])]),\r\n            ]),\r\n            compress.compress([\r\n                compress.compress([hash.hash_item(v[4]), hash.hash_item(v[5])]),\r\n                compress.compress([hash.hash_item(v[6]), hash.hash_item(v[7])]),\r\n            ]),\r\n        ]);\r\n        assert_eq!(commit, expected_result);\r\n    }\r\n\r\n    #[test]\r\n    fn commit_single_8x1() {\r\n        let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash.clone(), compress.clone());\r\n\r\n        let mat = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1, 8);\r\n        let (commit, _) = mmcs.commit(vec![mat.clone()]);\r\n\r\n        let expected_result = hash.hash_iter(mat.clone().vertically_packed_row(0));\r\n        assert_eq!(commit, expected_result);\r\n    }\r\n\r\n    #[test]\r\n    fn commit_single_2x2() {\r\n        let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash.clone(), compress.clone());\r\n\r\n        // mat = [\r\n        //   0 1\r\n        //   2 1\r\n        // ]\r\n        let mat = RowMajorMatrix::new(vec![F::ZERO, F::ONE, F::TWO, F::ONE], 2);\r\n\r\n        let (commit, _) = mmcs.commit(vec![mat]);\r\n\r\n        let expected_result = compress.compress([\r\n            hash.hash_slice(\u0026[F::ZERO, F::ONE]),\r\n            hash.hash_slice(\u0026[F::TWO, F::ONE]),\r\n        ]);\r\n        assert_eq!(commit, expected_result);\r\n    }\r\n\r\n    #[test]\r\n    fn commit_single_2x3() {\r\n        let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash.clone(), compress.clone());\r\n        let default_digest = [F::ZERO; 8];\r\n\r\n        // mat = [\r\n        //   0 1\r\n        //   2 1\r\n        //   2 2\r\n        // ]\r\n        let mat = RowMajorMatrix::new(vec![F::ZERO, F::ONE, F::TWO, F::ONE, F::TWO, F::TWO], 2);\r\n\r\n        let (commit, _) = mmcs.commit(vec![mat]);\r\n\r\n        let expected_result = compress.compress([\r\n            compress.compress([\r\n                hash.hash_slice(\u0026[F::ZERO, F::ONE]),\r\n                hash.hash_slice(\u0026[F::TWO, F::ONE]),\r\n            ]),\r\n            compress.compress([hash.hash_slice(\u0026[F::TWO, F::TWO]), default_digest]),\r\n        ]);\r\n        assert_eq!(commit, expected_result);\r\n    }\r\n\r\n    #[test]\r\n    fn commit_mixed() {\r\n        let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash.clone(), compress.clone());\r\n        let default_digest = [F::ZERO; 8];\r\n\r\n        // mat_1 = [\r\n        //   0 1\r\n        //   2 1\r\n        //   2 2\r\n        //   2 1\r\n        //   2 2\r\n        // ]\r\n        let mat_1 = RowMajorMatrix::new(\r\n            vec![\r\n                F::ZERO,\r\n                F::ONE,\r\n                F::TWO,\r\n                F::ONE,\r\n                F::TWO,\r\n                F::TWO,\r\n                F::TWO,\r\n                F::ONE,\r\n                F::TWO,\r\n                F::TWO,\r\n            ],\r\n            2,\r\n        );\r\n        // mat_2 = [\r\n        //   1 2 1\r\n        //   0 2 2\r\n        //   1 2 1\r\n        // ]\r\n        let mat_2 = RowMajorMatrix::new(\r\n            vec![\r\n                F::ONE,\r\n                F::TWO,\r\n                F::ONE,\r\n                F::ZERO,\r\n                F::TWO,\r\n                F::TWO,\r\n                F::ONE,\r\n                F::TWO,\r\n                F::ONE,\r\n            ],\r\n            3,\r\n        );\r\n\r\n        let (commit, prover_data) = mmcs.commit(vec![mat_1, mat_2]);\r\n\r\n        let mat_1_leaf_hashes = [\r\n            hash.hash_slice(\u0026[F::ZERO, F::ONE]),\r\n            hash.hash_slice(\u0026[F::TWO, F::ONE]),\r\n            hash.hash_slice(\u0026[F::TWO, F::TWO]),\r\n            hash.hash_slice(\u0026[F::TWO, F::ONE]),\r\n            hash.hash_slice(\u0026[F::TWO, F::TWO]),\r\n        ];\r\n        let mat_2_leaf_hashes = [\r\n            hash.hash_slice(\u0026[F::ONE, F::TWO, F::ONE]),\r\n            hash.hash_slice(\u0026[F::ZERO, F::TWO, F::TWO]),\r\n            hash.hash_slice(\u0026[F::ONE, F::TWO, F::ONE]),\r\n        ];\r\n\r\n        let expected_result = compress.compress([\r\n            compress.compress([\r\n                compress.compress([\r\n                    compress.compress([mat_1_leaf_hashes[0], mat_1_leaf_hashes[1]]),\r\n                    mat_2_leaf_hashes[0],\r\n                ]),\r\n                compress.compress([\r\n                    compress.compress([mat_1_leaf_hashes[2], mat_1_leaf_hashes[3]]),\r\n                    mat_2_leaf_hashes[1],\r\n                ]),\r\n            ]),\r\n            compress.compress([\r\n                compress.compress([\r\n                    compress.compress([mat_1_leaf_hashes[4], default_digest]),\r\n                    mat_2_leaf_hashes[2],\r\n                ]),\r\n                default_digest,\r\n            ]),\r\n        ]);\r\n\r\n        assert_eq!(commit, expected_result);\r\n\r\n        let (opened_values, _proof) = mmcs.open_batch(2, \u0026prover_data);\r\n        assert_eq!(\r\n            opened_values,\r\n            vec![vec![F::TWO, F::TWO], vec![F::ZERO, F::TWO, F::TWO]]\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn commit_either_order() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress);\r\n\r\n        let input_1 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 5, 8);\r\n        let input_2 = RowMajorMatrix::\u003cF\u003e::rand(\u0026mut rng, 3, 16);\r\n\r\n        let (commit_1_2, _) = mmcs.commit(vec![input_1.clone(), input_2.clone()]);\r\n        let (commit_2_1, _) = mmcs.commit(vec![input_2, input_1]);\r\n        assert_eq!(commit_1_2, commit_2_1);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn mismatched_heights() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress);\r\n\r\n        // attempt to commit to a mat with 8 rows and a mat with 7 rows. this should panic.\r\n        let large_mat = RowMajorMatrix::new([1, 2, 3, 4, 5, 6, 7, 8].map(F::from_u8).to_vec(), 1);\r\n        let small_mat = RowMajorMatrix::new([1, 2, 3, 4, 5, 6, 7].map(F::from_u8).to_vec(), 1);\r\n        let _ = mmcs.commit(vec![large_mat, small_mat]);\r\n    }\r\n\r\n    #[test]\r\n    fn verify_tampered_proof_fails() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress);\r\n\r\n        // 4 8x1 matrixes, 4 8x2 matrixes\r\n        let large_mats = (0..4).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 8, 1));\r\n        let large_mat_dims = (0..4).map(|_| Dimensions {\r\n            height: 8,\r\n            width: 1,\r\n        });\r\n        let small_mats = (0..4).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 8, 2));\r\n        let small_mat_dims = (0..4).map(|_| Dimensions {\r\n            height: 8,\r\n            width: 2,\r\n        });\r\n\r\n        let (commit, prover_data) = mmcs.commit(large_mats.chain(small_mats).collect_vec());\r\n\r\n        // open the 3rd row of each matrix, mess with proof, and verify\r\n        let (opened_values, mut proof) = mmcs.open_batch(3, \u0026prover_data);\r\n        proof[0][0] += F::ONE;\r\n        mmcs.verify_batch(\r\n            \u0026commit,\r\n            \u0026large_mat_dims.chain(small_mat_dims).collect_vec(),\r\n            3,\r\n            \u0026opened_values,\r\n            \u0026proof,\r\n        )\r\n        .expect_err(\"expected verification to fail\");\r\n    }\r\n\r\n    #[test]\r\n    fn size_gaps() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress);\r\n\r\n        // 4 mats with 1000 rows, 8 columns\r\n        let large_mats = (0..4).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1000, 8));\r\n        let large_mat_dims = (0..4).map(|_| Dimensions {\r\n            height: 1000,\r\n            width: 8,\r\n        });\r\n\r\n        // 5 mats with 70 rows, 8 columns\r\n        let medium_mats = (0..5).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 70, 8));\r\n        let medium_mat_dims = (0..5).map(|_| Dimensions {\r\n            height: 70,\r\n            width: 8,\r\n        });\r\n\r\n        // 6 mats with 8 rows, 8 columns\r\n        let small_mats = (0..6).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 8, 8));\r\n        let small_mat_dims = (0..6).map(|_| Dimensions {\r\n            height: 8,\r\n            width: 8,\r\n        });\r\n\r\n        // 7 tiny mat with 1 row, 8 columns\r\n        let tiny_mats = (0..7).map(|_| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 1, 8));\r\n        let tiny_mat_dims = (0..7).map(|_| Dimensions {\r\n            height: 1,\r\n            width: 8,\r\n        });\r\n\r\n        let (commit, prover_data) = mmcs.commit(\r\n            large_mats\r\n                .chain(medium_mats)\r\n                .chain(small_mats)\r\n                .chain(tiny_mats)\r\n                .collect_vec(),\r\n        );\r\n\r\n        // open the 6th row of each matrix and verify\r\n        let (opened_values, proof) = mmcs.open_batch(6, \u0026prover_data);\r\n        mmcs.verify_batch(\r\n            \u0026commit,\r\n            \u0026large_mat_dims\r\n                .chain(medium_mat_dims)\r\n                .chain(small_mat_dims)\r\n                .chain(tiny_mat_dims)\r\n                .collect_vec(),\r\n            6,\r\n            \u0026opened_values,\r\n            \u0026proof,\r\n        )\r\n        .expect(\"expected verification to succeed\");\r\n    }\r\n\r\n    #[test]\r\n    fn different_widths() {\r\n        let mut rng = thread_rng();\r\n        let perm = Perm::new_from_rng_128(\u0026mut rng);\r\n        let hash = MyHash::new(perm.clone());\r\n        let compress = MyCompress::new(perm);\r\n        let mmcs = MyMmcs::new(hash, compress);\r\n\r\n        // 10 mats with 32 rows where the ith mat has i + 1 cols\r\n        let mats = (0..10)\r\n            .map(|i| RowMajorMatrix::\u003cF\u003e::rand(\u0026mut thread_rng(), 32, i + 1))\r\n            .collect_vec();\r\n        let dims = mats.iter().map(|m| m.dimensions()).collect_vec();\r\n\r\n        let (commit, prover_data) = mmcs.commit(mats);\r\n        let (opened_values, proof) = mmcs.open_batch(17, \u0026prover_data);\r\n        mmcs.verify_batch(\u0026commit, \u0026dims, 17, \u0026opened_values, \u0026proof)\r\n            .expect(\"expected verification to succeed\");\r\n    }\r\n}\r\n","traces":[{"line":43,"address":[],"length":0,"stats":{"Line":3386706919782613025}},{"line":71,"address":[],"length":0,"stats":{"Line":16429131440647569433}},{"line":75,"address":[],"length":0,"stats":{"Line":16429131440647569433}},{"line":76,"address":[],"length":0,"stats":{"Line":16429131440647569433}},{"line":77,"address":[],"length":0,"stats":{"Line":16429131440647569433}},{"line":80,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":85,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":86,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":88,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":89,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":91,"address":[],"length":0,"stats":{"Line":9871890383196127231}},{"line":92,"address":[],"length":0,"stats":{"Line":6629298651489370111}},{"line":93,"address":[],"length":0,"stats":{"Line":6629298651489370111}},{"line":94,"address":[],"length":0,"stats":{"Line":6629298651489370111}},{"line":95,"address":[],"length":0,"stats":{"Line":6629298651489370111}},{"line":99,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":100,"address":[],"length":0,"stats":{"Line":6341068275337658367}},{"line":103,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":106,"address":[],"length":0,"stats":{"Line":7349874591868649471}},{"line":110,"address":[],"length":0,"stats":{"Line":7349874591868649471}},{"line":113,"address":[],"length":0,"stats":{"Line":11817445422220181519}},{"line":122,"address":[],"length":0,"stats":{"Line":11817445422220181519}},{"line":123,"address":[],"length":0,"stats":{"Line":30}},{"line":134,"address":[],"length":0,"stats":{"Line":9367487224930631748}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":11817445422220181513}},{"line":149,"address":[],"length":0,"stats":{"Line":5188146770730811410}},{"line":152,"address":[],"length":0,"stats":{"Line":11817445422220181513}},{"line":154,"address":[],"length":0,"stats":{"Line":11817445422220181510}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":14195346025471803416}},{"line":163,"address":[],"length":0,"stats":{"Line":14195346025471803416}},{"line":165,"address":[],"length":0,"stats":{"Line":5188146770730811391}},{"line":168,"address":[],"length":0,"stats":{"Line":15204152342002794501}},{"line":169,"address":[],"length":0,"stats":{"Line":11961560610296037386}},{"line":170,"address":[],"length":0,"stats":{"Line":3674937295934324775}},{"line":172,"address":[],"length":0,"stats":{"Line":8430738502437568392}},{"line":175,"address":[],"length":0,"stats":{"Line":15204152342002794501}},{"line":176,"address":[],"length":0,"stats":{"Line":15204152342002794501}},{"line":177,"address":[],"length":0,"stats":{"Line":15204152342002794501}},{"line":179,"address":[],"length":0,"stats":{"Line":15204152342002794501}},{"line":181,"address":[],"length":0,"stats":{"Line":11529215046068469803}},{"line":182,"address":[],"length":0,"stats":{"Line":11529215046068469780}},{"line":183,"address":[],"length":0,"stats":{"Line":7061644215716937700}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":187,"address":[],"length":0,"stats":{"Line":11385099857992613904}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":11817445422220181503}},{"line":195,"address":[],"length":0,"stats":{"Line":11745387828182253567}},{"line":197,"address":[],"length":0,"stats":{"Line":72057594037927966}}],"covered":47,"coverable":60},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","benches","bench_field.rs"],"content":"use criterion::{criterion_group, criterion_main, BatchSize, Criterion};\r\nuse p3_field::PrimeCharacteristicRing;\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_add_latency, benchmark_add_throughput, benchmark_inv, benchmark_iter_sum,\r\n    benchmark_sub_latency, benchmark_sub_throughput,\r\n};\r\nuse p3_mersenne_31::Mersenne31;\r\n\r\ntype F = Mersenne31;\r\n\r\nfn bench_field(c: \u0026mut Criterion) {\r\n    let name = \"Mersenne31\";\r\n    const REPS: usize = 1000;\r\n    benchmark_inv::\u003cF\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 4, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 8, REPS\u003e(c, name);\r\n    benchmark_iter_sum::\u003cF, 12, REPS\u003e(c, name);\r\n\r\n    // Note that each round of throughput has 10 operations\r\n    // So we should have 10 * more repetitions for latency tests.\r\n    const L_REPS: usize = 10 * REPS;\r\n    benchmark_add_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_add_throughput::\u003cF, REPS\u003e(c, name);\r\n    benchmark_sub_latency::\u003cF, L_REPS\u003e(c, name);\r\n    benchmark_sub_throughput::\u003cF, REPS\u003e(c, name);\r\n\r\n    c.bench_function(\"5th_root\", |b| {\r\n        b.iter_batched(\r\n            rand::random::\u003cF\u003e,\r\n            |x| x.exp_u64(1717986917),\r\n            BatchSize::SmallInput,\r\n        )\r\n    });\r\n}\r\n\r\ncriterion_group!(mersenne31_arithmetics, bench_field);\r\ncriterion_main!(mersenne31_arithmetics);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","benches","extension.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse p3_field::extension::{BinomialExtensionField, Complex};\r\nuse p3_field_testing::bench_func::{\r\n    benchmark_inv, benchmark_mul_latency, benchmark_mul_throughput, benchmark_square,\r\n};\r\nuse p3_mersenne_31::Mersenne31;\r\n\r\ntype EF2 = BinomialExtensionField\u003cComplex\u003cMersenne31\u003e, 2\u003e;\r\ntype EF3 = BinomialExtensionField\u003cComplex\u003cMersenne31\u003e, 3\u003e;\r\n\r\nconst REPS: usize = 100;\r\nconst L_REPS: usize = 10 * REPS;\r\n\r\nfn bench_qudratic_extension(c: \u0026mut Criterion) {\r\n    let name = \"BinomialExtensionField\u003cMersenne31Complex\u003cMersenne31\u003e, 2\u003e\";\r\n    benchmark_square::\u003cEF2\u003e(c, name);\r\n    benchmark_inv::\u003cEF2\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cEF2, REPS\u003e(c, name);\r\n    benchmark_mul_latency::\u003cEF2, L_REPS\u003e(c, name);\r\n}\r\n\r\nfn bench_cubic_extension(c: \u0026mut Criterion) {\r\n    let name = \"BinomialExtensionField\u003cMersenne31Complex\u003cMersenne31\u003e, 3\u003e\";\r\n    benchmark_square::\u003cEF3\u003e(c, name);\r\n    benchmark_inv::\u003cEF3\u003e(c, name);\r\n    benchmark_mul_throughput::\u003cEF3, REPS\u003e(c, name);\r\n    benchmark_mul_latency::\u003cEF3, L_REPS\u003e(c, name);\r\n}\r\n\r\ncriterion_group!(bench_mersennecomplex_ef2, bench_qudratic_extension);\r\ncriterion_group!(bench_mersennecomplex_ef3, bench_cubic_extension);\r\n\r\ncriterion_main!(bench_mersennecomplex_ef2, bench_mersennecomplex_ef3);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","aarch64_neon","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\npub use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","aarch64_neon","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::aarch64::{self, uint32x4_t};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::exponentiation::exp_1717986917;\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Mersenne31;\r\n\r\nconst WIDTH: usize = 4;\r\nconst P: uint32x4_t = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7fffffff; WIDTH]) };\r\n\r\n/// Vectorized NEON implementation of `Mersenne31` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct PackedMersenne31Neon(pub [Mersenne31; WIDTH]);\r\n\r\nimpl PackedMersenne31Neon {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    fn to_vector(self) -\u003e uint32x4_t {\r\n        unsafe {\r\n            // Safety: `Mersenne31` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[Mersenne31; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `uint32x4_t`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMersenne31Neon` is `repr(transparent)` so it can be transmuted to\r\n            // `[Mersenne31; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid\r\n    /// `Mersenne31`.  In particular, each element of vector must be in `0..=P` (i.e. it fits in 31\r\n    /// bits).\r\n    unsafe fn from_vector(vector: uint32x4_t) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `Mersenne31` values. We must only reason about memory representations. `uint32x4_t` can\r\n        // be transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which\r\n        // can be transmuted to `[Mersenne31; WIDTH]` (since `Mersenne31` is `repr(transparent)`),\r\n        // which in turn can be transmuted to `PackedMersenne31Neon` (since `PackedMersenne31Neon`\r\n        // is also `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMersenne31\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: Mersenne31) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl Add for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns valid values when given valid values.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Mul for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns valid values when given valid values.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Neg for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg(val);\r\n        unsafe {\r\n            // Safety: `neg` returns valid values when given valid values.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Sub for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns valid values when given valid values.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n/// Given a `val` in `0, ..., 2 P`, return a `res` in `0, ..., P` such that `res = val (mod P)`\r\n#[inline]\r\n#[must_use]\r\nfn reduce_sum(val: uint32x4_t) -\u003e uint32x4_t {\r\n    // val is in 0, ..., 2 P. If val is in 0, ..., P - 1 then it is valid and\r\n    // u := (val - P) mod 2^32 is in P \u003cu 2^32 - P, ..., 2^32 - 1 and unsigned_min(val, u) = val as\r\n    // desired. If val is in P + 1, ..., 2 P, then u is in 1, ..., P \u003c P + 1 so u is valid, and\r\n    // unsigned_min(val, u) = u as desired. The remaining case of val = P, u = 0 is trivial.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let u = aarch64::vsubq_u32(val, P);\r\n        aarch64::vminq_u32(val, u)\r\n    }\r\n}\r\n\r\n/// Add two vectors of Mersenne-31 field elements that fit in 31 bits.\r\n/// If the inputs do not fit in 31 bits, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn add(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      add   t.4s, lhs.4s, rhs.4s\r\n    //      sub   u.4s, t.4s, P.4s\r\n    //      umin  res.4s, t.4s, u.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 6 cyc\r\n\r\n    // lhs and rhs are in 0, ..., P, and we want the result to also be in that range.\r\n    // t := lhs + rhs is in 0, ..., 2 P, so we apply reduce_sum.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let t = aarch64::vaddq_u32(lhs, rhs);\r\n        reduce_sum(t)\r\n    }\r\n}\r\n\r\n/// Multiply two 31-bit numbers to obtain a 62-bit immediate result, and return the high 31 bits of\r\n/// that result. Results are arbitrary if the inputs do not fit in 31 bits.\r\n#[inline]\r\n#[must_use]\r\nfn mul_31x31_to_hi_31(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // This is just a wrapper around `aarch64::vqdmulhq_s32`, so we don't have to worry about the\r\n    // casting elsewhere.\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        aarch64::vreinterpretq_u32_s32(aarch64::vqdmulhq_s32(\r\n            aarch64::vreinterpretq_s32_u32(lhs),\r\n            aarch64::vreinterpretq_s32_u32(rhs),\r\n        ))\r\n    }\r\n}\r\n\r\n/// Multiply vectors of Mersenne-31 field elements that fit in 31 bits.\r\n/// If the inputs do not fit in 31 bits, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn mul(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      sqdmulh  prod_hi31.4s, lhs.4s, rhs.4s\r\n    //      mul      t.4s, lhs.4s, rhs.4s\r\n    //      mla      t.4s, prod_hi31.4s, P.4s\r\n    //      sub      u.4s, t.4s, P.4s\r\n    //      umin     res.4s, t.4s, u.4s\r\n    // throughput: 1.25 cyc/vec (3.2 els/cyc)\r\n    // latency: 10 cyc\r\n\r\n    // We want to return res in 0, ..., P such that res = lhs * rhs (mod P).\r\n    // Let prod := lhs * rhs. Break it up into prod = 2^31 prod_hi31 + prod_lo31, where both limbs\r\n    // are in 0, ..., 2^31 - 1. Then prod = prod_hi31 + prod_lo31 (mod P), so let\r\n    // t := prod_hi31 + prod_lo31.\r\n    // Define prod_lo32 = prod mod 2^32 and observe that\r\n    //   prod_lo32 = prod_lo31 + 2^31 (prod_hi31 mod 2)\r\n    //             = prod_lo31 + 2^31 prod_hi31                                          (mod 2^32)\r\n    // Then\r\n    //   t = prod_lo32 - 2^31 prod_hi31 + prod_hi31                                      (mod 2^32)\r\n    //     = prod_lo32 - (2^31 - 1) prod_hi31                                            (mod 2^32)\r\n    //     = prod_lo32 - prod_hi31 * P                                                   (mod 2^32)\r\n    //\r\n    // t is in 0, ..., 2 P, so we apply reduce_sum to get the result.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let prod_hi31 = mul_31x31_to_hi_31(lhs, rhs);\r\n        let prod_lo32 = aarch64::vmulq_u32(lhs, rhs);\r\n        let t = aarch64::vmlsq_u32(prod_lo32, prod_hi31, P);\r\n        reduce_sum(t)\r\n    }\r\n}\r\n\r\n/// Negate a vector of Mersenne-31 field elements that fit in 31 bits.\r\n/// If the inputs do not fit in 31 bits, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg(val: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      eor  res.16b, val.16b, P.16b\r\n    // throughput: .25 cyc/vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    // val is in 0, ..., P, so res := P - val is also in 0, ..., P.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        aarch64::vsubq_u32(P, val)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of Mersenne-31 field elements that fit in 31 bits.\r\n/// If the inputs do not fit in 31 bits, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn sub(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      sub   res.4s, lhs.4s, rhs.4s\r\n    //      cmhi  underflow.4s, rhs.4s, lhs.4s\r\n    //      mls   res.4s, underflow.4s, P.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 5 cyc\r\n\r\n    // lhs and rhs are in 0, ..., P, and we want the result to also be in that range.\r\n    // Define: diff := (lhs - rhs) mod 2^32\r\n    //         underflow := 2^32 - 1 if lhs \u003cu rhs else 0\r\n    //         res := (diff - underflow * P) mod 2^32\r\n    // By cases:\r\n    // 1. If lhs \u003e=u rhs, then diff is in 0, ..., P and underflow is 0. res = diff is valid.\r\n    // 2. Otherwise, lhs \u003cu rhs, so diff is in 2^32 - P, ..., 2^32 - 1 and underflow is 2^32 - 1.\r\n    //    res = (diff + P) mod 2^32 is in 0, ..., P - 1, so it is valid.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let diff = aarch64::vsubq_u32(lhs, rhs);\r\n        let underflow = aarch64::vcltq_u32(lhs, rhs);\r\n        aarch64::vmlsq_u32(diff, underflow, P)\r\n    }\r\n}\r\n\r\nimpl From\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn from(value: Mersenne31) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl Default for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        Mersenne31::default().into()\r\n    }\r\n}\r\n\r\nimpl AddAssign for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl MulAssign for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl SubAssign for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Product for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for PackedMersenne31Neon {\r\n    type PrimeSubfield = Mersenne31;\r\n\r\n    const ZERO: Self = Self::broadcast(Mersenne31::ZERO);\r\n    const ONE: Self = Self::broadcast(Mersenne31::ONE);\r\n    const TWO: Self = Self::broadcast(Mersenne31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(Mersenne31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(Mersenne31::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\nimpl Algebra\u003cMersenne31\u003e for PackedMersenne31Neon {}\r\n\r\n// Degree of the smallest permutation polynomial for Mersenne31.\r\n//\r\n// As p - 1 = 23^2711... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nimpl InjectiveMonomial\u003c5\u003e for PackedMersenne31Neon {}\r\n\r\nimpl PermutationMonomial\u003c5\u003e for PackedMersenne31Neon {\r\n    /// In the field `Mersenne31`, `a^{1/5}` is equal to a^{1717986917}.\r\n    ///\r\n    /// This follows from the calculation `5 * 1717986917 = 4*(2^31 - 2) + 1 = 1 mod p - 1`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_1717986917(*self)\r\n    }\r\n}\r\n\r\nimpl Add\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Mersenne31) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Mul\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Mersenne31) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sub\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Mersenne31) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl AddAssign\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl MulAssign\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl SubAssign\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sum\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.sum::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Product\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.product::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Div\u003cMersenne31\u003e for PackedMersenne31Neon {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Mersenne31) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl Add\u003cPackedMersenne31Neon\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31Neon;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMersenne31Neon) -\u003e PackedMersenne31Neon {\r\n        PackedMersenne31Neon::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl Mul\u003cPackedMersenne31Neon\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31Neon;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMersenne31Neon) -\u003e PackedMersenne31Neon {\r\n        PackedMersenne31Neon::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl Sub\u003cPackedMersenne31Neon\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31Neon;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMersenne31Neon) -\u003e PackedMersenne31Neon {\r\n        PackedMersenne31Neon::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cPackedMersenne31Neon\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMersenne31Neon {\r\n        PackedMersenne31Neon(rng.gen())\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(v0: uint32x4_t, v1: uint32x4_t) -\u003e (uint32x4_t, uint32x4_t) {\r\n    // We want this to compile to:\r\n    //      trn1  res0.4s, v0.4s, v1.4s\r\n    //      trn2  res1.4s, v0.4s, v1.4s\r\n    // throughput: .5 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        (aarch64::vtrn1q_u32(v0, v1), aarch64::vtrn2q_u32(v0, v1))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(v0: uint32x4_t, v1: uint32x4_t) -\u003e (uint32x4_t, uint32x4_t) {\r\n    // We want this to compile to:\r\n    //      trn1  res0.2d, v0.2d, v1.2d\r\n    //      trn2  res1.2d, v0.2d, v1.2d\r\n    // throughput: .5 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    // To transpose 64-bit blocks, cast the [u32; 4] vectors to [u64; 2], transpose, and cast back.\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let v0 = aarch64::vreinterpretq_u64_u32(v0);\r\n        let v1 = aarch64::vreinterpretq_u64_u32(v1);\r\n        (\r\n            aarch64::vreinterpretq_u32_u64(aarch64::vtrn1q_u64(v0, v1)),\r\n            aarch64::vreinterpretq_u32_u64(aarch64::vtrn2q_u64(v0, v1)),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl PackedValue for PackedMersenne31Neon {\r\n    type Value = Mersenne31;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[Mersenne31]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31Neon` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast\r\n            // is safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [Mersenne31]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31Neon` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast\r\n            // is safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e Mersenne31\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[Mersenne31] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Mersenne31] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl PackedField for PackedMersenne31Neon {\r\n    type Scalar = Mersenne31;\r\n}\r\n\r\nunsafe impl PackedFieldPow2 for PackedMersenne31Neon {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::{Mersenne31, WIDTH};\r\n\r\n    /// Zero has a redundant representation, so let's test both.\r\n    const ZEROS: [Mersenne31; WIDTH] =\r\n        Mersenne31::new_array([0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff]);\r\n\r\n    const SPECIAL_VALS: [Mersenne31; WIDTH] =\r\n        Mersenne31::new_array([0x00000000, 0x00000001, 0x00000002, 0x7ffffffe]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedMersenne31Neon,\r\n        crate::PackedMersenne31Neon(super::ZEROS),\r\n        crate::PackedMersenne31Neon(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":329,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":545,"address":[],"length":0,"stats":{"Line":0}},{"line":546,"address":[],"length":0,"stats":{"Line":0}},{"line":547,"address":[],"length":0,"stats":{"Line":0}},{"line":551,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":114},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","aarch64_neon","poseidon2.rs"],"content":"//! Eventually this will hold a vectorized Neon implementation of Poseidon2 for PackedMersenne31Neon\r\n//! Currently this is essentially a placeholder to allow compilation on Neon devices.\r\n//!\r\n//! Converting the AVX2/AVX512 code across to Neon is on the TODO list.\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    ExternalLayer, ExternalLayerConstants, ExternalLayerConstructor, GenericPoseidon2LinearLayers,\r\n    InternalLayer, InternalLayerConstructor, MDSMat4,\r\n};\r\n\r\nuse crate::{\r\n    GenericPoseidon2LinearLayersMersenne31, Mersenne31, PackedMersenne31Neon,\r\n    MERSENNE31_S_BOX_DEGREE,\r\n};\r\n\r\n/// The internal layers of the Poseidon2 permutation.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMersenne31 {\r\n    pub(crate) internal_constants: Vec\u003cMersenne31\u003e,\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerMersenne31\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cMersenne31\u003e for Poseidon2InternalLayerMersenne31 {\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        Self { internal_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cMersenne31, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize, const D: u64\u003e InternalLayer\u003cPackedMersenne31Neon, WIDTH, D\u003e\r\n    for Poseidon2InternalLayerMersenne31\r\nwhere\r\n    GenericPoseidon2LinearLayersMersenne31:\r\n        GenericPoseidon2LinearLayers\u003cPackedMersenne31Neon, WIDTH\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMersenne31Neon; WIDTH]) {\r\n        self.internal_constants.iter().for_each(|\u0026rc| {\r\n            add_rc_and_sbox_generic::\u003c_, MERSENNE31_S_BOX_DEGREE\u003e(\u0026mut state[0], rc);\r\n            GenericPoseidon2LinearLayersMersenne31::internal_linear_layer(state);\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cconst D: u64, const WIDTH: usize\u003e ExternalLayer\u003cPackedMersenne31Neon, WIDTH, D\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMersenne31Neon; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic::\u003c_, MERSENNE31_S_BOX_DEGREE\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMersenne31Neon; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic::\u003c_, MERSENNE31_S_BOX_DEGREE\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use super::*;\r\n    use crate::Poseidon2Mersenne31;\r\n\r\n    type F = Mersenne31;\r\n    type Perm16 = Poseidon2Mersenne31\u003c16\u003e;\r\n    type Perm24 = Poseidon2Mersenne31\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedMersenne31Neon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input.\r\n    #[test]\r\n    fn test_neon_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut neon_input = input.map(Into::\u003cPackedMersenne31Neon\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut neon_input);\r\n\r\n        let neon_output = neon_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(neon_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","complex.rs"],"content":"//! Implementation of the quadratic extension of the Mersenne31 field\r\n//! by X^2 + 1.\r\n//!\r\n//! Note that X^2 + 1 is irreducible over p = Mersenne31 field because\r\n//! kronecker(-1, p) = -1, that is, -1 is not square in F_p.\r\n\r\nuse p3_field::extension::{Complex, ComplexExtendable, HasTwoAdicBinomialExtension};\r\nuse p3_field::PrimeCharacteristicRing;\r\n\r\nuse crate::Mersenne31;\r\n\r\nimpl ComplexExtendable for Mersenne31 {\r\n    const CIRCLE_TWO_ADICITY: usize = 31;\r\n\r\n    // sage: p = 2^31 - 1\r\n    // sage: F = GF(p)\r\n    // sage: R.\u003cx\u003e = F[]\r\n    // sage: F2.\u003cu\u003e = F.extension(x^2 + 1)\r\n    // sage: F2.multiplicative_generator()\r\n    // u + 12\r\n    const COMPLEX_GENERATOR: Complex\u003cSelf\u003e =\r\n        Complex::new_complex(Mersenne31::new(12), Mersenne31::ONE);\r\n\r\n    fn circle_two_adic_generator(bits: usize) -\u003e Complex\u003cSelf\u003e {\r\n        // Generator of the whole 2^TWO_ADICITY group\r\n        // sage: p = 2^31 - 1\r\n        // sage: F = GF(p)\r\n        // sage: R.\u003cx\u003e = F[]\r\n        // sage: F2.\u003cu\u003e = F.extension(x^2 + 1)\r\n        // sage: g = F2.multiplicative_generator()^((p^2 - 1) / 2^31); g\r\n        // 1584694829*u + 311014874\r\n        // sage: assert(g.multiplicative_order() == 2^31)\r\n        // sage: assert(g.norm() == 1)\r\n        let base =\r\n            Complex::new_complex(Mersenne31::new(311_014_874), Mersenne31::new(1_584_694_829));\r\n        base.exp_power_of_2(Self::CIRCLE_TWO_ADICITY - bits)\r\n    }\r\n}\r\n\r\nimpl HasTwoAdicBinomialExtension\u003c2\u003e for Mersenne31 {\r\n    const EXT_TWO_ADICITY: usize = 32;\r\n\r\n    fn ext_two_adic_generator(bits: usize) -\u003e [Self; 2] {\r\n        // TODO: Consider a `match` which may speed this up.\r\n        assert!(bits \u003c= Self::EXT_TWO_ADICITY);\r\n        // Generator of the whole 2^TWO_ADICITY group\r\n        // sage: p = 2^31 - 1\r\n        // sage: F = GF(p)\r\n        // sage: R.\u003cx\u003e = F[]\r\n        // sage: F2.\u003cu\u003e = F.extension(x^2 + 1)\r\n        // sage: g = F2.multiplicative_generator()^((p^2 - 1) / 2^32); g\r\n        // 1117296306*u + 1166849849\r\n        // sage: assert(g.multiplicative_order() == 2^32)\r\n        let base = Complex::\u003cSelf\u003e::new_complex(\r\n            Mersenne31::new(1_166_849_849),\r\n            Mersenne31::new(1_117_296_306),\r\n        );\r\n        base.exp_power_of_2(Self::EXT_TWO_ADICITY - bits).to_array()\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field::PrimeField32;\r\n    use p3_field_testing::{test_field, test_two_adic_field};\r\n\r\n    use super::*;\r\n\r\n    type Fi = Complex\u003cMersenne31\u003e;\r\n    type F = Mersenne31;\r\n\r\n    #[test]\r\n    fn add() {\r\n        // real part\r\n        assert_eq!(Fi::ONE + Fi::ONE, Fi::TWO);\r\n        assert_eq!(Fi::NEG_ONE + Fi::ONE, Fi::ZERO);\r\n        assert_eq!(Fi::NEG_ONE + Fi::TWO, Fi::ONE);\r\n        assert_eq!((Fi::NEG_ONE + Fi::NEG_ONE).real(), F::new(F::ORDER_U32 - 2));\r\n\r\n        // complex part\r\n        assert_eq!(\r\n            Fi::new_imag(F::ONE) + Fi::new_imag(F::ONE),\r\n            Fi::new_imag(F::TWO)\r\n        );\r\n        assert_eq!(\r\n            Fi::new_imag(F::NEG_ONE) + Fi::new_imag(F::ONE),\r\n            Fi::new_imag(F::ZERO)\r\n        );\r\n        assert_eq!(\r\n            Fi::new_imag(F::NEG_ONE) + Fi::new_imag(F::TWO),\r\n            Fi::new_imag(F::ONE)\r\n        );\r\n        assert_eq!(\r\n            (Fi::new_imag(F::NEG_ONE) + Fi::new_imag(F::NEG_ONE)).imag(),\r\n            F::new(F::ORDER_U32 - 2)\r\n        );\r\n\r\n        // further tests\r\n        assert_eq!(\r\n            Fi::new_complex(F::ONE, F::TWO) + Fi::new_complex(F::ONE, F::ONE),\r\n            Fi::new_complex(F::TWO, F::new(3))\r\n        );\r\n        assert_eq!(\r\n            Fi::new_complex(F::NEG_ONE, F::NEG_ONE) + Fi::new_complex(F::ONE, F::ONE),\r\n            Fi::ZERO\r\n        );\r\n        assert_eq!(\r\n            Fi::new_complex(F::NEG_ONE, F::ONE) + Fi::new_complex(F::TWO, F::new(F::ORDER_U32 - 2)),\r\n            Fi::new_complex(F::ONE, F::NEG_ONE)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn sub() {\r\n        // real part\r\n        assert_eq!(Fi::ONE - Fi::ONE, Fi::ZERO);\r\n        assert_eq!(Fi::TWO - Fi::TWO, Fi::ZERO);\r\n        assert_eq!(Fi::NEG_ONE - Fi::NEG_ONE, Fi::ZERO);\r\n        assert_eq!(Fi::TWO - Fi::ONE, Fi::ONE);\r\n        assert_eq!(Fi::NEG_ONE - Fi::ZERO, Fi::NEG_ONE);\r\n\r\n        // complex part\r\n        assert_eq!(Fi::new_imag(F::ONE) - Fi::new_imag(F::ONE), Fi::ZERO);\r\n        assert_eq!(Fi::new_imag(F::TWO) - Fi::new_imag(F::TWO), Fi::ZERO);\r\n        assert_eq!(\r\n            Fi::new_imag(F::NEG_ONE) - Fi::new_imag(F::NEG_ONE),\r\n            Fi::ZERO\r\n        );\r\n        assert_eq!(\r\n            Fi::new_imag(F::TWO) - Fi::new_imag(F::ONE),\r\n            Fi::new_imag(F::ONE)\r\n        );\r\n        assert_eq!(\r\n            Fi::new_imag(F::NEG_ONE) - Fi::ZERO,\r\n            Fi::new_imag(F::NEG_ONE)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn mul() {\r\n        assert_eq!(\r\n            Fi::new_complex(F::TWO, F::TWO) * Fi::new_complex(F::new(4), F::new(5)),\r\n            Fi::new_complex(-F::TWO, F::new(18))\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn mul_2exp_u64() {\r\n        // real part\r\n        // 1 * 2^0 = 1.\r\n        assert_eq!(Fi::ONE.mul_2exp_u64(0), Fi::ONE);\r\n        // 2 * 2^30 = 2^31 = 1.\r\n        assert_eq!(Fi::TWO.mul_2exp_u64(30), Fi::ONE);\r\n        // 5 * 2^2 = 20.\r\n        assert_eq!(\r\n            Fi::new_real(F::new(5)).mul_2exp_u64(2),\r\n            Fi::new_real(F::new(20))\r\n        );\r\n\r\n        // complex part\r\n        // i * 2^0 = i.\r\n        assert_eq!(Fi::new_imag(F::ONE).mul_2exp_u64(0), Fi::new_imag(F::ONE));\r\n        // (2i) * 2^30 = (2^31) * i = i.\r\n        assert_eq!(Fi::new_imag(F::TWO).mul_2exp_u64(30), Fi::new_imag(F::ONE));\r\n        // 5i * 2^2 = 20i.\r\n        assert_eq!(\r\n            Fi::new_imag(F::new(5)).mul_2exp_u64(2),\r\n            Fi::new_imag(F::new(20))\r\n        );\r\n    }\r\n\r\n    test_field!(p3_field::extension::Complex\u003ccrate::Mersenne31\u003e);\r\n    test_two_adic_field!(p3_field::extension::Complex\u003ccrate::Mersenne31\u003e);\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":34,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":35,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":36,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":43,"address":[],"length":0,"stats":{"Line":10448351135499550822}},{"line":45,"address":[],"length":0,"stats":{"Line":10448351135499550822}},{"line":55,"address":[],"length":0,"stats":{"Line":10448351135499550720}},{"line":56,"address":[],"length":0,"stats":{"Line":10448351135499550720}},{"line":58,"address":[],"length":0,"stats":{"Line":10448351135499550720}}],"covered":9,"coverable":9},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","dft.rs"],"content":"//! Implementation of DFT for `Mersenne31`.\r\n//!\r\n//! Strategy follows: `\u003chttps://www.robinscheibler.org/2013/02/13/real-fft.html\u003e`\r\n//! In short, fold a Mersenne31 DFT of length n into a Mersenne31Complex DFT\r\n//! of length n/2. Some pre/post-processing is necessary so that the result\r\n//! of the transform behaves as expected wrt the convolution theorem etc.\r\n//!\r\n//! Note that we don't return the final n/2 - 1 elements since we know that\r\n//! the \"complex conjugate\" of the (n-k)th element equals the kth element.\r\n//! The convolution theorem maintains this relationship and so these final\r\n//! n/2 - 1 elements are essentially redundant.\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::extension::Complex;\r\nuse p3_field::{Field, PrimeCharacteristicRing, TwoAdicField};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::Mersenne31;\r\n\r\ntype F = Mersenne31;\r\ntype C = Complex\u003cMersenne31\u003e;\r\n\r\n/// Given an hxw matrix M = (m_{ij}) where h is even, return an\r\n/// (h/2)xw matrix N whose (k,l) entry is\r\n///\r\n///    Mersenne31Complex(m_{2k,l}, m_{2k+1,l})\r\n///\r\n/// i.e. the even rows become the real parts and the odd rows become\r\n/// the imaginary parts.\r\n///\r\n/// This packing is suitable as input to a Fourier Transform over the\r\n/// domain Mersenne31Complex; it is inverse to `idft_postprocess()`\r\n/// below.\r\nfn dft_preprocess(input: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cC\u003e {\r\n    assert!(input.height() % 2 == 0, \"input height must be even\");\r\n    RowMajorMatrix::new(\r\n        input\r\n            .rows()\r\n            .tuples()\r\n            .flat_map(|(row_0, row_1)| {\r\n                // For each pair of rows in input, convert each\r\n                // two-element column into a Mersenne31Complex\r\n                // treating the first row as the real part and the\r\n                // second row as the imaginary part.\r\n                row_0.zip(row_1).map(|(x, y)| C::new_complex(x, y))\r\n            })\r\n            .collect(),\r\n        input.width(),\r\n    )\r\n}\r\n\r\n/// Transform the result of applying the DFT to the packed\r\n/// `Mersenne31` values so that the convolution theorem holds.\r\n///\r\n/// Source: https://www.robinscheibler.org/2013/02/13/real-fft.html\r\n///\r\n/// NB: This function and `idft_preprocess()` are inverses.\r\nfn dft_postprocess(input: RowMajorMatrix\u003cC\u003e) -\u003e RowMajorMatrix\u003cC\u003e {\r\n    let h = input.height();\r\n    let log2_h = log2_strict_usize(h); // checks that h is a power of two\r\n\r\n    // NB: The original real matrix had height 2h, hence log2(2h) = log2(h) + 1.\r\n    // omega is a 2h-th root of unity\r\n    let omega = C::two_adic_generator(log2_h + 1);\r\n    let mut omega_j = omega;\r\n\r\n    let mut output = Vec::with_capacity((h + 1) * input.width());\r\n    output.extend(input.first_row().map(|x| C::new_real(x.real() + x.imag())));\r\n\r\n    for j in 1..h {\r\n        let row = izip!(input.row(j), input.row(h - j)).map(|(x, y)| {\r\n            let even = x + y.conjugate();\r\n            // odd = (x - y.conjugate()) * -i\r\n            let odd = C::new_complex(x.imag() + y.imag(), y.real() - x.real());\r\n            (even + odd * omega_j).halve()\r\n        });\r\n        output.extend(row);\r\n        omega_j *= omega;\r\n    }\r\n\r\n    output.extend(input.first_row().map(|x| C::new_real(x.real() - x.imag())));\r\n    debug_assert_eq!(output.len(), (h + 1) * input.width());\r\n    RowMajorMatrix::new(output, input.width())\r\n}\r\n\r\n/// Undo the transform of the DFT matrix in `dft_postprocess()` so\r\n/// that the inverse DFT can be applied.\r\n///\r\n/// Source: https://www.robinscheibler.org/2013/02/13/real-fft.html\r\n///\r\n/// NB: This function and `dft_postprocess()` are inverses.\r\nfn idft_preprocess(input: RowMajorMatrix\u003cC\u003e) -\u003e RowMajorMatrix\u003cC\u003e {\r\n    let h = input.height() - 1;\r\n    let log2_h = log2_strict_usize(h); // checks that h is a power of two\r\n\r\n    // NB: The original real matrix had length 2h, hence log2(2h) = log2(h) + 1.\r\n    // omega is a 2n-th root of unity\r\n    let omega = C::two_adic_generator(log2_h + 1).inverse();\r\n    let mut omega_j = C::ONE;\r\n\r\n    let mut output = Vec::with_capacity(h * input.width());\r\n    // TODO: Specialise j = 0 and j = n (which we know must be real)?\r\n    for j in 0..h {\r\n        let row = izip!(input.row(j), input.row(h - j)).map(|(x, y)| {\r\n            let even = x + y.conjugate();\r\n            // odd = (x - y.conjugate()) * -i\r\n            let odd = C::new_complex(x.imag() + y.imag(), y.real() - x.real());\r\n            (even - odd * omega_j).halve()\r\n        });\r\n        output.extend(row);\r\n        omega_j *= omega;\r\n    }\r\n    RowMajorMatrix::new(output, input.width())\r\n}\r\n\r\n/// Given an (h/2)xw matrix M = (m_{kl}) = (a_{kl} + I*b_{kl}) (where\r\n/// I is the imaginary unit), return the hxw matrix N whose (i,j)\r\n/// entry is a_{i/2,j} if i is even and b_{(i-1)/2,j} if i is odd.\r\n///\r\n/// This function is inverse to `dft_preprocess()` above.\r\nfn idft_postprocess(input: RowMajorMatrix\u003cC\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    // Allocate necessary `Vec`s upfront:\r\n    //   1) The actual output,\r\n    //   2) A temporary buf to store the imaginary parts.\r\n    //      This buf is filled and flushed per row\r\n    //      throughout postprocessing to save on allocations.\r\n    let mut output = Vec::with_capacity(input.width() * input.height() * 2);\r\n    let mut buf = Vec::with_capacity(input.width());\r\n\r\n    // Convert each row of input into two rows, the first row\r\n    // having the real parts of the input, the second row\r\n    // having the imaginary parts.\r\n    for row in input.rows() {\r\n        for ext in row {\r\n            output.push(ext.real());\r\n            buf.push(ext.imag());\r\n        }\r\n        output.append(\u0026mut buf);\r\n    }\r\n\r\n    RowMajorMatrix::new(output, input.width())\r\n}\r\n\r\n/// The DFT for Mersenne31\r\n#[derive(Debug, Default, Clone)]\r\npub struct Mersenne31Dft;\r\n\r\nimpl Mersenne31Dft {\r\n    /// Compute the DFT of each column of `mat`.\r\n    ///\r\n    /// NB: The DFT works by packing pairs of `Mersenne31` values into\r\n    /// a `Mersenne31Complex` and doing a (half-length) DFT on the\r\n    /// result. In particular, the type of the result elements are in\r\n    /// the extension field, not the domain field.\r\n    pub fn dft_batch\u003cDft: TwoAdicSubgroupDft\u003cC\u003e\u003e(mat: RowMajorMatrix\u003cF\u003e) -\u003e RowMajorMatrix\u003cC\u003e {\r\n        let dft = Dft::default();\r\n        dft_postprocess(dft.dft_batch(dft_preprocess(mat)).to_row_major_matrix())\r\n    }\r\n\r\n    /// Compute the inverse DFT of each column of `mat`.\r\n    ///\r\n    /// NB: See comment on `dft_batch()` for information on packing.\r\n    pub fn idft_batch\u003cDft: TwoAdicSubgroupDft\u003cC\u003e\u003e(mat: RowMajorMatrix\u003cC\u003e) -\u003e RowMajorMatrix\u003cF\u003e {\r\n        let dft = Dft::default();\r\n        idft_postprocess(dft.idft_batch(idft_preprocess(mat)))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use rand::distributions::{Distribution, Standard};\r\n    use rand::{thread_rng, Rng};\r\n\r\n    use super::*;\r\n    use crate::Mersenne31ComplexRadix2Dit;\r\n\r\n    type Base = Mersenne31;\r\n    type Dft = Mersenne31ComplexRadix2Dit;\r\n\r\n    #[test]\r\n    fn consistency()\r\n    where\r\n        Standard: Distribution\u003cBase\u003e,\r\n    {\r\n        const N: usize = 1 \u003c\u003c 12;\r\n        let input = thread_rng()\r\n            .sample_iter(Standard)\r\n            .take(N)\r\n            .collect::\u003cVec\u003cBase\u003e\u003e();\r\n        let input = RowMajorMatrix::new_col(input);\r\n        let fft_input = Mersenne31Dft::dft_batch::\u003cDft\u003e(input.clone());\r\n        let output = Mersenne31Dft::idft_batch::\u003cDft\u003e(fft_input);\r\n        assert_eq!(input, output);\r\n    }\r\n\r\n    #[test]\r\n    fn convolution()\r\n    where\r\n        Standard: Distribution\u003cBase\u003e,\r\n    {\r\n        const N: usize = 1 \u003c\u003c 6;\r\n        let a = thread_rng()\r\n            .sample_iter(Standard)\r\n            .take(N)\r\n            .collect::\u003cVec\u003cBase\u003e\u003e();\r\n        let a = RowMajorMatrix::new_col(a);\r\n        let b = thread_rng()\r\n            .sample_iter(Standard)\r\n            .take(N)\r\n            .collect::\u003cVec\u003cBase\u003e\u003e();\r\n        let b = RowMajorMatrix::new_col(b);\r\n\r\n        let fft_a = Mersenne31Dft::dft_batch::\u003cDft\u003e(a.clone());\r\n        let fft_b = Mersenne31Dft::dft_batch::\u003cDft\u003e(b.clone());\r\n\r\n        let fft_c = fft_a\r\n            .values\r\n            .iter()\r\n            .zip(fft_b.values.iter())\r\n            .map(|(\u0026xi, \u0026yi)| xi * yi)\r\n            .collect();\r\n        let fft_c = RowMajorMatrix::new_col(fft_c);\r\n\r\n        let c = Mersenne31Dft::idft_batch::\u003cDft\u003e(fft_c);\r\n\r\n        let mut conv = Vec::with_capacity(N);\r\n        for i in 0..N {\r\n            let mut t = Base::ZERO;\r\n            for j in 0..N {\r\n                t += a.values[j] * b.values[(N + i - j) % N];\r\n            }\r\n            conv.push(t);\r\n        }\r\n\r\n        assert_eq!(c.values, conv);\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783824}},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":45,"address":[],"length":0,"stats":{"Line":4827858800541171728}},{"line":50,"address":[],"length":0,"stats":{"Line":13835058055282163752}},{"line":52,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":53,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":63,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":73,"address":[],"length":0,"stats":{"Line":648518346341351432}},{"line":75,"address":[],"length":0,"stats":{"Line":9007199254740992000}},{"line":76,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":77,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":79,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":80,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":82,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":83,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351448}},{"line":87,"address":[],"length":0,"stats":{"Line":432345564227567624}},{"line":88,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":108,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":109,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":110,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":112,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":115,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":116,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855880}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":133,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":138,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":139,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":140,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":141,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":143,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":146,"address":[],"length":0,"stats":{"Line":144115188075855880}},{"line":160,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":161,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":162,"address":[],"length":0,"stats":{"Line":216172782113783816}},{"line":168,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":55,"coverable":55},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","extension.rs"],"content":"use p3_field::extension::{\r\n    BinomiallyExtendable, Complex, HasComplexBinomialExtension, HasTwoAdicComplexBinomialExtension,\r\n};\r\nuse p3_field::{field_to_array, PrimeCharacteristicRing, TwoAdicField};\r\n\r\nuse crate::Mersenne31;\r\n\r\nimpl BinomiallyExtendable\u003c3\u003e for Mersenne31 {\r\n    // ```sage\r\n    // p = 2^31 - 1\r\n    // F = GF(p)\r\n    // R.\u003cx\u003e = F[]\r\n    // assert (x^3 - 5).is_irreducible()\r\n    // ```\r\n    const W: Self = Self::new(5);\r\n\r\n    // ```sage\r\n    // F(5)^((p-1)/3)\r\n    // ```\r\n    const DTH_ROOT: Self = Self::new(1513477735);\r\n\r\n    // ```sage\r\n    // F.extension(x^3 - 5, 'u').multiplicative_generator()\r\n    // ```\r\n    const EXT_GENERATOR: [Self; 3] = [Self::new(10), Self::ONE, Self::ZERO];\r\n}\r\n\r\nimpl HasComplexBinomialExtension\u003c2\u003e for Mersenne31 {\r\n    // Verifiable in Sage with\r\n    // ```sage\r\n    // p = 2**31 - 1  # Mersenne31\r\n    // F = GF(p)  # The base field GF(p)\r\n    // R.\u003cx\u003e = F[]  # The polynomial ring over F\r\n    // K.\u003ci\u003e = F.extension(x^2 + 1)  # The complex extension field\r\n    // R2.\u003cy\u003e = K[]\r\n    // f2 = y^2 - i - 2\r\n    // assert f2.is_irreducible()\r\n    // ```\r\n    const W: Complex\u003cSelf\u003e = Complex::new_complex(Mersenne31::TWO, Mersenne31::ONE);\r\n\r\n    // DTH_ROOT = W^((p^2 - 1)/2).\r\n    const DTH_ROOT: Complex\u003cSelf\u003e = Complex::new_real(Mersenne31::new(2147483646));\r\n\r\n    // Verifiable in Sage with\r\n    // ```sage\r\n    // K2.\u003cj\u003e = K.extension(f2)\r\n    //  g = j + 6\r\n    // for f in factor(p^4 - 1):\r\n    //   assert g^((p^4-1) // f) != 1\r\n    // ```\r\n    const EXT_GENERATOR: [Complex\u003cSelf\u003e; 2] = [Complex::new_real(Mersenne31::new(6)), Complex::ONE];\r\n}\r\n\r\nimpl HasTwoAdicComplexBinomialExtension\u003c2\u003e for Mersenne31 {\r\n    const COMPLEX_EXT_TWO_ADICITY: usize = 33;\r\n\r\n    fn complex_ext_two_adic_generator(bits: usize) -\u003e [Complex\u003cSelf\u003e; 2] {\r\n        assert!(bits \u003c= 33);\r\n        if bits == 33 {\r\n            [\r\n                Complex::ZERO,\r\n                Complex::new_complex(Mersenne31::new(1437746044), Mersenne31::new(946469285)),\r\n            ]\r\n        } else {\r\n            [Complex::two_adic_generator(bits), Complex::ZERO]\r\n        }\r\n    }\r\n}\r\n\r\nimpl HasComplexBinomialExtension\u003c3\u003e for Mersenne31 {\r\n    // Verifiable in Sage with\r\n    // ```sage\r\n    // p = 2**31 - 1  # Mersenne31\r\n    // F = GF(p)  # The base field GF(p)\r\n    // R.\u003cx\u003e = F[]  # The polynomial ring over F\r\n    // K.\u003ci\u003e = F.extension(x^2 + 1)  # The complex extension field\r\n    // R2.\u003cy\u003e = K[]\r\n    // f2 = y^3 - 5*i\r\n    // assert f2.is_irreducible()\r\n    // ```\r\n    const W: Complex\u003cSelf\u003e = Complex::new_imag(Mersenne31::new(5));\r\n\r\n    // DTH_ROOT = W^((p^2 - 1)/2).\r\n    const DTH_ROOT: Complex\u003cSelf\u003e = Complex::new_real(Mersenne31::new(634005911));\r\n\r\n    // Verifiable in Sage with\r\n    // ```sage\r\n    // K2.\u003cj\u003e = K.extension(f2)\r\n    //  g = j + 5\r\n    // for f in factor(p^6 - 1):\r\n    //   assert g^((p^6-1) // f) != 1\r\n    // ```\r\n    const EXT_GENERATOR: [Complex\u003cSelf\u003e; 3] = [\r\n        Complex::new_real(Mersenne31::new(5)),\r\n        Complex::new_real(Mersenne31::ONE),\r\n        Complex::ZERO,\r\n    ];\r\n}\r\n\r\nimpl HasTwoAdicComplexBinomialExtension\u003c3\u003e for Mersenne31 {\r\n    const COMPLEX_EXT_TWO_ADICITY: usize = 32;\r\n\r\n    fn complex_ext_two_adic_generator(bits: usize) -\u003e [Complex\u003cSelf\u003e; 3] {\r\n        field_to_array(Complex::two_adic_generator(bits))\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_cubic_extension {\r\n    use p3_field::extension::{BinomialExtensionField, Complex};\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::Mersenne31;\r\n\r\n    type F = Complex\u003cMersenne31\u003e;\r\n    type EF = BinomialExtensionField\u003cF, 3\u003e;\r\n\r\n    test_field!(super::EF);\r\n\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n}\r\n\r\n#[cfg(test)]\r\nmod test_quadratic_extension {\r\n\r\n    use p3_field::extension::{BinomialExtensionField, Complex};\r\n    use p3_field_testing::{test_field, test_two_adic_extension_field};\r\n\r\n    use crate::Mersenne31;\r\n\r\n    type F = Complex\u003cMersenne31\u003e;\r\n    type EF = BinomialExtensionField\u003cF, 2\u003e;\r\n\r\n    test_field!(super::EF);\r\n\r\n    test_two_adic_extension_field!(super::F, super::EF);\r\n}\r\n","traces":[{"line":57,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":58,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":59,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":62,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":65,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":103,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":104,"address":[],"length":0,"stats":{"Line":3242591731706757120}}],"covered":8,"coverable":8},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","lib.rs"],"content":"//! The prime field `F_p` where `p = 2^31 - 1`.\r\n\r\n#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nextern crate alloc;\r\n\r\nmod complex;\r\nmod dft;\r\nmod extension;\r\nmod mds;\r\nmod mersenne_31;\r\nmod poseidon2;\r\nmod radix_2_dit;\r\n\r\npub use dft::Mersenne31Dft;\r\npub use mds::*;\r\npub use mersenne_31::*;\r\npub use poseidon2::*;\r\npub use radix_2_dit::Mersenne31ComplexRadix2Dit;\r\n\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\nmod aarch64_neon;\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub use aarch64_neon::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\nmod x86_64_avx2;\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use x86_64_avx2::*;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\nmod x86_64_avx512;\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use x86_64_avx512::*;\r\n\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(target_arch = \"x86_64\", target_feature = \"avx2\",),\r\n)))]\r\nmod no_packing;\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(target_arch = \"x86_64\", target_feature = \"avx2\",),\r\n)))]\r\npub use no_packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","mds.rs"],"content":"//! MDS matrices over the Mersenne31 field, and permutations defined by them.\r\n//!\r\n//! NB: Not all sizes have fast implementations of their permutations.\r\n//! Supported sizes: 8, 12, 16, 32, 64.\r\n//! Sizes 8 and 12 are from Plonky2, size 16 was found as part of concurrent\r\n//! work by Angus Gruen and Hamish Ivey-Law. Other sizes are from Ulrich Habck's\r\n//! database.\r\n\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::PrimeCharacteristicRing;\r\nuse p3_mds::karatsuba_convolution::Convolve;\r\nuse p3_mds::util::{dot_product, first_row_to_first_col};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\n\r\nuse crate::Mersenne31;\r\n\r\n#[derive(Clone, Debug, Default)]\r\npub struct MdsMatrixMersenne31;\r\n\r\n/// Instantiate convolution for \"small\" RHS vectors over Mersenne31.\r\n///\r\n/// Here \"small\" means N = len(rhs) \u003c= 16 and sum(r for r in rhs) \u003c\r\n/// 2^24 (roughly), though in practice the sum will be less than 2^9.\r\nstruct SmallConvolveMersenne31;\r\nimpl Convolve\u003cMersenne31, i64, i64, i64\u003e for SmallConvolveMersenne31 {\r\n    /// Return the lift of an (almost) reduced Mersenne31 element.\r\n    /// The Mersenne31 implementation guarantees that\r\n    /// 0 \u003c= input.value \u003c= P \u003c 2^31.\r\n    #[inline(always)]\r\n    fn read(input: Mersenne31) -\u003e i64 {\r\n        input.value as i64\r\n    }\r\n\r\n    /// FIXME: Refactor the dot product\r\n    /// For a convolution of size N, |x| \u003c N * 2^31 and (as per the\r\n    /// assumption above), |y| \u003c 2^24. So the product is at most N * 2^55\r\n    /// which will not overflow for N \u003c= 16.\r\n    #[inline(always)]\r\n    fn parity_dot\u003cconst N: usize\u003e(u: [i64; N], v: [i64; N]) -\u003e i64 {\r\n        dot_product(u, v)\r\n    }\r\n\r\n    /// The assumptions above mean z \u003c N^2 * 2^55, which is at most\r\n    /// 2^63 when N \u003c= 16.\r\n    ///\r\n    /// NB: Even though intermediate values could be negative, the\r\n    /// output must be non-negative since the inputs were\r\n    /// non-negative.\r\n    #[inline(always)]\r\n    fn reduce(z: i64) -\u003e Mersenne31 {\r\n        debug_assert!(z \u003e= 0);\r\n        Mersenne31::from_u64(z as u64)\r\n    }\r\n}\r\n\r\n/// Instantiate convolution for \"large\" RHS vectors over Mersenne31.\r\n///\r\n/// Here \"large\" means the elements can be as big as the field\r\n/// characteristic, and the size N of the RHS is \u003c= 64.\r\nstruct LargeConvolveMersenne31;\r\nimpl Convolve\u003cMersenne31, i64, i64, i64\u003e for LargeConvolveMersenne31 {\r\n    /// Return the lift of an (almost) reduced Mersenne31 element.\r\n    /// The Mersenne31 implementation guarantees that\r\n    /// 0 \u003c= input.value \u003c= P \u003c 2^31.\r\n    #[inline(always)]\r\n    fn read(input: Mersenne31) -\u003e i64 {\r\n        input.value as i64\r\n    }\r\n\r\n    #[inline]\r\n    fn parity_dot\u003cconst N: usize\u003e(u: [i64; N], v: [i64; N]) -\u003e i64 {\r\n        // For a convolution of size N, |x|, |y| \u003c N * 2^31, so the product\r\n        // could be as much as N^2 * 2^62. This will overflow an i64, so\r\n        // we first widen to i128.\r\n\r\n        let mut dp = 0i128;\r\n        for i in 0..N {\r\n            dp += u[i] as i128 * v[i] as i128;\r\n        }\r\n\r\n        const LOWMASK: i128 = (1 \u003c\u003c 42) - 1; // Gets the bits lower than 42.\r\n        const HIGHMASK: i128 = !LOWMASK; // Gets all bits higher than 42.\r\n\r\n        let low_bits = (dp \u0026 LOWMASK) as i64; // low_bits \u003c 2**42\r\n        let high_bits = ((dp \u0026 HIGHMASK) \u003e\u003e 31) as i64; // |high_bits| \u003c 2**(n - 31)\r\n\r\n        // Proof that low_bits + high_bits is congruent to dp (mod p)\r\n        // and congruent to dp (mod 2^11):\r\n        //\r\n        // The individual bounds clearly show that low_bits +\r\n        // high_bits \u003c 2**(n - 30).\r\n        //\r\n        // Next observe that low_bits + high_bits = input - (2**31 -\r\n        // 1) * (high_bits) = input mod P.\r\n        //\r\n        // Finally note that 2**11 divides high_bits and so low_bits +\r\n        // high_bits = low_bits mod 2**11 = input mod 2**11.\r\n\r\n        low_bits + high_bits\r\n    }\r\n\r\n    #[inline]\r\n    fn reduce(z: i64) -\u003e Mersenne31 {\r\n        // After the dot product, the maximal size is N^2 * 2^62 \u003c 2^74\r\n        // as N = 64 is the biggest size. So, after the partial\r\n        // reduction, the output z of parity dot satisfies |z| \u003c 2^44\r\n        // (Where 44 is 74 - 30).\r\n        //\r\n        // In the recombining steps, conv maps (wo, w1) -\u003e ((wo + w1)/2,\r\n        // (wo + w1)/2) which has no effect on the maximal size. (Indeed,\r\n        // it makes sizes almost strictly smaller).\r\n        //\r\n        // On the other hand, negacyclic_conv (ignoring the re-index)\r\n        // recombines as: (w0, w1, w2) -\u003e (w0 + w1, w2 - w0 - w1). Hence\r\n        // if the input is \u003c= K, the output is \u003c= 3K.\r\n        //\r\n        // Thus the values appearing at the end are bounded by 3^n 2^44\r\n        // where n is the maximal number of negacyclic_conv recombination\r\n        // steps. When N = 64, we need to recombine for singed_conv_32,\r\n        // singed_conv_16, singed_conv_8 so the overall bound will be 3^3\r\n        // 2^44 \u003c 32 * 2^44 \u003c 2^49.\r\n        debug_assert!(z \u003e -(1i64 \u003c\u003c 49));\r\n        debug_assert!(z \u003c (1i64 \u003c\u003c 49));\r\n\r\n        const MASK: i64 = (1 \u003c\u003c 31) - 1;\r\n        // Morally, our value is a i62 not a i64 as the top 3 bits are\r\n        // guaranteed to be equal.\r\n        let low_bits = unsafe {\r\n            // This is safe as 0 \u003c= z \u0026 MASK \u003c 2^31\r\n            Mersenne31::from_canonical_unchecked((z \u0026 MASK) as u32)\r\n        };\r\n\r\n        let high_bits = ((z \u003e\u003e 31) \u0026 MASK) as i32;\r\n        let sign_bits = (z \u003e\u003e 62) as i32;\r\n\r\n        let high = unsafe {\r\n            // This is safe as high_bits + sign_bits \u003e 0 as by assumption b[63] = b[61].\r\n            Mersenne31::from_canonical_unchecked((high_bits + sign_bits) as u32)\r\n        };\r\n        low_bits + high\r\n    }\r\n}\r\n\r\nconst MATRIX_CIRC_MDS_8_SML_ROW: [i64; 8] = [7, 1, 3, 8, 8, 3, 4, 9];\r\n\r\nimpl Permutation\u003c[Mersenne31; 8]\u003e for MdsMatrixMersenne31 {\r\n    fn permute(\u0026self, input: [Mersenne31; 8]) -\u003e [Mersenne31; 8] {\r\n        const MATRIX_CIRC_MDS_8_SML_COL: [i64; 8] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_8_SML_ROW);\r\n        SmallConvolveMersenne31::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_8_SML_COL,\r\n            SmallConvolveMersenne31::conv8,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; 8]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cMersenne31, 8\u003e for MdsMatrixMersenne31 {}\r\n\r\nconst MATRIX_CIRC_MDS_12_SML_ROW: [i64; 12] = [1, 1, 2, 1, 8, 9, 10, 7, 5, 9, 4, 10];\r\n\r\nimpl Permutation\u003c[Mersenne31; 12]\u003e for MdsMatrixMersenne31 {\r\n    fn permute(\u0026self, input: [Mersenne31; 12]) -\u003e [Mersenne31; 12] {\r\n        const MATRIX_CIRC_MDS_12_SML_COL: [i64; 12] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_12_SML_ROW);\r\n        SmallConvolveMersenne31::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_12_SML_COL,\r\n            SmallConvolveMersenne31::conv12,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; 12]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cMersenne31, 12\u003e for MdsMatrixMersenne31 {}\r\n\r\nconst MATRIX_CIRC_MDS_16_SML_ROW: [i64; 16] =\r\n    [1, 1, 51, 1, 11, 17, 2, 1, 101, 63, 15, 2, 67, 22, 13, 3];\r\n\r\nimpl Permutation\u003c[Mersenne31; 16]\u003e for MdsMatrixMersenne31 {\r\n    fn permute(\u0026self, input: [Mersenne31; 16]) -\u003e [Mersenne31; 16] {\r\n        const MATRIX_CIRC_MDS_16_SML_COL: [i64; 16] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_16_SML_ROW);\r\n        SmallConvolveMersenne31::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_16_SML_COL,\r\n            SmallConvolveMersenne31::conv16,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; 16]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cMersenne31, 16\u003e for MdsMatrixMersenne31 {}\r\n\r\n#[rustfmt::skip]\r\nconst MATRIX_CIRC_MDS_32_MERSENNE31_ROW: [i64; 32] = [\r\n    0x1896DC78, 0x559D1E29, 0x04EBD732, 0x3FF449D7,\r\n    0x2DB0E2CE, 0x26776B85, 0x76018E57, 0x1025FA13,\r\n    0x06486BAB, 0x37706EBA, 0x25EB966B, 0x113C24E5,\r\n    0x2AE20EC4, 0x5A27507C, 0x0CD38CF1, 0x761C10E5,\r\n    0x19E3EF1A, 0x032C730F, 0x35D8AF83, 0x651DF13B,\r\n    0x7EC3DB1A, 0x6A146994, 0x588F9145, 0x09B79455,\r\n    0x7FDA05EC, 0x19FE71A8, 0x6988947A, 0x624F1D31,\r\n    0x500BB628, 0x0B1428CE, 0x3A62E1D6, 0x77692387\r\n];\r\n\r\nimpl Permutation\u003c[Mersenne31; 32]\u003e for MdsMatrixMersenne31 {\r\n    fn permute(\u0026self, input: [Mersenne31; 32]) -\u003e [Mersenne31; 32] {\r\n        const MATRIX_CIRC_MDS_32_MERSENNE31_COL: [i64; 32] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_32_MERSENNE31_ROW);\r\n        LargeConvolveMersenne31::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_32_MERSENNE31_COL,\r\n            LargeConvolveMersenne31::conv32,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; 32]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cMersenne31, 32\u003e for MdsMatrixMersenne31 {}\r\n\r\n#[rustfmt::skip]\r\nconst MATRIX_CIRC_MDS_64_MERSENNE31_ROW: [i64; 64] = [\r\n    0x570227A5, 0x3702983F, 0x4B7B3B0A, 0x74F13DE3,\r\n    0x485314B0, 0x0157E2EC, 0x1AD2E5DE, 0x721515E3,\r\n    0x5452ADA3, 0x0C74B6C1, 0x67DA9450, 0x33A48369,\r\n    0x3BDBEE06, 0x7C678D5E, 0x160F16D3, 0x54888B8C,\r\n    0x666C7AA6, 0x113B89E2, 0x2A403CE2, 0x18F9DF42,\r\n    0x2A685E84, 0x49EEFDE5, 0x5D044806, 0x560A41F8,\r\n    0x69EF1BD0, 0x2CD15786, 0x62E07766, 0x22A231E2,\r\n    0x3CFCF40C, 0x4E8F63D8, 0x69657A15, 0x466B4B2D,\r\n    0x4194B4D2, 0x1E9A85EA, 0x39709C27, 0x4B030BF3,\r\n    0x655DCE1D, 0x251F8899, 0x5B2EA879, 0x1E10E42F,\r\n    0x31F5BE07, 0x2AFBB7F9, 0x3E11021A, 0x5D97A17B,\r\n    0x6F0620BD, 0x5DBFC31D, 0x76C4761D, 0x21938559,\r\n    0x33777473, 0x71F0E92C, 0x0B9872A1, 0x4C2411F9,\r\n    0x545B7C96, 0x20256BAF, 0x7B8B493E, 0x33AD525C,\r\n    0x15EAEA1C, 0x6D2D1A21, 0x06A81D14, 0x3FACEB4F,\r\n    0x130EC21C, 0x3C84C4F5, 0x50FD67C0, 0x30FDD85A,\r\n];\r\n\r\nimpl Permutation\u003c[Mersenne31; 64]\u003e for MdsMatrixMersenne31 {\r\n    fn permute(\u0026self, input: [Mersenne31; 64]) -\u003e [Mersenne31; 64] {\r\n        const MATRIX_CIRC_MDS_64_MERSENNE31_COL: [i64; 64] =\r\n            first_row_to_first_col(\u0026MATRIX_CIRC_MDS_64_MERSENNE31_ROW);\r\n        LargeConvolveMersenne31::apply(\r\n            input,\r\n            MATRIX_CIRC_MDS_64_MERSENNE31_COL,\r\n            LargeConvolveMersenne31::conv64,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; 64]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl MdsPermutation\u003cMersenne31, 64\u003e for MdsMatrixMersenne31 {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n\r\n    use super::{MdsMatrixMersenne31, Mersenne31};\r\n\r\n    #[test]\r\n    fn mersenne8() {\r\n        let input: [Mersenne31; 8] = Mersenne31::new_array([\r\n            1741044457, 327154658, 318297696, 1528828225, 468360260, 1271368222, 1906288587,\r\n            1521884224,\r\n        ]);\r\n\r\n        let output = MdsMatrixMersenne31.permute(input);\r\n\r\n        let expected: [Mersenne31; 8] = Mersenne31::new_array([\r\n            895992680, 1343855369, 2107796831, 266468728, 846686506, 252887121, 205223309,\r\n            260248790,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn mersenne12() {\r\n        let input: [Mersenne31; 12] = Mersenne31::new_array([\r\n            1232740094, 661555540, 11024822, 1620264994, 471137070, 276755041, 1316882747,\r\n            1023679816, 1675266989, 743211887, 44774582, 1990989306,\r\n        ]);\r\n\r\n        let output = MdsMatrixMersenne31.permute(input);\r\n\r\n        let expected: [Mersenne31; 12] = Mersenne31::new_array([\r\n            860812289, 399778981, 1228500858, 798196553, 673507779, 1116345060, 829764188,\r\n            138346433, 578243475, 553581995, 578183208, 1527769050,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn mersenne16() {\r\n        let input: [Mersenne31; 16] = Mersenne31::new_array([\r\n            1431168444, 963811518, 88067321, 381314132, 908628282, 1260098295, 980207659,\r\n            150070493, 357706876, 2014609375, 387876458, 1621671571, 183146044, 107201572,\r\n            166536524, 2078440788,\r\n        ]);\r\n\r\n        let output = MdsMatrixMersenne31.permute(input);\r\n\r\n        let expected: [Mersenne31; 16] = Mersenne31::new_array([\r\n            1858869691, 1607793806, 1200396641, 1400502985, 1511630695, 187938132, 1332411488,\r\n            2041577083, 2014246632, 802022141, 796807132, 1647212930, 813167618, 1867105010,\r\n            508596277, 1457551581,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn mersenne32() {\r\n        let input: [Mersenne31; 32] = Mersenne31::new_array([\r\n            873912014, 1112497426, 300405095, 4255553, 1234979949, 156402357, 1952135954,\r\n            718195399, 1041748465, 683604342, 184275751, 1184118518, 214257054, 1293941921,\r\n            64085758, 710448062, 1133100009, 350114887, 1091675272, 671421879, 1226105999,\r\n            546430131, 1298443967, 1787169653, 2129310791, 1560307302, 471771931, 1191484402,\r\n            1550203198, 1541319048, 229197040, 839673789,\r\n        ]);\r\n\r\n        let output = MdsMatrixMersenne31.permute(input);\r\n\r\n        let expected: [Mersenne31; 32] = Mersenne31::new_array([\r\n            1439049928, 890642852, 694402307, 713403244, 553213342, 1049445650, 321709533,\r\n            1195683415, 2118492257, 623077773, 96734062, 990488164, 1674607608, 749155000,\r\n            353377854, 966432998, 1114654884, 1370359248, 1624965859, 685087760, 1631836645,\r\n            1615931812, 2061986317, 1773551151, 1449911206, 1951762557, 545742785, 582866449,\r\n            1379774336, 229242759, 1871227547, 752848413,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n\r\n    #[test]\r\n    fn mersenne64() {\r\n        let input: [Mersenne31; 64] = Mersenne31::new_array([\r\n            837269696, 1509031194, 413915480, 1889329185, 315502822, 1529162228, 1454661012,\r\n            1015826742, 973381409, 1414676304, 1449029961, 1968715566, 2027226497, 1721820509,\r\n            434042616, 1436005045, 1680352863, 651591867, 260585272, 1078022153, 703990572,\r\n            269504423, 1776357592, 1174979337, 1142666094, 1897872960, 1387995838, 250774418,\r\n            776134750, 73930096, 194742451, 1860060380, 666407744, 669566398, 963802147,\r\n            2063418105, 1772573581, 998923482, 701912753, 1716548204, 860820931, 1680395948,\r\n            949886256, 1811558161, 501734557, 1671977429, 463135040, 1911493108, 207754409,\r\n            608714758, 1553060084, 1558941605, 980281686, 2014426559, 650527801, 53015148,\r\n            1521176057, 720530872, 713593252, 88228433, 1194162313, 1922416934, 1075145779,\r\n            344403794,\r\n        ]);\r\n\r\n        let output = MdsMatrixMersenne31.permute(input);\r\n\r\n        let expected: [Mersenne31; 64] = Mersenne31::new_array([\r\n            1599981950, 252630853, 1171557270, 116468420, 1269245345, 666203050, 46155642,\r\n            1701131520, 530845775, 508460407, 630407239, 1731628135, 1199144768, 295132047,\r\n            77536342, 1472377703, 30752443, 1300339617, 18647556, 1267774380, 1194573079,\r\n            1624665024, 646848056, 1667216490, 1184843555, 1250329476, 254171597, 1902035936,\r\n            1706882202, 964921003, 952266538, 1215696284, 539510504, 1056507562, 1393151480,\r\n            733644883, 1663330816, 1100715048, 991108703, 1671345065, 1376431774, 408310416,\r\n            313176996, 743567676, 304660642, 1842695838, 958201635, 1650792218, 541570244,\r\n            968523062, 1958918704, 1866282698, 849808680, 1193306222, 794153281, 822835360,\r\n            135282913, 1149868448, 2068162123, 1474283743, 2039088058, 720305835, 746036736,\r\n            671006610,\r\n        ]);\r\n\r\n        assert_eq!(output, expected);\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":32,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":40,"address":[],"length":0,"stats":{"Line":16933534598913064966}},{"line":41,"address":[],"length":0,"stats":{"Line":16933534598913064966}},{"line":51,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":52,"address":[],"length":0,"stats":{"Line":5188146770730811395}},{"line":53,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":67,"address":[],"length":0,"stats":{"Line":6917529027641081859}},{"line":68,"address":[],"length":0,"stats":{"Line":6917529027641081859}},{"line":72,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":77,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":78,"address":[],"length":0,"stats":{"Line":18158513697557839872}},{"line":79,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":85,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":86,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":100,"address":[],"length":0,"stats":{"Line":15852670688344145920}},{"line":104,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":123,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":124,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":131,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":134,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":135,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":139,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":141,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":148,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":152,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":153,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":154,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":171,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":172,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":173,"address":[],"length":0,"stats":{"Line":4683743612465315840}},{"line":177,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":178,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":187,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":191,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":192,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":193,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":220,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":222,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":257,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":258,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":259,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}}],"covered":46,"coverable":54},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","mersenne_31.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt;\r\nuse core::fmt::{Debug, Display, Formatter};\r\nuse core::hash::{Hash, Hasher};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse num_bigint::BigUint;\r\nuse p3_field::exponentiation::exp_1717986917;\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{\r\n    halve_u32, quotient_map_large_iint, quotient_map_large_uint, quotient_map_small_int, Field,\r\n    InjectiveMonomial, Packable, PermutationMonomial, PrimeCharacteristicRing, PrimeField,\r\n    PrimeField32, PrimeField64,\r\n};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::de::Error;\r\nuse serde::{Deserialize, Deserializer, Serialize};\r\n\r\n/// The Mersenne31 prime\r\nconst P: u32 = (1 \u003c\u003c 31) - 1;\r\n\r\n/// The prime field `F_p` where `p = 2^31 - 1`.\r\n#[derive(Copy, Clone, Default)]\r\n#[repr(transparent)] // Packed field implementations rely on this!\r\npub struct Mersenne31 {\r\n    /// Not necessarily canonical, but must fit in 31 bits.\r\n    pub(crate) value: u32,\r\n}\r\n\r\nimpl Mersenne31 {\r\n    #[inline]\r\n    pub const fn new(value: u32) -\u003e Self {\r\n        debug_assert!((value \u003e\u003e 31) == 0);\r\n        Self { value }\r\n    }\r\n\r\n    /// Convert a constant `u32` array into a constant array of field elements.\r\n    /// This allows inputs to be `\u003e 2^31`, and just reduces them `mod P`.\r\n    ///\r\n    /// This means that this will be slower than `array.map(Mersenne31::new)` but\r\n    /// has the advantage of being able to be used in `const` environments.\r\n    #[inline]\r\n    pub const fn new_array\u003cconst N: usize\u003e(input: [u32; N]) -\u003e [Self; N] {\r\n        let mut output = [Mersenne31::ZERO; N];\r\n        let mut i = 0;\r\n        loop {\r\n            if i == N {\r\n                break;\r\n            }\r\n            output[i].value = input[i] % P;\r\n            i += 1;\r\n        }\r\n        output\r\n    }\r\n}\r\n\r\nimpl PartialEq for Mersenne31 {\r\n    #[inline]\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        self.as_canonical_u32() == other.as_canonical_u32()\r\n    }\r\n}\r\n\r\nimpl Eq for Mersenne31 {}\r\n\r\nimpl Packable for Mersenne31 {}\r\n\r\nimpl Hash for Mersenne31 {\r\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        state.write_u32(self.to_unique_u32());\r\n    }\r\n}\r\n\r\nimpl Ord for Mersenne31 {\r\n    #[inline]\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e core::cmp::Ordering {\r\n        self.as_canonical_u32().cmp(\u0026other.as_canonical_u32())\r\n    }\r\n}\r\n\r\nimpl PartialOrd for Mersenne31 {\r\n    #[inline]\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccore::cmp::Ordering\u003e {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\nimpl Display for Mersenne31 {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Display::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl Debug for Mersenne31 {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Debug::fmt(\u0026self.value, f)\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cMersenne31\u003e for Standard {\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e Mersenne31 {\r\n        loop {\r\n            let next_u31 = rng.next_u32() \u003e\u003e 1;\r\n            let is_canonical = next_u31 != Mersenne31::ORDER_U32;\r\n            if is_canonical {\r\n                return Mersenne31::new(next_u31);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Serialize for Mersenne31 {\r\n    fn serialize\u003cS: serde::Serializer\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e {\r\n        // No need to convert to canonical.\r\n        serializer.serialize_u32(self.value)\r\n    }\r\n}\r\n\r\nimpl\u003c'a\u003e Deserialize\u003c'a\u003e for Mersenne31 {\r\n    fn deserialize\u003cD: Deserializer\u003c'a\u003e\u003e(d: D) -\u003e Result\u003cSelf, D::Error\u003e {\r\n        let val = u32::deserialize(d)?;\r\n        // Ensure that `val` satisfies our invariant. i.e. Not necessarily canonical, but must fit in 31 bits.\r\n        if val \u003c= P {\r\n            Ok(Mersenne31::new(val))\r\n        } else {\r\n            Err(D::Error::custom(\"Value is out of range\"))\r\n        }\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for Mersenne31 {\r\n    type PrimeSubfield = Self;\r\n\r\n    const ZERO: Self = Self { value: 0 };\r\n    const ONE: Self = Self { value: 1 };\r\n    const TWO: Self = Self { value: 2 };\r\n    const NEG_ONE: Self = Self {\r\n        value: Self::ORDER_U32 - 1,\r\n    };\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f\r\n    }\r\n\r\n    #[inline]\r\n    fn from_bool(b: bool) -\u003e Self {\r\n        Self::new(b as u32)\r\n    }\r\n\r\n    #[inline]\r\n    fn mul_2exp_u64(\u0026self, exp: u64) -\u003e Self {\r\n        // In a Mersenne field, multiplication by 2^k is just a left rotation by k bits.\r\n        let exp = exp % 31;\r\n        let left = (self.value \u003c\u003c exp) \u0026 ((1 \u003c\u003c 31) - 1);\r\n        let right = self.value \u003e\u003e (31 - exp);\r\n        let rotated = left | right;\r\n        Self::new(rotated)\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: repr(transparent) ensures transmutation safety.\r\n        unsafe { transmute(vec![0u32; len]) }\r\n    }\r\n}\r\n\r\n// Degree of the smallest permutation polynomial for Mersenne31.\r\n//\r\n// As p - 1 = 23^2711... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nimpl InjectiveMonomial\u003c5\u003e for Mersenne31 {}\r\n\r\nimpl PermutationMonomial\u003c5\u003e for Mersenne31 {\r\n    /// In the field `Mersenne31`, `a^{1/5}` is equal to a^{1717986917}.\r\n    ///\r\n    /// This follows from the calculation `5 * 1717986917 = 4*(2^31 - 2) + 1 = 1 mod p - 1`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // We use a custom addition chain.\r\n        // This could possibly be further optimised.\r\n        exp_1717986917(*self)\r\n    }\r\n}\r\n\r\nimpl Field for Mersenne31 {\r\n    #[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\n    type Packing = crate::PackedMersenne31Neon;\r\n    #[cfg(all(\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx2\",\r\n        not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n    ))]\r\n    type Packing = crate::PackedMersenne31AVX2;\r\n    #[cfg(all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ))]\r\n    type Packing = crate::PackedMersenne31AVX512;\r\n    #[cfg(not(any(\r\n        all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n        all(\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx2\",\r\n            not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n        ),\r\n        all(\r\n            feature = \"nightly-features\",\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx512f\"\r\n        ),\r\n    )))]\r\n    type Packing = Self;\r\n\r\n    // Sage: GF(2^31 - 1).multiplicative_generator()\r\n    const GENERATOR: Self = Self::new(7);\r\n\r\n    #[inline]\r\n    fn is_zero(\u0026self) -\u003e bool {\r\n        self.value == 0 || self.value == Self::ORDER_U32\r\n    }\r\n\r\n    #[inline]\r\n    fn div_2exp_u64(\u0026self, exp: u64) -\u003e Self {\r\n        // In a Mersenne field, division by 2^k is just a right rotation by k bits.\r\n        let exp = (exp % 31) as u8;\r\n        let left = self.value \u003e\u003e exp;\r\n        let right = (self.value \u003c\u003c (31 - exp)) \u0026 ((1 \u003c\u003c 31) - 1);\r\n        let rotated = left | right;\r\n        Self::new(rotated)\r\n    }\r\n\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\r\n        if self.is_zero() {\r\n            return None;\r\n        }\r\n\r\n        // From Fermat's little theorem, in a prime field `F_p`, the inverse of `a` is `a^(p-2)`.\r\n        // Here p-2 = 2147483645 = 1111111111111111111111111111101_2.\r\n        // Uses 30 Squares + 7 Multiplications =\u003e 37 Operations total.\r\n\r\n        let p1 = *self;\r\n        let p101 = p1.exp_power_of_2(2) * p1;\r\n        let p1111 = p101.square() * p101;\r\n        let p11111111 = p1111.exp_power_of_2(4) * p1111;\r\n        let p111111110000 = p11111111.exp_power_of_2(4);\r\n        let p111111111111 = p111111110000 * p1111;\r\n        let p1111111111111111 = p111111110000.exp_power_of_2(4) * p11111111;\r\n        let p1111111111111111111111111111 = p1111111111111111.exp_power_of_2(12) * p111111111111;\r\n        let p1111111111111111111111111111101 =\r\n            p1111111111111111111111111111.exp_power_of_2(3) * p101;\r\n        Some(p1111111111111111111111111111101)\r\n    }\r\n\r\n    #[inline]\r\n    fn halve(\u0026self) -\u003e Self {\r\n        Mersenne31::new(halve_u32::\u003cP\u003e(self.value))\r\n    }\r\n\r\n    #[inline]\r\n    fn order() -\u003e BigUint {\r\n        P.into()\r\n    }\r\n}\r\n\r\n// We can use some macros to implement QuotientMap\u003cInt\u003e for all integer types except for u32 and i32's.\r\nquotient_map_small_int!(Mersenne31, u32, [u8, u16]);\r\nquotient_map_small_int!(Mersenne31, i32, [i8, i16]);\r\nquotient_map_large_uint!(\r\n    Mersenne31,\r\n    u32,\r\n    Mersenne31::ORDER_U32,\r\n    \"`[0, 2^31 - 2]`\",\r\n    \"`[0, 2^31 - 1]`\",\r\n    [u64, u128]\r\n);\r\nquotient_map_large_iint!(\r\n    Mersenne31,\r\n    i32,\r\n    \"`[-2^30, 2^30]`\",\r\n    \"`[1 - 2^31, 2^31 - 1]`\",\r\n    [(i64, u64), (i128, u128)]\r\n);\r\n\r\n// We simple need to prove custom Mersenne31 impls for QuotientMap\u003cu32\u003e and QuotientMap\u003ci32\u003e\r\nimpl QuotientMap\u003cu32\u003e for Mersenne31 {\r\n    /// Convert a given `u32` integer into an element of the `Mersenne31` field.\r\n    #[inline]\r\n    fn from_int(int: u32) -\u003e Self {\r\n        // To reduce `n` to 31 bits, we clear its MSB, then add it back in its reduced form.\r\n        let msb = int \u0026 (1 \u003c\u003c 31);\r\n        let msb_reduced = msb \u003e\u003e 31;\r\n        Self::new(int ^ msb) + Self::new(msb_reduced)\r\n    }\r\n\r\n    /// Convert a given `u32` integer into an element of the `Mersenne31` field.\r\n    ///\r\n    /// Returns none if the input does not lie in the range `[0, 2^31 - 1]`.\r\n    #[inline]\r\n    fn from_canonical_checked(int: u32) -\u003e Option\u003cMersenne31\u003e {\r\n        if int \u003c Self::ORDER_U32 {\r\n            Some(Self::new(int))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `u32` integer into an element of the `Mersenne31` field.\r\n    ///\r\n    /// # Safety\r\n    /// The input must lie in the range: `[0, 2^31 - 1]`.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: u32) -\u003e Mersenne31 {\r\n        debug_assert!(int \u003c Self::ORDER_U32);\r\n        Self::new(int)\r\n    }\r\n}\r\n\r\nimpl QuotientMap\u003ci32\u003e for Mersenne31 {\r\n    /// Convert a given `i32` integer into an element of the `Mersenne31` field.\r\n    #[inline]\r\n    fn from_int(int: i32) -\u003e Self {\r\n        if int \u003e= 0 {\r\n            Self::new(int as u32)\r\n        } else if int \u003e (-1 \u003c\u003c 31) {\r\n            Self::new(Mersenne31::ORDER_U32.wrapping_add_signed(int))\r\n        } else {\r\n            // The only other option is int = -(2^31) = -1 mod p.\r\n            Self::NEG_ONE\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i32` integer into an element of the `Mersenne31` field.\r\n    ///\r\n    /// Returns none if the input does not lie in the range `(-2^30, 2^30)`.\r\n    #[inline]\r\n    fn from_canonical_checked(int: i32) -\u003e Option\u003cMersenne31\u003e {\r\n        const TWO_EXP_30: i32 = 1 \u003c\u003c 30;\r\n        const NEG_TWO_EXP_30_PLUS_1: i32 = (-1 \u003c\u003c 30) + 1;\r\n        match int {\r\n            0..TWO_EXP_30 =\u003e Some(Self::new(int as u32)),\r\n            NEG_TWO_EXP_30_PLUS_1..0 =\u003e {\r\n                Some(Self::new(Mersenne31::ORDER_U32.wrapping_add_signed(int)))\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i32` integer into an element of the `Mersenne31` field.\r\n    ///\r\n    /// # Safety\r\n    /// The input must lie in the range: `[1 - 2^31, 2^31 - 1]`.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: i32) -\u003e Mersenne31 {\r\n        if int \u003e= 0 {\r\n            Self::new(int as u32)\r\n        } else {\r\n            Self::new(Mersenne31::ORDER_U32.wrapping_add_signed(int))\r\n        }\r\n    }\r\n}\r\n\r\nimpl PrimeField for Mersenne31 {\r\n    fn as_canonical_biguint(\u0026self) -\u003e BigUint {\r\n        \u003cSelf as PrimeField32\u003e::as_canonical_u32(self).into()\r\n    }\r\n}\r\n\r\nimpl PrimeField32 for Mersenne31 {\r\n    const ORDER_U32: u32 = P;\r\n\r\n    #[inline]\r\n    fn as_canonical_u32(\u0026self) -\u003e u32 {\r\n        // Since our invariant guarantees that `value` fits in 31 bits, there is only one possible\r\n        // `value` that is not canonical, namely 2^31 - 1 = p = 0.\r\n        if self.value == Self::ORDER_U32 {\r\n            0\r\n        } else {\r\n            self.value\r\n        }\r\n    }\r\n}\r\n\r\nimpl PrimeField64 for Mersenne31 {\r\n    const ORDER_U64: u64 = \u003cSelf as PrimeField32\u003e::ORDER_U32 as u64;\r\n\r\n    #[inline]\r\n    fn as_canonical_u64(\u0026self) -\u003e u64 {\r\n        self.as_canonical_u32().into()\r\n    }\r\n}\r\n\r\nimpl Add for Mersenne31 {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        // See the following for a way to compute the sum that avoids\r\n        // the conditional which may be preferable on some\r\n        // architectures.\r\n        // https://github.com/Plonky3/Plonky3/blob/6049a30c3b1f5351c3eb0f7c994dc97e8f68d10d/mersenne-31/src/lib.rs#L249\r\n\r\n        // Working with i32 means we get a flag which informs us if overflow happened.\r\n        let (sum_i32, over) = (self.value as i32).overflowing_add(rhs.value as i32);\r\n        let sum_u32 = sum_i32 as u32;\r\n        let sum_corr = sum_u32.wrapping_sub(Self::ORDER_U32);\r\n\r\n        // If self + rhs did not overflow, return it.\r\n        // If self + rhs overflowed, sum_corr = self + rhs - (2**31 - 1).\r\n        Self::new(if over { sum_corr } else { sum_u32 })\r\n    }\r\n}\r\n\r\nimpl AddAssign for Mersenne31 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for Mersenne31 {\r\n    #[inline]\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        // This is faster than iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO) for iterators of length \u003e= 6.\r\n        // It assumes that iter.len() \u003c 2^31.\r\n\r\n        // This sum will not overflow so long as iter.len() \u003c 2^33.\r\n        let sum = iter.map(|x| x.value as u64).sum::\u003cu64\u003e();\r\n\r\n        // sum is \u003c 2^62 provided iter.len() \u003c 2^31.\r\n        from_u62(sum)\r\n    }\r\n}\r\n\r\nimpl Sub for Mersenne31 {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let (mut sub, over) = self.value.overflowing_sub(rhs.value);\r\n\r\n        // If we didn't overflow we have the correct value.\r\n        // Otherwise we have added 2**32 = 2**31 + 1 mod 2**31 - 1.\r\n        // Hence we need to remove the most significant bit and subtract 1.\r\n        sub -= over as u32;\r\n        Self::new(sub \u0026 Self::ORDER_U32)\r\n    }\r\n}\r\n\r\nimpl SubAssign for Mersenne31 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Neg for Mersenne31 {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self::Output {\r\n        // Can't underflow, since self.value is 31-bits and thus can't exceed ORDER.\r\n        Self::new(Self::ORDER_U32 - self.value)\r\n    }\r\n}\r\n\r\nimpl Mul for Mersenne31 {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    #[allow(clippy::cast_possible_truncation)]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let prod = u64::from(self.value) * u64::from(rhs.value);\r\n        from_u62(prod)\r\n    }\r\n}\r\n\r\nimpl MulAssign for Mersenne31 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl Product for Mersenne31 {\r\n    #[inline]\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl Div for Mersenne31 {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    fn div(self, rhs: Self) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\npub(crate) fn from_u62(input: u64) -\u003e Mersenne31 {\r\n    debug_assert!(input \u003c (1 \u003c\u003c 62));\r\n    let input_lo = (input \u0026 ((1 \u003c\u003c 31) - 1)) as u32;\r\n    let input_high = (input \u003e\u003e 31) as u32;\r\n    Mersenne31::new(input_lo) + Mersenne31::new(input_high)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field::{Field, InjectiveMonomial, PermutationMonomial, PrimeCharacteristicRing};\r\n    use p3_field_testing::{\r\n        test_field, test_prime_field, test_prime_field_32, test_prime_field_64,\r\n    };\r\n\r\n    use crate::Mersenne31;\r\n\r\n    type F = Mersenne31;\r\n\r\n    #[test]\r\n    fn mul_2exp_u64() {\r\n        // 1 * 2^0 = 1.\r\n        assert_eq!(F::ONE.mul_2exp_u64(0), F::ONE);\r\n        // 2 * 2^30 = 2^31 = 1.\r\n        assert_eq!(F::TWO.mul_2exp_u64(30), F::ONE);\r\n        // 5 * 2^2 = 20.\r\n        assert_eq!(F::new(5).mul_2exp_u64(2), F::new(20));\r\n    }\r\n\r\n    #[test]\r\n    fn div_2exp_u64() {\r\n        // 1 / 2^0 = 1.\r\n        assert_eq!(F::ONE.div_2exp_u64(0), F::ONE);\r\n        // 2 / 2^0 = 2.\r\n        assert_eq!(F::TWO.div_2exp_u64(0), F::TWO);\r\n        // 32 / 2^5 = 1.\r\n        assert_eq!(F::new(32).div_2exp_u64(5), F::new(1));\r\n    }\r\n\r\n    #[test]\r\n    fn exp_root() {\r\n        // Confirm that (x^{1/5})^5 = x\r\n\r\n        let m1 = F::from_u32(0x34167c58);\r\n        let m2 = F::from_u32(0x61f3207b);\r\n\r\n        assert_eq!(m1.injective_exp_n().injective_exp_root_n(), m1);\r\n        assert_eq!(m2.injective_exp_n().injective_exp_root_n(), m2);\r\n        assert_eq!(F::TWO.injective_exp_n().injective_exp_root_n(), F::TWO);\r\n    }\r\n\r\n    test_field!(crate::Mersenne31);\r\n    test_prime_field!(crate::Mersenne31);\r\n    test_prime_field_64!(crate::Mersenne31);\r\n    test_prime_field_32!(crate::Mersenne31);\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":16789419410837209086}},{"line":37,"address":[],"length":0,"stats":{"Line":15132094747964928941}},{"line":47,"address":[],"length":0,"stats":{"Line":1008806316530991119}},{"line":48,"address":[],"length":0,"stats":{"Line":1008806316530991119}},{"line":49,"address":[],"length":0,"stats":{"Line":1008806316530991119}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":52,"address":[],"length":0,"stats":{"Line":1008806316530991119}},{"line":54,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":55,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":57,"address":[],"length":0,"stats":{"Line":1008806316530991119}},{"line":63,"address":[],"length":0,"stats":{"Line":12610078956637478102}},{"line":64,"address":[],"length":0,"stats":{"Line":12610078956637478102}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":2232}},{"line":94,"address":[],"length":0,"stats":{"Line":2232}},{"line":99,"address":[],"length":0,"stats":{"Line":140}},{"line":100,"address":[],"length":0,"stats":{"Line":140}},{"line":105,"address":[],"length":0,"stats":{"Line":7493989779944505350}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":7493989779944505751}},{"line":108,"address":[],"length":0,"stats":{"Line":7493989779944505751}},{"line":109,"address":[],"length":0,"stats":{"Line":7493989779944505751}},{"line":110,"address":[],"length":0,"stats":{"Line":7493989779944505350}},{"line":117,"address":[],"length":0,"stats":{"Line":11096869481840902164}},{"line":119,"address":[],"length":0,"stats":{"Line":11096869481840902164}},{"line":124,"address":[],"length":0,"stats":{"Line":11096869481840902175}},{"line":125,"address":[],"length":0,"stats":{"Line":3746994889972252734}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":11096869481840902144}},{"line":130,"address":[],"length":0,"stats":{"Line":31}},{"line":146,"address":[],"length":0,"stats":{"Line":216}},{"line":147,"address":[],"length":0,"stats":{"Line":216}},{"line":151,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":152,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":156,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":158,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":159,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":160,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":161,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":162,"address":[],"length":0,"stats":{"Line":17365880163140634328}},{"line":166,"address":[],"length":0,"stats":{"Line":4899916394579099768}},{"line":168,"address":[],"length":0,"stats":{"Line":4899916394579099768}},{"line":181,"address":[],"length":0,"stats":{"Line":9439544818968559620}},{"line":184,"address":[],"length":0,"stats":{"Line":9439544818968559620}},{"line":222,"address":[],"length":0,"stats":{"Line":17798225727368200221}},{"line":223,"address":[],"length":0,"stats":{"Line":17509995351216488362}},{"line":227,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":229,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":230,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":232,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":233,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":236,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":237,"address":[],"length":0,"stats":{"Line":13835058055282163712}},{"line":238,"address":[],"length":0,"stats":{"Line":72057594037928123}},{"line":245,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":246,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":247,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":248,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":249,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":250,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":251,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":252,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":253,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":254,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":255,"address":[],"length":0,"stats":{"Line":13763000461244235589}},{"line":259,"address":[],"length":0,"stats":{"Line":4395513236313604116}},{"line":260,"address":[],"length":0,"stats":{"Line":4395513236313604116}},{"line":264,"address":[],"length":0,"stats":{"Line":720575940379279392}},{"line":265,"address":[],"length":0,"stats":{"Line":720575940379279392}},{"line":292,"address":[],"length":0,"stats":{"Line":2305843009213694087}},{"line":294,"address":[],"length":0,"stats":{"Line":2305843009213694087}},{"line":295,"address":[],"length":0,"stats":{"Line":2305843009213694087}},{"line":296,"address":[],"length":0,"stats":{"Line":2305843009213694087}},{"line":303,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":304,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":305,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":307,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":316,"address":[],"length":0,"stats":{"Line":14483576401623515149}},{"line":317,"address":[],"length":0,"stats":{"Line":10520408729537479022}},{"line":318,"address":[],"length":0,"stats":{"Line":14483576401623515149}},{"line":325,"address":[],"length":0,"stats":{"Line":1152921504606847267}},{"line":326,"address":[],"length":0,"stats":{"Line":1152921504606847267}},{"line":327,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":328,"address":[],"length":0,"stats":{"Line":504403158265495843}},{"line":329,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":343,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":344,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":345,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":346,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":348,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":357,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":358,"address":[],"length":0,"stats":{"Line":8358680908399640576}},{"line":359,"address":[],"length":0,"stats":{"Line":4827858800541171712}},{"line":361,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":367,"address":[],"length":0,"stats":{"Line":4}},{"line":368,"address":[],"length":0,"stats":{"Line":4}},{"line":376,"address":[],"length":0,"stats":{"Line":16789419410837209086}},{"line":379,"address":[],"length":0,"stats":{"Line":16789419410837209086}},{"line":380,"address":[],"length":0,"stats":{"Line":1152921504606860229}},{"line":382,"address":[],"length":0,"stats":{"Line":13907115649320085245}},{"line":391,"address":[],"length":0,"stats":{"Line":936748722493063203}},{"line":392,"address":[],"length":0,"stats":{"Line":936748722493063203}},{"line":400,"address":[],"length":0,"stats":{"Line":14843864371813155340}},{"line":407,"address":[],"length":0,"stats":{"Line":14843864371813155340}},{"line":408,"address":[],"length":0,"stats":{"Line":14843864371813155340}},{"line":409,"address":[],"length":0,"stats":{"Line":14843864371813155340}},{"line":413,"address":[],"length":0,"stats":{"Line":13763000461244258506}},{"line":419,"address":[],"length":0,"stats":{"Line":2305843009213733055}},{"line":420,"address":[],"length":0,"stats":{"Line":2305843009213733055}},{"line":426,"address":[],"length":0,"stats":{"Line":5476377146882523681}},{"line":431,"address":[],"length":0,"stats":{"Line":7926335344172074425}},{"line":434,"address":[],"length":0,"stats":{"Line":5476377146882523681}},{"line":442,"address":[],"length":0,"stats":{"Line":15708555500268290966}},{"line":443,"address":[],"length":0,"stats":{"Line":15708555500268290966}},{"line":448,"address":[],"length":0,"stats":{"Line":15708555500268290966}},{"line":449,"address":[],"length":0,"stats":{"Line":15708555500268290966}},{"line":455,"address":[],"length":0,"stats":{"Line":12754194144713267899}},{"line":456,"address":[],"length":0,"stats":{"Line":12754194144713267899}},{"line":464,"address":[],"length":0,"stats":{"Line":9583660007044416005}},{"line":466,"address":[],"length":0,"stats":{"Line":9583660007044416005}},{"line":475,"address":[],"length":0,"stats":{"Line":5188146770730811584}},{"line":476,"address":[],"length":0,"stats":{"Line":5188146770730811584}},{"line":477,"address":[],"length":0,"stats":{"Line":5188146770730811584}},{"line":483,"address":[],"length":0,"stats":{"Line":10808639105689230486}},{"line":484,"address":[],"length":0,"stats":{"Line":10808639105689230486}},{"line":490,"address":[],"length":0,"stats":{"Line":72057594037927973}},{"line":491,"address":[],"length":0,"stats":{"Line":720575940379279737}},{"line":500,"address":[],"length":0,"stats":{"Line":432345564227570354}},{"line":501,"address":[],"length":0,"stats":{"Line":432345564227570354}},{"line":506,"address":[],"length":0,"stats":{"Line":10592466323575437652}},{"line":507,"address":[],"length":0,"stats":{"Line":2738188573441299021}},{"line":508,"address":[],"length":0,"stats":{"Line":10592466323575437652}},{"line":509,"address":[],"length":0,"stats":{"Line":10592466323575437652}},{"line":510,"address":[],"length":0,"stats":{"Line":10592466323575437652}}],"covered":133,"coverable":143},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","no_packing","mod.rs"],"content":"//! A couple of simple functions needed in the case that this is compiled without architecture optimizations available.\r\n\r\nmod poseidon2;\r\n\r\npub use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","no_packing","poseidon2.rs"],"content":"//! This file contains simple wrapper structs on top of which we can implement Poseidon2 Internal/ExternalLayer.\r\n//!\r\n//! They are used only in the case that none of the vectorization architectures (AVX2/AVX512/NEON) are available.\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_poseidon2::{ExternalLayerConstants, ExternalLayerConstructor, InternalLayerConstructor};\r\n\r\nuse crate::Mersenne31;\r\n\r\n/// The internal layers of the Poseidon2 permutation.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMersenne31 {\r\n    pub(crate) internal_constants: Vec\u003cMersenne31\u003e,\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerMersenne31\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cMersenne31\u003e for Poseidon2InternalLayerMersenne31 {\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        Self { internal_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cMersenne31, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","poseidon2.rs"],"content":"//! Implementation of Poseidon2, see: `\u003chttps://eprint.iacr.org/2023/323\u003e`\r\n//!\r\n//! For the diffusion matrix, 1 + Diag(V), we perform a search to find an optimized\r\n//! vector V composed of elements with efficient multiplication algorithms in AVX2/AVX512/NEON.\r\n//!\r\n//! This leads to using small values (e.g. 1, 2) where multiplication is implemented using addition\r\n//! and, powers of 2 where multiplication is implemented using shifts.\r\n//! Additionally, for technical reasons, having the first entry be -2 is useful.\r\n//!\r\n//! Optimized Diagonal for Mersenne31 width 16:\r\n//! [-2, 2^0, 2, 4, 8, 16, 32, 64, 2^7, 2^8, 2^10, 2^12, 2^13,  2^14,  2^15, 2^16]\r\n//! Optimized Diagonal for Mersenne31 width 24:\r\n//! [-2, 2^0, 2, 4, 8, 16, 32, 64, 2^7, 2^8, 2^9, 2^10, 2^11, 2^12, 2^13,  2^14,  2^15,  2^16,   2^17,   2^18,   2^19,    2^20,    2^21,    2^22]\r\n//! See poseidon2\\src\\diffusion.rs for information on how to double check these matrices in Sage.\r\n\r\nuse p3_field::Algebra;\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    internal_permute_state, ExternalLayer, GenericPoseidon2LinearLayers, InternalLayer, MDSMat4,\r\n    Poseidon2,\r\n};\r\n\r\nuse crate::{\r\n    from_u62, Mersenne31, Poseidon2ExternalLayerMersenne31, Poseidon2InternalLayerMersenne31,\r\n};\r\n\r\n/// Degree of the chosen permutation polynomial for Mersenne31, used as the Poseidon2 S-Box.\r\n///\r\n/// As p - 1 = 23^2711... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\n/// Currently pub(crate) as it is used in the default neon implementation. Once that is optimized\r\n/// this should no longer be public.\r\npub(crate) const MERSENNE31_S_BOX_DEGREE: u64 = 5;\r\n\r\n/// An implementation of the Poseidon2 hash function specialised to run on the current architecture.\r\n///\r\n/// It acts on arrays of the form either `[Mersenne31::Packing; WIDTH]` or `[Mersenne31; WIDTH]`. For speed purposes,\r\n/// wherever possible, input arrays should of the form `[Mersenne31::Packing; WIDTH]`.\r\npub type Poseidon2Mersenne31\u003cconst WIDTH: usize\u003e = Poseidon2\u003c\r\n    Mersenne31,\r\n    Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e,\r\n    Poseidon2InternalLayerMersenne31,\r\n    WIDTH,\r\n    MERSENNE31_S_BOX_DEGREE,\r\n\u003e;\r\n\r\n/// An implementation of the matrix multiplications in the internal and external layers of Poseidon2.\r\n///\r\n/// This can act on `[A; WIDTH]` for any ring implementing `Algebra\u003cMersenne31\u003e`.\r\n/// If you have either `[Mersenne31::Packing; WIDTH]` or `[Mersenne31; WIDTH]` it will be much faster\r\n/// to use `Poseidon2Mersenne31\u003cWIDTH\u003e` instead of building a Poseidon2 permutation using this.\r\npub struct GenericPoseidon2LinearLayersMersenne31 {}\r\n\r\nconst POSEIDON2_INTERNAL_MATRIX_DIAG_16_SHIFTS: [u8; 15] =\r\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16];\r\n\r\nconst POSEIDON2_INTERNAL_MATRIX_DIAG_24_SHIFTS: [u8; 23] = [\r\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\r\n];\r\n\r\n/// Multiply state by the matrix (1 + Diag(V))\r\n///\r\n/// Here V is the vector [-2] + 1 \u003c\u003c shifts. This used delayed reduction to be slightly faster.\r\nfn permute_mut\u003cconst N: usize\u003e(state: \u0026mut [Mersenne31; N], shifts: \u0026[u8]) {\r\n    debug_assert_eq!(shifts.len() + 1, N);\r\n    let part_sum: u64 = state[1..].iter().map(|x| x.value as u64).sum();\r\n    let full_sum = part_sum + (state[0].value as u64);\r\n    let s0 = part_sum + (-state[0]).value as u64;\r\n    state[0] = from_u62(s0);\r\n    for i in 1..N {\r\n        let si = full_sum + ((state[i].value as u64) \u003c\u003c shifts[i - 1]);\r\n        state[i] = from_u62(si);\r\n    }\r\n}\r\n\r\nimpl InternalLayer\u003cMersenne31, 16, MERSENNE31_S_BOX_DEGREE\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [Mersenne31; 16]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| permute_mut(x, \u0026POSEIDON2_INTERNAL_MATRIX_DIAG_16_SHIFTS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\nimpl InternalLayer\u003cMersenne31, 24, MERSENNE31_S_BOX_DEGREE\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [Mersenne31; 24]) {\r\n        internal_permute_state(\r\n            state,\r\n            |x| permute_mut(x, \u0026POSEIDON2_INTERNAL_MATRIX_DIAG_24_SHIFTS),\r\n            \u0026self.internal_constants,\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayer\u003cMersenne31, WIDTH, MERSENNE31_S_BOX_DEGREE\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [Mersenne31; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [Mersenne31; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cMersenne31\u003e\u003e GenericPoseidon2LinearLayers\u003cA, 16\u003e\r\n    for GenericPoseidon2LinearLayersMersenne31\r\n{\r\n    fn internal_linear_layer(state: \u0026mut [A; 16]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use the mul_2exp_u64 method.\r\n        // We need state[1..] as POSEIDON2_INTERNAL_MATRIX_DIAG_16_SHIFTS\r\n        // doesn't include the shift for the 0'th element as it is -2.\r\n        state[1..]\r\n            .iter_mut()\r\n            .zip(POSEIDON2_INTERNAL_MATRIX_DIAG_16_SHIFTS)\r\n            .skip(2)\r\n            .for_each(|(val, diag_shift)| {\r\n                *val = full_sum.clone() + val.clone().mul_2exp_u64(diag_shift as u64);\r\n            });\r\n    }\r\n}\r\n\r\nimpl\u003cA: Algebra\u003cMersenne31\u003e\u003e GenericPoseidon2LinearLayers\u003cA, 24\u003e\r\n    for GenericPoseidon2LinearLayersMersenne31\r\n{\r\n    fn internal_linear_layer(state: \u0026mut [A; 24]) {\r\n        let part_sum: A = state[1..].iter().cloned().sum();\r\n        let full_sum = part_sum.clone() + state[0].clone();\r\n\r\n        // The first three diagonal elements are -2, 1, 2 so we do something custom.\r\n        state[0] = part_sum - state[0].clone();\r\n        state[1] = full_sum.clone() + state[1].clone();\r\n        state[2] = full_sum.clone() + state[2].double();\r\n\r\n        // For the remaining elements we use the mul_2exp_u64 method.\r\n        // We need state[1..] as POSEIDON2_INTERNAL_MATRIX_DIAG_24_SHIFTS\r\n        // doesn't include the shift for the 0'th element as it is -2.\r\n        state[1..]\r\n            .iter_mut()\r\n            .zip(POSEIDON2_INTERNAL_MATRIX_DIAG_24_SHIFTS)\r\n            .skip(2)\r\n            .for_each(|(val, diag_shift)| {\r\n                *val = full_sum.clone() + val.clone().mul_2exp_u64(diag_shift as u64);\r\n            });\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::SeedableRng;\r\n    use rand_xoshiro::Xoroshiro128Plus;\r\n\r\n    use super::*;\r\n\r\n    type F = Mersenne31;\r\n\r\n    // We need to make some round constants. We use Xoroshiro128Plus for this as we can easily match this PRNG in sage.\r\n    // See: https://github.com/0xPolygonZero/hash-constants for the sage code used to create all these tests.\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(16)\r\n    /// vector([M31.random_element() for t in range(16)]).\r\n    #[test]\r\n    fn test_poseidon2_width_16_random() {\r\n        let mut input: [F; 16] = Mersenne31::new_array([\r\n            894848333, 1437655012, 1200606629, 1690012884, 71131202, 1749206695, 1717947831,\r\n            120589055, 19776022, 42382981, 1831865506, 724844064, 171220207, 1299207443, 227047920,\r\n            1783754913,\r\n        ]);\r\n\r\n        let expected: [F; 16] = Mersenne31::new_array([\r\n            1124552602, 2127602268, 1834113265, 1207687593, 1891161485, 245915620, 981277919,\r\n            627265710, 1534924153, 1580826924, 887997842, 1526280482, 547791593, 1028672510,\r\n            1803086471, 323071277,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2Mersenne31::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n\r\n    /// Test on a roughly random input.\r\n    /// This random input is generated by the following sage code:\r\n    /// set_random_seed(24)\r\n    /// vector([M31.random_element() for t in range(24)]).\r\n    #[test]\r\n    fn test_poseidon2_width_24_random() {\r\n        let mut input: [F; 24] = Mersenne31::new_array([\r\n            886409618, 1327899896, 1902407911, 591953491, 648428576, 1844789031, 1198336108,\r\n            355597330, 1799586834, 59617783, 790334801, 1968791836, 559272107, 31054313,\r\n            1042221543, 474748436, 135686258, 263665994, 1962340735, 1741539604, 2026927696,\r\n            449439011, 1131357108, 50869465,\r\n        ]);\r\n\r\n        let expected: [F; 24] = Mersenne31::new_array([\r\n            87189408, 212775836, 954807335, 1424761838, 1222521810, 1264950009, 1891204592,\r\n            710452896, 957091834, 1776630156, 1091081383, 786687731, 1101902149, 1281649821,\r\n            436070674, 313565599, 1961711763, 2002894460, 2040173120, 854107426, 25198245,\r\n            1967213543, 604802266, 2086190331,\r\n        ]);\r\n\r\n        let mut rng = Xoroshiro128Plus::seed_from_u64(1);\r\n        let perm = Poseidon2Mersenne31::new_from_rng_128(\u0026mut rng);\r\n\r\n        perm.permute_mut(\u0026mut input);\r\n        assert_eq!(input, expected);\r\n    }\r\n}\r\n","traces":[{"line":63,"address":[],"length":0,"stats":{"Line":5188146770730811398}},{"line":64,"address":[],"length":0,"stats":{"Line":10376293541461622790}},{"line":65,"address":[],"length":0,"stats":{"Line":5188146770730811397}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":16140901064495857668}},{"line":70,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":71,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":2305843009213693955}},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":90,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":91,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":103,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":104,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":105,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":47},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","radix_2_dit.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::extension::Complex;\r\nuse p3_field::{PrimeCharacteristicRing, PrimeField64, TwoAdicField};\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixViewMut};\r\nuse p3_matrix::util::reverse_matrix_index_bits;\r\nuse p3_matrix::Matrix;\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::Mersenne31;\r\n\r\ntype F = Mersenne31;\r\ntype C = Complex\u003cF\u003e;\r\n\r\n#[derive(Debug, Default, Clone)]\r\npub struct Mersenne31ComplexRadix2Dit;\r\n\r\nimpl TwoAdicSubgroupDft\u003cC\u003e for Mersenne31ComplexRadix2Dit {\r\n    type Evaluations = RowMajorMatrix\u003cC\u003e;\r\n    fn dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cC\u003e) -\u003e RowMajorMatrix\u003cC\u003e {\r\n        let h = mat.height();\r\n        let log_h = log2_strict_usize(h);\r\n\r\n        let root = C::two_adic_generator(log_h);\r\n        let twiddles: Vec\u003cC\u003e = root.powers().take(h / 2).collect();\r\n\r\n        // DIT butterfly\r\n        reverse_matrix_index_bits(\u0026mut mat);\r\n        for layer in 0..log_h {\r\n            dit_layer(\u0026mut mat.as_view_mut(), layer, \u0026twiddles);\r\n        }\r\n        mat\r\n    }\r\n}\r\n\r\n// NB: Most of what follows is copypasta from `dft/src/radix_2_dit.rs`.\r\n// This is ugly, but the alternative is finding another way to \"inject\"\r\n// the specialisation of the butterfly evaluation to Mersenne31Complex\r\n// (in `dit_butterfly_inner()` below) into the existing structure.\r\n\r\n/// One layer of a DIT butterfly network.\r\nfn dit_layer(mat: \u0026mut RowMajorMatrixViewMut\u003c'_, C\u003e, layer: usize, twiddles: \u0026[C]) {\r\n    let h = mat.height();\r\n    let log_h = log2_strict_usize(h);\r\n    let layer_rev = log_h - 1 - layer;\r\n\r\n    let half_block_size = 1 \u003c\u003c layer;\r\n    let block_size = half_block_size * 2;\r\n\r\n    for j in (0..h).step_by(block_size) {\r\n        // Unroll i=0 case\r\n        let butterfly_hi = j;\r\n        let butterfly_lo = butterfly_hi + half_block_size;\r\n        twiddle_free_butterfly(mat, butterfly_hi, butterfly_lo);\r\n\r\n        for i in 1..half_block_size {\r\n            let butterfly_hi = j + i;\r\n            let butterfly_lo = butterfly_hi + half_block_size;\r\n            let twiddle = twiddles[i \u003c\u003c layer_rev];\r\n            dit_butterfly(mat, butterfly_hi, butterfly_lo, twiddle);\r\n        }\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn twiddle_free_butterfly(mat: \u0026mut RowMajorMatrixViewMut\u003c'_, C\u003e, row_1: usize, row_2: usize) {\r\n    let ((shorts_1, suffix_1), (shorts_2, suffix_2)) = mat.packed_row_pair_mut(row_1, row_2);\r\n\r\n    // TODO: There's no special packing for Mersenne31Complex at the\r\n    // time of writing; when there is we'll want to expand this out\r\n    // into three separate loops.\r\n    let row_1 = shorts_1.iter_mut().chain(suffix_1);\r\n    let row_2 = shorts_2.iter_mut().chain(suffix_2);\r\n\r\n    for (x, y) in row_1.zip(row_2) {\r\n        let sum = *x + *y;\r\n        let diff = *x - *y;\r\n        *x = sum;\r\n        *y = diff;\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn dit_butterfly(mat: \u0026mut RowMajorMatrixViewMut\u003c'_, C\u003e, row_1: usize, row_2: usize, twiddle: C) {\r\n    let ((shorts_1, suffix_1), (shorts_2, suffix_2)) = mat.packed_row_pair_mut(row_1, row_2);\r\n\r\n    // TODO: There's no special packing for Mersenne31Complex at the\r\n    // time of writing; when there is we'll want to expand this out\r\n    // into three separate loops.\r\n    let row_1 = shorts_1.iter_mut().chain(suffix_1);\r\n    let row_2 = shorts_2.iter_mut().chain(suffix_2);\r\n\r\n    for (x, y) in row_1.zip(row_2) {\r\n        dit_butterfly_inner(x, y, twiddle);\r\n    }\r\n}\r\n\r\n/// Given x, y, and twiddle, return the \"butterfly values\"\r\n/// x' = x + y*twiddle and y' = x - y*twiddle.\r\n///\r\n/// NB: At the time of writing, replacing the straight-forward\r\n/// implementation\r\n///\r\n///    let sum = *x + *y * twiddle;\r\n///    let diff = *x - *y * twiddle;\r\n///    *x = sum;\r\n///    *y = diff;\r\n///\r\n/// with the one below approximately halved the runtime of a DFT over\r\n/// `Mersenne31Complex`.\r\n#[inline]\r\nfn dit_butterfly_inner(x: \u0026mut C, y: \u0026mut C, twiddle: C) {\r\n    // Adding any multiple of P doesn't change the result modulo P;\r\n    // we use this to ensure that the inputs to `from_u64`\r\n    // below are non-negative.\r\n    const P_SQR: i64 = (F::ORDER_U64 * F::ORDER_U64) as i64;\r\n    const TWO_P_SQR: i64 = 2 * P_SQR;\r\n\r\n    // Unpack the inputs;\r\n    //   x = x1 + i*x2\r\n    //   y = y1 + i*y2\r\n    //   twiddle = w1 + i*w2\r\n    let unpack = |x: C| (x.to_array()[0].value as i64, x.to_array()[1].value as i64);\r\n    let (x1, x2) = unpack(*x);\r\n    let (y1, y2) = unpack(*y);\r\n    let (w1, w2) = unpack(twiddle);\r\n\r\n    // x  y*twiddle\r\n    // = (x1 + i*x2)  (y1 + i*y2)*(w1 + i*w2)\r\n    // = (x1  (y1*w1 - y2*w2)) + i*(x2  (y2*w1 + y1*w2))\r\n    // = (x1  z1) + i*(x2  z2)\r\n    // where z1 + i*z2 = y*twiddle\r\n\r\n    // SAFE: multiplying `u64` values within the range of `Mersennes31` doesn't overflow:\r\n    // (2^31 - 1) * (2^31 - 1) = 2^62 - 2^32 + 1 \u003c 2^64 - 1\r\n    let z1 = y1 * w1 - y2 * w2; // -P^2 \u003c= z1 \u003c= P^2\r\n\r\n    // NB: 2*P^2 + P \u003c 2^63\r\n\r\n    // -P^2 \u003c= x1 + z1 \u003c= P^2 + P\r\n    let a1 = F::from_u64((P_SQR + x1 + z1) as u64);\r\n    // -P^2 \u003c= x1 - z1 \u003c= P^2 + P\r\n    let b1 = F::from_u64((P_SQR + x1 - z1) as u64);\r\n\r\n    // SAFE: multiplying `u64` values within the range of `Mersennes31` doesn't overflow:\r\n    // 2 * (2^31 - 1) * (2^31 - 1) = 2 * (2^62 - 2^32 + 1) \u003c 2^64 - 1\r\n    let z2 = y2 * w1 + y1 * w2; // 0 \u003c= z2 \u003c= 2*P^2\r\n\r\n    // 0 \u003c= x2 + z2 \u003c= 2*P^2 + P\r\n    let a2 = F::from_u64((x2 + z2) as u64);\r\n    // -2*P^2 \u003c= x2 - z2 \u003c= P\r\n    let b2 = F::from_u64((TWO_P_SQR + x2 - z2) as u64);\r\n\r\n    *x = C::new_complex(a1, a2);\r\n    *y = C::new_complex(b1, b2);\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":22,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":23,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":25,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":26,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":29,"address":[],"length":0,"stats":{"Line":360287970189639825}},{"line":30,"address":[],"length":0,"stats":{"Line":5692549928996307089}},{"line":31,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":33,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":43,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":44,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":45,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":46,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":48,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":49,"address":[],"length":0,"stats":{"Line":2666130979403333632}},{"line":51,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":53,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":54,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":55,"address":[],"length":0,"stats":{"Line":6557241057451442176}},{"line":57,"address":[],"length":0,"stats":{"Line":9583660007044415488}},{"line":58,"address":[],"length":0,"stats":{"Line":10736581511651262464}},{"line":59,"address":[],"length":0,"stats":{"Line":10736581511651262464}},{"line":60,"address":[],"length":0,"stats":{"Line":10736581511651262464}},{"line":61,"address":[],"length":0,"stats":{"Line":10736581511651262464}},{"line":67,"address":[],"length":0,"stats":{"Line":6557241057451442248}},{"line":68,"address":[],"length":0,"stats":{"Line":6557241057451442248}},{"line":73,"address":[],"length":0,"stats":{"Line":6557241057451442248}},{"line":74,"address":[],"length":0,"stats":{"Line":6557241057451442248}},{"line":76,"address":[],"length":0,"stats":{"Line":1224979098644775016}},{"line":77,"address":[],"length":0,"stats":{"Line":6557241057451442192}},{"line":78,"address":[],"length":0,"stats":{"Line":6557241057451442192}},{"line":79,"address":[],"length":0,"stats":{"Line":6557241057451442192}},{"line":80,"address":[],"length":0,"stats":{"Line":6557241057451442192}},{"line":85,"address":[],"length":0,"stats":{"Line":10736581511651262480}},{"line":86,"address":[],"length":0,"stats":{"Line":10736581511651262480}},{"line":91,"address":[],"length":0,"stats":{"Line":10736581511651262480}},{"line":92,"address":[],"length":0,"stats":{"Line":10736581511651262480}},{"line":94,"address":[],"length":0,"stats":{"Line":13763000461244235936}},{"line":95,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":113,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":124,"address":[],"length":0,"stats":{"Line":6052837899185946696}},{"line":125,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":126,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":127,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":137,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":142,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":144,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":148,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":151,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":153,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":155,"address":[],"length":0,"stats":{"Line":10736581511651262536}},{"line":156,"address":[],"length":0,"stats":{"Line":10736581511651262536}}],"covered":52,"coverable":52},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx2","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\npub use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx2","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m256i};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::exponentiation::exp_1717986917;\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Mersenne31;\r\n\r\nconst WIDTH: usize = 8;\r\npub(crate) const P: __m256i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7fffffff; WIDTH]) };\r\n\r\n/// Vectorized AVX2 implementation of `Mersenne31` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct PackedMersenne31AVX2(pub [Mersenne31; WIDTH]);\r\n\r\nimpl PackedMersenne31AVX2 {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    pub(crate) fn to_vector(self) -\u003e __m256i {\r\n        unsafe {\r\n            // Safety: `Mersenne31` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[Mersenne31; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `__m256i`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMersenne31AVX2` is `repr(transparent)` so it can be transmuted to\r\n            // `[Mersenne31; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid\r\n    /// `Mersenne31`. In particular, each element of vector must be in `0..=P`.\r\n    pub(crate) unsafe fn from_vector(vector: __m256i) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `Mersenne31` values. We must only reason about memory representations. `__m256i` can be\r\n        // transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which can\r\n        // be transmuted to `[Mersenne31; WIDTH]` (since `Mersenne31` is `repr(transparent)`), which\r\n        // in turn can be transmuted to `PackedMersenne31AVX2` (since `PackedMersenne31AVX2` is also\r\n        // `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMersenne31\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: Mersenne31) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl Add for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Mul for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Neg for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg(val);\r\n        unsafe {\r\n            // Safety: `neg` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Sub for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n/// Add two vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn add(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpaddd   t, lhs, rhs\r\n    //      vpsubd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1 cyc/vec (8 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let t := lhs + rhs. We want to return a value r in {0, ..., P} such that r = t (mod P).\r\n    //   Define u := (t - P) mod 2^32 and r := min(t, u). t is in {0, ..., 2 P}. We argue by cases.\r\n    //   If t is in {0, ..., P - 1}, then u is in {(P - 1 \u003c) 2^32 - P, ..., 2^32 - 1}, so r = t is\r\n    // in the correct range.\r\n    //   If t is in {P, ..., 2 P}, then u is in {0, ..., P} and r = u is in the correct range.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let t = x86_64::_mm256_add_epi32(lhs, rhs);\r\n        let u = x86_64::_mm256_sub_epi32(t, P);\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn movehdup_epi32(x: __m256i) -\u003e __m256i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, duplicate, and cast back.\r\n    unsafe {\r\n        x86_64::_mm256_castps_si256(x86_64::_mm256_movehdup_ps(x86_64::_mm256_castsi256_ps(x)))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn moveldup_epi32(x: __m256i) -\u003e __m256i {\r\n    // This instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, duplicate, and cast back.\r\n    unsafe {\r\n        x86_64::_mm256_castps_si256(x86_64::_mm256_moveldup_ps(x86_64::_mm256_castsi256_ps(x)))\r\n    }\r\n}\r\n\r\n/// Multiply vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn mul(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    // vpsrlq     lhs_odd_dbl, lhs, 31\r\n    // vmovshdup  rhs_odd, rhs\r\n    // vpmuludq   prod_odd_dbl, lhs_odd_dbl, rhs_odd\r\n    // vpmuludq   prod_evn, lhs, rhs\r\n    // vpsllq     prod_odd_lo_dirty, prod_odd_dbl, 31\r\n    // vpsrlq     prod_evn_hi, prod_evn, 31\r\n    // vpblendd   prod_lo_dirty, prod_evn, prod_odd_lo_dirty, aah\r\n    // vpblendd   prod_hi, prod_evn_hi, prod_odd_dbl, aah\r\n    // vpand      prod_lo, prod_lo_dirty, P\r\n    // vpaddd     t, prod_lo, prod_hi\r\n    // vpsubd     u, t, P\r\n    // vpminud    res, t, u\r\n    // throughput: 4 cyc/vec (2 els/cyc)\r\n    // latency: 13 cyc\r\n    unsafe {\r\n        // vpmuludq only reads the bottom 32 bits of every 64-bit quadword.\r\n        // The even indices are already in the bottom 32 bits of a quadword, so we can leave them.\r\n        let lhs_evn = lhs;\r\n        let rhs_evn = rhs;\r\n        // Right shift by 31 is equivalent to moving the high 32 bits down to the low 32, and then\r\n        // doubling it. So these are the odd indices in lhs, but doubled.\r\n        let lhs_odd_dbl = x86_64::_mm256_srli_epi64::\u003c31\u003e(lhs);\r\n        // Copy the high 32 bits in each quadword of rhs down to the low 32.\r\n        let rhs_odd = movehdup_epi32(rhs);\r\n\r\n        // Multiply odd indices; since lhs_odd_dbl is doubled, these products are also doubled.\r\n        // prod_odd_dbl.quadword[i] = 2 * lsh.doubleword[2 * i + 1] * rhs.doubleword[2 * i + 1]\r\n        let prod_odd_dbl = x86_64::_mm256_mul_epu32(rhs_odd, lhs_odd_dbl);\r\n        // Multiply even indices.\r\n        // prod_evn.quadword[i] = lsh.doubleword[2 * i] * rhs.doubleword[2 * i]\r\n        let prod_evn = x86_64::_mm256_mul_epu32(rhs_evn, lhs_evn);\r\n\r\n        // We now need to extract the low 31 bits and the high 31 bits of each 62 bit product and\r\n        // prepare to add them.\r\n        // Put the low 31 bits of the product (recall that it is shifted left by 1) in an odd\r\n        // doubleword. (Notice that the high 31 bits are already in an odd doubleword in\r\n        // prod_odd_dbl.) We will still need to clear the sign bit, hence we mark it _dirty.\r\n        let prod_odd_lo_dirty = x86_64::_mm256_slli_epi64::\u003c31\u003e(prod_odd_dbl);\r\n        // Put the high 31 bits in an even doubleword, again noting that in prod_evn the even\r\n        // doublewords contain the low 31 bits (with a dirty sign bit).\r\n        let prod_evn_hi = x86_64::_mm256_srli_epi64::\u003c31\u003e(prod_evn);\r\n\r\n        // Put all the low halves of all the products into one vector. Take the even values from\r\n        // prod_evn and odd values from prod_odd_lo_dirty. Note that the sign bits still need\r\n        // clearing.\r\n        let prod_lo_dirty = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(prod_evn, prod_odd_lo_dirty);\r\n        // Now put all the high halves into one vector. The even values come from prod_evn_hi and\r\n        // the odd values come from prod_odd_dbl.\r\n        let prod_hi = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(prod_evn_hi, prod_odd_dbl);\r\n        // Clear the most significant bit.\r\n        let prod_lo = x86_64::_mm256_and_si256(prod_lo_dirty, P);\r\n\r\n        // Standard addition of two 31-bit values.\r\n        add(prod_lo, prod_hi)\r\n    }\r\n}\r\n\r\n/// Negate a vector of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the input does not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg(val: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpxor  res, val, P\r\n    // throughput: .33 cyc/vec (24 els/cyc)\r\n    // latency: 1 cyc\r\n\r\n    //   Since val is in {0, ..., P (= 2^31 - 1)}, res = val XOR P = P - val. Then res is in {0,\r\n    // ..., P}.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        x86_64::_mm256_xor_si256(val, P)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn sub(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpsubd   t, lhs, rhs\r\n    //      vpaddd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1 cyc/vec (8 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let d := lhs - rhs and t := d mod 2^32. We want to return a value r in {0, ..., P} such\r\n    // that r = d (mod P).\r\n    //   Define u := (t + P) mod 2^32 and r := min(t, u). d is in {-P, ..., P}. We argue by cases.\r\n    //   If d is in {0, ..., P}, then t = d and u is in {P, ..., 2 P}. r = t is in the correct\r\n    // range.\r\n    //   If d is in {-P, ..., -1}, then t is in {2^32 - P, ..., 2^32 - 1} and u is in\r\n    // {0, ..., P - 1}. r = u is in the correct range.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let t = x86_64::_mm256_sub_epi32(lhs, rhs);\r\n        let u = x86_64::_mm256_add_epi32(t, P);\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n/// Reduce a representative in {0, ..., P^2}\r\n/// to a representative in [-P, P]. If the input is greater than P^2, the output will\r\n/// still correspond to the same class but will instead lie in [-P, 2^34].\r\n#[inline(always)]\r\nfn partial_reduce_neg(x: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        // Get the top bits shifted down.\r\n        let hi = x86_64::_mm256_srli_epi64::\u003c31\u003e(x);\r\n\r\n        const LOW31: __m256i = unsafe { transmute::\u003c[u64; 4], _\u003e([0x7fffffff; 4]) };\r\n        // nand instead of and means this returns P - lo.\r\n        let neg_lo = x86_64::_mm256_andnot_si256(x, LOW31);\r\n\r\n        // Compiling with sub_epi64 vs sub_epi32 both produce reasonable code so we use\r\n        // sub_epi64 for the slightly greater flexibility.\r\n        // See: https://godbolt.org/z/WPze9e3f3\r\n        x86_64::_mm256_sub_epi64(hi, neg_lo)\r\n    }\r\n}\r\n\r\n/// Compute the square of the Mersenne-31 field elements located in the even indices.\r\n/// These field elements are represented as values in {-P, ..., P}. If the even inputs\r\n/// do not conform to this representation, the result is undefined.\r\n/// Values in odd indices are ignored.\r\n/// Output will contain 0's in odd indices.\r\n#[inline(always)]\r\nfn square_unred(x: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let x2 = x86_64::_mm256_mul_epi32(x, x);\r\n        partial_reduce_neg(x2)\r\n    }\r\n}\r\n\r\n/// Compute the permutation x -\u003e x^5 on Mersenne-31 field elements\r\n/// represented as values in {0, ..., P}. If the inputs do not conform\r\n/// to this representation, the result is undefined.\r\n#[inline(always)]\r\npub(crate) fn exp5(x: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let input_evn = x;\r\n        let input_odd = movehdup_epi32(x);\r\n\r\n        let evn_sq = square_unred(input_evn);\r\n        let odd_sq = square_unred(input_odd);\r\n\r\n        let evn_4 = square_unred(evn_sq);\r\n        let odd_4 = square_unred(odd_sq);\r\n\r\n        let evn_5 = x86_64::_mm256_mul_epi32(evn_4, input_evn);\r\n        let odd_5 = x86_64::_mm256_mul_epi32(odd_4, input_odd);\r\n\r\n        // Marked dirty as the top bit needs to be cleared.\r\n        let odd_5_lo_dirty = moveldup_epi32(odd_5);\r\n        let odd_5_hi = x86_64::_mm256_add_epi64(odd_5, odd_5);\r\n        let evn_5_hi = x86_64::_mm256_srli_epi64::\u003c31\u003e(evn_5);\r\n\r\n        // Marked dirty as the top bit needs to be cleared.\r\n        let lo_dirty = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(evn_5, odd_5_lo_dirty);\r\n        let hi = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(evn_5_hi, odd_5_hi);\r\n        let lo = x86_64::_mm256_and_si256(lo_dirty, P);\r\n        let corr = x86_64::_mm256_sign_epi32(P, hi);\r\n        let t = x86_64::_mm256_add_epi32(hi, lo);\r\n        let u = x86_64::_mm256_sub_epi32(t, corr);\r\n\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\nimpl From\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn from(value: Mersenne31) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl Default for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        Mersenne31::default().into()\r\n    }\r\n}\r\n\r\nimpl AddAssign for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl MulAssign for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl SubAssign for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Product for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for PackedMersenne31AVX2 {\r\n    type PrimeSubfield = Mersenne31;\r\n\r\n    const ZERO: Self = Self::broadcast(Mersenne31::ZERO);\r\n    const ONE: Self = Self::broadcast(Mersenne31::ONE);\r\n    const TWO: Self = Self::broadcast(Mersenne31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(Mersenne31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[must_use]\r\n    #[inline(always)]\r\n    fn exp_const_u64\u003cconst POWER: u64\u003e(\u0026self) -\u003e Self {\r\n        // We provide specialised code for power 5 as this turns up regularly.\r\n        // The other powers could be specialised similarly but we ignore this for now.\r\n        // These ideas could also be used to speed up the more generic exp_u64.\r\n        match POWER {\r\n            0 =\u003e Self::ONE,\r\n            1 =\u003e *self,\r\n            2 =\u003e self.square(),\r\n            3 =\u003e self.cube(),\r\n            4 =\u003e self.square().square(),\r\n            5 =\u003e unsafe {\r\n                let val = self.to_vector();\r\n                Self::from_vector(exp5(val))\r\n            },\r\n            6 =\u003e self.square().cube(),\r\n            7 =\u003e {\r\n                let x2 = self.square();\r\n                let x3 = x2 * *self;\r\n                let x4 = x2.square();\r\n                x3 * x4\r\n            }\r\n            _ =\u003e self.exp_u64(POWER),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(Mersenne31::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\n// Degree of the smallest permutation polynomial for Mersenne31.\r\n//\r\n// As p - 1 = 23^2711... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nimpl InjectiveMonomial\u003c5\u003e for PackedMersenne31AVX2 {}\r\n\r\nimpl PermutationMonomial\u003c5\u003e for PackedMersenne31AVX2 {\r\n    /// In the field `Mersenne31`, `a^{1/5}` is equal to a^{1717986917}.\r\n    ///\r\n    /// This follows from the calculation `5 * 1717986917 = 4*(2^31 - 2) + 1 = 1 mod p - 1`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_1717986917(*self)\r\n    }\r\n}\r\n\r\nimpl Algebra\u003cMersenne31\u003e for PackedMersenne31AVX2 {}\r\n\r\nimpl Add\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Mersenne31) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Mul\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Mersenne31) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sub\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Mersenne31) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl AddAssign\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl MulAssign\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl SubAssign\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sum\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.sum::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Product\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.product::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Div\u003cMersenne31\u003e for PackedMersenne31AVX2 {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Mersenne31) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl Add\u003cPackedMersenne31AVX2\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX2;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMersenne31AVX2) -\u003e PackedMersenne31AVX2 {\r\n        PackedMersenne31AVX2::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl Mul\u003cPackedMersenne31AVX2\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX2;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMersenne31AVX2) -\u003e PackedMersenne31AVX2 {\r\n        PackedMersenne31AVX2::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl Sub\u003cPackedMersenne31AVX2\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX2;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMersenne31AVX2) -\u003e PackedMersenne31AVX2 {\r\n        PackedMersenne31AVX2::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cPackedMersenne31AVX2\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMersenne31AVX2 {\r\n        PackedMersenne31AVX2(rng.gen())\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vpsllq    t, a, 32\r\n    //      vpsrlq    u, b, 32\r\n    //      vpblendd  res0, a, u, aah\r\n    //      vpblendd  res1, t, b, aah\r\n    // throughput: 1.33 cyc/2 vec (12 els/cyc)\r\n    // latency: (1 -\u003e 1)  1 cyc\r\n    //          (1 -\u003e 2)  2 cyc\r\n    //          (2 -\u003e 1)  2 cyc\r\n    //          (2 -\u003e 2)  1 cyc\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a1   0  a3   0  a5   0  a7   0 ].\r\n        //   u = [  0  b0   0  b2   0  b4   0  b6 ].\r\n        let t = x86_64::_mm256_srli_epi64::\u003c32\u003e(a);\r\n        let u = x86_64::_mm256_slli_epi64::\u003c32\u003e(b);\r\n\r\n        // Then\r\n        //   res0 = [ a0  b0  a2  b2  a4  b4  a6  b6 ],\r\n        //   res1 = [ a1  b1  a3  b3  a5  b5  a7  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(a, u),\r\n            x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vpalignr  t, b, a, 8\r\n    //      vpblendd  res0, a, t, cch\r\n    //      vpblendd  res1, t, b, cch\r\n    // throughput: 1 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a2  a3  b0  b1  a6  a7  b4  b5 ].\r\n        let t = x86_64::_mm256_alignr_epi8::\u003c8\u003e(b, a);\r\n\r\n        // Then\r\n        //   res0 = [ a0  a1  b0  b1  a4  a5  b4  b5 ],\r\n        //   res1 = [ a2  a3  b2  b3  a6  a7  b6  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b11001100\u003e(a, t),\r\n            x86_64::_mm256_blend_epi32::\u003c0b11001100\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave4(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vperm2i128  t, a, b, 21h\r\n    //      vpblendd    res0, a, t, f0h\r\n    //      vpblendd    res1, t, b, f0h\r\n    // throughput: 1 cyc/2 vec (16 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a4  a5  a6  a7  b0  b1  b2  b3 ].\r\n        let t = x86_64::_mm256_permute2x128_si256::\u003c0x21\u003e(a, b);\r\n\r\n        // Then\r\n        //   res0 = [ a0  a1  a2  a3  b0  b1  b2  b3 ],\r\n        //   res1 = [ a4  a5  a6  a7  b4  b5  b6  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b11110000\u003e(a, t),\r\n            x86_64::_mm256_blend_epi32::\u003c0b11110000\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl PackedValue for PackedMersenne31AVX2 {\r\n    type Value = Mersenne31;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[Mersenne31]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31AVX2` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [Mersenne31]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31AVX2` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e Mersenne31\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[Mersenne31] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Mersenne31] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl PackedField for PackedMersenne31AVX2 {\r\n    type Scalar = Mersenne31;\r\n}\r\n\r\nunsafe impl PackedFieldPow2 for PackedMersenne31AVX2 {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e interleave4(v0, v1),\r\n            8 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::{Mersenne31, WIDTH};\r\n\r\n    /// Zero has a redundant representation, so let's test both.\r\n    const ZEROS: [Mersenne31; WIDTH] = Mersenne31::new_array([\r\n        0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000,\r\n        0x7fffffff,\r\n    ]);\r\n\r\n    const SPECIAL_VALS: [Mersenne31; WIDTH] = Mersenne31::new_array([\r\n        0x00000000, 0x7fffffff, 0x00000001, 0x7ffffffe, 0x00000002, 0x7ffffffd, 0x40000000,\r\n        0x3fffffff,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedMersenne31AVX2,\r\n        crate::PackedMersenne31AVX2(super::ZEROS),\r\n        crate::PackedMersenne31AVX2(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":15060037153926940356}},{"line":37,"address":[],"length":0,"stats":{"Line":15060037153926940356}},{"line":47,"address":[],"length":0,"stats":{"Line":7566047373982434517}},{"line":54,"address":[],"length":0,"stats":{"Line":7566047373982434517}},{"line":61,"address":[],"length":0,"stats":{"Line":17293822569102711726}},{"line":62,"address":[],"length":0,"stats":{"Line":17293822569102711726}},{"line":69,"address":[],"length":0,"stats":{"Line":9223372036854775944}},{"line":70,"address":[],"length":0,"stats":{"Line":9223372036854775944}},{"line":71,"address":[],"length":0,"stats":{"Line":9223372036854775944}},{"line":72,"address":[],"length":0,"stats":{"Line":9223372036854775944}},{"line":75,"address":[],"length":0,"stats":{"Line":9223372036854775944}},{"line":83,"address":[],"length":0,"stats":{"Line":8574853690513425370}},{"line":84,"address":[],"length":0,"stats":{"Line":8574853690513425370}},{"line":85,"address":[],"length":0,"stats":{"Line":8574853690513425370}},{"line":86,"address":[],"length":0,"stats":{"Line":8574853690513425370}},{"line":89,"address":[],"length":0,"stats":{"Line":8574853690513425370}},{"line":97,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":98,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":99,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":102,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":110,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":111,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":112,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":113,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":116,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":125,"address":[],"length":0,"stats":{"Line":17798225727368203547}},{"line":140,"address":[],"length":0,"stats":{"Line":17798225727368203547}},{"line":141,"address":[],"length":0,"stats":{"Line":17798225727368203547}},{"line":142,"address":[],"length":0,"stats":{"Line":17798225727368203547}},{"line":148,"address":[],"length":0,"stats":{"Line":15996785876420015971}},{"line":152,"address":[],"length":0,"stats":{"Line":15996785876420015971}},{"line":158,"address":[],"length":0,"stats":{"Line":7421932185906577434}},{"line":162,"address":[],"length":0,"stats":{"Line":7421932185906577434}},{"line":170,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":189,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":190,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":193,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":195,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":199,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":202,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":209,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":212,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":217,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":220,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":222,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":225,"address":[],"length":0,"stats":{"Line":8574853690513430480}},{"line":233,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":243,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":251,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":268,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":269,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":270,"address":[],"length":0,"stats":{"Line":8142508126285860148}},{"line":278,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":281,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":285,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":290,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":300,"address":[],"length":0,"stats":{"Line":10376293541461622789}},{"line":303,"address":[],"length":0,"stats":{"Line":10376293541461622789}},{"line":304,"address":[],"length":0,"stats":{"Line":10376293541461622789}},{"line":312,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":315,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":316,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":318,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":319,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":321,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":322,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":324,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":325,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":328,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":329,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":330,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":333,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":334,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":335,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":336,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":337,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":338,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":340,"address":[],"length":0,"stats":{"Line":7205759403792793605}},{"line":346,"address":[],"length":0,"stats":{"Line":17293822569102705614}},{"line":347,"address":[],"length":0,"stats":{"Line":17293822569102705614}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":12970366926827030212}},{"line":361,"address":[],"length":0,"stats":{"Line":12970366926827030212}},{"line":367,"address":[],"length":0,"stats":{"Line":2882303761517118716}},{"line":368,"address":[],"length":0,"stats":{"Line":2882303761517118716}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":385,"address":[],"length":0,"stats":{"Line":10376293541461622783}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":408,"address":[],"length":0,"stats":{"Line":1059}},{"line":409,"address":[],"length":0,"stats":{"Line":1059}},{"line":414,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":418,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":426,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":431,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":432,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":433,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":1729382256910270481}},{"line":442,"address":[],"length":0,"stats":{"Line":1729382256910270481}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":4611686018427389599}},{"line":475,"address":[],"length":0,"stats":{"Line":4611686018427389599}},{"line":482,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":541,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":590,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":591,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":597,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":598,"address":[],"length":0,"stats":{"Line":72057594037927940}},{"line":605,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":621,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":627,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":628,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":635,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":651,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":657,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":658,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":669,"address":[],"length":0,"stats":{"Line":310}},{"line":670,"address":[],"length":0,"stats":{"Line":310}},{"line":675,"address":[],"length":0,"stats":{"Line":3}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":18230571291595767996}},{"line":692,"address":[],"length":0,"stats":{"Line":18230571291595767996}},{"line":693,"address":[],"length":0,"stats":{"Line":18230571291595767996}},{"line":697,"address":[],"length":0,"stats":{"Line":6196953087261802498}},{"line":698,"address":[],"length":0,"stats":{"Line":6196953087261802498}},{"line":701,"address":[],"length":0,"stats":{"Line":7205759403792794183}},{"line":702,"address":[],"length":0,"stats":{"Line":7205759403792794183}},{"line":712,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":713,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":714,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":715,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":716,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":717,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":718,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}}],"covered":131,"coverable":175},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx2","poseidon2.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m256i};\r\nuse core::mem::transmute;\r\n\r\nuse p3_field::PrimeField32;\r\nuse p3_poseidon2::{\r\n    external_initial_permute_state, external_terminal_permute_state, sum_15, sum_23, ExternalLayer,\r\n    ExternalLayerConstants, ExternalLayerConstructor, InternalLayer, InternalLayerConstructor,\r\n    MDSMat4,\r\n};\r\n\r\nuse crate::{exp5, Mersenne31, PackedMersenne31AVX2, P};\r\n\r\n/// The internal layers of the Poseidon2 permutation for Mersenne31.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 8 copies of `x - P` into the corresponding `__m256i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMersenne31 {\r\n    pub(crate) internal_constants: Vec\u003cMersenne31\u003e,\r\n    packed_internal_constants: Vec\u003c__m256i\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cMersenne31\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// We save the round constants in the {-P, ..., 0} representation instead of the standard\r\n    /// {0, ..., P} one. This saves several instructions later.\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        Self::new_from_constants(internal_constants)\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Mersenne31.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 8 copies of `x - P` into the corresponding `__m256i` packed constant.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerMersenne31\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e,\r\n    packed_initial_external_constants: Vec\u003c[__m256i; WIDTH]\u003e,\r\n    packed_terminal_external_constants: Vec\u003c[__m256i; WIDTH]\u003e,\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cMersenne31, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        Self::new_from_constants(external_constants)\r\n    }\r\n}\r\n\r\n/// Convert elements from the standard form {0, ..., P} to {-P, ..., 0} and copy into a vector\r\nfn convert_to_vec_neg_form(input: i32) -\u003e __m256i {\r\n    let input_sub_p = input - (Mersenne31::ORDER_U32 as i32);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        x86_64::_mm256_set1_epi32(input_sub_p)\r\n    }\r\n}\r\n\r\nimpl Poseidon2InternalLayerMersenne31 {\r\n    /// Construct an instance of Poseidon2InternalLayerMersenne31 from a vector containing\r\n    /// the constants for each round. Internally, the constants are transformed into th\r\n    /// {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        let packed_internal_constants = internal_constants\r\n            .iter()\r\n            .map(|constant| convert_to_vec_neg_form(constant.value as i32))\r\n            .collect();\r\n        Self {\r\n            internal_constants,\r\n            packed_internal_constants,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e {\r\n    /// Construct an instance of Poseidon2ExternalLayerMersenne31 from a array of\r\n    /// vectors containing the constants for each round. Internally, the constants\r\n    ///  are transformed into the {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        let packed_initial_external_constants = external_constants\r\n            .get_initial_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form(constant.value as i32)))\r\n            .collect();\r\n        let packed_terminal_external_constants = external_constants\r\n            .get_terminal_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form(constant.value as i32)))\r\n            .collect();\r\n        Self {\r\n            external_constants,\r\n            packed_initial_external_constants,\r\n            packed_terminal_external_constants,\r\n        }\r\n    }\r\n}\r\n\r\n/// Compute the map `x -\u003e 2^I x` on Mersenne-31 field elements.\r\n///\r\n/// `x` must be represented as a value in `[0, P]`.\r\n/// This requires 2 generic parameters, `I` and `I_PRIME` satisfying `I + I_PRIME = 31`.\r\n/// If the inputs do not conform to this representations, the result is undefined.\r\n#[inline(always)]\r\nfn mul_2exp_i\u003cconst I: i32, const I_PRIME: i32\u003e(val: PackedMersenne31AVX2) -\u003e PackedMersenne31AVX2 {\r\n    /*\r\n        We want this to compile to:\r\n            vpslld   hi_dirty, val,      I\r\n            vpsrld   lo,       val,      31 - I\r\n            vpand    hi,       hi_dirty, P\r\n            vpor     res,      lo,       hi\r\n        throughput: 1.33 cyc/vec\r\n        latency: 3 cyc\r\n    */\r\n    assert_eq!(I + I_PRIME, 31);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let input = val.to_vector();\r\n\r\n        // In M31, multiplication by 2^n corresponds to a cyclic rotation which\r\n        // is much faster than the naive multiplication method.\r\n\r\n        // Shift the low bits up. This also shifts something unwanted into\r\n        // the sign bit so we mark it dirty.\r\n        let hi_bits_dirty = x86_64::_mm256_slli_epi32::\u003cI\u003e(input);\r\n\r\n        // Shift the high bits down.\r\n        let lo_bits = x86_64::_mm256_srli_epi32::\u003cI_PRIME\u003e(input);\r\n\r\n        // Clear the sign bit.\r\n        let hi_bits = x86_64::_mm256_and_si256(hi_bits_dirty, P);\r\n\r\n        // Combine the lo and high bits.\r\n        let output = x86_64::_mm256_or_si256(lo_bits, hi_bits);\r\n        PackedMersenne31AVX2::from_vector(output)\r\n    }\r\n}\r\n\r\n/// Compute the map `x -\u003e 2^15 x` on Mersenne-31 field elements.\r\n///\r\n/// `x` must be represented as a value in `[0, P]`.\r\n/// If the input does not conform to this representations, the result is undefined.\r\n/// This has higher throughput and higher latency than mul_2exp_i so should be used\r\n/// in contexts where latency is less important.\r\n#[inline(always)]\r\nfn mul_2exp_15(val: PackedMersenne31AVX2) -\u003e PackedMersenne31AVX2 {\r\n    /*\r\n        We want this to compile to:\r\n            vpmaddwd  neg_madds,     val,           C\r\n            vpaddd    dirty_neg_res, neg_madds,     P\r\n            vpandn    res,           dirty_neg_res, P\r\n        throughput: 1 cyc/vec\r\n        latency: 7 cyc\r\n\r\n        The following is a proof that this works:\r\n        Let our input be x which we can decompose as (x_lo + 2^{16}x_hi).\r\n        Additionally let x_n denote the n'th binary digit of x.\r\n\r\n        Our goal is to output y = 2^15x = 2^15x_lo + 2^{31}x_hi = x_hi + 2^{15}x_lo\r\n        Note additionally that x_hi + 2^{15}x_lo \u003c 2^31 as x_lo \u003c 2^16 and x_hi \u003c 2^15.\r\n\r\n        On each 32 bit lane vpmaddwd signed multiplies matching 16 bit integers and adds the result.\r\n        Hence setting C = [[-2^{15}, -1]; 8], the first instruction outputs\r\n\r\n        -x_hi - 2^{15}(x_lo - 2^{16}x_{16})  (The x_{16} appears as we interpret x_lo as a signed integer).\r\n        = -(x_hi + 2^{15}x_lo) + 2^{31}x_{16}\r\n        = -y + 2^{31}x_{16}\r\n\r\n        Next, we add P = 2^31 - 1 to this, giving us:\r\n        -y + 2^{31}x_{16} + P = 2^31(1 + x_{16}) + (- y - 1) mod 2^32.\r\n        Note that -y-1 is exactly (NOT y) as y + (NOT y) = - 1 so we are left with:\r\n\r\n        2^31(1 + x_{16}) + (NOT y)\r\n\r\n        As we know y \u003c 2^31, we simply do a NOT followed by clearing the sign bit\r\n        this is exactly what vpandn accomplishes (with third argument equal to P.)\r\n\r\n    */\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let input = val.to_vector();\r\n\r\n        const C: __m256i = unsafe { transmute([[(-1_i16) \u003c\u003c 15, -1_i16]; 8]) };\r\n\r\n        let neg_madds = x86_64::_mm256_madd_epi16(input, C);\r\n        let dirty_neg_output = x86_64::_mm256_add_epi32(neg_madds, P);\r\n        let output = x86_64::_mm256_andnot_si256(dirty_neg_output, P);\r\n\r\n        PackedMersenne31AVX2::from_vector(output)\r\n    }\r\n}\r\n\r\n/// We hard code multiplication by the diagonal minus 1 of our internal matrix (1 + Diag(V))\r\n/// In the Mersenne31, WIDTH = 16 case, the diagonal minus 1 is:\r\n/// [-2] + 1 \u003c\u003c [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16]\r\n/// i.e. The first entry is -2 and all other entries are powers of 2.\r\n#[inline(always)]\r\nfn diagonal_mul_16(state: \u0026mut [PackedMersenne31AVX2; 16]) {\r\n    // The first three entries involve multiplication by -2, 1, 2 which are simple:\r\n    // state[0] -\u003e -2*state[0] is handled by the calling code.\r\n    state[2] = state[2] + state[2]; // add is 3 instructions whereas shift is 4.\r\n\r\n    // For the remaining entries we use our fast shift code.\r\n    state[3] = mul_2exp_i::\u003c2, 29\u003e(state[3]);\r\n    state[4] = mul_2exp_i::\u003c3, 28\u003e(state[4]);\r\n    state[5] = mul_2exp_i::\u003c4, 27\u003e(state[5]);\r\n    state[6] = mul_2exp_i::\u003c5, 26\u003e(state[6]);\r\n    state[7] = mul_2exp_i::\u003c6, 25\u003e(state[7]);\r\n    state[8] = mul_2exp_i::\u003c7, 24\u003e(state[8]);\r\n    state[9] = mul_2exp_i::\u003c8, 23\u003e(state[9]);\r\n    state[10] = mul_2exp_i::\u003c10, 21\u003e(state[10]);\r\n    state[11] = mul_2exp_i::\u003c12, 19\u003e(state[11]);\r\n    state[12] = mul_2exp_i::\u003c13, 18\u003e(state[12]);\r\n    state[13] = mul_2exp_i::\u003c14, 17\u003e(state[13]);\r\n    state[14] = mul_2exp_15(state[14]);\r\n    state[15] = mul_2exp_i::\u003c16, 15\u003e(state[15]);\r\n}\r\n\r\n/// We hard code multiplication by the diagonal minus 1 of our internal matrix (1 + Diag(V))\r\n/// In the Mersenne31, WIDTH = 24 case, the diagonal minus 1 is:\r\n/// [-2] + 1 \u003c\u003c [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\r\n/// i.e. The first entry is -2 and all other entries are powers of 2.\r\n#[inline(always)]\r\nfn diagonal_mul_24(state: \u0026mut [PackedMersenne31AVX2; 24]) {\r\n    // The first three entries involve multiplication by -2, 1, 2 which are simple:\r\n    // state[0] -\u003e -2*state[0] is handled by the calling code.\r\n    state[2] = state[2] + state[2]; // add is 3 instructions whereas shift is 4.\r\n\r\n    // For the remaining entries we use our fast shift code.\r\n    state[3] = mul_2exp_i::\u003c2, 29\u003e(state[3]);\r\n    state[4] = mul_2exp_i::\u003c3, 28\u003e(state[4]);\r\n    state[5] = mul_2exp_i::\u003c4, 27\u003e(state[5]);\r\n    state[6] = mul_2exp_i::\u003c5, 26\u003e(state[6]);\r\n    state[7] = mul_2exp_i::\u003c6, 25\u003e(state[7]);\r\n    state[8] = mul_2exp_i::\u003c7, 24\u003e(state[8]);\r\n    state[9] = mul_2exp_i::\u003c8, 23\u003e(state[9]);\r\n    state[10] = mul_2exp_i::\u003c9, 22\u003e(state[10]);\r\n    state[11] = mul_2exp_i::\u003c10, 21\u003e(state[11]);\r\n    state[12] = mul_2exp_i::\u003c11, 20\u003e(state[12]);\r\n    state[13] = mul_2exp_i::\u003c12, 19\u003e(state[13]);\r\n    state[14] = mul_2exp_i::\u003c13, 18\u003e(state[14]);\r\n    state[15] = mul_2exp_i::\u003c14, 17\u003e(state[15]);\r\n    state[16] = mul_2exp_15(state[16]);\r\n    state[17] = mul_2exp_i::\u003c16, 15\u003e(state[17]);\r\n    state[18] = mul_2exp_i::\u003c17, 14\u003e(state[18]);\r\n    state[19] = mul_2exp_i::\u003c18, 13\u003e(state[19]);\r\n    state[20] = mul_2exp_i::\u003c19, 12\u003e(state[20]);\r\n    state[21] = mul_2exp_i::\u003c20, 11\u003e(state[21]);\r\n    state[22] = mul_2exp_i::\u003c21, 10\u003e(state[22]);\r\n    state[23] = mul_2exp_i::\u003c22, 9\u003e(state[23]);\r\n}\r\n\r\n/// Compute the map x -\u003e (x + rc)^5 on Mersenne-31 field elements.\r\n/// x must be represented as a value in {0..P}.\r\n/// rc mut be represented as a value in {-P, ..., 0}.\r\n/// If the inputs do not conform to these representations, the result is undefined.\r\n/// The output will be represented as a value in {0..P}.\r\n#[inline(always)]\r\nfn add_rc_and_sbox(input: \u0026mut PackedMersenne31AVX2, rc: __m256i) {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let input_vec = input.to_vector();\r\n        let input_plus_rc = x86_64::_mm256_add_epi32(input_vec, rc);\r\n\r\n        // Due to the representations of input and rc, input_plus_rc is in {-P, ..., P}.\r\n        // This is exactly the required bound to apply sbox.\r\n        let input_post_sbox = exp5(input_plus_rc);\r\n        *input = PackedMersenne31AVX2::from_vector(input_post_sbox);\r\n    }\r\n}\r\n\r\n/// Compute a single Poseidon2 internal layer on a state of width 16.\r\n#[inline(always)]\r\nfn internal_16(state: \u0026mut [PackedMersenne31AVX2; 16], rc: __m256i) {\r\n    add_rc_and_sbox(\u0026mut state[0], rc);\r\n    let sum_non_0 = sum_15(\u0026state[1..]);\r\n    let sum = sum_non_0 + state[0];\r\n    state[0] = sum_non_0 - state[0];\r\n    diagonal_mul_16(state);\r\n    state[1..].iter_mut().for_each(|x| *x += sum);\r\n}\r\n\r\nimpl InternalLayer\u003cPackedMersenne31AVX2, 16, 5\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMersenne31AVX2; 16]) {\r\n        self.packed_internal_constants\r\n            .iter()\r\n            .for_each(|\u0026rc| internal_16(state, rc))\r\n    }\r\n}\r\n\r\n/// Compute a single Poseidon2 internal layer on a state of width 24.\r\n#[inline(always)]\r\nfn internal_24(state: \u0026mut [PackedMersenne31AVX2; 24], rc: __m256i) {\r\n    add_rc_and_sbox(\u0026mut state[0], rc);\r\n    let sum_non_0 = sum_23(\u0026state[1..]);\r\n    let sum = sum_non_0 + state[0];\r\n    state[0] = sum_non_0 - state[0];\r\n    diagonal_mul_24(state);\r\n    state[1..].iter_mut().for_each(|x| *x += sum);\r\n}\r\n\r\nimpl InternalLayer\u003cPackedMersenne31AVX2, 24, 5\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMersenne31AVX2; 24]) {\r\n        self.packed_internal_constants\r\n            .iter()\r\n            .for_each(|\u0026rc| internal_24(state, rc))\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayer\u003cPackedMersenne31AVX2, WIDTH, 5\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMersenne31AVX2; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            \u0026self.packed_initial_external_constants,\r\n            add_rc_and_sbox,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMersenne31AVX2; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            \u0026self.packed_terminal_external_constants,\r\n            add_rc_and_sbox,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use super::*;\r\n    use crate::Poseidon2Mersenne31;\r\n\r\n    type F = Mersenne31;\r\n    type Perm16 = Poseidon2Mersenne31\u003c16\u003e;\r\n    type Perm24 = Poseidon2Mersenne31\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input of length 16.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedMersenne31AVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input of length 24.\r\n    #[test]\r\n    fn test_avx2_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx2_input = input.map(Into::\u003cPackedMersenne31AVX2\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx2_input);\r\n\r\n        let avx2_output = avx2_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx2_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":54,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":55,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":58,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":66,"address":[],"length":0,"stats":{"Line":288230376151711746}},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711746}},{"line":69,"address":[],"length":0,"stats":{"Line":5764607523034234884}},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":83,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":86,"address":[],"length":0,"stats":{"Line":2882303761517117439}},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":91,"address":[],"length":0,"stats":{"Line":2882303761517117439}},{"line":107,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":108,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":109,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":110,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":111,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":112,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":113,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":114,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":115,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":116,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":117,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":120,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":127,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":130,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":133,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":136,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":137,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":148,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":149,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":150,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":151,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":152,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":153,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":154,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":155,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":157,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":158,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":159,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":161,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":162,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":164,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":165,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":167,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":168,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":169,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":171,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":172,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":173,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":175,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":177,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":178,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":180,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":183,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":187,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":188,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":189,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":191,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":200,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":203,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":206,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":207,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":208,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":209,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":210,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":211,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":212,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":213,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":214,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":215,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":216,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":217,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":218,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":226,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":229,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":232,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":233,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":234,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":235,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":236,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":237,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":238,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":239,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":240,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":241,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":242,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":243,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":244,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":245,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":246,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":247,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":248,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":249,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":250,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":251,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":252,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":261,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":264,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":265,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":269,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":270,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":276,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":277,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":278,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":279,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":280,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":281,"address":[],"length":0,"stats":{"Line":1008806316530991105}},{"line":282,"address":[],"length":0,"stats":{"Line":17149707381026848770}},{"line":287,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":288,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":290,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":296,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":297,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":298,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":299,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":300,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":301,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":302,"address":[],"length":0,"stats":{"Line":2738188573441261568}},{"line":307,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":308,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":310,"address":[],"length":0,"stats":{"Line":1729382256910270465}},{"line":318,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":320,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":321,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":322,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":323,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":328,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":330,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":331,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":332,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":333,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":135,"coverable":135},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx512","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\npub(crate) use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx512","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m512i, __mmask16, __mmask8};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::exponentiation::exp_1717986917;\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::Mersenne31;\r\n\r\nconst WIDTH: usize = 16;\r\npub(crate) const P: __m512i = unsafe { transmute::\u003c[u32; WIDTH], _\u003e([0x7fffffff; WIDTH]) };\r\nconst EVENS: __mmask16 = 0b0101010101010101;\r\nconst ODDS: __mmask16 = 0b1010101010101010;\r\nconst EVENS4: __mmask16 = 0x0f0f;\r\n\r\n/// Vectorized AVX-512F implementation of `Mersenne31` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct PackedMersenne31AVX512(pub [Mersenne31; WIDTH]);\r\n\r\nimpl PackedMersenne31AVX512 {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    pub(crate) fn to_vector(self) -\u003e __m512i {\r\n        unsafe {\r\n            // Safety: `Mersenne31` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[Mersenne31; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `__m512i`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMersenne31AVX512` is `repr(transparent)` so it can be transmuted to\r\n            // `[Mersenne31; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid\r\n    /// `Mersenne31`. In particular, each element of vector must be in `0..=P`.\r\n    pub(crate) unsafe fn from_vector(vector: __m512i) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `Mersenne31` values. We must only reason about memory representations. `__m512i` can be\r\n        // transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which can\r\n        // be transmuted to `[Mersenne31; WIDTH]` (since `Mersenne31` is `repr(transparent)`), which\r\n        // in turn can be transmuted to `PackedMersenne31AVX512` (since `PackedMersenne31AVX512` is also\r\n        // `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMersenne31\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: Mersenne31) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl Add for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Mul for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Neg for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg(val);\r\n        unsafe {\r\n            // Safety: `neg` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl Sub for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n/// Add two vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn add(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vpaddd   t, lhs, rhs\r\n    //      vpsubd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1.5 cyc/vec (10.67 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let t := lhs + rhs. We want to return a value r in {0, ..., P} such that r = t (mod P).\r\n    //   Define u := (t - P) mod 2^32 and r := min(t, u). t is in {0, ..., 2 P}. We argue by cases.\r\n    //   If t is in {0, ..., P - 1}, then u is in {(P - 1 \u003c) 2^32 - P, ..., 2^32 - 1}, so r = t is\r\n    // in the correct range.\r\n    //   If t is in {P, ..., 2 P}, then u is in {0, ..., P} and r = u is in the correct range.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let t = x86_64::_mm512_add_epi32(lhs, rhs);\r\n        let u = x86_64::_mm512_sub_epi32(t, P);\r\n        x86_64::_mm512_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn movehdup_epi32(a: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        x86_64::_mm512_castps_si512(x86_64::_mm512_movehdup_ps(x86_64::_mm512_castsi512_ps(a)))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn mask_movehdup_epi32(src: __m512i, k: __mmask16, a: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        let src = x86_64::_mm512_castsi512_ps(src);\r\n        let a = x86_64::_mm512_castsi512_ps(a);\r\n        x86_64::_mm512_castps_si512(x86_64::_mm512_mask_movehdup_ps(src, k, a))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn mask_moveldup_epi32(src: __m512i, k: __mmask16, a: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        let src = x86_64::_mm512_castsi512_ps(src);\r\n        let a = x86_64::_mm512_castsi512_ps(a);\r\n        x86_64::_mm512_castps_si512(x86_64::_mm512_mask_moveldup_ps(src, k, a))\r\n    }\r\n}\r\n\r\n/// Multiply vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn mul(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    // vpaddd     lhs_evn_dbl, lhs, lhs\r\n    // vmovshdup  rhs_odd, rhs\r\n    // vpsrlq     lhs_odd_dbl, lhs, 31\r\n    // vpmuludq   prod_lo_dbl, lhs_evn_dbl, rhs\r\n    // vpmuludq   prod_odd_dbl, lhs_odd_dbl, rhs_odd\r\n    // vmovdqa32  prod_hi, prod_odd_dbl\r\n    // vmovshdup  prod_hi{EVENS}, prod_lo_dbl\r\n    // vmovsldup  prod_lo_dbl{ODDS}, prod_odd_dbl\r\n    // vpsrld     prod_lo, prod_lo_dbl, 1\r\n    // vpaddd     t, prod_lo, prod_hi\r\n    // vpsubd     u, t, P\r\n    // vpminud    res, t, u\r\n    // throughput: 5.5 cyc/vec (2.91 els/cyc)\r\n    // latency: (lhs-\u003eres) 15 cyc, (rhs-\u003eres) 14 cyc\r\n    unsafe {\r\n        // vpmuludq only reads the bottom 32 bits of every 64-bit quadword.\r\n        // The even indices are already in the bottom 32 bits of a quadword, so we can leave them.\r\n        let rhs_evn = rhs;\r\n        // Again, vpmuludq only reads the bottom 32 bits so we don't need to clear the top. But we\r\n        // do want to double the lhs.\r\n        let lhs_evn_dbl = x86_64::_mm512_add_epi32(lhs, lhs);\r\n        // Copy the high 32 bits in each quadword of rhs down to the low 32.\r\n        let rhs_odd = movehdup_epi32(rhs);\r\n        // Right shift by 31 is equivalent to moving the high 32 bits down to the low 32, and then\r\n        // doubling it. So these are the odd indices in lhs, but doubled.\r\n        let lhs_odd_dbl = x86_64::_mm512_srli_epi64::\u003c31\u003e(lhs);\r\n\r\n        // Multiply odd indices; since lhs_odd_dbl is doubled, these products are also doubled.\r\n        // prod_odd_dbl.quadword[i] = 2 * lhs.doubleword[2 * i + 1] * rhs.doubleword[2 * i + 1]\r\n        let prod_odd_dbl = x86_64::_mm512_mul_epu32(lhs_odd_dbl, rhs_odd);\r\n        // Multiply even indices; these are also doubled.\r\n        // prod_evn_dbl.quadword[i] = 2 * lhs.doubleword[2 * i] * rhs.doubleword[2 * i]\r\n        let prod_evn_dbl = x86_64::_mm512_mul_epu32(lhs_evn_dbl, rhs_evn);\r\n\r\n        // Move the low halves of odd products into odd positions; keep the low halves of even\r\n        // products in even positions (where they already are). Note that the products are doubled,\r\n        // so the result is a vector of all the low halves, but doubled.\r\n        let prod_lo_dbl = mask_moveldup_epi32(prod_evn_dbl, ODDS, prod_odd_dbl);\r\n        // Move the high halves of even products into even positions, keeping the high halves of odd\r\n        // products where they are. The products are doubled, but we are looking at (prod \u003e\u003e 32),\r\n        // which cancels out the doubling, so this result is _not_ doubled.\r\n        let prod_hi = mask_movehdup_epi32(prod_odd_dbl, EVENS, prod_evn_dbl);\r\n        // Right shift to undo the doubling.\r\n        let prod_lo = x86_64::_mm512_srli_epi32::\u003c1\u003e(prod_lo_dbl);\r\n\r\n        // Standard addition of two 31-bit values.\r\n        add(prod_lo, prod_hi)\r\n    }\r\n}\r\n\r\n/// Negate a vector of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the input does not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg(val: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vpxord  res, val, P\r\n    // throughput: .5 cyc/vec (32 els/cyc)\r\n    // latency: 1 cyc\r\n\r\n    //   Since val is in {0, ..., P (= 2^31 - 1)}, res = val XOR P = P - val. Then res is in {0,\r\n    // ..., P}.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        x86_64::_mm512_xor_epi32(val, P)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of Mersenne-31 field elements represented as values in {0, ..., P}.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn sub(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vpsubd   t, lhs, rhs\r\n    //      vpaddd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1.5 cyc/vec (10.67 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let d := lhs - rhs and t := d mod 2^32. We want to return a value r in {0, ..., P} such\r\n    // that r = d (mod P).\r\n    //   Define u := (t + P) mod 2^32 and r := min(t, u). d is in {-P, ..., P}. We argue by cases.\r\n    //   If d is in {0, ..., P}, then t = d and u is in {P, ..., 2 P}. r = t is in the correct\r\n    // range.\r\n    //   If d is in {-P, ..., -1}, then t is in {2^32 - P, ..., 2^32 - 1} and u is in\r\n    // {0, ..., P - 1}. r = u is in the correct range.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let t = x86_64::_mm512_sub_epi32(lhs, rhs);\r\n        let u = x86_64::_mm512_add_epi32(t, P);\r\n        x86_64::_mm512_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n/// Reduce a representative in {0, ..., P^2}\r\n/// to a representative in [-P, P]. If the input is greater than P^2, the output will\r\n/// still correspond to the same class but will instead lie in [-P, 2^34].\r\n#[inline(always)]\r\nfn partial_reduce_neg(x: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // Get the top bits shifted down.\r\n        let hi = x86_64::_mm512_srli_epi64::\u003c31\u003e(x);\r\n\r\n        const LOW31: __m512i = unsafe { transmute::\u003c[u64; 8], _\u003e([0x7fffffff; 8]) };\r\n\r\n        // nand instead of and means this returns P - lo.\r\n        let neg_lo = x86_64::_mm512_andnot_si512(x, LOW31);\r\n\r\n        // we could also try:\r\n        // let neg_lo = x86_64::_mm512_maskz_andnot_epi32(EVENS, x, P);\r\n        // but this seems to get compiled badly and likes outputting vpternlogd.\r\n        // See: https://godbolt.org/z/WPze9e3f3\r\n\r\n        // Compiling with sub_epi64 vs sub_epi32 both produce reasonable code so we use\r\n        // sub_epi64 for the slightly greater flexibility.\r\n        x86_64::_mm512_sub_epi64(hi, neg_lo)\r\n    }\r\n}\r\n\r\n/// Compute the square of the Mersenne-31 field elements located in the even indices.\r\n/// These field elements are represented as values in {-P, ..., P}. If the even inputs\r\n/// do not conform to this representation, the result is undefined.\r\n/// The top half of each 64-bit lane is is ignored.\r\n/// The top half of each 64-bit lane in the result is 0.\r\n#[inline(always)]\r\nfn square_unred(x: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let x2 = x86_64::_mm512_mul_epi32(x, x);\r\n        partial_reduce_neg(x2)\r\n    }\r\n}\r\n\r\n/// Compute the permutation x -\u003e x^5 on Mersenne-31 field elements\r\n/// represented as values in {0, ..., P}. If the inputs do not conform\r\n/// to this representation, the result is undefined.\r\n#[inline(always)]\r\npub(crate) fn exp5(x: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let input_evn = x;\r\n        let input_odd = movehdup_epi32(x);\r\n\r\n        let evn_sq = square_unred(input_evn);\r\n        let odd_sq = square_unred(input_odd);\r\n\r\n        let evn_4 = square_unred(evn_sq);\r\n        let odd_4 = square_unred(odd_sq);\r\n\r\n        let evn_5 = x86_64::_mm512_mul_epi32(evn_4, input_evn);\r\n        let odd_5 = x86_64::_mm512_mul_epi32(odd_4, input_odd);\r\n\r\n        // Marked dirty as the top bit needs to be cleared.\r\n        let lo_dirty = mask_moveldup_epi32(evn_5, ODDS, odd_5);\r\n\r\n        // We could use 2 adds and mask_movehdup_epi32.\r\n        // instead of an add, a shift and a blend.\r\n        let odd_5_hi = x86_64::_mm512_add_epi64(odd_5, odd_5);\r\n        let evn_5_hi = x86_64::_mm512_srli_epi64::\u003c31\u003e(evn_5);\r\n        let hi = x86_64::_mm512_mask_blend_epi32(ODDS, evn_5_hi, odd_5_hi);\r\n\r\n        let zero = x86_64::_mm512_setzero_si512();\r\n        let signs = x86_64::_mm512_movepi32_mask(hi);\r\n        let corr = x86_64::_mm512_mask_sub_epi32(P, signs, zero, P);\r\n\r\n        let lo = x86_64::_mm512_and_si512(lo_dirty, P);\r\n\r\n        let t = x86_64::_mm512_add_epi32(hi, lo);\r\n        let u = x86_64::_mm512_sub_epi32(t, corr);\r\n\r\n        x86_64::_mm512_min_epu32(t, u)\r\n    }\r\n}\r\n\r\nimpl From\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn from(value: Mersenne31) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl Default for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        Mersenne31::default().into()\r\n    }\r\n}\r\n\r\nimpl AddAssign for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl MulAssign for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl SubAssign for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl Sum for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl Product for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl PrimeCharacteristicRing for PackedMersenne31AVX512 {\r\n    type PrimeSubfield = Mersenne31;\r\n\r\n    const ZERO: Self = Self::broadcast(Mersenne31::ZERO);\r\n    const ONE: Self = Self::broadcast(Mersenne31::ONE);\r\n    const TWO: Self = Self::broadcast(Mersenne31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(Mersenne31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(Mersenne31::zero_vec(len * WIDTH)) }\r\n    }\r\n\r\n    #[must_use]\r\n    #[inline(always)]\r\n    fn exp_const_u64\u003cconst POWER: u64\u003e(\u0026self) -\u003e Self {\r\n        // We provide specialised code for power 5 as this turns up regularly.\r\n        // The other powers could be specialised similarly but we ignore this for now.\r\n        // These ideas could also be used to speed up the more generic exp_u64.\r\n        match POWER {\r\n            0 =\u003e Self::ONE,\r\n            1 =\u003e *self,\r\n            2 =\u003e self.square(),\r\n            3 =\u003e self.cube(),\r\n            4 =\u003e self.square().square(),\r\n            5 =\u003e unsafe {\r\n                let val = self.to_vector();\r\n                Self::from_vector(exp5(val))\r\n            },\r\n            6 =\u003e self.square().cube(),\r\n            7 =\u003e {\r\n                let x2 = self.square();\r\n                let x3 = x2 * *self;\r\n                let x4 = x2.square();\r\n                x3 * x4\r\n            }\r\n            _ =\u003e self.exp_u64(POWER),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Algebra\u003cMersenne31\u003e for PackedMersenne31AVX512 {}\r\n\r\n// Degree of the smallest permutation polynomial for Mersenne31.\r\n//\r\n// As p - 1 = 23^2711... the smallest choice for a degree D satisfying gcd(p - 1, D) = 1 is 5.\r\nimpl InjectiveMonomial\u003c5\u003e for PackedMersenne31AVX512 {}\r\n\r\nimpl PermutationMonomial\u003c5\u003e for PackedMersenne31AVX512 {\r\n    /// In the field `Mersenne31`, `a^{1/5}` is equal to a^{1717986917}.\r\n    ///\r\n    /// This follows from the calculation `5 * 1717986917 = 4*(2^31 - 2) + 1 = 1 mod p - 1`.\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        // This could likely be further optimised.\r\n        exp_1717986917(*self)\r\n    }\r\n}\r\n\r\nimpl Add\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Mersenne31) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Mul\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Mersenne31) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sub\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Mersenne31) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl AddAssign\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl MulAssign\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl SubAssign\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Mersenne31) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl Sum\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.sum::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Product\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Mersenne31\u003e,\r\n    {\r\n        iter.product::\u003cMersenne31\u003e().into()\r\n    }\r\n}\r\n\r\nimpl Div\u003cMersenne31\u003e for PackedMersenne31AVX512 {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Mersenne31) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl Add\u003cPackedMersenne31AVX512\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX512;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMersenne31AVX512) -\u003e PackedMersenne31AVX512 {\r\n        PackedMersenne31AVX512::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl Mul\u003cPackedMersenne31AVX512\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX512;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMersenne31AVX512) -\u003e PackedMersenne31AVX512 {\r\n        PackedMersenne31AVX512::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl Sub\u003cPackedMersenne31AVX512\u003e for Mersenne31 {\r\n    type Output = PackedMersenne31AVX512;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMersenne31AVX512) -\u003e PackedMersenne31AVX512 {\r\n        PackedMersenne31AVX512::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl Distribution\u003cPackedMersenne31AVX512\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMersenne31AVX512 {\r\n        PackedMersenne31AVX512(rng.gen())\r\n    }\r\n}\r\n\r\n// vpshrdq requires AVX-512VBMI2.\r\n#[cfg(target_feature = \"avx512vbmi2\")]\r\n#[inline]\r\n#[must_use]\r\nfn interleave1_antidiagonal(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512VBMI2 intrinsics are available.\r\n        x86_64::_mm512_shrdi_epi64::\u003c32\u003e(y, x)\r\n    }\r\n}\r\n\r\n// If we can't use vpshrdq, then do a vpermi2d, but we waste a register and double the latency.\r\n#[cfg(not(target_feature = \"avx512vbmi2\"))]\r\n#[inline]\r\n#[must_use]\r\nfn interleave1_antidiagonal(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    const INTERLEAVE1_INDICES: __m512i = unsafe {\r\n        // Safety: `[u32; 16]` is trivially transmutable to `__m512i`.\r\n        transmute::\u003c[u32; WIDTH], _\u003e([\r\n            0x01, 0x10, 0x03, 0x12, 0x05, 0x14, 0x07, 0x16, 0x09, 0x18, 0x0b, 0x1a, 0x0d, 0x1c,\r\n            0x0f, 0x1e,\r\n        ])\r\n    };\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        x86_64::_mm512_permutex2var_epi32(x, INTERLEAVE1_INDICES, y)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // If we have AVX-512VBMI2, we want this to compile to:\r\n    //      vpshrdq    t, x, y, 32\r\n    //      vpblendmd  res0 {EVENS}, t, x\r\n    //      vpblendmd  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 2 cyc\r\n    //\r\n    // Otherwise, we want it to compile to:\r\n    //      vmovdqa32  t, INTERLEAVE1_INDICES\r\n    //      vpermi2d   t, x, y\r\n    //      vpblendmd  res0 {EVENS}, t, x\r\n    //      vpblendmd  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    // We currently have:\r\n    //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n    //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n    // First form\r\n    //   t = [ x1  y0  x3  y2  x5  y4  x7  y6  x9  y8  xb  ya  xd  yc  xf  ye ].\r\n    let t = interleave1_antidiagonal(x, y);\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // Then\r\n        //   res0 = [ x0  y0  x2  y2  x4  y4  x6  y6  x8  y8  xa  ya  xc  yc  xe  ye ],\r\n        //   res1 = [ x1  y1  x3  y3  x5  y5  x7  y7  x9  y9  xb  yb  xd  yd  xf  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi32(EVENS, t, x),\r\n            x86_64::_mm512_mask_blend_epi32(EVENS, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn shuffle_epi64\u003cconst MASK: i32\u003e(a: __m512i, b: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        let a = x86_64::_mm512_castsi512_pd(a);\r\n        let b = x86_64::_mm512_castsi512_pd(b);\r\n        x86_64::_mm512_castpd_si512(x86_64::_mm512_shuffle_pd::\u003cMASK\u003e(a, b))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vshufpd    t, x, y, 55h\r\n    //      vpblendmq  res0 {EVENS}, t, x\r\n    //      vpblendmq  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x2  x3  y0  y1  x6  x7  y4  y5  xa  xb  y8  y9  xe  xf  yc  yd ].\r\n        let t = shuffle_epi64::\u003c0b01010101\u003e(x, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  y0  y1  x4  x5  y4  y5  x8  x9  y8  y9  xc  xd  yc  yd ],\r\n        //   res1 = [ x2  x3  y2  y3  x6  x7  y6  y7  xa  xb  ya  yb  xe  xf  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi64(EVENS as __mmask8, t, x),\r\n            x86_64::_mm512_mask_blend_epi64(EVENS as __mmask8, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave4(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vmovdqa64   t, INTERLEAVE4_INDICES\r\n    //      vpermi2q    t, x, y\r\n    //      vpblendmd   res0 {EVENS4}, t, x\r\n    //      vpblendmd   res1 {EVENS4}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    const INTERLEAVE4_INDICES: __m512i = unsafe {\r\n        // Safety: `[u64; 8]` is trivially transmutable to `__m512i`.\r\n        transmute::\u003c[u64; WIDTH / 2], _\u003e([0o02, 0o03, 0o10, 0o11, 0o06, 0o07, 0o14, 0o15])\r\n    };\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x4  x5  x6  x7  y0  y1  y2  y3  xc  xd  xe  xf  y8  y9  ya  yb ].\r\n        let t = x86_64::_mm512_permutex2var_epi64(x, INTERLEAVE4_INDICES, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  x2  x3  y0  y1  y2  y3  x8  x9  xa  xb  y8  y9  ya  yb ],\r\n        //   res1 = [ x4  x5  x6  x7  y4  y5  y6  y7  xc  xd  xe  xf  yc  yd  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi32(EVENS4, t, x),\r\n            x86_64::_mm512_mask_blend_epi32(EVENS4, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave8(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vshufi64x2  t, x, b, 4eh\r\n    //      vpblendmq   res0 {EVENS4}, t, x\r\n    //      vpblendmq   res1 {EVENS4}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x8  x9  xa  xb  xc  xd  xe  xf  y0  y1  y2  y3  y4  y5  y6  y7 ].\r\n        let t = x86_64::_mm512_shuffle_i64x2::\u003c0b01_00_11_10\u003e(x, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  x2  x3  x4  x5  x6  x7  y0  y1  y2  y3  y4  y5  y6  y7 ],\r\n        //   res1 = [ x8  x9  xa  xb  xc  xd  xe  xf  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi64(EVENS4 as __mmask8, t, x),\r\n            x86_64::_mm512_mask_blend_epi64(EVENS4 as __mmask8, y, t),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl PackedValue for PackedMersenne31AVX512 {\r\n    type Value = Mersenne31;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[Mersenne31]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31AVX512` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [Mersenne31]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[Mersenne31; WIDTH]` can be transmuted to `PackedMersenne31AVX512` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e Mersenne31\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[Mersenne31] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [Mersenne31] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl PackedField for PackedMersenne31AVX512 {\r\n    type Scalar = Mersenne31;\r\n}\r\n\r\nunsafe impl PackedFieldPow2 for PackedMersenne31AVX512 {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e interleave4(v0, v1),\r\n            8 =\u003e interleave8(v0, v1),\r\n            16 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field_testing::test_packed_field;\r\n\r\n    use super::{Mersenne31, WIDTH};\r\n\r\n    /// Zero has a redundant representation, so let's test both.\r\n    const ZEROS: [Mersenne31; WIDTH] = Mersenne31::new_array([\r\n        0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000,\r\n        0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff, 0x00000000, 0x7fffffff,\r\n        0x00000000, 0x7fffffff,\r\n    ]);\r\n\r\n    const SPECIAL_VALS: [Mersenne31; WIDTH] = Mersenne31::new_array([\r\n        0x00000000, 0x7fffffff, 0x00000001, 0x7ffffffe, 0x00000002, 0x7ffffffd, 0x40000000,\r\n        0x3fffffff, 0x00000000, 0x7fffffff, 0x00000001, 0x7ffffffe, 0x00000002, 0x7ffffffd,\r\n        0x40000000, 0x3fffffff,\r\n    ]);\r\n\r\n    test_packed_field!(\r\n        crate::PackedMersenne31AVX512,\r\n        crate::PackedMersenne31AVX512(super::ZEROS),\r\n        crate::PackedMersenne31AVX512(super::SPECIAL_VALS)\r\n    );\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":552,"address":[],"length":0,"stats":{"Line":0}},{"line":553,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":568,"address":[],"length":0,"stats":{"Line":0}},{"line":569,"address":[],"length":0,"stats":{"Line":0}},{"line":576,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":728,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":797,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":815,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":186},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","mersenne-31","src","x86_64_avx512","poseidon2.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m512i};\r\n\r\nuse p3_field::PrimeField32;\r\nuse p3_poseidon2::{\r\n    mds_light_permutation, sum_15, sum_23, ExternalLayer, ExternalLayerConstants,\r\n    ExternalLayerConstructor, InternalLayer, InternalLayerConstructor, MDSMat4,\r\n};\r\n\r\nuse crate::{exp5, Mersenne31, PackedMersenne31AVX512, P};\r\n\r\n/// The internal layers of the Poseidon2 permutation for Mersenne31.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 16 copies of `x - P` into the corresponding `__m512i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMersenne31 {\r\n    pub(crate) internal_constants: Vec\u003cMersenne31\u003e,\r\n    packed_internal_constants: Vec\u003c__m512i\u003e,\r\n}\r\n\r\nimpl InternalLayerConstructor\u003cMersenne31\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// We save the round constants in the {-P, ..., 0} representation instead of the standard\r\n    /// {0, ..., P} one. This saves several instructions later.\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        Self::new_from_constants(internal_constants)\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Mersenne31.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 16 copies of `x - P` into the corresponding `__m512i` packed constant.\r\n#[derive(Clone)]\r\npub struct Poseidon2ExternalLayerMersenne31\u003cconst WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e,\r\n    packed_initial_external_constants: Vec\u003c[__m512i; WIDTH]\u003e,\r\n    packed_terminal_external_constants: Vec\u003c[__m512i; WIDTH]\u003e,\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayerConstructor\u003cMersenne31, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        Self::new_from_constants(external_constants)\r\n    }\r\n}\r\n\r\n/// Convert elements from the standard form {0, ..., P} to {-P, ..., 0} and copy into a vector\r\nfn convert_to_vec_neg_form(input: i32) -\u003e __m512i {\r\n    let input_sub_p = input - (Mersenne31::ORDER_U32 as i32);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX512-F intrinsics are available.\r\n        x86_64::_mm512_set1_epi32(input_sub_p)\r\n    }\r\n}\r\n\r\nimpl Poseidon2InternalLayerMersenne31 {\r\n    /// Construct an instance of Poseidon2InternalLayerMersenne31 from a vector containing\r\n    /// the constants for each round. Internally, the constants are transformed into th\r\n    /// {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(internal_constants: Vec\u003cMersenne31\u003e) -\u003e Self {\r\n        let packed_internal_constants = internal_constants\r\n            .iter()\r\n            .map(|constant| convert_to_vec_neg_form(constant.value as i32))\r\n            .collect();\r\n        Self {\r\n            internal_constants,\r\n            packed_internal_constants,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e {\r\n    /// Construct an instance of Poseidon2ExternalLayerMersenne31 from a array of\r\n    /// vectors containing the constants for each round. Internally, the constants\r\n    ///  are transformed into the {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cMersenne31, WIDTH\u003e) -\u003e Self {\r\n        let packed_initial_external_constants = external_constants\r\n            .get_initial_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form(constant.value as i32)))\r\n            .collect();\r\n        let packed_terminal_external_constants = external_constants\r\n            .get_terminal_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form(constant.value as i32)))\r\n            .collect();\r\n        Self {\r\n            external_constants,\r\n            packed_initial_external_constants,\r\n            packed_terminal_external_constants,\r\n        }\r\n    }\r\n}\r\n\r\n/// Compute the map x -\u003e 2^I x on Mersenne-31 field elements.\r\n/// x must be represented as a value in {0..P}.\r\n/// This requires 2 generic parameters, I and I_PRIME satisfying I + I_PRIME = 31.\r\n/// If the inputs do not conform to this representations, the result is undefined.\r\n#[inline(always)]\r\nfn mul_2exp_i\u003cconst I: u32, const I_PRIME: u32\u003e(\r\n    val: PackedMersenne31AVX512,\r\n) -\u003e PackedMersenne31AVX512 {\r\n    assert_eq!(I + I_PRIME, 31);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX512-F intrinsics are available.\r\n        let input = val.to_vector();\r\n\r\n        // In M31, multiplication by 2^n corresponds to a cyclic rotation which\r\n        // is much faster than the naive multiplication method.\r\n\r\n        // Shift the low bits up. This also shifts something unwanted into\r\n        // the sign bit so we mark it dirty.\r\n        let hi_bits_dirty = x86_64::_mm512_slli_epi32::\u003cI\u003e(input);\r\n\r\n        // Shift the high bits down.\r\n        let lo_bits = x86_64::_mm512_srli_epi32::\u003cI_PRIME\u003e(input);\r\n\r\n        // Clear the sign bit and combine the lo and high bits.\r\n        // The simplest description of the operation we want is lo OR (hi_dirty AND P) which has bit pattern:\r\n        // 111 =\u003e 1, 110 =\u003e 1, 101 =\u003e 1, 100 =\u003e 1, 011 =\u003e 1, 010 =\u003e 0, 001 =\u003e 0, 000 =\u003e 0\r\n        // Note that the input patterns: 111, 110, 100 cannot occur so any constant of the form **1*1000 should work.\r\n        let output = x86_64::_mm512_ternarylogic_epi32::\u003c0b11111000\u003e(lo_bits, hi_bits_dirty, P);\r\n        PackedMersenne31AVX512::from_vector(output)\r\n    }\r\n}\r\n\r\n/// We hard code multiplication by the diagonal minus 1 of our internal matrix (1 + Diag(V))\r\n/// In the Mersenne31, WIDTH = 16 case, the diagonal minus 1 is:\r\n/// [-2] + 1 \u003c\u003c [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 13, 14, 15, 16]\r\n/// i.e. The first entry is -2 and all other entries are powers of 2.\r\n#[inline(always)]\r\nfn diagonal_mul_16(state: \u0026mut [PackedMersenne31AVX512; 16]) {\r\n    // The first three entries involve multiplication by -2, 1, 2 which are simple:\r\n    // state[0] -\u003e -2*state[0] is handled by the calling code.\r\n\r\n    // We could use mul_2exp_i here as it is also 3 instructions but add should have better throughput as its instructions work on more ports.\r\n    state[2] = state[2] + state[2];\r\n\r\n    // For the remaining entries we use our fast shift code.\r\n    state[3] = mul_2exp_i::\u003c2, 29\u003e(state[3]);\r\n    state[4] = mul_2exp_i::\u003c3, 28\u003e(state[4]);\r\n    state[5] = mul_2exp_i::\u003c4, 27\u003e(state[5]);\r\n    state[6] = mul_2exp_i::\u003c5, 26\u003e(state[6]);\r\n    state[7] = mul_2exp_i::\u003c6, 25\u003e(state[7]);\r\n    state[8] = mul_2exp_i::\u003c7, 24\u003e(state[8]);\r\n    state[9] = mul_2exp_i::\u003c8, 23\u003e(state[9]);\r\n    state[10] = mul_2exp_i::\u003c10, 21\u003e(state[10]);\r\n    state[11] = mul_2exp_i::\u003c12, 19\u003e(state[11]);\r\n    state[12] = mul_2exp_i::\u003c13, 18\u003e(state[12]);\r\n    state[13] = mul_2exp_i::\u003c14, 17\u003e(state[13]);\r\n    state[14] = mul_2exp_i::\u003c15, 16\u003e(state[14]);\r\n    state[15] = mul_2exp_i::\u003c16, 15\u003e(state[15]);\r\n}\r\n\r\n/// We hard code multiplication by the diagonal minus 1 of our internal matrix (1 + Diag(V))\r\n/// In the Mersenne31, WIDTH = 24 case, the diagonal minus 1 is:\r\n/// [-2] + 1 \u003c\u003c [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\r\n/// i.e. The first entry is -2 and all other entries a power of 2.\r\n#[inline(always)]\r\nfn diagonal_mul_24(state: \u0026mut [PackedMersenne31AVX512; 24]) {\r\n    // The first three entries involve multiplication by -2, 1, 2 which are simple:\r\n    // state[0] -\u003e -2*state[0] is handled by the calling code.\r\n\r\n    // We could use mul_2exp_i here as it is also 3 instructions but add should have better throughput as its instructions work on more ports.\r\n    state[2] = state[2] + state[2];\r\n\r\n    // For the remaining entries we use our fast shift code.\r\n    state[3] = mul_2exp_i::\u003c2, 29\u003e(state[3]);\r\n    state[4] = mul_2exp_i::\u003c3, 28\u003e(state[4]);\r\n    state[5] = mul_2exp_i::\u003c4, 27\u003e(state[5]);\r\n    state[6] = mul_2exp_i::\u003c5, 26\u003e(state[6]);\r\n    state[7] = mul_2exp_i::\u003c6, 25\u003e(state[7]);\r\n    state[8] = mul_2exp_i::\u003c7, 24\u003e(state[8]);\r\n    state[9] = mul_2exp_i::\u003c8, 23\u003e(state[9]);\r\n    state[10] = mul_2exp_i::\u003c9, 22\u003e(state[10]);\r\n    state[11] = mul_2exp_i::\u003c10, 21\u003e(state[11]);\r\n    state[12] = mul_2exp_i::\u003c11, 20\u003e(state[12]);\r\n    state[13] = mul_2exp_i::\u003c12, 19\u003e(state[13]);\r\n    state[14] = mul_2exp_i::\u003c13, 18\u003e(state[14]);\r\n    state[15] = mul_2exp_i::\u003c14, 17\u003e(state[15]);\r\n    state[16] = mul_2exp_i::\u003c15, 16\u003e(state[16]);\r\n    state[17] = mul_2exp_i::\u003c16, 15\u003e(state[17]);\r\n    state[18] = mul_2exp_i::\u003c17, 14\u003e(state[18]);\r\n    state[19] = mul_2exp_i::\u003c18, 13\u003e(state[19]);\r\n    state[20] = mul_2exp_i::\u003c19, 12\u003e(state[20]);\r\n    state[21] = mul_2exp_i::\u003c20, 11\u003e(state[21]);\r\n    state[22] = mul_2exp_i::\u003c21, 10\u003e(state[22]);\r\n    state[23] = mul_2exp_i::\u003c22, 9\u003e(state[23]);\r\n}\r\n\r\n/// Compute the map x -\u003e (x + rc)^5 on Mersenne-31 field elements.\r\n/// x must be represented as a value in {0..P}.\r\n/// rc mut be represented as a value in {-P, ..., 0}.\r\n/// If the inputs do not conform to these representations, the result is undefined.\r\n/// The output will be represented as a value in {0..P}.\r\n#[inline(always)]\r\nfn add_rc_and_sbox(input: PackedMersenne31AVX512, rc: __m512i) -\u003e PackedMersenne31AVX512 {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX512-F intrinsics are available.\r\n        let input_vec = input.to_vector();\r\n        let input_plus_rc = x86_64::_mm512_add_epi32(input_vec, rc);\r\n\r\n        // Due to the representations of input and rc, input_plus_rc is in {-P, ..., P}.\r\n        // This is exactly the required bound to apply sbox.\r\n        let input_post_sbox = exp5(input_plus_rc);\r\n        PackedMersenne31AVX512::from_vector(input_post_sbox)\r\n    }\r\n}\r\n\r\n/// Compute a single Poseidon2 internal layer on a state of width 16.\r\n#[inline(always)]\r\nfn internal_16(state: \u0026mut [PackedMersenne31AVX512; 16], rc: __m512i) {\r\n    state[0] = add_rc_and_sbox(state[0], rc);\r\n    let sum_non_0 = sum_15(\u0026state[1..]);\r\n    let sum = sum_non_0 + state[0];\r\n    state[0] = sum_non_0 - state[0];\r\n    diagonal_mul_16(state);\r\n    state[1..].iter_mut().for_each(|x| *x += sum);\r\n}\r\n\r\nimpl InternalLayer\u003cPackedMersenne31AVX512, 16, 5\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMersenne31AVX512; 16]) {\r\n        self.packed_internal_constants\r\n            .iter()\r\n            .for_each(|\u0026rc| internal_16(state, rc))\r\n    }\r\n}\r\n\r\n/// Compute a single Poseidon2 internal layer on a state of width 24.\r\n#[inline(always)]\r\nfn internal_24(state: \u0026mut [PackedMersenne31AVX512; 24], rc: __m512i) {\r\n    state[0] = add_rc_and_sbox(state[0], rc);\r\n    let sum_non_0 = sum_23(\u0026state[1..]);\r\n    let sum = sum_non_0 + state[0];\r\n    state[0] = sum_non_0 - state[0];\r\n    diagonal_mul_24(state);\r\n    state[1..].iter_mut().for_each(|x| *x += sum);\r\n}\r\n\r\nimpl InternalLayer\u003cPackedMersenne31AVX512, 24, 5\u003e for Poseidon2InternalLayerMersenne31 {\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMersenne31AVX512; 24]) {\r\n        self.packed_internal_constants\r\n            .iter()\r\n            .for_each(|\u0026rc| internal_24(state, rc))\r\n    }\r\n}\r\n\r\n/// Compute a collection of Poseidon2 external layers.\r\n/// One layer for every constant supplied.\r\n#[inline]\r\nfn external_rounds\u003cconst WIDTH: usize\u003e(\r\n    state: \u0026mut [PackedMersenne31AVX512; WIDTH],\r\n    packed_external_constants: \u0026[[__m512i; WIDTH]],\r\n) {\r\n    packed_external_constants.iter().for_each(|round_consts| {\r\n        state\r\n            .iter_mut()\r\n            .zip(round_consts.iter())\r\n            .for_each(|(val, \u0026rc)| *val = add_rc_and_sbox(*val, rc));\r\n        mds_light_permutation(state, \u0026MDSMat4);\r\n    });\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize\u003e ExternalLayer\u003cPackedMersenne31AVX512, WIDTH, 5\u003e\r\n    for Poseidon2ExternalLayerMersenne31\u003cWIDTH\u003e\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMersenne31AVX512; WIDTH]) {\r\n        mds_light_permutation(state, \u0026MDSMat4);\r\n        external_rounds(state, \u0026self.packed_initial_external_constants);\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMersenne31AVX512; WIDTH]) {\r\n        external_rounds(state, \u0026self.packed_terminal_external_constants);\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_symmetric::Permutation;\r\n    use rand::Rng;\r\n\r\n    use super::*;\r\n    use crate::Poseidon2Mersenne31;\r\n\r\n    type F = Mersenne31;\r\n    type Perm16 = Poseidon2Mersenne31\u003c16\u003e;\r\n    type Perm24 = Poseidon2Mersenne31\u003c24\u003e;\r\n\r\n    /// Test that the output is the same as the scalar version on a random input of length 16.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_16() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm16::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 16] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedMersenne31AVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n\r\n    /// Test that the output is the same as the scalar version on a random input of length 24.\r\n    #[test]\r\n    fn test_avx512_poseidon2_width_24() {\r\n        let mut rng = rand::thread_rng();\r\n\r\n        // Our Poseidon2 implementation.\r\n        let poseidon2 = Perm24::new_from_rng_128(\u0026mut rng);\r\n\r\n        let input: [F; 24] = rng.gen();\r\n\r\n        let mut expected = input;\r\n        poseidon2.permute_mut(\u0026mut expected);\r\n\r\n        let mut avx512_input = input.map(Into::\u003cPackedMersenne31AVX512\u003e::into);\r\n        poseidon2.permute_mut(\u0026mut avx512_input);\r\n\r\n        let avx512_output = avx512_input.map(|x| x.0[0]);\r\n\r\n        assert_eq!(avx512_output, expected);\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monolith","benches","permute.rs"],"content":"use std::array;\r\n\r\nuse criterion::{criterion_group, criterion_main, Criterion};\r\nuse p3_field::PrimeCharacteristicRing;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::{MdsMatrixMersenne31, Mersenne31};\r\nuse p3_monolith::MonolithMersenne31;\r\n\r\nfn bench_monolith(c: \u0026mut Criterion) {\r\n    monolith::\u003c_, 12\u003e(c, MdsMatrixMersenne31);\r\n    monolith::\u003c_, 16\u003e(c, MdsMatrixMersenne31);\r\n}\r\n\r\nfn monolith\u003cMds, const WIDTH: usize\u003e(c: \u0026mut Criterion, mds: Mds)\r\nwhere\r\n    Mds: MdsPermutation\u003cMersenne31, WIDTH\u003e,\r\n{\r\n    let monolith: MonolithMersenne31\u003c_, WIDTH, 5\u003e = MonolithMersenne31::new(mds);\r\n\r\n    let mut input = array::from_fn(Mersenne31::from_usize);\r\n\r\n    let name = format!(\"monolith::\u003cMersenne31, {}\u003e\", WIDTH);\r\n    c.bench_function(name.as_str(), |b| {\r\n        b.iter(|| monolith.permutation(\u0026mut input))\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_monolith);\r\ncriterion_main!(benches);\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monolith","src","lib.rs"],"content":"//! The Monolith permutation, and hash functions built from it.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod monolith;\r\nmod monolith_mds;\r\nmod util;\r\n\r\npub use monolith::MonolithMersenne31;\r\npub use monolith_mds::MonolithMdsMatrixMersenne31;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monolith","src","monolith.rs"],"content":"//! The Monolith-31 permutation.\r\n//! With significant inspiration from https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo/\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::borrow::ToOwned;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{PrimeCharacteristicRing, PrimeField32};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse sha3::digest::{ExtendableOutput, Update};\r\nuse sha3::{Shake128, Shake128Reader};\r\n\r\nuse crate::util::get_random_u32;\r\n\r\n// The Monolith-31 permutation over Mersenne31.\r\n// NUM_FULL_ROUNDS is the number of rounds - 1\r\n// (used to avoid const generics because we need an array of length NUM_FULL_ROUNDS)\r\n#[derive(Debug)]\r\npub struct MonolithMersenne31\u003cMds, const WIDTH: usize, const NUM_FULL_ROUNDS: usize\u003e\r\nwhere\r\n    Mds: MdsPermutation\u003cMersenne31, WIDTH\u003e,\r\n{\r\n    pub round_constants: [[Mersenne31; WIDTH]; NUM_FULL_ROUNDS],\r\n    pub lookup1: Vec\u003cu16\u003e,\r\n    pub lookup2: Vec\u003cu16\u003e,\r\n    pub mds: Mds,\r\n}\r\n\r\nimpl\u003cMds, const WIDTH: usize, const NUM_FULL_ROUNDS: usize\u003e\r\n    MonolithMersenne31\u003cMds, WIDTH, NUM_FULL_ROUNDS\u003e\r\nwhere\r\n    Mds: MdsPermutation\u003cMersenne31, WIDTH\u003e,\r\n{\r\n    pub const NUM_BARS: usize = 8;\r\n\r\n    pub fn new(mds: Mds) -\u003e Self {\r\n        assert!(WIDTH \u003e= 8);\r\n        assert!(WIDTH \u003c= 24);\r\n        assert_eq!(WIDTH % 4, 0);\r\n\r\n        let round_constants = Self::instantiate_round_constants();\r\n        let lookup1 = Self::instantiate_lookup1();\r\n        let lookup2 = Self::instantiate_lookup2();\r\n\r\n        Self {\r\n            round_constants,\r\n            lookup1,\r\n            lookup2,\r\n            mds,\r\n        }\r\n    }\r\n\r\n    const fn s_box(y: u8) -\u003e u8 {\r\n        let tmp = y ^ !y.rotate_left(1) \u0026 y.rotate_left(2) \u0026 y.rotate_left(3);\r\n        tmp.rotate_left(1)\r\n    }\r\n\r\n    pub fn final_s_box(y: u8) -\u003e u8 {\r\n        debug_assert_eq!(y \u003e\u003e 7, 0); // must be a 7-bit value\r\n\r\n        let y_rot_1 = (y \u003e\u003e 6) | (y \u003c\u003c 1);\r\n        let y_rot_2 = (y \u003e\u003e 5) | (y \u003c\u003c 2);\r\n\r\n        let tmp = (y ^ !y_rot_1 \u0026 y_rot_2) \u0026 0x7F;\r\n        ((tmp \u003e\u003e 6) | (tmp \u003c\u003c 1)) \u0026 0x7F\r\n    }\r\n\r\n    fn instantiate_lookup1() -\u003e Vec\u003cu16\u003e {\r\n        (0..=u16::MAX)\r\n            .map(|i| {\r\n                let hi = (i \u003e\u003e 8) as u8;\r\n                let lo = i as u8;\r\n                ((Self::s_box(hi) as u16) \u003c\u003c 8) | Self::s_box(lo) as u16\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn instantiate_lookup2() -\u003e Vec\u003cu16\u003e {\r\n        (0..(1 \u003c\u003c 15))\r\n            .map(|i| {\r\n                let hi = (i \u003e\u003e 8) as u8;\r\n                let lo: u8 = i as u8;\r\n                ((Self::final_s_box(hi) as u16) \u003c\u003c 8) | Self::s_box(lo) as u16\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    fn random_field_element(shake: \u0026mut Shake128Reader) -\u003e Mersenne31 {\r\n        let mut val = get_random_u32(shake);\r\n        while val \u003e= Mersenne31::ORDER_U32 {\r\n            val = get_random_u32(shake);\r\n        }\r\n\r\n        unsafe {\r\n            // Safety: By construction, val is now \u003c 2^31 - 1.\r\n            Mersenne31::from_canonical_unchecked(val)\r\n        }\r\n    }\r\n\r\n    fn init_shake() -\u003e Shake128Reader {\r\n        let num_rounds = (NUM_FULL_ROUNDS + 1) as u8;\r\n\r\n        let mut shake = Shake128::default();\r\n        shake.update(\"Monolith\".as_bytes());\r\n        shake.update(\u0026[WIDTH as u8, num_rounds]);\r\n        shake.update(\u0026Mersenne31::ORDER_U32.to_le_bytes());\r\n        shake.update(\u0026[8, 8, 8, 7]);\r\n        shake.finalize_xof()\r\n    }\r\n\r\n    fn instantiate_round_constants() -\u003e [[Mersenne31; WIDTH]; NUM_FULL_ROUNDS] {\r\n        let mut shake = Self::init_shake();\r\n\r\n        [[Mersenne31::ZERO; WIDTH]; NUM_FULL_ROUNDS]\r\n            .map(|arr| arr.map(|_| Self::random_field_element(\u0026mut shake)))\r\n    }\r\n\r\n    #[inline]\r\n    pub fn concrete(\u0026self, state: \u0026mut [Mersenne31; WIDTH]) {\r\n        self.mds.permute_mut(state);\r\n    }\r\n\r\n    #[inline]\r\n    pub fn add_round_constants(\r\n        \u0026self,\r\n        state: \u0026mut [Mersenne31; WIDTH],\r\n        round_constants: \u0026[Mersenne31; WIDTH],\r\n    ) {\r\n        // TODO: vectorize?\r\n        for (x, rc) in state.iter_mut().zip(round_constants) {\r\n            *x += *rc;\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    pub fn bricks(state: \u0026mut [Mersenne31; WIDTH]) {\r\n        // Feistel Type-3\r\n        for (x, x_mut) in state.to_owned().iter().zip(state.iter_mut().skip(1)) {\r\n            *x_mut += x.square();\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    pub fn bar(\u0026self, el: Mersenne31) -\u003e Mersenne31 {\r\n        let val = \u0026mut el.as_canonical_u32();\r\n\r\n        unsafe {\r\n            // get_unchecked here is safe because lookup table 1 contains 2^16 elements\r\n            let low = *self.lookup1.get_unchecked(*val as u16 as usize);\r\n\r\n            // get_unchecked here is safe because lookup table 2 contains 2^15 elements,\r\n            // and el \u003e\u003e 16 \u003c 2^15 (since el \u003c Mersenne31::ORDER_U32 \u003c 2^31)\r\n            let high = *self.lookup2.get_unchecked((*val \u003e\u003e 16) as u16 as usize);\r\n            *val = (high as u32) \u003c\u003c 16 | low as u32\r\n        }\r\n\r\n        unsafe {\r\n            // Safety: low + high \u003c 2^31 as low \u003c 2^16 and high \u003c 2^15.\r\n            Mersenne31::from_canonical_unchecked(*val)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    pub fn bars(\u0026self, state: \u0026mut [Mersenne31; WIDTH]) {\r\n        state\r\n            .iter_mut()\r\n            .take(Self::NUM_BARS)\r\n            .for_each(|el| *el = self.bar(*el));\r\n    }\r\n\r\n    pub fn permutation(\u0026self, state: \u0026mut [Mersenne31; WIDTH]) {\r\n        self.concrete(state);\r\n        for rc in self.round_constants {\r\n            self.bars(state);\r\n            Self::bricks(state);\r\n            self.concrete(state);\r\n            self.add_round_constants(state, \u0026rc);\r\n        }\r\n        self.bars(state);\r\n        Self::bricks(state);\r\n        self.concrete(state);\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use core::array;\r\n\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_mersenne_31::Mersenne31;\r\n\r\n    use crate::monolith::MonolithMersenne31;\r\n    use crate::monolith_mds::MonolithMdsMatrixMersenne31;\r\n\r\n    #[test]\r\n    fn test_monolith_31() {\r\n        let mds = MonolithMdsMatrixMersenne31::\u003c6\u003e;\r\n        let monolith: MonolithMersenne31\u003c_, 16, 5\u003e = MonolithMersenne31::new(mds);\r\n\r\n        let mut input = array::from_fn(Mersenne31::from_usize);\r\n\r\n        let expected = [\r\n            609156607, 290107110, 1900746598, 1734707571, 2050994835, 1648553244, 1307647296,\r\n            1941164548, 1707113065, 1477714255, 1170160793, 93800695, 769879348, 375548503,\r\n            1989726444, 1349325635,\r\n        ]\r\n        .map(Mersenne31::from_u32);\r\n\r\n        monolith.permutation(\u0026mut input);\r\n\r\n        assert_eq!(input, expected);\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":41,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":42,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":640}},{"line":62,"address":[],"length":0,"stats":{"Line":768}},{"line":64,"address":[],"length":0,"stats":{"Line":640}},{"line":65,"address":[],"length":0,"stats":{"Line":640}},{"line":67,"address":[],"length":0,"stats":{"Line":640}},{"line":68,"address":[],"length":0,"stats":{"Line":640}},{"line":71,"address":[],"length":0,"stats":{"Line":72057594037928064}},{"line":72,"address":[],"length":0,"stats":{"Line":72057594037928064}},{"line":73,"address":[],"length":0,"stats":{"Line":72057594037928064}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":72057594037928192}},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037928192}},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037928192}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":5764607523034235008}},{"line":92,"address":[],"length":0,"stats":{"Line":5764607523034235008}},{"line":93,"address":[],"length":0,"stats":{"Line":15852670688344146048}},{"line":94,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":99,"address":[],"length":0,"stats":{"Line":5764607523034235008}},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":108,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":109,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":110,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":117,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":118,"address":[],"length":0,"stats":{"Line":6629298651489370112}},{"line":122,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":123,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":127,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":133,"address":[],"length":0,"stats":{"Line":11889503016258109440}},{"line":134,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":139,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":141,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":142,"address":[],"length":0,"stats":{"Line":6485183463413514240}},{"line":147,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":148,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":152,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":156,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":157,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":162,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":170,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":171,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":174,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":176,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":177,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":178,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":179,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":180,"address":[],"length":0,"stats":{"Line":360287970189639680}},{"line":182,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":184,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":64,"coverable":73},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monolith","src","monolith_mds.rs"],"content":"//! Monolith-31's default MDS permutation.\r\n//! With significant inspiration from https://extgit.iaik.tugraz.at/krypto/zkfriendlyhashzoo/\r\n\r\nuse p3_field::PrimeField32;\r\nuse p3_mds::util::apply_circulant;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_symmetric::Permutation;\r\nuse sha3::digest::{ExtendableOutput, Update};\r\nuse sha3::{Shake128, Shake128Reader};\r\n\r\nuse crate::util::get_random_u32;\r\n\r\n#[derive(Clone, Debug)]\r\npub struct MonolithMdsMatrixMersenne31\u003cconst NUM_ROUNDS: usize\u003e;\r\n\r\nconst MATRIX_CIRC_MDS_16_MERSENNE31_MONOLITH: [u64; 16] = [\r\n    61402, 17845, 26798, 59689, 12021, 40901, 41351, 27521, 56951, 12034, 53865, 43244, 7454,\r\n    33823, 28750, 1108,\r\n];\r\n\r\nimpl\u003cconst WIDTH: usize, const NUM_ROUNDS: usize\u003e Permutation\u003c[Mersenne31; WIDTH]\u003e\r\n    for MonolithMdsMatrixMersenne31\u003cNUM_ROUNDS\u003e\r\n{\r\n    fn permute(\u0026self, input: [Mersenne31; WIDTH]) -\u003e [Mersenne31; WIDTH] {\r\n        if WIDTH == 16 {\r\n            let matrix: [u64; WIDTH] = MATRIX_CIRC_MDS_16_MERSENNE31_MONOLITH[..]\r\n                .try_into()\r\n                .unwrap();\r\n            apply_circulant(\u0026matrix, input)\r\n        } else {\r\n            let mut shake = Shake128::default();\r\n            shake.update(\"Monolith\".as_bytes());\r\n            shake.update(\u0026[WIDTH as u8, NUM_ROUNDS as u8]);\r\n            shake.update(\u0026Mersenne31::ORDER_U32.to_le_bytes());\r\n            shake.update(\u0026[16, 15]);\r\n            shake.update(\"MDS\".as_bytes());\r\n            let mut shake_finalized = shake.finalize_xof();\r\n            apply_cauchy_mds_matrix(\u0026mut shake_finalized, input)\r\n        }\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [Mersenne31; WIDTH]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize, const NUM_ROUNDS: usize\u003e MdsPermutation\u003cMersenne31, WIDTH\u003e\r\n    for MonolithMdsMatrixMersenne31\u003cNUM_ROUNDS\u003e\r\n{\r\n}\r\n\r\nfn apply_cauchy_mds_matrix\u003cF: PrimeField32, const WIDTH: usize\u003e(\r\n    shake: \u0026mut Shake128Reader,\r\n    to_multiply: [F; WIDTH],\r\n) -\u003e [F; WIDTH] {\r\n    let mut output: [F; WIDTH] = [F::ZERO; WIDTH];\r\n\r\n    // As F is a PrimeField, it's order is equal to its characteristic.\r\n    // Thus 2|F| \u003e 2^bits \u003e |F|.\r\n    let bits = F::bits();\r\n    let x_mask = (1 \u003c\u003c (bits - 9)) - 1;\r\n    let y_mask = ((1 \u003c\u003c bits) - 1) \u003e\u003e 2;\r\n\r\n    let y = get_random_y_i::\u003cWIDTH\u003e(shake, x_mask, y_mask);\r\n    let mut x = y;\r\n    x.iter_mut().for_each(|x_i| *x_i \u0026= x_mask);\r\n\r\n    for (i, x_i) in x.iter().enumerate() {\r\n        for (j, y_j) in y.iter().enumerate() {\r\n            let val = unsafe {\r\n                // Safety:\r\n                // x_i \u003c x_mask \u003c 2^{-8}|F|\r\n                // y_j \u003c y_mask \u003c 2^{-1}|F|\r\n                // Hence x_i + y_j \u003c |F|.\r\n                F::from_canonical_unchecked(x_i + y_j).inverse()\r\n            };\r\n            output[i] += val * to_multiply[j];\r\n        }\r\n    }\r\n\r\n    output\r\n}\r\n\r\nfn get_random_y_i\u003cconst WIDTH: usize\u003e(\r\n    shake: \u0026mut Shake128Reader,\r\n    x_mask: u32,\r\n    y_mask: u32,\r\n) -\u003e [u32; WIDTH] {\r\n    let mut res = [0; WIDTH];\r\n\r\n    for i in 0..WIDTH {\r\n        let mut y_i = get_random_u32(shake) \u0026 y_mask;\r\n        let mut x_i = y_i \u0026 x_mask;\r\n        while res.iter().take(i).any(|r| r \u0026 x_mask == x_i) {\r\n            y_i = get_random_u32(shake) \u0026 y_mask;\r\n            x_i = y_i \u0026 x_mask;\r\n        }\r\n        res[i] = y_i;\r\n    }\r\n\r\n    res\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":26,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":27,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":30,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":44,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":37},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monolith","src","util.rs"],"content":"use sha3::digest::XofReader;\r\nuse sha3::Shake128Reader;\r\n\r\npub(crate) fn get_random_u32(shake: \u0026mut Shake128Reader) -\u003e u32 {\r\n    let mut rand = [0u8; 4];\r\n    shake.read(\u0026mut rand);\r\n    u32::from_le_bytes(rand)\r\n}\r\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":5,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":6,"address":[],"length":0,"stats":{"Line":10808639105689190400}},{"line":7,"address":[],"length":0,"stats":{"Line":10808639105689190400}}],"covered":4,"coverable":4},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","aarch64_neon","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\n\r\npub use packing::*;\r\npub use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","aarch64_neon","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::aarch64::{self, int32x4_t, uint32x4_t};\r\nuse core::arch::asm;\r\nuse core::hint::unreachable_unchecked;\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::{FieldParameters, MontyField31, PackedMontyParameters, RelativelyPrimePower};\r\n\r\nconst WIDTH: usize = 4;\r\n\r\npub trait MontyParametersNeon {\r\n    const PACKED_P: uint32x4_t;\r\n    const PACKED_MU: int32x4_t;\r\n}\r\n\r\n/// Vectorized NEON implementation of `MontyField31` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct PackedMontyField31Neon\u003cPMP: PackedMontyParameters\u003e(pub [MontyField31\u003cPMP\u003e; WIDTH]);\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    fn to_vector(self) -\u003e uint32x4_t {\r\n        unsafe {\r\n            // Safety: `MontyField31` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[MontyField31; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `uint32x4_t`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMontyField31Neon` is `repr(transparent)` so it can be transmuted to\r\n            // `[MontyField31; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid `MontyField31`.\r\n    /// In particular, each element of vector must be in `0..P` (canonical form).\r\n    unsafe fn from_vector(vector: uint32x4_t) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `MontyField31` values. We must only reason about memory representations. `uint32x4_t` can be\r\n        // transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which can\r\n        // be transmuted to `[MontyField31; WIDTH]` (since `MontyField31` is `repr(transparent)`), which in\r\n        // turn can be transmuted to `PackedMontyField31Neon` (since `PackedMontyField31Neon` is also\r\n        // `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMontyField31\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Neg for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg::\u003cPMP\u003e(val);\r\n        unsafe {\r\n            // Safety: `neg` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n/// No-op. Prevents the compiler from deducing the value of the vector.\r\n///\r\n/// Similar to `std::hint::black_box`, it can be used to stop the compiler applying undesirable\r\n/// \"optimizations\". Unlike the built-in `black_box`, it does not force the value to be written to\r\n/// and then read from the stack.\r\n#[inline]\r\n#[must_use]\r\nfn confuse_compiler(x: uint32x4_t) -\u003e uint32x4_t {\r\n    let y;\r\n    unsafe {\r\n        asm!(\r\n            \"/*{0:v}*/\",\r\n            inlateout(vreg) x =\u003e y,\r\n            options(nomem, nostack, preserves_flags, pure),\r\n        );\r\n        // Below tells the compiler the semantics of this so it can still do constant folding, etc.\r\n        // You may ask, doesn't it defeat the point of the inline asm block to tell the compiler\r\n        // what it does? The answer is that we still inhibit the transform we want to avoid, so\r\n        // apparently not. Idk, LLVM works in mysterious ways.\r\n        if transmute::\u003cuint32x4_t, [u32; 4]\u003e(x) != transmute::\u003cuint32x4_t, [u32; 4]\u003e(y) {\r\n            unreachable_unchecked();\r\n        }\r\n    }\r\n    y\r\n}\r\n\r\n/// Add two vectors of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn add\u003cMPNeon: MontyParametersNeon\u003e(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      add   t.4s, lhs.4s, rhs.4s\r\n    //      sub   u.4s, t.4s, P.4s\r\n    //      umin  res.4s, t.4s, u.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 6 cyc\r\n\r\n    //   Let `t := lhs + rhs`. We want to return `t mod P`. Recall that `lhs` and `rhs` are in\r\n    // `0, ..., P - 1`, so `t` is in `0, ..., 2 P - 2 (\u003c 2^32)`. It suffices to return `t` if\r\n    // `t \u003c P` and `t - P` otherwise.\r\n    //   Let `u := (t - P) mod 2^32` and `r := unsigned_min(t, u)`.\r\n    //   If `t` is in `0, ..., P - 1`, then `u` is in `(P - 1 \u003c) 2^32 - P, ..., 2^32 - 1` and\r\n    // `r = t`. Otherwise `t` is in `P, ..., 2 P - 2`, `u` is in `0, ..., P - 2 (\u003c P)` and `r = u`.\r\n    // Hence, `r` is `t` if `t \u003c P` and `t - P` otherwise, as desired.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let t = aarch64::vaddq_u32(lhs, rhs);\r\n        let u = aarch64::vsubq_u32(t, MPNeon::PACKED_P);\r\n        aarch64::vminq_u32(t, u)\r\n    }\r\n}\r\n\r\n// MONTGOMERY MULTIPLICATION\r\n//   This implementation is based on [1] but with changes. The reduction is as follows:\r\n//\r\n// Constants: P \u003c 2^31\r\n//            B = 2^32\r\n//             = P^-1 mod B\r\n// Input: -P^2 \u003c= C \u003c= P^2\r\n// Output: -P \u003c D \u003c P such that D = C B^-1 (mod P)\r\n// Define:\r\n//   smod_B(a) = r, where -B/2 \u003c= r \u003c= B/2 - 1 and r = a (mod B).\r\n// Algorithm:\r\n//   1. Q := smod_B( C)\r\n//   2. D := (C - Q P) / B\r\n//\r\n// We first show that the division in step 2. is exact. It suffices to show that C = Q P (mod B). By\r\n// definition of Q, smod_B, and , we have Q P = smod_B( C) P =  C P = P^-1 C P = C (mod B).\r\n//\r\n// We also have C - Q P = C (mod P), so thus D = C B^-1 (mod P).\r\n//\r\n// It remains to show that D is in the correct range. It suffices to show that -P B \u003c C - Q P \u003c P B.\r\n// We know that -P^2 \u003c= C \u003c= P^2 and (-B / 2) P \u003c= Q P \u003c= (B/2 - 1) P. Then\r\n// (1 - B/2) P - P^2 \u003c= C - Q P \u003c= (B/2) P + P^2. Now, P \u003c B/2, so B/2 + P \u003c B and\r\n// (B/2) P + P^2 \u003c P B; also B/2 - 1 + P \u003c B, so -P B \u003c (1 - B/2) P - P^2.\r\n// Hence, -P B \u003c C - Q P \u003c P B as desired.\r\n//\r\n// [1] Modern Computer Arithmetic, Richard Brent and Paul Zimmermann, Cambridge University Press,\r\n//     2010, algorithm 2.7.\r\n\r\n#[inline]\r\n#[must_use]\r\nfn mulby_mu\u003cMPNeon: MontyParametersNeon\u003e(val: int32x4_t) -\u003e int32x4_t {\r\n    // We want this to compile to:\r\n    //      mul      res.4s, val.4s, MU.4s\r\n    // throughput: .25 cyc/vec (16 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    unsafe { aarch64::vmulq_s32(val, MPNeon::PACKED_MU) }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn get_c_hi(lhs: int32x4_t, rhs: int32x4_t) -\u003e int32x4_t {\r\n    // We want this to compile to:\r\n    //      sqdmulh  c_hi.4s, lhs.4s, rhs.4s\r\n    // throughput: .25 cyc/vec (16 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    unsafe {\r\n        // Get bits 31, ..., 62 of C. Note that `sqdmulh` saturates when the product doesn't fit in\r\n        // an `i63`, but this cannot happen here due to our bounds on `lhs` and `rhs`.\r\n        aarch64::vqdmulhq_s32(lhs, rhs)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn get_qp_hi\u003cMPNeon: MontyParametersNeon\u003e(lhs: int32x4_t, mu_rhs: int32x4_t) -\u003e int32x4_t {\r\n    // We want this to compile to:\r\n    //      mul      q.4s, lhs.4s, mu_rhs.4s\r\n    //      sqdmulh  qp_hi.4s, q.4s, P.4s\r\n    // throughput: .5 cyc/vec (8 els/cyc)\r\n    // latency: 6 cyc\r\n\r\n    unsafe {\r\n        // Form `Q`.\r\n        let q = aarch64::vmulq_s32(lhs, mu_rhs);\r\n\r\n        // Gets bits 31, ..., 62 of Q P. Again, saturation is not an issue because `P` is not\r\n        // -2**31.\r\n        aarch64::vqdmulhq_s32(q, aarch64::vreinterpretq_s32_u32(MPNeon::PACKED_P))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn get_d(c_hi: int32x4_t, qp_hi: int32x4_t) -\u003e int32x4_t {\r\n    // We want this to compile to:\r\n    //      shsub    res.4s, c_hi.4s, qp_hi.4s\r\n    // throughput: .25 cyc/vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    unsafe {\r\n        // Form D. Note that `c_hi` is C \u003e\u003e 31 and `qp_hi` is (Q P) \u003e\u003e 31, whereas we want\r\n        // (C - Q P) \u003e\u003e 32, so we need to subtract and divide by 2. Luckily NEON has an instruction\r\n        // for that! The lowest bit of `c_hi` and `qp_hi` is the same, so the division is exact.\r\n        aarch64::vhsubq_s32(c_hi, qp_hi)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn get_reduced_d\u003cMPNeon: MontyParametersNeon\u003e(c_hi: int32x4_t, qp_hi: int32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      shsub    res.4s, c_hi.4s, qp_hi.4s\r\n    //      cmgt     underflow.4s, qp_hi.4s, c_hi.4s\r\n    //      mls      res.4s, underflow.4s, P.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 5 cyc\r\n\r\n    unsafe {\r\n        let d = aarch64::vreinterpretq_u32_s32(get_d(c_hi, qp_hi));\r\n\r\n        // Finally, we reduce D to canonical form. D is negative iff `c_hi \u003e qp_hi`, so if that's the\r\n        // case then we add P. Note that if `c_hi \u003e qp_hi` then `underflow` is -1, so we must\r\n        // _subtract_ `underflow` * P.\r\n        let underflow = aarch64::vcltq_s32(c_hi, qp_hi);\r\n        aarch64::vmlsq_u32(d, confuse_compiler(underflow), MPNeon::PACKED_P)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn mul\u003cMPNeon: MontyParametersNeon\u003e(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      sqdmulh  c_hi.4s, lhs.4s, rhs.4s\r\n    //      mul      mu_rhs.4s, rhs.4s, MU.4s\r\n    //      mul      q.4s, lhs.4s, mu_rhs.4s\r\n    //      sqdmulh  qp_hi.4s, q.4s, P.4s\r\n    //      shsub    res.4s, c_hi.4s, qp_hi.4s\r\n    //      cmgt     underflow.4s, qp_hi.4s, c_hi.4s\r\n    //      mls      res.4s, underflow.4s, P.4s\r\n    // throughput: 1.75 cyc/vec (2.29 els/cyc)\r\n    // latency: (lhs-\u003e) 11 cyc, (rhs-\u003e) 14 cyc\r\n\r\n    unsafe {\r\n        // No-op. The inputs are non-negative so we're free to interpret them as signed numbers.\r\n        let lhs = aarch64::vreinterpretq_s32_u32(lhs);\r\n        let rhs = aarch64::vreinterpretq_s32_u32(rhs);\r\n\r\n        let mu_rhs = mulby_mu::\u003cMPNeon\u003e(rhs);\r\n        let c_hi = get_c_hi(lhs, rhs);\r\n        let qp_hi = get_qp_hi::\u003cMPNeon\u003e(lhs, mu_rhs);\r\n        get_reduced_d::\u003cMPNeon\u003e(c_hi, qp_hi)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn cube\u003cMPNeon: MontyParametersNeon\u003e(val: uint32x4_t) -\u003e uint32x4_t {\r\n    // throughput: 2.75 cyc/vec (1.45 els/cyc)\r\n    // latency: 22 cyc\r\n\r\n    unsafe {\r\n        let val = aarch64::vreinterpretq_s32_u32(val);\r\n        let mu_val = mulby_mu::\u003cMPNeon\u003e(val);\r\n\r\n        let c_hi_2 = get_c_hi(val, val);\r\n        let qp_hi_2 = get_qp_hi::\u003cMPNeon\u003e(val, mu_val);\r\n        let val_2 = get_d(c_hi_2, qp_hi_2);\r\n\r\n        let c_hi_3 = get_c_hi(val_2, val);\r\n        let qp_hi_3 = get_qp_hi::\u003cMPNeon\u003e(val_2, mu_val);\r\n        get_reduced_d::\u003cMPNeon\u003e(c_hi_3, qp_hi_3)\r\n    }\r\n}\r\n\r\n/// Negate a vector of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg\u003cMPNeon: MontyParametersNeon\u003e(val: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      sub   t.4s, P.4s, val.4s\r\n    //      cmeq  is_zero.4s, val.4s, #0\r\n    //      bic   res.4s, t.4s, is_zero.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    // This has the same throughput as `sub(0, val)` but slightly lower latency.\r\n\r\n    //   We want to return (-val) mod P. This is equivalent to returning `0` if `val = 0` and\r\n    // `P - val` otherwise, since `val` is in `0, ..., P - 1`.\r\n    //   Let `t := P - val` and let `is_zero := (-1) mod 2^32` if `val = 0` and `0` otherwise.\r\n    //   We return `r := t \u0026 ~is_zero`, which is `t` if `val \u003e 0` and `0` otherwise, as desired.\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let t = aarch64::vsubq_u32(MPNeon::PACKED_P, val);\r\n        let is_zero = aarch64::vceqzq_u32(val);\r\n        aarch64::vbicq_u32(t, is_zero)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn sub\u003cMPNeon: MontyParametersNeon\u003e(lhs: uint32x4_t, rhs: uint32x4_t) -\u003e uint32x4_t {\r\n    // We want this to compile to:\r\n    //      sub   res.4s, lhs.4s, rhs.4s\r\n    //      cmhi  underflow.4s, rhs.4s, lhs.4s\r\n    //      mls   res.4s, underflow.4s, P.4s\r\n    // throughput: .75 cyc/vec (5.33 els/cyc)\r\n    // latency: 5 cyc\r\n\r\n    //   Let `d := lhs - rhs`. We want to return `d mod P`.\r\n    //   Since `lhs` and `rhs` are both in `0, ..., P - 1`, `d` is in `-P + 1, ..., P - 1`. It\r\n    // suffices to return `d + P` if `d \u003c 0` and `d` otherwise.\r\n    //   Equivalently, we return `d + P` if `rhs \u003e lhs` and `d` otherwise.  Observe that this\r\n    // permits us to perform all calculations `mod 2^32`, so define `diff := d mod 2^32`.\r\n    //   Let `underflow` be `-1 mod 2^32` if `rhs \u003e lhs` and `0` otherwise.\r\n    //   Finally, let `r := (diff - underflow * P) mod 2^32` and observe that\r\n    // `r = (diff + P) mod 2^32` if `rhs \u003e lhs` and `diff` otherwise, as desired.\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let diff = aarch64::vsubq_u32(lhs, rhs);\r\n        let underflow = aarch64::vcltq_u32(lhs, rhs);\r\n        // We really want to emit a `mls` instruction here. The compiler knows that `underflow` is\r\n        // either 0 or -1 and will try to do an `and` and `add` instead, which is slower on the M1.\r\n        // The `confuse_compiler` prevents this \"optimization\".\r\n        aarch64::vmlsq_u32(diff, confuse_compiler(underflow), MPNeon::PACKED_P)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e From\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn from(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Default for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        MontyField31::\u003cPMP\u003e::default().into()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum for PackedMontyField31Neon\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product for PackedMontyField31Neon\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeCharacteristicRing for PackedMontyField31Neon\u003cFP\u003e {\r\n    type PrimeSubfield = MontyField31\u003cFP\u003e;\r\n\r\n    const ZERO: Self = Self::broadcast(MontyField31::ZERO);\r\n    const ONE: Self = Self::broadcast(MontyField31::ONE);\r\n    const TWO: Self = Self::broadcast(MontyField31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(MontyField31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline]\r\n    fn cube(\u0026self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = cube::\u003cFP\u003e(val);\r\n        unsafe {\r\n            // Safety: `cube` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(MontyField31::\u003cFP\u003e::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Algebra\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31Neon\u003cFP\u003e {}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e InjectiveMonomial\u003cD\u003e\r\n    for PackedMontyField31Neon\u003cFP\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e PermutationMonomial\u003cD\u003e\r\n    for PackedMontyField31Neon\u003cFP\u003e\r\n{\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        FP::exp_root_d(*self)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31Neon\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31Neon\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.sum::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31Neon\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.product::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Div\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31Neon\u003cFP\u003e {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: MontyField31\u003cFP\u003e) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cPackedMontyField31Neon\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31Neon\u003cPMP\u003e;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMontyField31Neon\u003cPMP\u003e) -\u003e PackedMontyField31Neon\u003cPMP\u003e {\r\n        PackedMontyField31Neon::\u003cPMP\u003e::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cPackedMontyField31Neon\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31Neon\u003cPMP\u003e;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMontyField31Neon\u003cPMP\u003e) -\u003e PackedMontyField31Neon\u003cPMP\u003e {\r\n        PackedMontyField31Neon::\u003cPMP\u003e::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cPackedMontyField31Neon\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31Neon\u003cPMP\u003e;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMontyField31Neon\u003cPMP\u003e) -\u003e PackedMontyField31Neon\u003cPMP\u003e {\r\n        PackedMontyField31Neon::\u003cPMP\u003e::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Distribution\u003cPackedMontyField31Neon\u003cPMP\u003e\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMontyField31Neon\u003cPMP\u003e {\r\n        PackedMontyField31Neon::\u003cPMP\u003e(rng.gen())\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(v0: uint32x4_t, v1: uint32x4_t) -\u003e (uint32x4_t, uint32x4_t) {\r\n    // We want this to compile to:\r\n    //      trn1  res0.4s, v0.4s, v1.4s\r\n    //      trn2  res1.4s, v0.4s, v1.4s\r\n    // throughput: .5 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        (aarch64::vtrn1q_u32(v0, v1), aarch64::vtrn2q_u32(v0, v1))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(v0: uint32x4_t, v1: uint32x4_t) -\u003e (uint32x4_t, uint32x4_t) {\r\n    // We want this to compile to:\r\n    //      trn1  res0.2d, v0.2d, v1.2d\r\n    //      trn2  res1.2d, v0.2d, v1.2d\r\n    // throughput: .5 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    // To transpose 64-bit blocks, cast the [u32; 4] vectors to [u64; 2], transpose, and cast back.\r\n    unsafe {\r\n        // Safety: If this code got compiled then NEON intrinsics are available.\r\n        let v0 = aarch64::vreinterpretq_u64_u32(v0);\r\n        let v1 = aarch64::vreinterpretq_u64_u32(v1);\r\n        (\r\n            aarch64::vreinterpretq_u32_u64(aarch64::vtrn1q_u64(v0, v1)),\r\n            aarch64::vreinterpretq_u32_u64(aarch64::vtrn2q_u64(v0, v1)),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedValue for PackedMontyField31Neon\u003cFP\u003e {\r\n    type Value = MontyField31\u003cFP\u003e;\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[MontyField31\u003cFP\u003e]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31; WIDTH]` can be transmuted to `PackedMontyField31Neon` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [MontyField31\u003cFP\u003e]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31; WIDTH]` can be transmuted to `PackedMontyField31Neon` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e MontyField31\u003cFP\u003e\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[MontyField31\u003cFP\u003e] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [MontyField31\u003cFP\u003e] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedField for PackedMontyField31Neon\u003cFP\u003e {\r\n    type Scalar = MontyField31\u003cFP\u003e;\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedFieldPow2 for PackedMontyField31Neon\u003cFP\u003e {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":410,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":504,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":544,"address":[],"length":0,"stats":{"Line":0}},{"line":554,"address":[],"length":0,"stats":{"Line":0}},{"line":562,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":570,"address":[],"length":0,"stats":{"Line":0}},{"line":571,"address":[],"length":0,"stats":{"Line":0}},{"line":578,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":147},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","aarch64_neon","poseidon2.rs"],"content":"//! Eventually this will hold a Vectorized Neon implementation of Poseidon2 for MontyField31\r\n//! Currently this is essentially a placeholder to allow compilation on Neon devices.\r\n//!\r\n//! Converting the AVX2/AVX512 code across to Neon is on the TODO list.\r\n\r\nuse alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    ExternalLayer, ExternalLayerConstants, ExternalLayerConstructor, InternalLayer,\r\n    InternalLayerConstructor, MDSMat4,\r\n};\r\n\r\nuse crate::{\r\n    FieldParameters, InternalLayerBaseParameters, MontyField31, MontyParameters,\r\n    PackedMontyField31Neon, RelativelyPrimePower,\r\n};\r\n\r\n/// The internal layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// This is currently not optimized for the Neon architecture but this is on the TODO list.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMonty31\u003c\r\n    MP: MontyParameters,\r\n    const WIDTH: usize,\r\n    ILP: InternalLayerBaseParameters\u003cMP, WIDTH\u003e,\r\n\u003e {\r\n    pub(crate) internal_constants: Vec\u003cMontyField31\u003cMP\u003e\u003e,\r\n    _phantom: PhantomData\u003cILP\u003e,\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// This is currently not optimized for the Neon architecture but this is on the TODO list.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2ExternalLayerMonty31\u003cMP: MontyParameters, const WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMontyField31\u003cMP\u003e, WIDTH\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize, ILP: InternalLayerBaseParameters\u003cFP, WIDTH\u003e\u003e\r\n    InternalLayerConstructor\u003cMontyField31\u003cFP\u003e\u003e for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, ILP\u003e\r\n{\r\n    fn new_from_constants(internal_constants: Vec\u003cMontyField31\u003cFP\u003e\u003e) -\u003e Self {\r\n        Self {\r\n            internal_constants,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize\u003e ExternalLayerConstructor\u003cMontyField31\u003cFP\u003e, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\n{\r\n    fn new_from_constants(\r\n        external_constants: ExternalLayerConstants\u003cMontyField31\u003cFP\u003e, WIDTH\u003e,\r\n    ) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n\r\nimpl\u003cFP, ILP, const WIDTH: usize, const D: u64\u003e InternalLayer\u003cPackedMontyField31Neon\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, ILP\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n    ILP: InternalLayerBaseParameters\u003cFP, WIDTH\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMontyField31Neon\u003cFP\u003e; WIDTH]) {\r\n        self.internal_constants.iter().for_each(|\u0026rc| {\r\n            add_rc_and_sbox_generic::\u003c_, D\u003e(\u0026mut state[0], rc);\r\n            ILP::generic_internal_linear_layer(state);\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cFP, const D: u64, const WIDTH: usize\u003e ExternalLayer\u003cPackedMontyField31Neon\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMontyField31Neon\u003cFP\u003e; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic::\u003c_, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMontyField31Neon\u003cFP\u003e; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic::\u003c_, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","data_traits.rs"],"content":"use core::fmt::Debug;\r\nuse core::hash::Hash;\r\n\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\n\r\nuse crate::MontyField31;\r\n\r\n/// MontyParameters contains the prime P along with constants needed to convert elements into and out of MONTY form.\r\n/// The MONTY constant is assumed to be a power of 2.\r\npub trait MontyParameters:\r\n    Copy + Clone + Default + Debug + Eq + PartialEq + Sync + Send + Hash + 'static\r\n{\r\n    // A 31-bit prime.\r\n    const PRIME: u32;\r\n\r\n    // The log_2 of our MONTY constant.\r\n    const MONTY_BITS: u32;\r\n\r\n    // We define MONTY_MU = PRIME^-1 (mod 2^MONTY_BITS). This is different from the usual convention\r\n    // (MONTY_MU = -PRIME^-1 (mod 2^MONTY_BITS)) but it avoids a carry.\r\n    const MONTY_MU: u32;\r\n\r\n    const MONTY_MASK: u32 = ((1u64 \u003c\u003c Self::MONTY_BITS) - 1) as u32;\r\n}\r\n\r\n/// PackedMontyParameters contains constants needed for MONTY operations for packings of Monty31 fields.\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub trait PackedMontyParameters: crate::MontyParametersNeon + MontyParameters {}\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\n/// PackedMontyParameters contains constants needed for MONTY operations for packings of Monty31 fields.\r\npub trait PackedMontyParameters: crate::MontyParametersAVX2 + MontyParameters {}\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\n/// PackedMontyParameters contains constants needed for MONTY operations for packings of Monty31 fields.\r\npub trait PackedMontyParameters: crate::MontyParametersAVX512 + MontyParameters {}\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx2\",\r\n        not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n    ),\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n)))]\r\n/// PackedMontyParameters contains constants needed for MONTY operations for packings of Monty31 fields.\r\npub trait PackedMontyParameters: MontyParameters {}\r\n\r\n/// BarrettParameters contains constants needed for the Barrett reduction used in the MDS code.\r\npub trait BarrettParameters: MontyParameters {\r\n    const N: usize = 40; // beta = 2^N, fixing N = 40 here\r\n    const PRIME_I128: i128 = Self::PRIME as i128;\r\n    const PSEUDO_INV: i64 = (((1_i128) \u003c\u003c (2 * Self::N)) / Self::PRIME_I128) as i64; // I = 2^80 / P =\u003e I \u003c 2**50\r\n    const MASK: i64 = !((1 \u003c\u003c 10) - 1); // Lets us 0 out the bottom 10 digits of an i64.\r\n}\r\n\r\n/// FieldParameters contains constants and methods needed to imply PrimeCharacteristicRing, Field and PrimeField32 for MontyField31.\r\npub trait FieldParameters: PackedMontyParameters + Sized {\r\n    // Simple field constants.\r\n    const MONTY_ZERO: MontyField31\u003cSelf\u003e = MontyField31::new(0);\r\n    const MONTY_ONE: MontyField31\u003cSelf\u003e = MontyField31::new(1);\r\n    const MONTY_TWO: MontyField31\u003cSelf\u003e = MontyField31::new(2);\r\n    const MONTY_NEG_ONE: MontyField31\u003cSelf\u003e = MontyField31::new(Self::PRIME - 1);\r\n\r\n    // A generator of the fields multiplicative group. Needs to be given in Monty Form.\r\n    const MONTY_GEN: MontyField31\u003cSelf\u003e;\r\n\r\n    const HALF_P_PLUS_1: u32 = (Self::PRIME + 1) \u003e\u003e 1;\r\n\r\n    fn try_inverse\u003cF: Field\u003e(p1: F) -\u003e Option\u003cF\u003e;\r\n}\r\n\r\n/// An integer `D` such that `gcd(D, p - 1) = 1`.\r\npub trait RelativelyPrimePower\u003cconst D: u64\u003e {\r\n    /// Compute `x -\u003e x^{1/D}` using the modular inverse\r\n    /// of `D mod p - 1`.\r\n    fn exp_root_d\u003cR: PrimeCharacteristicRing\u003e(val: R) -\u003e R;\r\n}\r\n\r\n/// TwoAdicData contains constants needed to imply TwoAdicField for Monty31 fields.\r\npub trait TwoAdicData: MontyParameters {\r\n    /// Largest n such that 2^n divides p - 1.\r\n    const TWO_ADICITY: usize;\r\n\r\n    /// The odd constant r such that p = r * 2^n + 1\r\n    const ODD_FACTOR: i32 = (Self::PRIME \u003e\u003e Self::TWO_ADICITY) as i32;\r\n\r\n    /// ArrayLike should usually be `\u0026'static [MontyField31]`.\r\n    type ArrayLike: AsRef\u003c[MontyField31\u003cSelf\u003e]\u003e + Sized;\r\n\r\n    /// A list of generators of 2-adic subgroups.\r\n    /// The i'th element must be a 2^i root of unity and the i'th element squared must be the i-1'th element.\r\n    const TWO_ADIC_GENERATORS: Self::ArrayLike;\r\n\r\n    /// Precomputation of the first 3 8th-roots of unity.\r\n    ///\r\n    /// Must agree with the 8th-root in TWO_ADIC_GENERATORS, i.e.\r\n    /// ROOTS_8[1] == TWO_ADIC_GENERATORS[3]\r\n    const ROOTS_8: Self::ArrayLike;\r\n\r\n    /// Precomputation of the inverses of ROOTS_8.\r\n    const INV_ROOTS_8: Self::ArrayLike;\r\n\r\n    /// Precomputation of the first 7 16th-roots of unity.\r\n    ///\r\n    /// Must agree with the 16th-root in TWO_ADIC_GENERATORS, i.e.\r\n    /// ROOTS_16[1] == TWO_ADIC_GENERATORS[4]\r\n    const ROOTS_16: Self::ArrayLike;\r\n\r\n    /// Precomputation of the inverses of ROOTS_16.\r\n    const INV_ROOTS_16: Self::ArrayLike;\r\n}\r\n\r\n/// TODO: This should be deleted long term once we have improved our API for defining extension fields.\r\n/// This allows us to implement Binomial Extensions over Monty31 fields.\r\npub trait BinomialExtensionData\u003cconst DEG: usize\u003e: MontyParameters + Sized {\r\n    /// W is a value such that (x^DEG - WN) is irreducible.\r\n    const W: MontyField31\u003cSelf\u003e;\r\n\r\n    /// DTH_ROOT = W^((p - 1)/DEG)\r\n    const DTH_ROOT: MontyField31\u003cSelf\u003e;\r\n\r\n    /// A generator of the extension fields multiplicative group.\r\n    const EXT_GENERATOR: [MontyField31\u003cSelf\u003e; DEG];\r\n\r\n    const EXT_TWO_ADICITY: usize;\r\n\r\n    /// ArrayLike should usually be [MontyField31; EXT_TWO_ADICITY - TWO_ADICITY].\r\n    type ArrayLike: AsRef\u003c[[MontyField31\u003cSelf\u003e; DEG]]\u003e + Sized;\r\n\r\n    /// A list of generators of 2-adic subgroups not contained in the base field.\r\n    const TWO_ADIC_EXTENSION_GENERATORS: Self::ArrayLike;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","dft","backward.rs"],"content":"//! Discrete Fourier Transform, in-place, decimation-in-time\r\n//!\r\n//! Straightforward recursive algorithm, \"unrolled\" up to size 256.\r\n//!\r\n//! Inspired by Bernstein's djbfft: https://cr.yp.to/djbfft.html\r\n\r\nextern crate alloc;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::izip;\r\nuse p3_field::{Field, PackedFieldPow2, PackedValue, PrimeCharacteristicRing};\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::utils::monty_reduce;\r\nuse crate::{FieldParameters, MontyField31, TwoAdicData};\r\n\r\n#[inline(always)]\r\nfn backward_butterfly\u003cT: PrimeCharacteristicRing + Copy\u003e(x: T, y: T, roots: T) -\u003e (T, T) {\r\n    let t = y * roots;\r\n    (x + t, x - t)\r\n}\r\n\r\n#[inline(always)]\r\nfn backward_butterfly_interleaved\u003cconst HALF_RADIX: usize, T: PackedFieldPow2\u003e(\r\n    x: T,\r\n    y: T,\r\n    roots: T,\r\n) -\u003e (T, T) {\r\n    let (x, y) = x.interleave(y, HALF_RADIX);\r\n    let (x, y) = backward_butterfly(x, y, roots);\r\n    x.interleave(y, HALF_RADIX)\r\n}\r\n\r\n#[inline]\r\nfn backward_pass_packed\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T], roots: \u0026[T::Scalar]) {\r\n    let packed_roots = T::pack_slice(roots);\r\n    let n = input.len();\r\n    let (xs, ys) = unsafe { input.split_at_mut_unchecked(n / 2) };\r\n\r\n    izip!(xs, ys, packed_roots)\r\n        .for_each(|(x, y, \u0026roots)| (*x, *y) = backward_butterfly(*x, *y, roots));\r\n}\r\n\r\n#[inline]\r\nfn backward_iterative_layer_1\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T], roots: \u0026[T::Scalar]) {\r\n    let packed_roots = T::pack_slice(roots);\r\n    let n = input.len();\r\n    let (top_half, bottom_half) = unsafe { input.split_at_mut_unchecked(n / 2) };\r\n    let (xs, ys) = unsafe { top_half.split_at_mut_unchecked(n / 4) };\r\n    let (zs, ws) = unsafe { bottom_half.split_at_mut_unchecked(n / 4) };\r\n\r\n    izip!(xs, ys, zs, ws, packed_roots).for_each(|(x, y, z, w, \u0026root)| {\r\n        (*x, *y) = backward_butterfly(*x, *y, root);\r\n        (*z, *w) = backward_butterfly(*z, *w, root);\r\n    });\r\n}\r\n\r\n#[inline]\r\nfn backward_iterative_packed\u003cconst HALF_RADIX: usize, T: PackedFieldPow2\u003e(\r\n    input: \u0026mut [T],\r\n    roots: \u0026[T::Scalar],\r\n) {\r\n    // roots[0] == 1\r\n    // roots \u003c-- [1, roots[1], ..., roots[HALF_RADIX-1], 1, roots[1], ...]\r\n    let roots = T::from_fn(|i| roots[i % HALF_RADIX]);\r\n\r\n    input.chunks_exact_mut(2).for_each(|pair| {\r\n        let (x, y) = backward_butterfly_interleaved::\u003cHALF_RADIX, _\u003e(pair[0], pair[1], roots);\r\n        pair[0] = x;\r\n        pair[1] = y;\r\n    });\r\n}\r\n\r\n#[inline]\r\nfn backward_iterative_packed_radix_2\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T]) {\r\n    input.chunks_exact_mut(2).for_each(|pair| {\r\n        let x = pair[0];\r\n        let y = pair[1];\r\n        let (mut x, y) = x.interleave(y, 1);\r\n        let t = x - y; // roots[0] == 1\r\n        x += y;\r\n        let (x, y) = x.interleave(t, 1);\r\n        pair[0] = x;\r\n        pair[1] = y;\r\n    });\r\n}\r\n\r\nimpl\u003cMP: FieldParameters + TwoAdicData\u003e MontyField31\u003cMP\u003e {\r\n    /// Breadth-first DIT FFT for smallish vectors (must be \u003e= 64)\r\n    #[inline]\r\n    fn backward_iterative_layer(\r\n        packed_input: \u0026mut [\u003cSelf as Field\u003e::Packing],\r\n        roots: \u0026[Self],\r\n        m: usize,\r\n    ) {\r\n        debug_assert_eq!(roots.len(), m);\r\n        let packed_roots = \u003cSelf as Field\u003e::Packing::pack_slice(roots);\r\n\r\n        // lg_m \u003e= 4, so m = 2^lg_m \u003e= 2^4, hence packing_width divides m\r\n        let packed_m = m / \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        packed_input\r\n            .chunks_exact_mut(2 * packed_m)\r\n            .for_each(|layer_chunk| {\r\n                let (xs, ys) = unsafe { layer_chunk.split_at_mut_unchecked(packed_m) };\r\n\r\n                izip!(xs, ys, packed_roots)\r\n                    .for_each(|(x, y, \u0026root)| (*x, *y) = backward_butterfly(*x, *y, root));\r\n            });\r\n    }\r\n\r\n    #[inline]\r\n    fn backward_iterative_packed_radix_16(input: \u0026mut [\u003cSelf as Field\u003e::Packing]) {\r\n        // Rather surprisingly, a version similar where the separate\r\n        // loops in each call to backward_iterative_packed() are\r\n        // combined into one, was not only not faster, but was\r\n        // actually a bit slower.\r\n\r\n        // Radix 2\r\n        backward_iterative_packed_radix_2(input);\r\n\r\n        // Radix 4\r\n        let roots4 = [MP::INV_ROOTS_8.as_ref()[0], MP::INV_ROOTS_8.as_ref()[2]];\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 4 {\r\n            backward_iterative_packed::\u003c2, _\u003e(input, \u0026roots4);\r\n        } else {\r\n            Self::backward_iterative_layer(input, \u0026roots4, 2);\r\n        }\r\n\r\n        // Radix 8\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 8 {\r\n            backward_iterative_packed::\u003c4, _\u003e(input, MP::INV_ROOTS_8.as_ref());\r\n        } else {\r\n            Self::backward_iterative_layer(input, MP::INV_ROOTS_8.as_ref(), 4);\r\n        }\r\n\r\n        // Radix 16\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 16 {\r\n            backward_iterative_packed::\u003c8, _\u003e(input, MP::INV_ROOTS_16.as_ref());\r\n        } else {\r\n            Self::backward_iterative_layer(input, MP::INV_ROOTS_16.as_ref(), 8);\r\n        }\r\n    }\r\n\r\n    fn backward_iterative(packed_input: \u0026mut [\u003cSelf as Field\u003e::Packing], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        assert!(packed_input.len() \u003e= 2);\r\n        let packing_width = \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        let n = packed_input.len() * packing_width;\r\n        let lg_n = log2_strict_usize(n);\r\n\r\n        // Start loop after doing radix 16 separately. This value is determined by the largest\r\n        // packing width we will encounter, which is 16 at the moment for AVX512. Specifically\r\n        // it is log_2(max{possible packing widths}) = lg(16) = 4.\r\n        const FIRST_LOOP_LAYER: usize = 4;\r\n\r\n        // How many layers have we specialised after the main loop\r\n        const NUM_SPECIALISATIONS: usize = 2;\r\n\r\n        // Needed to avoid overlap of the 2 specialisations at the start\r\n        // with the radix-16 specialisation at the end of the loop\r\n        assert!(lg_n \u003e= FIRST_LOOP_LAYER + NUM_SPECIALISATIONS);\r\n\r\n        Self::backward_iterative_packed_radix_16(packed_input);\r\n\r\n        for lg_m in FIRST_LOOP_LAYER..(lg_n - NUM_SPECIALISATIONS) {\r\n            let s = lg_n - lg_m - 1;\r\n            let m = 1 \u003c\u003c lg_m;\r\n\r\n            let roots = \u0026root_table[s];\r\n            debug_assert_eq!(roots.len(), m);\r\n\r\n            Self::backward_iterative_layer(packed_input, roots, m);\r\n        }\r\n        // Specialise the last few iterations; improves performance a little.\r\n        backward_iterative_layer_1(packed_input, \u0026root_table[1]); // lg_m == lg_n - 2, s == 1\r\n        backward_pass_packed(packed_input, \u0026root_table[0]); // lg_m == lg_n - 1, s == 0\r\n    }\r\n\r\n    #[inline]\r\n    fn backward_pass(input: \u0026mut [Self], roots: \u0026[Self]) {\r\n        let half_n = input.len() / 2;\r\n        assert_eq!(roots.len(), half_n);\r\n\r\n        // Safe because 0 \u003c= half_n \u003c a.len()\r\n        let (xs, ys) = unsafe { input.split_at_mut_unchecked(half_n) };\r\n\r\n        let s = xs[0] + ys[0];\r\n        let t = xs[0] - ys[0];\r\n        xs[0] = s;\r\n        ys[0] = t;\r\n\r\n        izip!(\u0026mut xs[1..], \u0026mut ys[1..], \u0026roots[1..]).for_each(|(x, y, \u0026root)| {\r\n            (*x, *y) = backward_butterfly(*x, *y, root);\r\n        });\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn backward_2(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 2);\r\n\r\n        let s = a[0] + a[1];\r\n        let t = a[0] - a[1];\r\n        a[0] = s;\r\n        a[1] = t;\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn backward_4(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 4);\r\n\r\n        // Read in bit-reversed order\r\n        let a0 = a[0];\r\n        let a2 = a[1];\r\n        let a1 = a[2];\r\n        let a3 = a[3];\r\n\r\n        // Expanding the calculation of t3 saves one instruction\r\n        let t1 = MP::PRIME + a1.value - a3.value;\r\n        let t3 = MontyField31::new_monty(monty_reduce::\u003cMP\u003e(\r\n            t1 as u64 * MP::INV_ROOTS_8.as_ref()[2].value as u64,\r\n        ));\r\n        let t5 = a1 + a3;\r\n        let t4 = a0 + a2;\r\n        let t2 = a0 - a2;\r\n\r\n        a[0] = t4 + t5;\r\n        a[1] = t2 + t3;\r\n        a[2] = t4 - t5;\r\n        a[3] = t2 - t3;\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn backward_8(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 8);\r\n\r\n        // Safe because a.len() == 8\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::backward_4(a0);\r\n        Self::backward_4(a1);\r\n\r\n        Self::backward_pass(a, MP::INV_ROOTS_8.as_ref());\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn backward_16(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 16);\r\n\r\n        // Safe because a.len() == 16\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::backward_8(a0);\r\n        Self::backward_8(a1);\r\n\r\n        Self::backward_pass(a, MP::INV_ROOTS_16.as_ref());\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn backward_32(a: \u0026mut [Self], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        assert_eq!(a.len(), 32);\r\n\r\n        // Safe because a.len() == 32\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::backward_16(a0);\r\n        Self::backward_16(a1);\r\n\r\n        Self::backward_pass(a, \u0026root_table[0]);\r\n    }\r\n\r\n    /// Assumes `input.len() \u003e= 64`.\r\n    /// current packing widths.\r\n    #[inline]\r\n    fn backward_fft_recur(input: \u0026mut [\u003cSelf as Field\u003e::Packing], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        const ITERATIVE_FFT_THRESHOLD: usize = 1024;\r\n\r\n        let n = input.len() * \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        if n \u003c= ITERATIVE_FFT_THRESHOLD {\r\n            Self::backward_iterative(input, root_table);\r\n        } else {\r\n            assert_eq!(n, 1 \u003c\u003c (root_table.len() + 1));\r\n\r\n            // Safe because input.len() \u003e ITERATIVE_FFT_THRESHOLD\r\n            let (a0, a1) = unsafe { input.split_at_mut_unchecked(input.len() / 2) };\r\n            Self::backward_fft_recur(a0, \u0026root_table[1..]);\r\n            Self::backward_fft_recur(a1, \u0026root_table[1..]);\r\n\r\n            backward_pass_packed(input, \u0026root_table[0]);\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    pub fn backward_fft(input: \u0026mut [Self], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        let n = input.len();\r\n        if n == 1 {\r\n            return;\r\n        }\r\n\r\n        assert_eq!(n, 1 \u003c\u003c (root_table.len() + 1));\r\n        match n {\r\n            32 =\u003e Self::backward_32(input, root_table),\r\n            16 =\u003e Self::backward_16(input),\r\n            8 =\u003e Self::backward_8(input),\r\n            4 =\u003e Self::backward_4(input),\r\n            2 =\u003e Self::backward_2(input),\r\n            _ =\u003e {\r\n                let packed_input = \u003cSelf as Field\u003e::Packing::pack_slice_mut(input);\r\n                Self::backward_fft_recur(packed_input, root_table)\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":19,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":20,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":24,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":29,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":30,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":31,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":35,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":36,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":37,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":38,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":40,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":41,"address":[],"length":0,"stats":{"Line":10376293541461622996}},{"line":45,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":46,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":47,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":48,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":49,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":50,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":52,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":53,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":54,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":59,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":65,"address":[],"length":0,"stats":{"Line":10376293541461622820}},{"line":67,"address":[],"length":0,"stats":{"Line":12105675798371893246}},{"line":68,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":69,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":70,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":75,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":76,"address":[],"length":0,"stats":{"Line":2594073385365405700}},{"line":77,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":78,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":79,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":80,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":81,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":82,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":83,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":84,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":91,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":96,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":97,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":100,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":101,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":102,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":103,"address":[],"length":0,"stats":{"Line":8935141660703064066}},{"line":104,"address":[],"length":0,"stats":{"Line":5764607523034234882}},{"line":106,"address":[],"length":0,"stats":{"Line":5764607523034234882}},{"line":107,"address":[],"length":0,"stats":{"Line":14987979559889010702}},{"line":112,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":119,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":122,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":123,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":124,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":131,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":144,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":145,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":146,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":147,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":148,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":160,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":162,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":164,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":165,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":166,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":168,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":169,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":171,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":174,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":175,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":179,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":180,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":181,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":184,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":186,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":187,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":188,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":189,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":191,"address":[],"length":0,"stats":{"Line":10952754293765046326}},{"line":192,"address":[],"length":0,"stats":{"Line":14699749183737298998}},{"line":197,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":198,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":200,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":201,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":202,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":203,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":207,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":208,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":211,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":212,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":213,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":214,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":217,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":218,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":219,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":221,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":222,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":223,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":225,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":226,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":227,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":228,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":232,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":233,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":236,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":237,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":238,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":240,"address":[],"length":0,"stats":{"Line":9943947977234055168}},{"line":244,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":245,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":248,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":249,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":250,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":252,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":256,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":257,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":260,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":261,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":262,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":264,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":270,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":273,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":274,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":275,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":277,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":280,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":281,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":282,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":284,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":289,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":290,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":291,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":296,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":297,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":298,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":299,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":300,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":301,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":304,"address":[],"length":0,"stats":{"Line":5188146770730811392}}],"covered":143,"coverable":148},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","dft","forward.rs"],"content":"//! Discrete Fourier Transform, in-place, decimation-in-frequency\r\n//!\r\n//! Straightforward recursive algorithm, \"unrolled\" up to size 256.\r\n//!\r\n//! Inspired by Bernstein's djbfft: https://cr.yp.to/djbfft.html\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::izip;\r\nuse p3_field::{Field, PackedFieldPow2, PackedValue, PrimeCharacteristicRing, TwoAdicField};\r\nuse p3_util::log2_strict_usize;\r\n\r\nuse crate::utils::monty_reduce;\r\nuse crate::{FieldParameters, MontyField31, TwoAdicData};\r\n\r\nimpl\u003cMP: FieldParameters + TwoAdicData\u003e MontyField31\u003cMP\u003e {\r\n    /// Given a field element `gen` of order n where `n = 2^lg_n`,\r\n    /// return a vector of vectors `table` where table[i] is the\r\n    /// vector of twiddle factors for an fft of length n/2^i. The\r\n    /// values g_i^k for k \u003e= i/2 are skipped as these are just the\r\n    /// negatives of the other roots (using g_i^{i/2} = -1).  The\r\n    /// value gen^0 = 1 is included to aid consistency between the\r\n    /// packed and non-packed variants.\r\n    pub fn roots_of_unity_table(n: usize) -\u003e Vec\u003cVec\u003cSelf\u003e\u003e {\r\n        let lg_n = log2_strict_usize(n);\r\n        let gen = Self::two_adic_generator(lg_n);\r\n        let half_n = 1 \u003c\u003c (lg_n - 1);\r\n        // nth_roots = [1, g, g^2, g^3, ..., g^{n/2 - 1}]\r\n        let nth_roots: Vec\u003c_\u003e = gen.powers().take(half_n).collect();\r\n\r\n        (0..(lg_n - 1))\r\n            .map(|i| nth_roots.iter().step_by(1 \u003c\u003c i).copied().collect())\r\n            .collect()\r\n    }\r\n}\r\n\r\n#[inline(always)]\r\nfn forward_butterfly\u003cT: PrimeCharacteristicRing + Copy\u003e(x: T, y: T, roots: T) -\u003e (T, T) {\r\n    let t = x - y;\r\n    (x + y, t * roots)\r\n}\r\n\r\n#[inline(always)]\r\nfn forward_butterfly_interleaved\u003cconst HALF_RADIX: usize, T: PackedFieldPow2\u003e(\r\n    x: T,\r\n    y: T,\r\n    roots: T,\r\n) -\u003e (T, T) {\r\n    let (x, y) = x.interleave(y, HALF_RADIX);\r\n    let (x, y) = forward_butterfly(x, y, roots);\r\n    x.interleave(y, HALF_RADIX)\r\n}\r\n\r\n#[inline]\r\nfn forward_pass_packed\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T], roots: \u0026[T::Scalar]) {\r\n    let packed_roots = T::pack_slice(roots);\r\n    let n = input.len();\r\n    let (xs, ys) = unsafe { input.split_at_mut_unchecked(n / 2) };\r\n\r\n    izip!(xs, ys, packed_roots)\r\n        .for_each(|(x, y, \u0026roots)| (*x, *y) = forward_butterfly(*x, *y, roots));\r\n}\r\n\r\n#[inline]\r\nfn forward_iterative_layer_1\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T], roots: \u0026[T::Scalar]) {\r\n    let packed_roots = T::pack_slice(roots);\r\n    let n = input.len();\r\n    let (top_half, bottom_half) = unsafe { input.split_at_mut_unchecked(n / 2) };\r\n    let (xs, ys) = unsafe { top_half.split_at_mut_unchecked(n / 4) };\r\n    let (zs, ws) = unsafe { bottom_half.split_at_mut_unchecked(n / 4) };\r\n\r\n    izip!(xs, ys, zs, ws, packed_roots).for_each(|(x, y, z, w, \u0026root)| {\r\n        (*x, *y) = forward_butterfly(*x, *y, root);\r\n        (*z, *w) = forward_butterfly(*z, *w, root);\r\n    });\r\n}\r\n\r\n#[inline]\r\nfn forward_iterative_packed\u003cconst HALF_RADIX: usize, T: PackedFieldPow2\u003e(\r\n    input: \u0026mut [T],\r\n    roots: \u0026[T::Scalar],\r\n) {\r\n    // roots[0] == 1\r\n    // roots \u003c-- [1, roots[1], ..., roots[HALF_RADIX-1], 1, roots[1], ...]\r\n    let roots = T::from_fn(|i| roots[i % HALF_RADIX]);\r\n\r\n    input.chunks_exact_mut(2).for_each(|pair| {\r\n        let (x, y) = forward_butterfly_interleaved::\u003cHALF_RADIX, _\u003e(pair[0], pair[1], roots);\r\n        pair[0] = x;\r\n        pair[1] = y;\r\n    });\r\n}\r\n\r\n#[inline]\r\nfn forward_iterative_packed_radix_2\u003cT: PackedFieldPow2\u003e(input: \u0026mut [T]) {\r\n    input.chunks_exact_mut(2).for_each(|pair| {\r\n        let x = pair[0];\r\n        let y = pair[1];\r\n        let (mut x, y) = x.interleave(y, 1);\r\n        let t = x - y; // roots[0] == 1\r\n        x += y;\r\n        let (x, y) = x.interleave(t, 1);\r\n        pair[0] = x;\r\n        pair[1] = y;\r\n    });\r\n}\r\n\r\nimpl\u003cMP: FieldParameters + TwoAdicData\u003e MontyField31\u003cMP\u003e {\r\n    #[inline]\r\n    fn forward_iterative_layer(\r\n        packed_input: \u0026mut [\u003cSelf as Field\u003e::Packing],\r\n        roots: \u0026[Self],\r\n        m: usize,\r\n    ) {\r\n        debug_assert_eq!(roots.len(), m);\r\n        let packed_roots = \u003cSelf as Field\u003e::Packing::pack_slice(roots);\r\n\r\n        // lg_m \u003e= 4, so m = 2^lg_m \u003e= 2^4, hence packing_width divides m\r\n        let packed_m = m / \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        packed_input\r\n            .chunks_exact_mut(2 * packed_m)\r\n            .for_each(|layer_chunk| {\r\n                let (xs, ys) = unsafe { layer_chunk.split_at_mut_unchecked(packed_m) };\r\n\r\n                izip!(xs, ys, packed_roots)\r\n                    .for_each(|(x, y, \u0026root)| (*x, *y) = forward_butterfly(*x, *y, root));\r\n            });\r\n    }\r\n\r\n    #[inline]\r\n    fn forward_iterative_packed_radix_16(input: \u0026mut [\u003cSelf as Field\u003e::Packing]) {\r\n        // Rather surprisingly, a version similar where the separate\r\n        // loops in each call to forward_iterative_packed() are\r\n        // combined into one, was not only not faster, but was\r\n        // actually a bit slower.\r\n\r\n        // Radix 16\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 16 {\r\n            forward_iterative_packed::\u003c8, _\u003e(input, MP::ROOTS_16.as_ref());\r\n        } else {\r\n            Self::forward_iterative_layer(input, MP::ROOTS_16.as_ref(), 8);\r\n        }\r\n\r\n        // Radix 8\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 8 {\r\n            forward_iterative_packed::\u003c4, _\u003e(input, MP::ROOTS_8.as_ref());\r\n        } else {\r\n            Self::forward_iterative_layer(input, MP::ROOTS_8.as_ref(), 4);\r\n        }\r\n\r\n        // Radix 4\r\n        let roots4 = [MP::ROOTS_8.as_ref()[0], MP::ROOTS_8.as_ref()[2]];\r\n        if \u003cSelf as Field\u003e::Packing::WIDTH \u003e= 4 {\r\n            forward_iterative_packed::\u003c2, _\u003e(input, \u0026roots4);\r\n        } else {\r\n            Self::forward_iterative_layer(input, \u0026roots4, 2);\r\n        }\r\n\r\n        // Radix 2\r\n        forward_iterative_packed_radix_2(input);\r\n    }\r\n\r\n    /// Breadth-first DIF FFT for smallish vectors (must be \u003e= 64)\r\n    #[inline]\r\n    fn forward_iterative(packed_input: \u0026mut [\u003cSelf as Field\u003e::Packing], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        assert!(packed_input.len() \u003e= 2);\r\n        let packing_width = \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        let n = packed_input.len() * packing_width;\r\n        let lg_n = log2_strict_usize(n);\r\n\r\n        // Stop loop early to do radix 16 separately. This value is determined by the largest\r\n        // packing width we will encounter, which is 16 at the moment for AVX512. Specifically\r\n        // it is log_2(max{possible packing widths}) = lg(16) = 4.\r\n        const LAST_LOOP_LAYER: usize = 4;\r\n\r\n        // How many layers have we specialised before the main loop\r\n        const NUM_SPECIALISATIONS: usize = 2;\r\n\r\n        // Needed to avoid overlap of the 2 specialisations at the start\r\n        // with the radix-16 specialisation at the end of the loop\r\n        assert!(lg_n \u003e= LAST_LOOP_LAYER + NUM_SPECIALISATIONS);\r\n\r\n        // Specialise the first NUM_SPECIALISATIONS iterations; improves performance a little.\r\n        forward_pass_packed(packed_input, \u0026root_table[0]); // lg_m == lg_n - 1, s == 0\r\n        forward_iterative_layer_1(packed_input, \u0026root_table[1]); // lg_m == lg_n - 2, s == 1\r\n\r\n        // loop from lg_n-2 down to 4.\r\n        for lg_m in (LAST_LOOP_LAYER..(lg_n - NUM_SPECIALISATIONS)).rev() {\r\n            let s = lg_n - lg_m - 1;\r\n            let m = 1 \u003c\u003c lg_m;\r\n\r\n            let roots = \u0026root_table[s];\r\n            debug_assert_eq!(roots.len(), m);\r\n\r\n            Self::forward_iterative_layer(packed_input, roots, m);\r\n        }\r\n\r\n        // Last 4 layers\r\n        Self::forward_iterative_packed_radix_16(packed_input);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_butterfly(x: Self, y: Self, w: Self) -\u003e (Self, Self) {\r\n        let t = MP::PRIME + x.value - y.value;\r\n        (\r\n            x + y,\r\n            Self::new_monty(monty_reduce::\u003cMP\u003e(t as u64 * w.value as u64)),\r\n        )\r\n    }\r\n\r\n    #[inline]\r\n    fn forward_pass(input: \u0026mut [Self], roots: \u0026[Self]) {\r\n        let half_n = input.len() / 2;\r\n        assert_eq!(roots.len(), half_n);\r\n\r\n        // Safe because 0 \u003c= half_n \u003c a.len()\r\n        let (xs, ys) = unsafe { input.split_at_mut_unchecked(half_n) };\r\n\r\n        let s = xs[0] + ys[0];\r\n        let t = xs[0] - ys[0];\r\n        xs[0] = s;\r\n        ys[0] = t;\r\n\r\n        izip!(\u0026mut xs[1..], \u0026mut ys[1..], \u0026roots[1..]).for_each(|(x, y, \u0026root)| {\r\n            (*x, *y) = Self::forward_butterfly(*x, *y, root);\r\n        });\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_2(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 2);\r\n\r\n        let s = a[0] + a[1];\r\n        let t = a[0] - a[1];\r\n        a[0] = s;\r\n        a[1] = t;\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_4(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 4);\r\n\r\n        // Expanding the calculation of t3 saves one instruction\r\n        let t1 = MP::PRIME + a[1].value - a[3].value;\r\n        let t3 = MontyField31::new_monty(monty_reduce::\u003cMP\u003e(\r\n            t1 as u64 * MP::ROOTS_8.as_ref()[2].value as u64,\r\n        ));\r\n        let t5 = a[1] + a[3];\r\n        let t4 = a[0] + a[2];\r\n        let t2 = a[0] - a[2];\r\n\r\n        // Return in bit-reversed order\r\n        a[0] = t4 + t5;\r\n        a[1] = t4 - t5;\r\n        a[2] = t2 + t3;\r\n        a[3] = t2 - t3;\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_8(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 8);\r\n\r\n        Self::forward_pass(a, MP::ROOTS_8.as_ref());\r\n\r\n        // Safe because a.len() == 8\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::forward_4(a0);\r\n        Self::forward_4(a1);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_16(a: \u0026mut [Self]) {\r\n        assert_eq!(a.len(), 16);\r\n\r\n        Self::forward_pass(a, MP::ROOTS_16.as_ref());\r\n\r\n        // Safe because a.len() == 16\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::forward_8(a0);\r\n        Self::forward_8(a1);\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn forward_32(a: \u0026mut [Self], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        assert_eq!(a.len(), 32);\r\n\r\n        Self::forward_pass(a, \u0026root_table[0]);\r\n\r\n        // Safe because a.len() == 32\r\n        let (a0, a1) = unsafe { a.split_at_mut_unchecked(a.len() / 2) };\r\n        Self::forward_16(a0);\r\n        Self::forward_16(a1);\r\n    }\r\n\r\n    /// Assumes `input.len() \u003e= 64`.\r\n    #[inline]\r\n    fn forward_fft_recur(input: \u0026mut [\u003cSelf as Field\u003e::Packing], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        const ITERATIVE_FFT_THRESHOLD: usize = 1024;\r\n\r\n        let n = input.len() * \u003cSelf as Field\u003e::Packing::WIDTH;\r\n        if n \u003c= ITERATIVE_FFT_THRESHOLD {\r\n            Self::forward_iterative(input, root_table);\r\n        } else {\r\n            assert_eq!(n, 1 \u003c\u003c (root_table.len() + 1));\r\n            forward_pass_packed(input, \u0026root_table[0]);\r\n\r\n            // Safe because input.len() \u003e ITERATIVE_FFT_THRESHOLD\r\n            let (a0, a1) = unsafe { input.split_at_mut_unchecked(input.len() / 2) };\r\n\r\n            Self::forward_fft_recur(a0, \u0026root_table[1..]);\r\n            Self::forward_fft_recur(a1, \u0026root_table[1..]);\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    pub fn forward_fft(input: \u0026mut [Self], root_table: \u0026[Vec\u003cSelf\u003e]) {\r\n        let n = input.len();\r\n        if n == 1 {\r\n            return;\r\n        }\r\n        assert_eq!(n, 1 \u003c\u003c (root_table.len() + 1));\r\n        match n {\r\n            32 =\u003e Self::forward_32(input, root_table),\r\n            16 =\u003e Self::forward_16(input),\r\n            8 =\u003e Self::forward_8(input),\r\n            4 =\u003e Self::forward_4(input),\r\n            2 =\u003e Self::forward_2(input),\r\n            _ =\u003e {\r\n                let packed_input = \u003cSelf as Field\u003e::Packing::pack_slice_mut(input);\r\n                Self::forward_fft_recur(packed_input, root_table)\r\n            }\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":27,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":28,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":29,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":31,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":33,"address":[],"length":0,"stats":{"Line":6341068275340126556}},{"line":34,"address":[],"length":0,"stats":{"Line":4179340454204756718}},{"line":40,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":41,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":42,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":46,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":51,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":52,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":53,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":57,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":58,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":59,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":60,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":62,"address":[],"length":0,"stats":{"Line":6917529027641081962}},{"line":63,"address":[],"length":0,"stats":{"Line":10376293541461622996}},{"line":67,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":68,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":69,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":70,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":71,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":72,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":74,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":75,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":76,"address":[],"length":0,"stats":{"Line":16717361816799281152}},{"line":81,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":87,"address":[],"length":0,"stats":{"Line":10376293541461622820}},{"line":89,"address":[],"length":0,"stats":{"Line":12105675798371893246}},{"line":90,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":91,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":92,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":97,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":98,"address":[],"length":0,"stats":{"Line":2594073385365405700}},{"line":99,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":100,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":101,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":102,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":103,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":104,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":105,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":106,"address":[],"length":0,"stats":{"Line":14987979559889010692}},{"line":112,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":117,"address":[],"length":0,"stats":{"Line":6341068275337658368}},{"line":118,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":121,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":122,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":123,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":124,"address":[],"length":0,"stats":{"Line":8935141660703064068}},{"line":125,"address":[],"length":0,"stats":{"Line":5764607523034234884}},{"line":127,"address":[],"length":0,"stats":{"Line":5764607523034234884}},{"line":128,"address":[],"length":0,"stats":{"Line":14987979559889010706}},{"line":133,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":140,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":147,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":148,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":155,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":156,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":167,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":168,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":169,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":170,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":171,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":183,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":186,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":187,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":190,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":191,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":192,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":194,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":195,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":197,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":201,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":205,"address":[],"length":0,"stats":{"Line":13258597302978740228}},{"line":206,"address":[],"length":0,"stats":{"Line":13258597302978740228}},{"line":208,"address":[],"length":0,"stats":{"Line":13258597302978740228}},{"line":209,"address":[],"length":0,"stats":{"Line":13258597302978740228}},{"line":214,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":215,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":216,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":219,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":221,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":222,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":223,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":224,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":226,"address":[],"length":0,"stats":{"Line":15564440312192434176}},{"line":227,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":232,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":233,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":235,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":236,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":237,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":238,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":242,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":243,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":246,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":247,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":248,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":250,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":251,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":252,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":255,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":256,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":257,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":258,"address":[],"length":0,"stats":{"Line":10520408729537478656}},{"line":262,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":263,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":265,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":268,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":269,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":270,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":274,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":275,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":277,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":280,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":281,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":282,"address":[],"length":0,"stats":{"Line":5620492334958379008}},{"line":286,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":287,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":289,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":292,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":293,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":294,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":299,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":302,"address":[],"length":0,"stats":{"Line":6917529027641081856}},{"line":303,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":304,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":306,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":307,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":310,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":312,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":313,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":318,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":319,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":320,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":324,"address":[],"length":0,"stats":{"Line":15132094747964866560}},{"line":325,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":326,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":327,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":328,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":329,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":332,"address":[],"length":0,"stats":{"Line":5188146770730811392}}],"covered":150,"coverable":155},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","dft","mod.rs"],"content":"//! An implementation of the FFT for `MontyField31`\r\nextern crate alloc;\r\n\r\nuse alloc::vec::Vec;\r\nuse core::cell::RefCell;\r\nuse core::iter;\r\n\r\nuse itertools::izip;\r\nuse p3_dft::TwoAdicSubgroupDft;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_matrix::bitrev::{BitReversableMatrix, BitReversedMatrixView};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse tracing::{debug_span, instrument};\r\n\r\nmod backward;\r\nmod forward;\r\n\r\nuse crate::{FieldParameters, MontyField31, MontyParameters, TwoAdicData};\r\n\r\n/// Multiply each element of column `j` of `mat` by `shift**j`.\r\n#[instrument(level = \"debug\", skip_all)]\r\nfn coset_shift_and_scale_rows\u003cF: Field\u003e(\r\n    out: \u0026mut [F],\r\n    out_ncols: usize,\r\n    mat: \u0026[F],\r\n    ncols: usize,\r\n    shift: F,\r\n    scale: F,\r\n) {\r\n    let powers = shift.shifted_powers(scale).take(ncols).collect::\u003cVec\u003c_\u003e\u003e();\r\n    out.par_chunks_exact_mut(out_ncols)\r\n        .zip(mat.par_chunks_exact(ncols))\r\n        .for_each(|(out_row, in_row)| {\r\n            izip!(out_row.iter_mut(), in_row, \u0026powers).for_each(|(out, \u0026coeff, \u0026weight)| {\r\n                *out = coeff * weight;\r\n            });\r\n        });\r\n}\r\n\r\n/// Recursive DFT, decimation-in-frequency in the forward direction,\r\n/// decimation-in-time in the backward (inverse) direction.\r\n#[derive(Clone, Debug, Default)]\r\npub struct RecursiveDft\u003cF\u003e {\r\n    /// Memoized twiddle factors for each length log_n.\r\n    ///\r\n    /// TODO: The use of RefCell means this can't be shared across\r\n    /// threads; consider using RwLock or finding a better design\r\n    /// instead.\r\n    twiddles: RefCell\u003cVec\u003cVec\u003cF\u003e\u003e\u003e,\r\n    inv_twiddles: RefCell\u003cVec\u003cVec\u003cF\u003e\u003e\u003e,\r\n}\r\n\r\nimpl\u003cMP: FieldParameters + TwoAdicData\u003e RecursiveDft\u003cMontyField31\u003cMP\u003e\u003e {\r\n    pub fn new(n: usize) -\u003e Self {\r\n        let res = Self {\r\n            twiddles: RefCell::default(),\r\n            inv_twiddles: RefCell::default(),\r\n        };\r\n        res.update_twiddles(n);\r\n        res\r\n    }\r\n\r\n    #[inline]\r\n    fn decimation_in_freq_dft(\r\n        mat: \u0026mut [MontyField31\u003cMP\u003e],\r\n        ncols: usize,\r\n        twiddles: \u0026[Vec\u003cMontyField31\u003cMP\u003e\u003e],\r\n    ) {\r\n        if ncols \u003e 1 {\r\n            let lg_fft_len = p3_util::log2_ceil_usize(ncols);\r\n            let roots_idx = (twiddles.len() + 1) - lg_fft_len;\r\n            let twiddles = \u0026twiddles[roots_idx..];\r\n\r\n            mat.par_chunks_exact_mut(ncols)\r\n                .for_each(|v| MontyField31::forward_fft(v, twiddles))\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn decimation_in_time_dft(\r\n        mat: \u0026mut [MontyField31\u003cMP\u003e],\r\n        ncols: usize,\r\n        twiddles: \u0026[Vec\u003cMontyField31\u003cMP\u003e\u003e],\r\n    ) {\r\n        if ncols \u003e 1 {\r\n            let lg_fft_len = p3_util::log2_ceil_usize(ncols);\r\n            let roots_idx = (twiddles.len() + 1) - lg_fft_len;\r\n            let twiddles = \u0026twiddles[roots_idx..];\r\n\r\n            mat.par_chunks_exact_mut(ncols)\r\n                .for_each(|v| MontyField31::backward_fft(v, twiddles))\r\n        }\r\n    }\r\n\r\n    /// Compute twiddle factors, or take memoized ones if already available.\r\n    #[instrument(skip_all)]\r\n    fn update_twiddles(\u0026self, fft_len: usize) {\r\n        // TODO: This recomputes the entire table from scratch if we\r\n        // need it to be bigger, which is wasteful.\r\n\r\n        // As we don't save the twiddles for the final layer where\r\n        // the only twiddle is 1, roots_of_unity_table(fft_len)\r\n        // returns a vector of twiddles of length log_2(fft_len) - 1.\r\n        let curr_max_fft_len = 2 \u003c\u003c self.twiddles.borrow().len();\r\n        if fft_len \u003e curr_max_fft_len {\r\n            let new_twiddles = MontyField31::roots_of_unity_table(fft_len);\r\n            // We can obtain the inverse twiddles by reversing and\r\n            // negating the twiddles.\r\n            let new_inv_twiddles = new_twiddles\r\n                .iter()\r\n                .map(|ts| {\r\n                    // The first twiddle is still one, we reverse and negate the rest...\r\n                    iter::once(MontyField31::ONE)\r\n                        .chain(\r\n                            ts[1..]\r\n                                .iter()\r\n                                .rev()\r\n                                // A twiddle t is never zero, so negation simplifies\r\n                                // to P - t.\r\n                                .map(|\u0026t| MontyField31::new_monty(MP::PRIME - t.value)),\r\n                        )\r\n                        .collect()\r\n                })\r\n                .collect();\r\n            self.twiddles.replace(new_twiddles);\r\n            self.inv_twiddles.replace(new_inv_twiddles);\r\n        }\r\n    }\r\n}\r\n\r\n/// DFT implementation that uses DIT for the inverse \"backward\"\r\n/// direction and DIF for the \"forward\" direction.\r\n///\r\n/// The API mandates that the LDE is applied column-wise on the\r\n/// _row-major_ input. This is awkward for memory coherence, so the\r\n/// algorithm here transposes the input and operates on the rows in\r\n/// the typical way, then transposes back again for the output. Even\r\n/// for modestly large inputs, the cost of the two tranposes\r\n/// outweighed by the improved performance from operating row-wise.\r\n///\r\n/// The choice of DIT for inverse and DIF for \"forward\" transform mean\r\n/// that a (coset) LDE\r\n///\r\n/// - IDFT / zero extend / DFT\r\n///\r\n/// expands to\r\n///\r\n///   - bit-reverse input\r\n///   - invDFT DIT\r\n///     - result is in \"correct\" order\r\n///   - coset shift and zero extend result\r\n///   - DFT DIF on result\r\n///     - output is bit-reversed, as required for FRI.\r\n///\r\n/// Hence the only bit-reversal that needs to take place is on the input.\r\n///\r\nimpl\u003cMP: MontyParameters + FieldParameters + TwoAdicData\u003e TwoAdicSubgroupDft\u003cMontyField31\u003cMP\u003e\u003e\r\n    for RecursiveDft\u003cMontyField31\u003cMP\u003e\u003e\r\n{\r\n    type Evaluations = BitReversedMatrixView\u003cRowMajorMatrix\u003cMontyField31\u003cMP\u003e\u003e\u003e;\r\n\r\n    #[instrument(skip_all, fields(dims = %mat.dimensions(), added_bits))]\r\n    fn dft_batch(\u0026self, mut mat: RowMajorMatrix\u003cMontyField31\u003cMP\u003e\u003e) -\u003e Self::Evaluations\r\n    where\r\n        MP: MontyParameters + FieldParameters + TwoAdicData,\r\n    {\r\n        let nrows = mat.height();\r\n        let ncols = mat.width();\r\n        if nrows \u003c= 1 {\r\n            return mat.bit_reverse_rows();\r\n        }\r\n\r\n        let mut scratch = debug_span!(\"allocate scratch space\")\r\n            .in_scope(|| RowMajorMatrix::default(nrows, ncols));\r\n\r\n        self.update_twiddles(nrows);\r\n        let twiddles = self.twiddles.borrow();\r\n\r\n        // transpose input\r\n        debug_span!(\"pre-transpose\", nrows, ncols)\r\n            .in_scope(|| transpose::transpose(\u0026mat.values, \u0026mut scratch.values, ncols, nrows));\r\n\r\n        debug_span!(\"dft batch\", n_dfts = ncols, fft_len = nrows)\r\n            .in_scope(|| Self::decimation_in_freq_dft(\u0026mut scratch.values, nrows, \u0026twiddles));\r\n\r\n        // transpose output\r\n        debug_span!(\"post-transpose\", nrows = ncols, ncols = nrows)\r\n            .in_scope(|| transpose::transpose(\u0026scratch.values, \u0026mut mat.values, nrows, ncols));\r\n\r\n        mat.bit_reverse_rows()\r\n    }\r\n\r\n    #[instrument(skip_all, fields(dims = %mat.dimensions(), added_bits))]\r\n    fn idft_batch(\u0026self, mat: RowMajorMatrix\u003cMontyField31\u003cMP\u003e\u003e) -\u003e RowMajorMatrix\u003cMontyField31\u003cMP\u003e\u003e\r\n    where\r\n        MP: MontyParameters + FieldParameters + TwoAdicData,\r\n    {\r\n        let nrows = mat.height();\r\n        let ncols = mat.width();\r\n        if nrows \u003c= 1 {\r\n            return mat;\r\n        }\r\n\r\n        let mut scratch = debug_span!(\"allocate scratch space\")\r\n            .in_scope(|| RowMajorMatrix::default(nrows, ncols));\r\n\r\n        let mut mat =\r\n            debug_span!(\"initial bitrev\").in_scope(|| mat.bit_reverse_rows().to_row_major_matrix());\r\n\r\n        self.update_twiddles(nrows);\r\n        let inv_twiddles = self.inv_twiddles.borrow();\r\n\r\n        // transpose input\r\n        debug_span!(\"pre-transpose\", nrows, ncols)\r\n            .in_scope(|| transpose::transpose(\u0026mat.values, \u0026mut scratch.values, ncols, nrows));\r\n\r\n        debug_span!(\"idft\", n_dfts = ncols, fft_len = nrows)\r\n            .in_scope(|| Self::decimation_in_time_dft(\u0026mut scratch.values, nrows, \u0026inv_twiddles));\r\n\r\n        // transpose output\r\n        debug_span!(\"post-transpose\", nrows = ncols, ncols = nrows)\r\n            .in_scope(|| transpose::transpose(\u0026scratch.values, \u0026mut mat.values, nrows, ncols));\r\n\r\n        let inv_len = MontyField31::from_usize(nrows).inverse();\r\n        debug_span!(\"scale\").in_scope(|| mat.scale(inv_len));\r\n        mat\r\n    }\r\n\r\n    #[instrument(skip_all, fields(dims = %mat.dimensions(), added_bits))]\r\n    fn coset_lde_batch(\r\n        \u0026self,\r\n        mat: RowMajorMatrix\u003cMontyField31\u003cMP\u003e\u003e,\r\n        added_bits: usize,\r\n        shift: MontyField31\u003cMP\u003e,\r\n    ) -\u003e Self::Evaluations {\r\n        let nrows = mat.height();\r\n        let ncols = mat.width();\r\n        let result_nrows = nrows \u003c\u003c added_bits;\r\n\r\n        if nrows == 1 {\r\n            let dupd_rows = core::iter::repeat(mat.values)\r\n                .take(result_nrows)\r\n                .flatten()\r\n                .collect();\r\n            return RowMajorMatrix::new(dupd_rows, ncols).bit_reverse_rows();\r\n        }\r\n\r\n        let input_size = nrows * ncols;\r\n        let output_size = result_nrows * ncols;\r\n\r\n        let mat = mat.bit_reverse_rows().to_row_major_matrix();\r\n\r\n        // Allocate space for the output and the intermediate state.\r\n        let (mut output, mut padded) = debug_span!(\"allocate scratch space\").in_scope(|| {\r\n            // Safety: These are pretty dodgy, but work because MontyField31 is #[repr(transparent)]\r\n            let output = MontyField31::\u003cMP\u003e::zero_vec(output_size);\r\n            let padded = MontyField31::\u003cMP\u003e::zero_vec(output_size);\r\n            (output, padded)\r\n        });\r\n\r\n        // `coeffs` will hold the result of the inverse FFT; use the\r\n        // output storage as scratch space.\r\n        let coeffs = \u0026mut output[..input_size];\r\n\r\n        debug_span!(\"pre-transpose\", nrows, ncols)\r\n            .in_scope(|| transpose::transpose(\u0026mat.values, coeffs, ncols, nrows));\r\n\r\n        // Apply inverse DFT; result is not yet normalised.\r\n        self.update_twiddles(result_nrows);\r\n        let inv_twiddles = self.inv_twiddles.borrow();\r\n        debug_span!(\"inverse dft batch\", n_dfts = ncols, fft_len = nrows)\r\n            .in_scope(|| Self::decimation_in_time_dft(coeffs, nrows, \u0026inv_twiddles));\r\n\r\n        // At this point the inverse FFT of each column of `mat` appears\r\n        // as a row in `coeffs`.\r\n\r\n        // Normalise inverse DFT and coset shift in one go.\r\n        let inv_len = MontyField31::from_usize(nrows).inverse();\r\n        coset_shift_and_scale_rows(\u0026mut padded, result_nrows, coeffs, nrows, shift, inv_len);\r\n\r\n        // `padded` is implicitly zero padded since it was initialised\r\n        // to zeros when declared above.\r\n\r\n        let twiddles = self.twiddles.borrow();\r\n\r\n        // Apply DFT\r\n        debug_span!(\"dft batch\", n_dfts = ncols, fft_len = result_nrows)\r\n            .in_scope(|| Self::decimation_in_freq_dft(\u0026mut padded, result_nrows, \u0026twiddles));\r\n\r\n        // transpose output\r\n        debug_span!(\"post-transpose\", nrows = ncols, ncols = result_nrows)\r\n            .in_scope(|| transpose::transpose(\u0026padded, \u0026mut output, result_nrows, ncols));\r\n\r\n        RowMajorMatrix::new(output, ncols).bit_reverse_rows()\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":36,"address":[],"length":0,"stats":{"Line":14699749183737298944}},{"line":37,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":71,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":72,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":73,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":74,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":76,"address":[],"length":0,"stats":{"Line":5044031582654955520}},{"line":77,"address":[],"length":0,"stats":{"Line":6773413839565225984}},{"line":82,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":87,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":88,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":89,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":90,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":92,"address":[],"length":0,"stats":{"Line":4899916394579099648}},{"line":93,"address":[],"length":0,"stats":{"Line":6052837899185946624}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":115,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":116,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":117,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":118,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":119,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":122,"address":[],"length":0,"stats":{"Line":2449958197289550012}},{"line":124,"address":[],"length":0,"stats":{"Line":9943947977234055262}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":4467570830351532032}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":4323455642275676160}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":258,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":259,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":260,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":296,"address":[],"length":0,"stats":{"Line":0}}],"covered":43,"coverable":103},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","extension.rs"],"content":"use p3_field::extension::{BinomiallyExtendable, HasTwoAdicBinomialExtension};\r\nuse p3_field::{field_to_array, TwoAdicField};\r\n\r\nuse crate::{BinomialExtensionData, FieldParameters, MontyField31, TwoAdicData};\r\n\r\n// If a field implements BinomialExtensionData\u003cWIDTH\u003e then there is a natural\r\n// field extension of degree WIDTH we can define.\r\n// We perform no checks to make sure the data given in BinomialExtensionData\u003cWIDTH\u003e is valid and\r\n// corresponds to an actual field extension. Ensuring that is left to the implementor.\r\n\r\nimpl\u003cconst WIDTH: usize, FP\u003e BinomiallyExtendable\u003cWIDTH\u003e for MontyField31\u003cFP\u003e\r\nwhere\r\n    FP: BinomialExtensionData\u003cWIDTH\u003e + FieldParameters,\r\n{\r\n    const W: Self = \u003cFP as BinomialExtensionData\u003cWIDTH\u003e\u003e::W;\r\n\r\n    const DTH_ROOT: Self = \u003cFP as BinomialExtensionData\u003cWIDTH\u003e\u003e::DTH_ROOT;\r\n\r\n    const EXT_GENERATOR: [Self; WIDTH] = FP::EXT_GENERATOR;\r\n}\r\n\r\nimpl\u003cconst WIDTH: usize, FP\u003e HasTwoAdicBinomialExtension\u003cWIDTH\u003e for MontyField31\u003cFP\u003e\r\nwhere\r\n    FP: BinomialExtensionData\u003cWIDTH\u003e + TwoAdicData + FieldParameters,\r\n{\r\n    const EXT_TWO_ADICITY: usize = \u003cFP as BinomialExtensionData\u003cWIDTH\u003e\u003e::EXT_TWO_ADICITY;\r\n\r\n    fn ext_two_adic_generator(bits: usize) -\u003e [Self; WIDTH] {\r\n        assert!(bits \u003c= Self::EXT_TWO_ADICITY);\r\n        if bits \u003c= FP::TWO_ADICITY {\r\n            field_to_array(Self::two_adic_generator(bits))\r\n        } else {\r\n            FP::TWO_ADIC_EXTENSION_GENERATORS.as_ref()[bits - FP::TWO_ADICITY - 1]\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":13114482114902884355}},{"line":29,"address":[],"length":0,"stats":{"Line":13114482114902884355}},{"line":30,"address":[],"length":0,"stats":{"Line":13114482114902884379}},{"line":31,"address":[],"length":0,"stats":{"Line":12682136550675316763}},{"line":33,"address":[],"length":0,"stats":{"Line":432345564227567616}}],"covered":5,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","lib.rs"],"content":"#![no_std]\r\n#![cfg_attr(\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n    feature(stdarch_x86_avx512)\r\n)]\r\n\r\nextern crate alloc;\r\n\r\nmod data_traits;\r\npub mod dft;\r\nmod extension;\r\nmod mds;\r\nmod monty_31;\r\nmod poseidon2;\r\nmod utils;\r\npub use data_traits::*;\r\npub use mds::*;\r\npub use monty_31::*;\r\npub use poseidon2::*;\r\n\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\nmod aarch64_neon;\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub use aarch64_neon::*;\r\n\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\nmod x86_64_avx2;\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub use x86_64_avx2::*;\r\n\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\nmod x86_64_avx512;\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub use x86_64_avx512::*;\r\n\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(target_arch = \"x86_64\", target_feature = \"avx2\",),\r\n)))]\r\nmod no_packing;\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(target_arch = \"x86_64\", target_feature = \"avx2\",),\r\n)))]\r\npub use no_packing::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","mds.rs"],"content":"use core::marker::PhantomData;\r\n\r\nuse p3_mds::karatsuba_convolution::Convolve;\r\nuse p3_mds::util::dot_product;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\n\r\nuse crate::{BarrettParameters, MontyField31, MontyParameters};\r\n\r\n/// A collection of circulant MDS matrices saved using their left most column.\r\npub trait MDSUtils: Clone + Sync {\r\n    const MATRIX_CIRC_MDS_8_COL: [i64; 8];\r\n    const MATRIX_CIRC_MDS_12_COL: [i64; 12];\r\n    const MATRIX_CIRC_MDS_16_COL: [i64; 16];\r\n    const MATRIX_CIRC_MDS_24_COL: [i64; 24];\r\n    const MATRIX_CIRC_MDS_32_COL: [i64; 32];\r\n    const MATRIX_CIRC_MDS_64_COL: [i64; 64];\r\n}\r\n\r\n#[derive(Clone, Debug, Default)]\r\npub struct MdsMatrixMontyField31\u003cMU: MDSUtils\u003e {\r\n    _phantom: PhantomData\u003cMU\u003e,\r\n}\r\n\r\n/// Instantiate convolution for \"small\" RHS vectors over a 31-bit MONTY_FIELD.\r\n///\r\n/// Here \"small\" means N = len(rhs) \u003c= 16 and sum(r for r in rhs) \u003c\r\n/// 2^24 (roughly), though in practice the sum will be less than 2^9.\r\nstruct SmallConvolveMontyField31;\r\n\r\nimpl\u003cFP: MontyParameters\u003e Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e for SmallConvolveMontyField31 {\r\n    /// Return the lift of a Monty31 element, satisfying 0 \u003c=\r\n    /// input.value \u003c P \u003c 2^31. Note that Monty31 elements are\r\n    /// represented in Monty form.\r\n    #[inline(always)]\r\n    fn read(input: MontyField31\u003cFP\u003e) -\u003e i64 {\r\n        input.value as i64\r\n    }\r\n\r\n    /// For a convolution of size N, |x| \u003c N * 2^31 and (as per the\r\n    /// assumption above), |y| \u003c 2^24. So the product is at most N * 2^55\r\n    /// which will not overflow for N \u003c= 16.\r\n    ///\r\n    /// Note that the LHS element is in Monty form, while the RHS\r\n    /// element is a \"plain integer\". This informs the implementation\r\n    /// of `reduce()` below.\r\n    #[inline(always)]\r\n    fn parity_dot\u003cconst N: usize\u003e(u: [i64; N], v: [i64; N]) -\u003e i64 {\r\n        dot_product(u, v)\r\n    }\r\n\r\n    /// The assumptions above mean z \u003c N^2 * 2^55, which is at most\r\n    /// 2^63 when N \u003c= 16.\r\n    ///\r\n    /// Because the LHS elements were in Monty form and the RHS\r\n    /// elements were plain integers, reduction is simply the usual\r\n    /// reduction modulo P, rather than \"Monty reduction\".\r\n    ///\r\n    /// NB: Even though intermediate values could be negative, the\r\n    /// output must be non-negative since the inputs were\r\n    /// non-negative.\r\n    #[inline(always)]\r\n    fn reduce(z: i64) -\u003e MontyField31\u003cFP\u003e {\r\n        debug_assert!(z \u003e= 0);\r\n\r\n        MontyField31::new_monty((z as u64 % FP::PRIME as u64) as u32)\r\n    }\r\n}\r\n\r\n/// Given |x| \u003c 2^80 compute x' such that:\r\n/// |x'| \u003c 2**50\r\n/// x' = x mod p\r\n/// x' = x mod 2^10\r\n/// See Thm 1 (Below function) for a proof that this function is correct.\r\n#[inline(always)]\r\nfn barrett_red_monty31\u003cBP: BarrettParameters\u003e(input: i128) -\u003e i64 {\r\n    // input = input_low + beta*input_high\r\n    // So input_high \u003c 2**63 and fits in an i64.\r\n    let input_high = (input \u003e\u003e BP::N) as i64; // input_high \u003c input / beta \u003c 2**{80 - N}\r\n\r\n    // I, input_high are i64's so this multiplication can't overflow.\r\n    let quot = (((input_high as i128) * (BP::PSEUDO_INV as i128)) \u003e\u003e BP::N) as i64;\r\n\r\n    // Replace quot by a close value which is divisible by 2^10.\r\n    let quot_2adic = quot \u0026 BP::MASK;\r\n\r\n    // quot_2adic, P are i64's so this can't overflow.\r\n    // sub is by construction divisible by both P and 2^10.\r\n    let sub = (quot_2adic as i128) * BP::PRIME_I128;\r\n\r\n    (input - sub) as i64\r\n}\r\n\r\n// Theorem 1:\r\n// Given |x| \u003c 2^80, barrett_red(x) computes an x' such that:\r\n//       x' = x mod p\r\n//       x' = x mod 2^10\r\n//       |x'| \u003c 2**50.\r\n///////////////////////////////////////////////////////////////////////////////////////\r\n// PROOF:\r\n// By construction P, 2**10 | sub and so we immediately see that\r\n// x' = x mod p\r\n// x' = x mod 2^10.\r\n//\r\n// It remains to prove that |x'| \u003c 2**50.\r\n//\r\n// We start by introducing some simple inequalities and relations between our variables:\r\n//\r\n// First consider the relationship between bit-shift and division.\r\n// It's easy to check that for all x:\r\n// 1: (x \u003e\u003e N) \u003c= x / 2**N \u003c= 1 + (x \u003e\u003e N)\r\n//\r\n// Similarly, as our mask just 0's the last 10 bits,\r\n// 2: x + 1 - 2^10 \u003c= x \u0026 mask \u003c= x\r\n//\r\n// Now if x, y are positive integers then\r\n// (x / y) - 1 \u003c= x // y \u003c= x / y\r\n// Where // denotes integer division.\r\n//\r\n// From this last inequality we immediately derive:\r\n// 3: (2**{2N} / P) - 1 \u003c= I \u003c= (2**{2N} / P)\r\n// 3a: 2**{2N} - P \u003c= PI\r\n//\r\n// Finally, note that by definition:\r\n// input = input_high*(2**N) + input_low\r\n// Hence a simple rearrangement gets us\r\n// 4: input_high*(2**N) = input - input_low\r\n//\r\n//\r\n// We now need to split into cases depending on the sign of input.\r\n// Note that if x = 0 then x' = 0 so that case is trivial.\r\n///////////////////////////////////////////////////////////////////////////\r\n// CASE 1: input \u003e 0\r\n//\r\n// If input \u003e 0 then:\r\n// sub = Q*P = ((((input \u003e\u003e N) * I) \u003e\u003e N) \u0026 mask) * P \u003c= P * (input / 2**{N}) * (2**{2N} / P) / 2**{N} = input\r\n// So input - sub \u003e= 0.\r\n//\r\n// We need to improve our bound on Q. Observe that:\r\n// Q = (((input_high * I) \u003e\u003e N) \u0026 mask)\r\n// --(2)   =\u003e Q + (2^10 - 1) \u003e= (input_high * I) \u003e\u003e N)\r\n// --(1)   =\u003e Q + 2^10 \u003e= (I*x_high)/(2**N)\r\n//         =\u003e (2**N)*Q + 2^10*(2**N) \u003e= I*x_high\r\n//\r\n// Hence we find that:\r\n// (2**N)*Q*P + 2^10*(2**N)*P \u003e= input_high*I*P\r\n// --(3a)                     \u003e= input_high*2**{2N} - P*input_high\r\n// --(4)                      \u003e= (2**N)*input - (2**N)*input_low - (2**N)*input_high   (Assuming P \u003c 2**N)\r\n//\r\n// Dividing by 2**N we get\r\n// Q*P + 2^{10}*P \u003e= input - input_low - input_high\r\n// which rearranges to\r\n// x' = input - Q*P \u003c= 2^{10}*P + input_low + input_high\r\n//\r\n// Picking N = 40 we see that 2^{10}*P, input_low, input_high are all bounded by 2**40\r\n// Hence x' \u003c 2**42 \u003c 2**50 as desired.\r\n//\r\n//\r\n//\r\n///////////////////////////////////////////////////////////////////////////\r\n// CASE 2: input \u003c 0\r\n//\r\n// This case will be similar but all our inequalities will change slightly as negatives complicate things.\r\n// First observe that:\r\n// (input \u003e\u003e N) * I   \u003e= (input \u003e\u003e N) * 2**(2N) / P\r\n//                    \u003e= (1 + (input / 2**N)) * 2**(2N) / P\r\n//                    \u003e= (2**N + input) * 2**N / P\r\n//\r\n// Thus:\r\n// Q = ((input \u003e\u003e N) * I) \u003e\u003e N \u003e= ((2**N + input) * 2**N / P) \u003e\u003e N\r\n//                             \u003e= ((2**N + input) / P) - 1\r\n//\r\n// And so sub = Q*P \u003e= 2**N - P + input.\r\n// Hence input - sub \u003c 2**N - P.\r\n//\r\n// Thus if input - sub \u003e 0 then |input - sub| \u003c 2**50.\r\n// Thus we are left with bounding -(input - sub) = (sub - input).\r\n// Again we will proceed by improving our bound on Q.\r\n//\r\n// Q = (((input_high * I) \u003e\u003e N) \u0026 mask)\r\n// --(2)   =\u003e Q \u003c= (input_high * I) \u003e\u003e N) \u003c= (I*x_high)/(2**N)\r\n// --(1)   =\u003e Q \u003c= (I*x_high)/(2**N)\r\n//         =\u003e (2**N)*Q \u003c= I*x_high\r\n//\r\n// Hence we find that:\r\n// (2**N)*Q*P \u003c= input_high*I*P\r\n// --(3a)     \u003c= input_high*2**{2N} - P*input_high\r\n// --(4)      \u003c= (2**N)*input - (2**N)*input_low - (2**N)*input_high   (Assuming P \u003c 2**N)\r\n//\r\n// Dividing by 2**N we get\r\n// Q*P \u003c= input - input_low - input_high\r\n// which rearranges to\r\n// -x' = -input + Q*P \u003c= -input_high - input_low \u003c 2**50\r\n//\r\n// This completes the proof.\r\n\r\n/// Instantiate convolution for \"large\" RHS vectors over BabyBear.\r\n///\r\n/// Here \"large\" means the elements can be as big as the field\r\n/// characteristic, and the size N of the RHS is \u003c= 64.\r\n#[derive(Debug, Clone, Default)]\r\nstruct LargeConvolveMontyField31;\r\n\r\nimpl\u003cFP\u003e Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e for LargeConvolveMontyField31\r\nwhere\r\n    FP: BarrettParameters,\r\n{\r\n    /// Return the lift of a MontyField31 element, satisfying\r\n    /// 0 \u003c= input.value \u003c P \u003c 2^31.\r\n    /// Note that MontyField31 elements are represented in Monty form.\r\n    #[inline(always)]\r\n    fn read(input: MontyField31\u003cFP\u003e) -\u003e i64 {\r\n        input.value as i64\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn parity_dot\u003cconst N: usize\u003e(u: [i64; N], v: [i64; N]) -\u003e i64 {\r\n        // For a convolution of size N, |x|, |y| \u003c N * 2^31, so the\r\n        // product could be as much as N^2 * 2^62. This will overflow an\r\n        // i64, so we first widen to i128. Note that N^2 * 2^62 \u003c 2^80\r\n        // for N \u003c= 64, as required by `barrett_red_monty31()`.\r\n\r\n        let mut dp = 0i128;\r\n        for i in 0..N {\r\n            dp += u[i] as i128 * v[i] as i128;\r\n        }\r\n        barrett_red_monty31::\u003cFP\u003e(dp)\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn reduce(z: i64) -\u003e MontyField31\u003cFP\u003e {\r\n        // After the barrett reduction method, the output z of parity\r\n        // dot satisfies |z| \u003c 2^50 (See Thm 1 above).\r\n        //\r\n        // In the recombining steps, conv_n maps (wo, w1) -\u003e\r\n        // ((wo + w1)/2, (wo + w1)/2) which has no effect on the maximal\r\n        // size. (Indeed, it makes sizes almost strictly smaller).\r\n        //\r\n        // On the other hand, negacyclic_conv_n (ignoring the re-index)\r\n        // recombines as: (w0, w1, w2) -\u003e (w0 + w1, w2 - w0 - w1).\r\n        // Hence if the input is \u003c= K, the output is \u003c= 3K.\r\n        //\r\n        // Thus the values appearing at the end are bounded by 3^n 2^50\r\n        // where n is the maximal number of negacyclic_conv\r\n        // recombination steps. When N = 64, we need to recombine for\r\n        // signed_conv_32, signed_conv_16, signed_conv_8 so the\r\n        // overall bound will be 3^3 2^50 \u003c 32 * 2^50 \u003c 2^55.\r\n        debug_assert!(z \u003e -(1i64 \u003c\u003c 55));\r\n        debug_assert!(z \u003c (1i64 \u003c\u003c 55));\r\n\r\n        // Note we do NOT move it into MONTY form. We assume it is already\r\n        // in this form.\r\n        let red = (z % (FP::PRIME as i64)) as u32;\r\n\r\n        // If z \u003e= 0: 0 \u003c= red \u003c P is the correct value and P + red will\r\n        // not overflow.\r\n        // If z \u003c 0: -P \u003c red \u003c 0 and the value we want is P + red.\r\n        // On bits, + acts identically for i32 and u32. Hence we can use\r\n        // u32's and just check for overflow.\r\n\r\n        let (corr, over) = red.overflowing_add(FP::PRIME);\r\n        let value = if over { corr } else { red };\r\n        MontyField31::new_monty(value)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 8]\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 8]) -\u003e [MontyField31\u003cFP\u003e; 8] {\r\n        SmallConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_8_COL,\r\n            \u003cSmallConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv8,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 8]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 8\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 12]\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 12]) -\u003e [MontyField31\u003cFP\u003e; 12] {\r\n        SmallConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_12_COL,\r\n            \u003cSmallConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv12,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 12]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 12\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 16]\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 16]) -\u003e [MontyField31\u003cFP\u003e; 16] {\r\n        SmallConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_16_COL,\r\n            \u003cSmallConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv16,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 16]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: MontyParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 16\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 24]\u003e for MdsMatrixMontyField31\u003cMU\u003e\r\nwhere\r\n    FP: BarrettParameters,\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 24]) -\u003e [MontyField31\u003cFP\u003e; 24] {\r\n        LargeConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_24_COL,\r\n            \u003cLargeConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv24,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 24]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: BarrettParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 24\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: BarrettParameters, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 32]\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 32]) -\u003e [MontyField31\u003cFP\u003e; 32] {\r\n        LargeConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_32_COL,\r\n            \u003cLargeConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv32,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 32]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: BarrettParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 32\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: BarrettParameters, MU: MDSUtils\u003e Permutation\u003c[MontyField31\u003cFP\u003e; 64]\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n    fn permute(\u0026self, input: [MontyField31\u003cFP\u003e; 64]) -\u003e [MontyField31\u003cFP\u003e; 64] {\r\n        LargeConvolveMontyField31::apply(\r\n            input,\r\n            MU::MATRIX_CIRC_MDS_64_COL,\r\n            \u003cLargeConvolveMontyField31 as Convolve\u003cMontyField31\u003cFP\u003e, i64, i64, i64\u003e\u003e::conv64,\r\n        )\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut [MontyField31\u003cFP\u003e; 64]) {\r\n        *input = self.permute(*input);\r\n    }\r\n}\r\nimpl\u003cFP: BarrettParameters, MU: MDSUtils\u003e MdsPermutation\u003cMontyField31\u003cFP\u003e, 64\u003e\r\n    for MdsMatrixMontyField31\u003cMU\u003e\r\n{\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":37,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":48,"address":[],"length":0,"stats":{"Line":3098476543630901249}},{"line":49,"address":[],"length":0,"stats":{"Line":3098476543630901249}},{"line":63,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":64,"address":[],"length":0,"stats":{"Line":5188146770730811392}},{"line":66,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":76,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":79,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":82,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":85,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":89,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":91,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":212,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":213,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":217,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":223,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":224,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":225,"address":[],"length":0,"stats":{"Line":15996785876420001792}},{"line":227,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":231,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":248,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":249,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":253,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":261,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":262,"address":[],"length":0,"stats":{"Line":8646911284551352320}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":272,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":273,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":274,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":292,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":312,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":313,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":314,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":333,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":334,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":335,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":353,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":354,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":355,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":373,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":374,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":375,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}}],"covered":50,"coverable":63},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","monty_31.rs"],"content":"//! An abstraction of 31-bit fields which use a MONTY approach for faster multiplication.\r\n\r\nuse alloc::vec;\r\nuse alloc::vec::Vec;\r\nuse core::fmt::{self, Debug, Display, Formatter};\r\nuse core::hash::Hash;\r\nuse core::intrinsics::transmute;\r\nuse core::iter::{Product, Sum};\r\nuse core::marker::PhantomData;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse num_bigint::BigUint;\r\nuse p3_field::integers::QuotientMap;\r\nuse p3_field::{\r\n    quotient_map_small_int, Field, InjectiveMonomial, Packable, PermutationMonomial,\r\n    PrimeCharacteristicRing, PrimeField, PrimeField32, PrimeField64, TwoAdicField,\r\n};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\nuse serde::{Deserialize, Deserializer, Serialize};\r\n\r\nuse crate::utils::{\r\n    from_monty, halve_u32, monty_reduce, to_monty, to_monty_64, to_monty_64_signed, to_monty_signed,\r\n};\r\nuse crate::{FieldParameters, MontyParameters, RelativelyPrimePower, TwoAdicData};\r\n\r\n#[derive(Clone, Copy, Default, Eq, Hash, PartialEq)]\r\n#[repr(transparent)] // Packed field implementations rely on this!\r\npub struct MontyField31\u003cMP: MontyParameters\u003e {\r\n    /// The MONTY form of the field element, saved as a positive integer less than `P`.\r\n    ///\r\n    /// This is `pub(crate)` for tests and delayed reduction strategies. If you're accessing `value` outside of those, you're\r\n    /// likely doing something fishy.\r\n    pub(crate) value: u32,\r\n    _phantom: PhantomData\u003cMP\u003e,\r\n}\r\n\r\nimpl\u003cMP: MontyParameters\u003e MontyField31\u003cMP\u003e {\r\n    // The standard way to crate a new element.\r\n    // Note that new converts the input into MONTY form so should be avoided in performance critical implementations.\r\n    #[inline(always)]\r\n    pub const fn new(value: u32) -\u003e Self {\r\n        Self {\r\n            value: to_monty::\u003cMP\u003e(value),\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    // Create a new field element from something already in MONTY form.\r\n    // This is `pub(crate)` for tests and delayed reduction strategies. If you're using it outside of those, you're\r\n    // likely doing something fishy.\r\n    #[inline(always)]\r\n    pub(crate) const fn new_monty(value: u32) -\u003e Self {\r\n        Self {\r\n            value,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    /// Produce a u32 in range [0, P) from a field element corresponding to the true value.\r\n    #[inline(always)]\r\n    pub(crate) fn to_u32(elem: \u0026Self) -\u003e u32 {\r\n        from_monty::\u003cMP\u003e(elem.value)\r\n    }\r\n\r\n    /// Convert a constant u32 array into a constant array of field elements.\r\n    /// Constant version of array.map(MontyField31::new).\r\n    #[inline]\r\n    pub const fn new_array\u003cconst N: usize\u003e(input: [u32; N]) -\u003e [Self; N] {\r\n        let mut output = [MontyField31::new_monty(0); N];\r\n        let mut i = 0;\r\n        loop {\r\n            if i == N {\r\n                break;\r\n            }\r\n            output[i] = MontyField31::new(input[i]);\r\n            i += 1;\r\n        }\r\n        output\r\n    }\r\n\r\n    /// Convert a constant 2d u32 array into a constant 2d array of field elements.\r\n    /// Constant version of array.map(MontyField31::new_array).\r\n    #[inline]\r\n    pub const fn new_2d_array\u003cconst N: usize, const M: usize\u003e(\r\n        input: [[u32; N]; M],\r\n    ) -\u003e [[Self; N]; M] {\r\n        let mut output = [[MontyField31::new_monty(0); N]; M];\r\n        let mut i = 0;\r\n        loop {\r\n            if i == M {\r\n                break;\r\n            }\r\n            output[i] = MontyField31::new_array(input[i]);\r\n            i += 1;\r\n        }\r\n        output\r\n    }\r\n\r\n    /// Multiply the given MontyField31 element by `2^{-n}`.\r\n    ///\r\n    /// This makes use of the fact that, as the monty constant is `2^32`,\r\n    /// the monty form of `2^{-n}` is `2^{32 - n}`. Monty reduction works\r\n    /// provided the input is `\u003c 2^32P` so this works for `0 \u003c= n \u003c= 32`.\r\n    #[inline]\r\n    #[must_use]\r\n    pub const fn mul_2exp_neg_n(\u0026self, n: u32) -\u003e Self {\r\n        assert!(n \u003c 33);\r\n        let value_mul_2exp_neg_n = (self.value as u64) \u003c\u003c (32 - n);\r\n        MontyField31::new_monty(monty_reduce::\u003cMP\u003e(value_mul_2exp_neg_n))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Ord for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e core::cmp::Ordering {\r\n        MontyField31::to_u32(self).cmp(\u0026MontyField31::to_u32(other))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e PartialOrd for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccore::cmp::Ordering\u003e {\r\n        Some(self.cmp(other))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Display for MontyField31\u003cFP\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Display::fmt(\u0026MontyField31::to_u32(self), f)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Debug for MontyField31\u003cFP\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\r\n        Debug::fmt(\u0026MontyField31::to_u32(self), f)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Distribution\u003cMontyField31\u003cFP\u003e\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e MontyField31\u003cFP\u003e {\r\n        loop {\r\n            let next_u31 = rng.next_u32() \u003e\u003e 1;\r\n            let is_canonical = next_u31 \u003c FP::PRIME;\r\n            if is_canonical {\r\n                return MontyField31::new_monty(next_u31);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Serialize for MontyField31\u003cFP\u003e {\r\n    fn serialize\u003cS: serde::Serializer\u003e(\u0026self, serializer: S) -\u003e Result\u003cS::Ok, S::Error\u003e {\r\n        // It's faster to Serialize and Deserialize in monty form.\r\n        serializer.serialize_u32(self.value)\r\n    }\r\n}\r\n\r\nimpl\u003c'de, FP: FieldParameters\u003e Deserialize\u003c'de\u003e for MontyField31\u003cFP\u003e {\r\n    fn deserialize\u003cD: Deserializer\u003c'de\u003e\u003e(d: D) -\u003e Result\u003cSelf, D::Error\u003e {\r\n        // It's faster to Serialize and Deserialize in monty form.\r\n        let val = u32::deserialize(d)?;\r\n        Ok(MontyField31::new_monty(val))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Packable for MontyField31\u003cFP\u003e {}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeCharacteristicRing for MontyField31\u003cFP\u003e {\r\n    type PrimeSubfield = Self;\r\n\r\n    const ZERO: Self = FP::MONTY_ZERO;\r\n    const ONE: Self = FP::MONTY_ONE;\r\n    const TWO: Self = FP::MONTY_TWO;\r\n    const NEG_ONE: Self = FP::MONTY_NEG_ONE;\r\n\r\n    #[inline(always)]\r\n    fn from_prime_subfield(f: Self) -\u003e Self {\r\n        f\r\n    }\r\n\r\n    #[inline]\r\n    fn mul_2exp_u64(\u0026self, exp: u64) -\u003e Self {\r\n        let product = (self.value as u64) \u003c\u003c exp;\r\n        let value = (product % (FP::PRIME as u64)) as u32;\r\n        Self::new_monty(value)\r\n    }\r\n\r\n    #[inline]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: repr(transparent) ensures transmutation safety.\r\n        unsafe { transmute(vec![0u32; len]) }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e InjectiveMonomial\u003cD\u003e\r\n    for MontyField31\u003cFP\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e PermutationMonomial\u003cD\u003e\r\n    for MontyField31\u003cFP\u003e\r\n{\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        FP::exp_root_d(*self)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Field for MontyField31\u003cFP\u003e {\r\n    #[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\n    type Packing = crate::PackedMontyField31Neon\u003cFP\u003e;\r\n    #[cfg(all(\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx2\",\r\n        not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n    ))]\r\n    type Packing = crate::PackedMontyField31AVX2\u003cFP\u003e;\r\n    #[cfg(all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ))]\r\n    type Packing = crate::PackedMontyField31AVX512\u003cFP\u003e;\r\n    #[cfg(not(any(\r\n        all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n        all(\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx2\",\r\n            not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n        ),\r\n        all(\r\n            feature = \"nightly-features\",\r\n            target_arch = \"x86_64\",\r\n            target_feature = \"avx512f\"\r\n        ),\r\n    )))]\r\n    type Packing = Self;\r\n\r\n    const GENERATOR: Self = FP::MONTY_GEN;\r\n\r\n    fn try_inverse(\u0026self) -\u003e Option\u003cSelf\u003e {\r\n        FP::try_inverse(*self)\r\n    }\r\n\r\n    #[inline]\r\n    fn halve(\u0026self) -\u003e Self {\r\n        Self::new_monty(halve_u32::\u003cFP\u003e(self.value))\r\n    }\r\n\r\n    #[inline]\r\n    fn order() -\u003e BigUint {\r\n        FP::PRIME.into()\r\n    }\r\n}\r\n\r\nquotient_map_small_int!(MontyField31, u32, FieldParameters, [u8, u16]);\r\nquotient_map_small_int!(MontyField31, i32, FieldParameters, [i8, i16]);\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003cu32\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `u32` integer into an element of the `MontyField31` field.\r\n    #[inline]\r\n    fn from_int(int: u32) -\u003e Self {\r\n        Self::new(int)\r\n    }\r\n\r\n    /// Convert a given `u32` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer is greater than the Prime.\r\n    #[inline]\r\n    fn from_canonical_checked(int: u32) -\u003e Option\u003cSelf\u003e {\r\n        if int \u003c FP::PRIME {\r\n            Some(Self::new(int))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `u32` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// This is always safe as the conversion to monty form can accept any `u32`.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: u32) -\u003e Self {\r\n        Self::new(int)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003ci32\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `i32` integer into an element of the `MontyField31` field.\r\n    #[inline]\r\n    fn from_int(int: i32) -\u003e Self {\r\n        Self::new_monty(to_monty_signed::\u003cFP\u003e(int))\r\n    }\r\n\r\n    /// Convert a given `i32` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer does not lie in the range `[(1 - P)/2, (P - 1)/2]`.\r\n    #[inline]\r\n    fn from_canonical_checked(int: i32) -\u003e Option\u003cSelf\u003e {\r\n        let bound = (FP::PRIME \u003e\u003e 1) as i32;\r\n        if int \u003c= bound {\r\n            if int \u003e= (-bound) {\r\n                Some(Self::new_monty(to_monty_signed::\u003cFP\u003e(int)))\r\n            } else {\r\n                None\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i32` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// This is always safe as the conversion to monty form can accept any `i32`.\r\n    #[inline(always)]\r\n    unsafe fn from_canonical_unchecked(int: i32) -\u003e Self {\r\n        Self::new_monty(to_monty_signed::\u003cFP\u003e(int))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003cu64\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `u64` integer into an element of the `MontyField31` field.\r\n    fn from_int(int: u64) -\u003e Self {\r\n        Self::new_monty(to_monty_64::\u003cFP\u003e(int))\r\n    }\r\n\r\n    /// Convert a given `u64` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer is greater than the Prime.\r\n    fn from_canonical_checked(int: u64) -\u003e Option\u003cSelf\u003e {\r\n        if int \u003c FP::PRIME as u64 {\r\n            Some(Self::new(int as u32))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `u64` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// This is always safe as the conversion to monty form can accept any `u64`.\r\n    unsafe fn from_canonical_unchecked(int: u64) -\u003e Self {\r\n        Self::new_monty(to_monty_64::\u003cFP\u003e(int))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003ci64\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `i64` integer into an element of the `MontyField31` field.\r\n    fn from_int(int: i64) -\u003e Self {\r\n        Self::new_monty(to_monty_64_signed::\u003cFP\u003e(int))\r\n    }\r\n\r\n    /// Convert a given `i64` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer does not lie in the range `[(1 - P)/2, (P - 1)/2]`.\r\n    fn from_canonical_checked(int: i64) -\u003e Option\u003cSelf\u003e {\r\n        let bound = (FP::PRIME \u003e\u003e 1) as i64;\r\n        if int \u003c= bound {\r\n            if int \u003e= (-bound) {\r\n                Some(Self::new_monty(to_monty_signed::\u003cFP\u003e(int as i32)))\r\n            } else {\r\n                None\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i64` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// This is always safe as the conversion to monty form can accept any `i64`.\r\n    unsafe fn from_canonical_unchecked(int: i64) -\u003e Self {\r\n        Self::new_monty(to_monty_64_signed::\u003cFP\u003e(int))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003cu128\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `u128` integer into an element of the `MontyField31` field.\r\n    fn from_int(int: u128) -\u003e Self {\r\n        Self::new_monty(to_monty::\u003cFP\u003e((int % (FP::PRIME as u128)) as u32))\r\n    }\r\n\r\n    /// Convert a given `u128` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer is greater than the Prime.\r\n    fn from_canonical_checked(int: u128) -\u003e Option\u003cSelf\u003e {\r\n        if int \u003c FP::PRIME as u128 {\r\n            Some(Self::new(int as u32))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `u128` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// The input must be a valid `u64` element.\r\n    unsafe fn from_canonical_unchecked(int: u128) -\u003e Self {\r\n        Self::new_monty(to_monty_64::\u003cFP\u003e(int as u64))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e QuotientMap\u003ci128\u003e for MontyField31\u003cFP\u003e {\r\n    /// Convert a given `i128` integer into an element of the `MontyField31` field.\r\n    fn from_int(int: i128) -\u003e Self {\r\n        Self::new_monty(to_monty_signed::\u003cFP\u003e((int % (FP::PRIME as i128)) as i32))\r\n    }\r\n\r\n    /// Convert a given `i128` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// Returns `None` if the given integer does not lie in the range `[(1 - P)/2, (P - 1)/2]`.\r\n    fn from_canonical_checked(int: i128) -\u003e Option\u003cSelf\u003e {\r\n        let bound = (FP::PRIME \u003e\u003e 1) as i128;\r\n        if int \u003c= bound {\r\n            if int \u003e= (-bound) {\r\n                Some(Self::new_monty(to_monty_signed::\u003cFP\u003e(int as i32)))\r\n            } else {\r\n                None\r\n            }\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    /// Convert a given `i128` integer into an element of the `MontyField31` field.\r\n    ///\r\n    /// # Safety\r\n    /// The input must be a valid `i64` element.\r\n    unsafe fn from_canonical_unchecked(int: i128) -\u003e Self {\r\n        Self::new_monty(to_monty_64_signed::\u003cFP\u003e(int as i64))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeField for MontyField31\u003cFP\u003e {\r\n    fn as_canonical_biguint(\u0026self) -\u003e BigUint {\r\n        \u003cSelf as PrimeField32\u003e::as_canonical_u32(self).into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeField64 for MontyField31\u003cFP\u003e {\r\n    const ORDER_U64: u64 = FP::PRIME as u64;\r\n\r\n    #[inline]\r\n    fn as_canonical_u64(\u0026self) -\u003e u64 {\r\n        self.as_canonical_u32().into()\r\n    }\r\n\r\n    #[inline]\r\n    fn to_unique_u64(\u0026self) -\u003e u64 {\r\n        // The internal representation is already a unique u32 for each field element.\r\n        // It's fine to hash things in monty form.\r\n        self.value as u64\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeField32 for MontyField31\u003cFP\u003e {\r\n    const ORDER_U32: u32 = FP::PRIME;\r\n\r\n    #[inline]\r\n    fn as_canonical_u32(\u0026self) -\u003e u32 {\r\n        MontyField31::to_u32(self)\r\n    }\r\n\r\n    #[inline]\r\n    fn to_unique_u32(\u0026self) -\u003e u32 {\r\n        // The internal representation is already a unique u32 for each field element.\r\n        // It's fine to hash things in monty form.\r\n        self.value\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + TwoAdicData\u003e TwoAdicField for MontyField31\u003cFP\u003e {\r\n    const TWO_ADICITY: usize = FP::TWO_ADICITY;\r\n    fn two_adic_generator(bits: usize) -\u003e Self {\r\n        assert!(bits \u003c= Self::TWO_ADICITY);\r\n        FP::TWO_ADIC_GENERATORS.as_ref()[bits]\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Add for MontyField31\u003cFP\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let mut sum = self.value + rhs.value;\r\n        let (corr_sum, over) = sum.overflowing_sub(FP::PRIME);\r\n        if !over {\r\n            sum = corr_sum;\r\n        }\r\n        Self::new_monty(sum)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e AddAssign for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Sum for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        // This is faster than iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO) for iterators of length \u003e 2.\r\n        // There might be a faster reduction method possible for lengths \u003c= 16 which avoids %.\r\n\r\n        // This sum will not overflow so long as iter.len() \u003c 2^33.\r\n        let sum = iter.map(|x| x.value as u64).sum::\u003cu64\u003e();\r\n        Self::new_monty((sum % FP::PRIME as u64) as u32)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Sub for MontyField31\u003cFP\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let (mut diff, over) = self.value.overflowing_sub(rhs.value);\r\n        let corr = if over { FP::PRIME } else { 0 };\r\n        diff = diff.wrapping_add(corr);\r\n        Self::new_monty(diff)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e SubAssign for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Neg for MontyField31\u003cFP\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn neg(self) -\u003e Self::Output {\r\n        Self::ZERO - self\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e Mul for MontyField31\u003cFP\u003e {\r\n    type Output = Self;\r\n\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let long_prod = self.value as u64 * rhs.value as u64;\r\n        Self::new_monty(monty_reduce::\u003cFP\u003e(long_prod))\r\n    }\r\n}\r\n\r\nimpl\u003cFP: MontyParameters\u003e MulAssign for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product for MontyField31\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI: Iterator\u003cItem = Self\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Div for MontyField31\u003cFP\u003e {\r\n    type Output = Self;\r\n\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: Self) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":720575940379286274}},{"line":44,"address":[],"length":0,"stats":{"Line":720575940379286274}},{"line":53,"address":[],"length":0,"stats":{"Line":10232178353385774789}},{"line":62,"address":[],"length":0,"stats":{"Line":14771806777775227005}},{"line":63,"address":[],"length":0,"stats":{"Line":14771806777775227005}},{"line":69,"address":[],"length":0,"stats":{"Line":1513209474796486663}},{"line":70,"address":[],"length":0,"stats":{"Line":1513209474796486663}},{"line":71,"address":[],"length":0,"stats":{"Line":1513209474796486663}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":6052837899185946630}},{"line":74,"address":[],"length":0,"stats":{"Line":1513209474796486663}},{"line":76,"address":[],"length":0,"stats":{"Line":5764607523034234879}},{"line":77,"address":[],"length":0,"stats":{"Line":5764607523034234879}},{"line":79,"address":[],"length":0,"stats":{"Line":1513209474796486663}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":11745387828182253583}},{"line":108,"address":[],"length":0,"stats":{"Line":11745387828182253583}},{"line":109,"address":[],"length":0,"stats":{"Line":11745387828182275895}},{"line":110,"address":[],"length":0,"stats":{"Line":11745387828182275895}},{"line":116,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":117,"address":[],"length":0,"stats":{"Line":13186539708940812288}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":130,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":135,"address":[],"length":0,"stats":{"Line":144115188075859233}},{"line":136,"address":[],"length":0,"stats":{"Line":144115188075859233}},{"line":142,"address":[],"length":0,"stats":{"Line":216172782113783886}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":18230571291595768902}},{"line":145,"address":[],"length":0,"stats":{"Line":18230571291595768902}},{"line":146,"address":[],"length":0,"stats":{"Line":18230571291595768902}},{"line":147,"address":[],"length":0,"stats":{"Line":216172782113783886}},{"line":154,"address":[],"length":0,"stats":{"Line":11817445422220181761}},{"line":156,"address":[],"length":0,"stats":{"Line":11817445422220181761}},{"line":161,"address":[],"length":0,"stats":{"Line":11817445422220181915}},{"line":163,"address":[],"length":0,"stats":{"Line":5188146770730812214}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":12249790986447749128}},{"line":180,"address":[],"length":0,"stats":{"Line":12249790986447749128}},{"line":184,"address":[],"length":0,"stats":{"Line":15636497906230362116}},{"line":185,"address":[],"length":0,"stats":{"Line":15636497906230362116}},{"line":186,"address":[],"length":0,"stats":{"Line":15636497906230362116}},{"line":187,"address":[],"length":0,"stats":{"Line":15636497906230362116}},{"line":191,"address":[],"length":0,"stats":{"Line":7133701809754865844}},{"line":193,"address":[],"length":0,"stats":{"Line":7133701809754865844}},{"line":205,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":206,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":242,"address":[],"length":0,"stats":{"Line":12970366926827028523}},{"line":243,"address":[],"length":0,"stats":{"Line":12970366926827028523}},{"line":247,"address":[],"length":0,"stats":{"Line":5548434740920803410}},{"line":248,"address":[],"length":0,"stats":{"Line":5548434740920803410}},{"line":252,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":253,"address":[],"length":0,"stats":{"Line":720575940379279360}},{"line":263,"address":[],"length":0,"stats":{"Line":6269010681299730553}},{"line":264,"address":[],"length":0,"stats":{"Line":6269010681299730553}},{"line":271,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":272,"address":[],"length":0,"stats":{"Line":1729382256910270464}},{"line":273,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":275,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":284,"address":[],"length":0,"stats":{"Line":17942340915444056231}},{"line":285,"address":[],"length":0,"stats":{"Line":17942340915444056231}},{"line":292,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":293,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":300,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":301,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":302,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":303,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":304,"address":[],"length":0,"stats":{"Line":2017612633061982208}},{"line":306,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":309,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":318,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":319,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":325,"address":[],"length":0,"stats":{"Line":8863084066665136182}},{"line":326,"address":[],"length":0,"stats":{"Line":8863084066665136182}},{"line":332,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":333,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":334,"address":[],"length":0,"stats":{"Line":2594073385365405696}},{"line":336,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":344,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":345,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":351,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":352,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":358,"address":[],"length":0,"stats":{"Line":5188146770730811394}},{"line":359,"address":[],"length":0,"stats":{"Line":5188146770730811394}},{"line":360,"address":[],"length":0,"stats":{"Line":5188146770730811394}},{"line":361,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":362,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":364,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":367,"address":[],"length":0,"stats":{"Line":576460752303423490}},{"line":375,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":376,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":382,"address":[],"length":0,"stats":{"Line":2161727821137838170}},{"line":383,"address":[],"length":0,"stats":{"Line":2161727821137838170}},{"line":389,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":390,"address":[],"length":0,"stats":{"Line":2449958197289549824}},{"line":391,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":393,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":401,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":402,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":408,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":409,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":415,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":416,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":417,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":418,"address":[],"length":0,"stats":{"Line":2882303761517117440}},{"line":419,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":421,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":424,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":432,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":433,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":448,"address":[],"length":0,"stats":{"Line":5116089176692883456}},{"line":452,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":455,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":463,"address":[],"length":0,"stats":{"Line":6124895493223874619}},{"line":464,"address":[],"length":0,"stats":{"Line":6124895493223874619}},{"line":468,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":471,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":477,"address":[],"length":0,"stats":{"Line":3026418949592973371}},{"line":478,"address":[],"length":0,"stats":{"Line":3026418949592973371}},{"line":479,"address":[],"length":0,"stats":{"Line":3026418949592973356}},{"line":487,"address":[],"length":0,"stats":{"Line":16501189034685503729}},{"line":488,"address":[],"length":0,"stats":{"Line":16501189034685503729}},{"line":489,"address":[],"length":0,"stats":{"Line":16501189034685503729}},{"line":490,"address":[],"length":0,"stats":{"Line":16789419410835869817}},{"line":491,"address":[],"length":0,"stats":{"Line":288230376150366088}},{"line":493,"address":[],"length":0,"stats":{"Line":16501189034685503729}},{"line":499,"address":[],"length":0,"stats":{"Line":5332261958807356555}},{"line":500,"address":[],"length":0,"stats":{"Line":5332261958807356555}},{"line":506,"address":[],"length":0,"stats":{"Line":10448351135499555058}},{"line":511,"address":[],"length":0,"stats":{"Line":1945555039024113163}},{"line":512,"address":[],"length":0,"stats":{"Line":10448351135499555058}},{"line":520,"address":[],"length":0,"stats":{"Line":5260204364769938618}},{"line":521,"address":[],"length":0,"stats":{"Line":5260204364769938618}},{"line":522,"address":[],"length":0,"stats":{"Line":15780613094309815854}},{"line":523,"address":[],"length":0,"stats":{"Line":5260204364769938618}},{"line":524,"address":[],"length":0,"stats":{"Line":5260204364769938618}},{"line":530,"address":[],"length":0,"stats":{"Line":6052837899185946662}},{"line":531,"address":[],"length":0,"stats":{"Line":6052837899185946662}},{"line":539,"address":[],"length":0,"stats":{"Line":1513209474796489401}},{"line":540,"address":[],"length":0,"stats":{"Line":1513209474796489401}},{"line":548,"address":[],"length":0,"stats":{"Line":5908722711110092031}},{"line":549,"address":[],"length":0,"stats":{"Line":5908722711110092031}},{"line":550,"address":[],"length":0,"stats":{"Line":5908722711110092031}},{"line":556,"address":[],"length":0,"stats":{"Line":13690942867207953281}},{"line":557,"address":[],"length":0,"stats":{"Line":13690942867207953281}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":15852670688344499681}},{"line":574,"address":[],"length":0,"stats":{"Line":15852670688344499681}}],"covered":143,"coverable":161},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","no_packing","mod.rs"],"content":"//! A couple of simple functions needed in the case that this is compiled without architecture optimizations available.\r\n\r\nmod poseidon2;\r\n\r\npub use poseidon2::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","no_packing","poseidon2.rs"],"content":"//! These are just simple wrapper structs allowing us to implement Poseidon2 Internal/ExternalLayer on top of them.\r\n//!\r\n//! They are used only in the case that none of the vectorization architectures (AVX2/AVX512/NEON) are available.\r\n\r\nuse alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse p3_poseidon2::{ExternalLayerConstants, ExternalLayerConstructor, InternalLayerConstructor};\r\n\r\nuse crate::{FieldParameters, InternalLayerBaseParameters, MontyField31, MontyParameters};\r\n\r\n/// The internal layers of the Poseidon2 permutation for Monty31 fields.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMonty31\u003c\r\n    MP: MontyParameters,\r\n    const WIDTH: usize,\r\n    ILP: InternalLayerBaseParameters\u003cMP, WIDTH\u003e,\r\n\u003e {\r\n    pub(crate) internal_constants: Vec\u003cMontyField31\u003cMP\u003e\u003e,\r\n    _phantom: PhantomData\u003cILP\u003e,\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Monty31 fields.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2ExternalLayerMonty31\u003cMP: MontyParameters, const WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMontyField31\u003cMP\u003e, WIDTH\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize, ILP: InternalLayerBaseParameters\u003cFP, WIDTH\u003e\u003e\r\n    InternalLayerConstructor\u003cMontyField31\u003cFP\u003e\u003e for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, ILP\u003e\r\n{\r\n    fn new_from_constants(internal_constants: Vec\u003cMontyField31\u003cFP\u003e\u003e) -\u003e Self {\r\n        Self {\r\n            internal_constants,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize\u003e ExternalLayerConstructor\u003cMontyField31\u003cFP\u003e, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\n{\r\n    fn new_from_constants(\r\n        external_constants: ExternalLayerConstants\u003cMontyField31\u003cFP\u003e, WIDTH\u003e,\r\n    ) -\u003e Self {\r\n        Self { external_constants }\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":1},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","poseidon2.rs"],"content":"use core::marker::PhantomData;\r\n\r\nuse p3_field::{Algebra, InjectiveMonomial};\r\nuse p3_poseidon2::{\r\n    add_rc_and_sbox_generic, external_initial_permute_state, external_terminal_permute_state,\r\n    ExternalLayer, GenericPoseidon2LinearLayers, InternalLayer, MDSMat4,\r\n};\r\n\r\nuse crate::{\r\n    FieldParameters, MontyField31, MontyParameters, Poseidon2ExternalLayerMonty31,\r\n    Poseidon2InternalLayerMonty31, RelativelyPrimePower,\r\n};\r\n\r\n/// Trait which handles the Poseidon2 internal layers.\r\n///\r\n/// Everything needed to compute multiplication by a `WIDTH x WIDTH` diffusion matrix whose monty form is `1 + Diag(vec)`.\r\n/// vec is assumed to be of the form `[-2, ...]` with all entries after the first being small powers of `2`.\r\npub trait InternalLayerBaseParameters\u003cMP: MontyParameters, const WIDTH: usize\u003e:\r\n    Clone + Sync\r\n{\r\n    // Most of the time, ArrayLike will be `[u8; WIDTH - 1]`.\r\n    type ArrayLike: AsRef\u003c[MontyField31\u003cMP\u003e]\u003e + Sized;\r\n\r\n    // Long term INTERNAL_DIAG_MONTY will be removed.\r\n    // Currently it is needed for the Packed field implementations.\r\n    const INTERNAL_DIAG_MONTY: [MontyField31\u003cMP\u003e; WIDTH];\r\n\r\n    /// Perform the internal matrix multiplication: s -\u003e (1 + Diag(V))s.\r\n    /// We ignore `state[0]` as it is handled separately.\r\n    fn internal_layer_mat_mul(state: \u0026mut [MontyField31\u003cMP\u003e; WIDTH], sum: MontyField31\u003cMP\u003e);\r\n\r\n    /// Perform the internal matrix multiplication for any Abstract field\r\n    /// which implements multiplication by MontyField31 elements.\r\n    fn generic_internal_linear_layer\u003cA: Algebra\u003cMontyField31\u003cMP\u003e\u003e\u003e(state: \u0026mut [A; WIDTH]);\r\n}\r\n\r\n#[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\r\npub trait InternalLayerParameters\u003cFP: FieldParameters, const WIDTH: usize\u003e:\r\n    InternalLayerBaseParameters\u003cFP, WIDTH\u003e\r\n{\r\n}\r\n#[cfg(all(\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx2\",\r\n    not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n))]\r\npub trait InternalLayerParameters\u003cFP: FieldParameters, const WIDTH: usize\u003e:\r\n    InternalLayerBaseParameters\u003cFP, WIDTH\u003e + crate::InternalLayerParametersAVX2\u003cFP, WIDTH\u003e\r\n{\r\n}\r\n#[cfg(all(\r\n    feature = \"nightly-features\",\r\n    target_arch = \"x86_64\",\r\n    target_feature = \"avx512f\"\r\n))]\r\npub trait InternalLayerParameters\u003cFP: FieldParameters, const WIDTH: usize\u003e:\r\n    InternalLayerBaseParameters\u003cFP, WIDTH\u003e + crate::InternalLayerParametersAVX512\u003cFP, WIDTH\u003e\r\n{\r\n}\r\n#[cfg(not(any(\r\n    all(target_arch = \"aarch64\", target_feature = \"neon\"),\r\n    all(\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx2\",\r\n        not(all(feature = \"nightly-features\", target_feature = \"avx512f\"))\r\n    ),\r\n    all(\r\n        feature = \"nightly-features\",\r\n        target_arch = \"x86_64\",\r\n        target_feature = \"avx512f\"\r\n    ),\r\n)))]\r\npub trait InternalLayerParameters\u003cFP: FieldParameters, const WIDTH: usize\u003e:\r\n    InternalLayerBaseParameters\u003cFP, WIDTH\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP, const WIDTH: usize, P2P, const D: u64\u003e InternalLayer\u003cMontyField31\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, P2P\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n    P2P: InternalLayerParameters\u003cFP, WIDTH\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [MontyField31\u003cFP\u003e; WIDTH]) {\r\n        self.internal_constants.iter().for_each(|rc| {\r\n            state[0] += *rc;\r\n            state[0] = state[0].injective_exp_n();\r\n            let part_sum: MontyField31\u003cFP\u003e = state[1..].iter().cloned().sum();\r\n            let full_sum = part_sum + state[0];\r\n            state[0] = part_sum - state[0];\r\n            P2P::internal_layer_mat_mul(state, full_sum);\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cFP, const WIDTH: usize, const D: u64\u003e ExternalLayer\u003cMontyField31\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [MontyField31\u003cFP\u003e; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            self.external_constants.get_initial_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [MontyField31\u003cFP\u003e; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            self.external_constants.get_terminal_constants(),\r\n            add_rc_and_sbox_generic,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n\r\n/// An implementation of the matrix multiplications in the internal and external layers of Poseidon2.\r\n///\r\n/// This can act on `[A; WIDTH]` for any ring implementing `Algebra\u003cMontyField31\u003cFP\u003e\u003e`.\r\n/// This will usually be slower than the Poseidon2 permutation built from `Poseidon2InternalLayerMonty31` and\r\n/// `Poseidon2ExternalLayerMonty31` but it does work in more cases.\r\npub struct GenericPoseidon2LinearLayersMonty31\u003cFP, ILBP\u003e {\r\n    _phantom1: PhantomData\u003cFP\u003e,\r\n    _phantom2: PhantomData\u003cILBP\u003e,\r\n}\r\n\r\nimpl\u003cFP, A, ILBP, const WIDTH: usize\u003e GenericPoseidon2LinearLayers\u003cA, WIDTH\u003e\r\n    for GenericPoseidon2LinearLayersMonty31\u003cFP, ILBP\u003e\r\nwhere\r\n    FP: FieldParameters,\r\n    A: Algebra\u003cMontyField31\u003cFP\u003e\u003e,\r\n    ILBP: InternalLayerBaseParameters\u003cFP, WIDTH\u003e,\r\n{\r\n    /// Perform the external matrix multiplication for any Abstract field\r\n    /// which implements multiplication by MontyField31 elements.\r\n    fn internal_linear_layer(state: \u0026mut [A; WIDTH]) {\r\n        ILBP::generic_internal_linear_layer(state);\r\n    }\r\n}\r\n","traces":[{"line":85,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":86,"address":[],"length":0,"stats":{"Line":3170534137668840861}},{"line":87,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":88,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":89,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":90,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":91,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":92,"address":[],"length":0,"stats":{"Line":15060037153926950242}},{"line":103,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":105,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":106,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":107,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":108,"address":[],"length":0,"stats":{"Line":6557241057451442235}},{"line":113,"address":[],"length":0,"stats":{"Line":6557241057451442418}},{"line":115,"address":[],"length":0,"stats":{"Line":6557241057451442418}},{"line":116,"address":[],"length":0,"stats":{"Line":6557241057451442418}},{"line":117,"address":[],"length":0,"stats":{"Line":6557241057451442418}},{"line":118,"address":[],"length":0,"stats":{"Line":6557241057451442418}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":18,"coverable":20},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","utils.rs"],"content":"use crate::{FieldParameters, MontyParameters};\r\n\r\n/// Convert a u32 into MONTY form.\r\n/// There are no constraints on the input.\r\n/// The output will be a u32 in range [0, P).\r\n#[inline]\r\npub(crate) const fn to_monty\u003cMP: MontyParameters\u003e(x: u32) -\u003e u32 {\r\n    (((x as u64) \u003c\u003c MP::MONTY_BITS) % MP::PRIME as u64) as u32\r\n}\r\n\r\n/// Convert an i32 into MONTY form.\r\n/// There are no constraints on the input.\r\n/// The output will be a u32 in range [0, P).\r\n#[inline]\r\npub(crate) const fn to_monty_signed\u003cMP: MontyParameters\u003e(x: i32) -\u003e u32 {\r\n    let red = (((x as i64) \u003c\u003c MP::MONTY_BITS) % MP::PRIME as i64) as i32;\r\n    if red \u003e= 0 {\r\n        red as u32\r\n    } else {\r\n        MP::PRIME.wrapping_add_signed(red)\r\n    }\r\n}\r\n\r\n/// Convert a u64 into MONTY form.\r\n/// There are no constraints on the input.\r\n/// The output will be a u32 in range [0, P).\r\n#[inline]\r\npub(crate) const fn to_monty_64\u003cMP: MontyParameters\u003e(x: u64) -\u003e u32 {\r\n    (((x as u128) \u003c\u003c MP::MONTY_BITS) % MP::PRIME as u128) as u32\r\n}\r\n\r\n/// Convert an i64 into MONTY form.\r\n/// There are no constraints on the input.\r\n/// The output will be a u32 in range [0, P).\r\n#[inline]\r\npub(crate) const fn to_monty_64_signed\u003cMP: MontyParameters\u003e(x: i64) -\u003e u32 {\r\n    let red = (((x as i128) \u003c\u003c MP::MONTY_BITS) % MP::PRIME as i128) as i32;\r\n    if red \u003e= 0 {\r\n        red as u32\r\n    } else {\r\n        MP::PRIME.wrapping_add_signed(red)\r\n    }\r\n}\r\n\r\n/// Convert a u32 out of MONTY form.\r\n/// There are no constraints on the input.\r\n/// The output will be a u32 in range [0, P).\r\n#[inline]\r\n#[must_use]\r\npub(crate) const fn from_monty\u003cMP: MontyParameters\u003e(x: u32) -\u003e u32 {\r\n    monty_reduce::\u003cMP\u003e(x as u64)\r\n}\r\n\r\n/// Given an element x from a 31 bit field F_P compute x/2.\r\n/// The input must be in [0, P).\r\n/// The output will also be in [0, P).\r\n#[inline]\r\npub(crate) const fn halve_u32\u003cFP: FieldParameters\u003e(input: u32) -\u003e u32 {\r\n    let shr = input \u003e\u003e 1;\r\n    let lo_bit = input \u0026 1;\r\n    let shr_corr = shr + FP::HALF_P_PLUS_1;\r\n    if lo_bit == 0 {\r\n        shr\r\n    } else {\r\n        shr_corr\r\n    }\r\n}\r\n\r\n/// Montgomery reduction of a value in `0..P \u003c\u003c MONTY_BITS`.\r\n/// the input must be in [0, MONTY * P).\r\n/// the output will be in [0, P).\r\n#[inline]\r\n#[must_use]\r\npub(crate) const fn monty_reduce\u003cMP: MontyParameters\u003e(x: u64) -\u003e u32 {\r\n    let t = x.wrapping_mul(MP::MONTY_MU as u64) \u0026 (MP::MONTY_MASK as u64);\r\n    let u = t * (MP::PRIME as u64);\r\n\r\n    let (x_sub_u, over) = x.overflowing_sub(u);\r\n    let x_sub_u_hi = (x_sub_u \u003e\u003e MP::MONTY_BITS) as u32;\r\n    let corr = if over { MP::PRIME } else { 0 };\r\n    x_sub_u_hi.wrapping_add(corr)\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":1152921504606847121}},{"line":8,"address":[],"length":0,"stats":{"Line":1152921504606847121}},{"line":15,"address":[],"length":0,"stats":{"Line":7493989779945739924}},{"line":16,"address":[],"length":0,"stats":{"Line":7493989779945739924}},{"line":17,"address":[],"length":0,"stats":{"Line":7493989779945739924}},{"line":18,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":20,"address":[],"length":0,"stats":{"Line":11096869481842136724}},{"line":28,"address":[],"length":0,"stats":{"Line":17149707381026848837}},{"line":29,"address":[],"length":0,"stats":{"Line":17149707381026848837}},{"line":36,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":37,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":38,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":39,"address":[],"length":0,"stats":{"Line":6196953087261802496}},{"line":41,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":50,"address":[],"length":0,"stats":{"Line":14771806777775227025}},{"line":51,"address":[],"length":0,"stats":{"Line":14771806777775227025}},{"line":58,"address":[],"length":0,"stats":{"Line":5548434740920667731}},{"line":59,"address":[],"length":0,"stats":{"Line":5548434740920667731}},{"line":60,"address":[],"length":0,"stats":{"Line":5548434740920667731}},{"line":61,"address":[],"length":0,"stats":{"Line":5548434740920667731}},{"line":62,"address":[],"length":0,"stats":{"Line":5548434740920667731}},{"line":63,"address":[],"length":0,"stats":{"Line":16140901064495864045}},{"line":65,"address":[],"length":0,"stats":{"Line":7854277750134355302}},{"line":74,"address":[],"length":0,"stats":{"Line":4467570830351557944}},{"line":75,"address":[],"length":0,"stats":{"Line":4467570830351557944}},{"line":76,"address":[],"length":0,"stats":{"Line":4467570830351557944}},{"line":78,"address":[],"length":0,"stats":{"Line":4467570830351557944}},{"line":79,"address":[],"length":0,"stats":{"Line":4467570830351557944}},{"line":80,"address":[],"length":0,"stats":{"Line":13402712491054673832}},{"line":81,"address":[],"length":0,"stats":{"Line":4467570830351557944}}],"covered":30,"coverable":30},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx2","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\nmod utils;\r\n\r\npub use packing::*;\r\npub use poseidon2::*;\r\npub use utils::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx2","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m256i};\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::{FieldParameters, MontyField31, PackedMontyParameters, RelativelyPrimePower};\r\n\r\nconst WIDTH: usize = 8;\r\n\r\npub trait MontyParametersAVX2 {\r\n    const PACKED_P: __m256i;\r\n    const PACKED_MU: __m256i;\r\n}\r\n\r\n/// Vectorized AVX2 implementation of `MontyField31\u003cFP\u003e` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This is needed to make `transmute`s safe.\r\npub struct PackedMontyField31AVX2\u003cPMP: PackedMontyParameters\u003e(pub [MontyField31\u003cPMP\u003e; WIDTH]);\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    pub(crate) fn to_vector(self) -\u003e __m256i {\r\n        unsafe {\r\n            // Safety: `MontyField31\u003cFP\u003e` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[MontyField31\u003cFP\u003e; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `__m256i`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMontyField31AVX2\u003cFP\u003e` is `repr(transparent)` so it can be transmuted to\r\n            // `[MontyField31\u003cFP\u003e; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid `MontyField31\u003cFP\u003e`.\r\n    /// In particular, each element of vector must be in `0..P` (canonical form).\r\n    pub(crate) unsafe fn from_vector(vector: __m256i) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `MontyField31\u003cFP\u003e` values. We must only reason about memory representations. `__m256i` can be\r\n        // transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which can\r\n        // be transmuted to `[MontyField31\u003cFP\u003e; WIDTH]` (since `MontyField31\u003cFP\u003e` is `repr(transparent)`), which in\r\n        // turn can be transmuted to `PackedMontyField31AVX2\u003cFP\u003e` (since `PackedMontyField31AVX2\u003cFP\u003e` is also\r\n        // `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMontyField31\u003cFP\u003e\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Neg for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg::\u003cPMP\u003e(val);\r\n        unsafe {\r\n            // Safety: `neg` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n/// Add two vectors of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn add\u003cMPAVX2: MontyParametersAVX2\u003e(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpaddd   t, lhs, rhs\r\n    //      vpsubd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1 cyc/vec (8 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let t := lhs + rhs. We want to return t mod P. Recall that lhs and rhs are in\r\n    // 0, ..., P - 1, so t is in 0, ..., 2 P - 2 (\u003c 2^32). It suffices to return t if t \u003c P and\r\n    // t - P otherwise.\r\n    //   Let u := (t - P) mod 2^32 and r := unsigned_min(t, u).\r\n    //   If t is in 0, ..., P - 1, then u is in (P - 1 \u003c) 2^32 - P, ..., 2^32 - 1 and r = t.\r\n    // Otherwise, t is in P, ..., 2 P - 2, u is in 0, ..., P - 2 (\u003c P) and r = u. Hence, r is t if\r\n    // t \u003c P and t - P otherwise, as desired.\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let t = x86_64::_mm256_add_epi32(lhs, rhs);\r\n        let u = x86_64::_mm256_sub_epi32(t, MPAVX2::PACKED_P);\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n// MONTGOMERY MULTIPLICATION\r\n//   This implementation is based on [1] but with minor changes. The reduction is as follows:\r\n//\r\n// Constants: P \u003c 2^31, prime\r\n//            B = 2^32\r\n//             = P^-1 mod B\r\n// Input: 0 \u003c= C \u003c P B\r\n// Output: 0 \u003c= R \u003c P such that R = C B^-1 (mod P)\r\n//   1. Q :=  C mod B\r\n//   2. D := (C - Q P) / B\r\n//   3. R := if D \u003c 0 then D + P else D\r\n//\r\n// We first show that the division in step 2. is exact. It suffices to show that C = Q P (mod B). By\r\n// definition of Q and , we have Q P =  C P = P^-1 C P = C (mod B). We also have\r\n// C - Q P = C (mod P), so thus D = C B^-1 (mod P).\r\n//\r\n// It remains to show that R is in the correct range. It suffices to show that -P \u003c D \u003c P. We know\r\n// that 0 \u003c= C \u003c P B and 0 \u003c= Q P \u003c P B. Then -P B \u003c C - QP \u003c P B and -P \u003c D \u003c P, as desired.\r\n//\r\n// [1] Modern Computer Arithmetic, Richard Brent and Paul Zimmermann, Cambridge University Press,\r\n//     2010, algorithm 2.7.\r\n\r\n// We provide 2 variants of Montgomery reduction depending on if the inputs are unsigned or signed.\r\n// The unsigned variant follows steps 1 and 2 in the above protocol to produce D in (-P, ..., P).\r\n// For the signed variant we assume -PB/2 \u003c C \u003c PB/2 and let Q :=  C mod B be the unique\r\n// representative in [-B/2, ..., B/2 - 1]. The division in step 2 is clearly still exact and\r\n// |C - Q P| \u003c= |C| + |Q||P| \u003c PB so D still lies in (-P, ..., P).\r\n\r\n/// Perform a partial Montgomery reduction on each 64 bit element.\r\n/// Input must lie in {0, ..., 2^32P}.\r\n/// The output will lie in {-P, ..., P} and be stored in the upper 32 bits.\r\n#[inline]\r\n#[must_use]\r\nfn partial_monty_red_unsigned_to_signed\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let q = x86_64::_mm256_mul_epu32(input, MPAVX2::PACKED_MU);\r\n        let q_p = x86_64::_mm256_mul_epu32(q, MPAVX2::PACKED_P);\r\n\r\n        // By construction, the bottom 32 bits of input and q_p are equal.\r\n        // Thus _mm256_sub_epi32 and _mm256_sub_epi64 should act identically.\r\n        // However for some reason, the compiler gets confused if we use _mm256_sub_epi64\r\n        // and outputs a load of nonsense, see: https://godbolt.org/z/3W8M7Tv84.\r\n        x86_64::_mm256_sub_epi32(input, q_p)\r\n    }\r\n}\r\n\r\n/// Perform a partial Montgomery reduction on each 64 bit element.\r\n/// Input must lie in {-2^{31}P, ..., 2^31P}.\r\n/// The output will lie in {-P, ..., P} and be stored in the upper 32 bits.\r\n#[inline]\r\n#[must_use]\r\nfn partial_monty_red_signed_to_signed\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let q = x86_64::_mm256_mul_epi32(input, MPAVX2::PACKED_MU);\r\n        let q_p = x86_64::_mm256_mul_epi32(q, MPAVX2::PACKED_P);\r\n\r\n        // Unlike the previous case the compiler output is essentially identical\r\n        // between _mm256_sub_epi32 and _mm256_sub_epi64. We use _mm256_sub_epi32\r\n        // again just for consistency.\r\n        x86_64::_mm256_sub_epi32(input, q_p)\r\n    }\r\n}\r\n\r\n/// Multiply the MontyField31 field elements in the even index entries.\r\n/// lhs[2i], rhs[2i] must be unsigned 32-bit integers such that\r\n/// lhs[2i] * rhs[2i] lies in {0, ..., 2^32P}.\r\n/// The output will lie in {-P, ..., P} and be stored in output[2i + 1].\r\n#[inline]\r\n#[must_use]\r\nfn monty_mul\u003cMPAVX2: MontyParametersAVX2\u003e(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let prod = x86_64::_mm256_mul_epu32(lhs, rhs);\r\n        partial_monty_red_unsigned_to_signed::\u003cMPAVX2\u003e(prod)\r\n    }\r\n}\r\n\r\n/// Multiply the MontyField31 field elements in the even index entries.\r\n/// lhs[2i], rhs[2i] must be signed 32-bit integers such that\r\n/// lhs[2i] * rhs[2i] lies in {-2^31P, ..., 2^31P}.\r\n/// The output will lie in {-P, ..., P} stored in output[2i + 1].\r\n#[inline]\r\n#[must_use]\r\nfn monty_mul_signed\u003cMPAVX2: MontyParametersAVX2\u003e(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    unsafe {\r\n        let prod = x86_64::_mm256_mul_epi32(lhs, rhs);\r\n        partial_monty_red_signed_to_signed::\u003cMPAVX2\u003e(prod)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn movehdup_epi32(x: __m256i) -\u003e __m256i {\r\n    // This instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, duplicate, and cast back.\r\n    unsafe {\r\n        x86_64::_mm256_castps_si256(x86_64::_mm256_movehdup_ps(x86_64::_mm256_castsi256_ps(x)))\r\n    }\r\n}\r\n\r\n/// Multiply vectors of MontyField31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn mul\u003cMPAVX2: MontyParametersAVX2\u003e(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vmovshdup  lhs_odd, lhs\r\n    //      vmovshdup  rhs_odd, rhs\r\n    //      vpmuludq   prod_evn, lhs, rhs\r\n    //      vpmuludq   prod_odd, lhs_odd, rhs_odd\r\n    //      vpmuludq   q_evn, prod_evn, MU\r\n    //      vpmuludq   q_odd, prod_odd, MU\r\n    //      vpmuludq   q_P_evn, q_evn, P\r\n    //      vpmuludq   q_P_odd, q_odd, P\r\n    //      vpsubq     d_evn, prod_evn, q_P_evn\r\n    //      vpsubq     d_odd, prod_odd, q_P_odd\r\n    //      vmovshdup  d_evn_hi, d_evn\r\n    //      vpblendd   t, d_evn_hi, d_odd, aah\r\n    //      vpaddd     u, t, P\r\n    //      vpminud    res, t, u\r\n    // throughput: 4.67 cyc/vec (1.71 els/cyc)\r\n    // latency: 21 cyc\r\n    unsafe {\r\n        let lhs_evn = lhs;\r\n        let rhs_evn = rhs;\r\n        let lhs_odd = movehdup_epi32(lhs);\r\n        let rhs_odd = movehdup_epi32(rhs);\r\n\r\n        let d_evn = monty_mul::\u003cMPAVX2\u003e(lhs_evn, rhs_evn);\r\n        let d_odd = monty_mul::\u003cMPAVX2\u003e(lhs_odd, rhs_odd);\r\n\r\n        let d_evn_hi = movehdup_epi32(d_evn);\r\n        let t = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(d_evn_hi, d_odd);\r\n\r\n        let u = x86_64::_mm256_add_epi32(t, MPAVX2::PACKED_P);\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n/// Square the MontyField31 field elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers.\r\n/// Outputs will be a signed integer in (-P, ..., P) copied into both the even and odd indices.\r\n#[inline]\r\n#[must_use]\r\nfn shifted_square\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    // Note that we do not need a restriction on the size of input[i]^2 as\r\n    // 2^30 \u003c P and |i32| \u003c= 2^31 and so =\u003e input[i]^2 \u003c= 2^62 \u003c 2^32P.\r\n    unsafe {\r\n        let square = x86_64::_mm256_mul_epi32(input, input);\r\n        let square_red = partial_monty_red_unsigned_to_signed::\u003cMPAVX2\u003e(square);\r\n        movehdup_epi32(square_red)\r\n    }\r\n}\r\n\r\n/// Cube the MontyField31 field elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will be a signed integer in (-P, ..., P) stored in the odd indices.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_3\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    let square = shifted_square::\u003cMPAVX2\u003e(input);\r\n    monty_mul_signed::\u003cMPAVX2\u003e(square, input)\r\n}\r\n\r\n/// Take the fifth power of the MontyField31 field elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will be a signed integer in (-P, ..., P) stored in the odd indices.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_5\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    let square = shifted_square::\u003cMPAVX2\u003e(input);\r\n    let quad = shifted_square::\u003cMPAVX2\u003e(square);\r\n    monty_mul_signed::\u003cMPAVX2\u003e(quad, input)\r\n}\r\n\r\n/// Take the seventh power of the MontyField31 field elements in the even index entries.\r\n/// Inputs must lie in [-P, ..., P].\r\n/// Outputs will also lie in (-P, ..., P) stored in the odd indices.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_7\u003cMPAVX2: MontyParametersAVX2\u003e(input: __m256i) -\u003e __m256i {\r\n    let square = shifted_square::\u003cMPAVX2\u003e(input);\r\n    let cube = monty_mul_signed::\u003cMPAVX2\u003e(square, input);\r\n    let cube_shifted = movehdup_epi32(cube);\r\n    let quad = shifted_square::\u003cMPAVX2\u003e(square);\r\n\r\n    monty_mul_signed::\u003cMPAVX2\u003e(quad, cube_shifted)\r\n}\r\n\r\n/// Apply func to the even and odd indices of the input vector.\r\n/// func should only depend in the 32 bit entries in the even indices.\r\n/// The output of func must lie in (-P, ..., P) and be stored in the odd indices.\r\n/// The even indices of the output of func will not be read.\r\n/// The input should conform to the requirements of `func`.\r\n#[inline]\r\n#[must_use]\r\npub(crate) unsafe fn apply_func_to_even_odd\u003cMPAVX2: MontyParametersAVX2\u003e(\r\n    input: __m256i,\r\n    func: fn(__m256i) -\u003e __m256i,\r\n) -\u003e __m256i {\r\n    let input_evn = input;\r\n    let input_odd = movehdup_epi32(input);\r\n\r\n    let d_evn = func(input_evn);\r\n    let d_odd = func(input_odd);\r\n\r\n    let d_evn_hi = movehdup_epi32(d_evn);\r\n    let t = x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(d_evn_hi, d_odd);\r\n\r\n    let u = x86_64::_mm256_add_epi32(t, MPAVX2::PACKED_P);\r\n    x86_64::_mm256_min_epu32(t, u)\r\n}\r\n\r\n/// Negate a vector of MontyField31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg\u003cMPAVX2: MontyParametersAVX2\u003e(val: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpsubd   t, P, val\r\n    //      vpsignd  res, t, val\r\n    // throughput: .67 cyc/vec (12 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    //   The vpsignd instruction is poorly named, because it doesn't _return_ or _copy_ the sign of\r\n    // anything, but _multiplies_ x by the sign of y (treating both as signed integers). In other\r\n    // words,\r\n    //                       { x            if y \u003es 0,\r\n    //      vpsignd(x, y) := { 0            if y = 0,\r\n    //                       { -x mod 2^32  if y \u003cs 0.\r\n    //   We define t := P - val and note that t = -val (mod P). When val is in {1, ..., P - 1}, t is\r\n    // similarly in {1, ..., P - 1}, so it's in canonical form. Otherwise, val = 0 and t = P.\r\n    //   This is where we define res := vpsignd(t, val). The sign bit of val is never set so either\r\n    // val = 0 or val \u003es 0. If val = 0, then res = vpsignd(t, 0) = 0, as desired. Otherwise,\r\n    // res = vpsignd(t, val) = t passes t through.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let t = x86_64::_mm256_sub_epi32(MPAVX2::PACKED_P, val);\r\n        x86_64::_mm256_sign_epi32(t, val)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of MontyField31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn sub\u003cMPAVX2: MontyParametersAVX2\u003e(lhs: __m256i, rhs: __m256i) -\u003e __m256i {\r\n    // We want this to compile to:\r\n    //      vpsubd   t, lhs, rhs\r\n    //      vpaddd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1 cyc/vec (8 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    //   Let t := lhs - rhs. We want to return t mod P. Recall that lhs and rhs are in\r\n    // 0, ..., P - 1, so t is in (-2^31 \u003c) -P + 1, ..., P - 1 (\u003c 2^31). It suffices to return t if\r\n    // t \u003e= 0 and t + P otherwise.\r\n    //   Let u := (t + P) mod 2^32 and r := unsigned_min(t, u).\r\n    //   If t is in 0, ..., P - 1, then u is in P, ..., 2 P - 1 and r = t.\r\n    // Otherwise, t is in -P + 1, ..., -1; u is in 1, ..., P - 1 (\u003c P) and r = u. Hence, r is t if\r\n    // t \u003c P and t - P otherwise, as desired.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        let t = x86_64::_mm256_sub_epi32(lhs, rhs);\r\n        let u = x86_64::_mm256_add_epi32(t, MPAVX2::PACKED_P);\r\n        x86_64::_mm256_min_epu32(t, u)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e From\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn from(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Default for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        MontyField31::\u003cPMP\u003e::default().into()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum for PackedMontyField31AVX2\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product for PackedMontyField31AVX2\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeCharacteristicRing for PackedMontyField31AVX2\u003cFP\u003e {\r\n    type PrimeSubfield = MontyField31\u003cFP\u003e;\r\n\r\n    const ZERO: Self = Self::broadcast(MontyField31::ZERO);\r\n    const ONE: Self = Self::broadcast(MontyField31::ONE);\r\n    const TWO: Self = Self::broadcast(MontyField31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(MontyField31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline]\r\n    fn cube(\u0026self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        unsafe {\r\n            // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n            let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_3::\u003cFP\u003e);\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    #[inline(always)]\r\n    fn exp_const_u64\u003cconst POWER: u64\u003e(\u0026self) -\u003e Self {\r\n        // We provide specialised code for the powers 3, 5, 7 as these turn up regularly.\r\n        // The other powers could be specialised similarly but we ignore this for now.\r\n        // These ideas could also be used to speed up the more generic exp_u64.\r\n        match POWER {\r\n            0 =\u003e Self::ONE,\r\n            1 =\u003e *self,\r\n            2 =\u003e self.square(),\r\n            3 =\u003e self.cube(),\r\n            4 =\u003e self.square().square(),\r\n            5 =\u003e {\r\n                let val = self.to_vector();\r\n                unsafe {\r\n                    // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n                    let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_5::\u003cFP\u003e);\r\n                    Self::from_vector(res)\r\n                }\r\n            }\r\n            6 =\u003e self.square().cube(),\r\n            7 =\u003e {\r\n                let val = self.to_vector();\r\n                unsafe {\r\n                    // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n                    let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_7::\u003cFP\u003e);\r\n                    Self::from_vector(res)\r\n                }\r\n            }\r\n            _ =\u003e self.exp_u64(POWER),\r\n        }\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(MontyField31::\u003cFP\u003e::zero_vec(len * WIDTH)) }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Algebra\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX2\u003cFP\u003e {}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e InjectiveMonomial\u003cD\u003e\r\n    for PackedMontyField31AVX2\u003cFP\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e PermutationMonomial\u003cD\u003e\r\n    for PackedMontyField31AVX2\u003cFP\u003e\r\n{\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        FP::exp_root_d(*self)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX2\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX2\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.sum::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX2\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.product::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Div\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX2\u003cFP\u003e {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: MontyField31\u003cFP\u003e) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cPackedMontyField31AVX2\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX2\u003cPMP\u003e;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMontyField31AVX2\u003cPMP\u003e) -\u003e PackedMontyField31AVX2\u003cPMP\u003e {\r\n        PackedMontyField31AVX2::\u003cPMP\u003e::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cPackedMontyField31AVX2\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX2\u003cPMP\u003e;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMontyField31AVX2\u003cPMP\u003e) -\u003e PackedMontyField31AVX2\u003cPMP\u003e {\r\n        PackedMontyField31AVX2::\u003cPMP\u003e::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cPackedMontyField31AVX2\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX2\u003cPMP\u003e;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMontyField31AVX2\u003cPMP\u003e) -\u003e PackedMontyField31AVX2\u003cPMP\u003e {\r\n        PackedMontyField31AVX2::\u003cPMP\u003e::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Distribution\u003cPackedMontyField31AVX2\u003cPMP\u003e\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMontyField31AVX2\u003cPMP\u003e {\r\n        PackedMontyField31AVX2::\u003cPMP\u003e(rng.gen())\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vpsllq    t, a, 32\r\n    //      vpsrlq    u, b, 32\r\n    //      vpblendd  res0, a, u, aah\r\n    //      vpblendd  res1, t, b, aah\r\n    // throughput: 1.33 cyc/2 vec (12 els/cyc)\r\n    // latency: (1 -\u003e 1)  1 cyc\r\n    //          (1 -\u003e 2)  2 cyc\r\n    //          (2 -\u003e 1)  2 cyc\r\n    //          (2 -\u003e 2)  1 cyc\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a1   0  a3   0  a5   0  a7   0 ].\r\n        //   u = [  0  b0   0  b2   0  b4   0  b6 ].\r\n        let t = x86_64::_mm256_srli_epi64::\u003c32\u003e(a);\r\n        let u = x86_64::_mm256_slli_epi64::\u003c32\u003e(b);\r\n\r\n        // Then\r\n        //   res0 = [ a0  b0  a2  b2  a4  b4  a6  b6 ],\r\n        //   res1 = [ a1  b1  a3  b3  a5  b5  a7  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(a, u),\r\n            x86_64::_mm256_blend_epi32::\u003c0b10101010\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vpalignr  t, b, a, 8\r\n    //      vpblendd  res0, a, t, cch\r\n    //      vpblendd  res1, t, b, cch\r\n    // throughput: 1 cyc/2 vec (16 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a2  a3  b0  b1  a6  a7  b4  b5 ].\r\n        let t = x86_64::_mm256_alignr_epi8::\u003c8\u003e(b, a);\r\n\r\n        // Then\r\n        //   res0 = [ a0  a1  b0  b1  a4  a5  b4  b5 ],\r\n        //   res1 = [ a2  a3  b2  b3  a6  a7  b6  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b11001100\u003e(a, t),\r\n            x86_64::_mm256_blend_epi32::\u003c0b11001100\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave4(a: __m256i, b: __m256i) -\u003e (__m256i, __m256i) {\r\n    // We want this to compile to:\r\n    //      vperm2i128  t, a, b, 21h\r\n    //      vpblendd    res0, a, t, f0h\r\n    //      vpblendd    res1, t, b, f0h\r\n    // throughput: 1 cyc/2 vec (16 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   a = [ a0  a1  a2  a3  a4  a5  a6  a7 ],\r\n        //   b = [ b0  b1  b2  b3  b4  b5  b6  b7 ].\r\n        // First form\r\n        //   t = [ a4  a5  a6  a7  b0  b1  b2  b3 ].\r\n        let t = x86_64::_mm256_permute2x128_si256::\u003c0x21\u003e(a, b);\r\n\r\n        // Then\r\n        //   res0 = [ a0  a1  a2  a3  b0  b1  b2  b3 ],\r\n        //   res1 = [ a4  a5  a6  a7  b4  b5  b6  b7 ].\r\n        (\r\n            x86_64::_mm256_blend_epi32::\u003c0b11110000\u003e(a, t),\r\n            x86_64::_mm256_blend_epi32::\u003c0b11110000\u003e(t, b),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedValue for PackedMontyField31AVX2\u003cFP\u003e {\r\n    type Value = MontyField31\u003cFP\u003e;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[MontyField31\u003cFP\u003e]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31\u003cFP\u003e; WIDTH]` can be transmuted to `PackedMontyField31AVX2\u003cFP\u003e` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [MontyField31\u003cFP\u003e]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31\u003cFP\u003e; WIDTH]` can be transmuted to `PackedMontyField31AVX2\u003cFP\u003e` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e MontyField31\u003cFP\u003e\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[MontyField31\u003cFP\u003e] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [MontyField31\u003cFP\u003e] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedField for PackedMontyField31AVX2\u003cFP\u003e {\r\n    type Scalar = MontyField31\u003cFP\u003e;\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedFieldPow2 for PackedMontyField31AVX2\u003cFP\u003e {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e interleave4(v0, v1),\r\n            8 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":8791026472627210284}},{"line":40,"address":[],"length":0,"stats":{"Line":8791026472627210284}},{"line":50,"address":[],"length":0,"stats":{"Line":1801439850948205108}},{"line":57,"address":[],"length":0,"stats":{"Line":1801439850948205108}},{"line":64,"address":[],"length":0,"stats":{"Line":5692549928996378216}},{"line":65,"address":[],"length":0,"stats":{"Line":5692549928996378216}},{"line":72,"address":[],"length":0,"stats":{"Line":15276209936040723176}},{"line":73,"address":[],"length":0,"stats":{"Line":15276209936040723176}},{"line":74,"address":[],"length":0,"stats":{"Line":15276209936040723176}},{"line":75,"address":[],"length":0,"stats":{"Line":15276209936040723176}},{"line":78,"address":[],"length":0,"stats":{"Line":15276209936040723176}},{"line":86,"address":[],"length":0,"stats":{"Line":17221764975064776743}},{"line":87,"address":[],"length":0,"stats":{"Line":17221764975064776743}},{"line":88,"address":[],"length":0,"stats":{"Line":17221764975064776743}},{"line":89,"address":[],"length":0,"stats":{"Line":17221764975064776743}},{"line":92,"address":[],"length":0,"stats":{"Line":17221764975064776743}},{"line":100,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":101,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":102,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":105,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":113,"address":[],"length":0,"stats":{"Line":11385099857992622982}},{"line":114,"address":[],"length":0,"stats":{"Line":11385099857992622982}},{"line":115,"address":[],"length":0,"stats":{"Line":11385099857992622982}},{"line":116,"address":[],"length":0,"stats":{"Line":11385099857992622982}},{"line":119,"address":[],"length":0,"stats":{"Line":11385099857992622982}},{"line":128,"address":[],"length":0,"stats":{"Line":9223372036854818967}},{"line":146,"address":[],"length":0,"stats":{"Line":9223372036854818967}},{"line":147,"address":[],"length":0,"stats":{"Line":9223372036854818967}},{"line":148,"address":[],"length":0,"stats":{"Line":9223372036854818967}},{"line":185,"address":[],"length":0,"stats":{"Line":3170534137668864229}},{"line":187,"address":[],"length":0,"stats":{"Line":3170534137668864229}},{"line":188,"address":[],"length":0,"stats":{"Line":3170534137668864229}},{"line":194,"address":[],"length":0,"stats":{"Line":3170534137668864229}},{"line":203,"address":[],"length":0,"stats":{"Line":4755801206503252535}},{"line":205,"address":[],"length":0,"stats":{"Line":4755801206503252535}},{"line":206,"address":[],"length":0,"stats":{"Line":4755801206503252535}},{"line":211,"address":[],"length":0,"stats":{"Line":4755801206503252535}},{"line":221,"address":[],"length":0,"stats":{"Line":15996785876420006708}},{"line":223,"address":[],"length":0,"stats":{"Line":15996785876420006708}},{"line":224,"address":[],"length":0,"stats":{"Line":15996785876420006708}},{"line":234,"address":[],"length":0,"stats":{"Line":4755801206503278821}},{"line":236,"address":[],"length":0,"stats":{"Line":4755801206503278821}},{"line":237,"address":[],"length":0,"stats":{"Line":4755801206503278821}},{"line":243,"address":[],"length":0,"stats":{"Line":6701356245527298144}},{"line":247,"address":[],"length":0,"stats":{"Line":6701356245527298144}},{"line":255,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":274,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":275,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":276,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":277,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":279,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":280,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":282,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":283,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":285,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":286,"address":[],"length":0,"stats":{"Line":17221764975064840522}},{"line":295,"address":[],"length":0,"stats":{"Line":5620492334958396527}},{"line":299,"address":[],"length":0,"stats":{"Line":5620492334958396527}},{"line":300,"address":[],"length":0,"stats":{"Line":5620492334958396527}},{"line":301,"address":[],"length":0,"stats":{"Line":5620492334958396527}},{"line":310,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":311,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":312,"address":[],"length":0,"stats":{"Line":16285016252571713536}},{"line":320,"address":[],"length":0,"stats":{"Line":864691128455135234}},{"line":321,"address":[],"length":0,"stats":{"Line":864691128455135234}},{"line":322,"address":[],"length":0,"stats":{"Line":864691128455135234}},{"line":323,"address":[],"length":0,"stats":{"Line":864691128455135234}},{"line":331,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":332,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":333,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":334,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":335,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":337,"address":[],"length":0,"stats":{"Line":3026418949592973420}},{"line":347,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":351,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":352,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":354,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":355,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":357,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":358,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":360,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":361,"address":[],"length":0,"stats":{"Line":864691128455170277}},{"line":368,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":388,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":389,"address":[],"length":0,"stats":{"Line":2017612633061982624}},{"line":397,"address":[],"length":0,"stats":{"Line":10088063165309917692}},{"line":414,"address":[],"length":0,"stats":{"Line":10088063165309917692}},{"line":415,"address":[],"length":0,"stats":{"Line":10088063165309917692}},{"line":416,"address":[],"length":0,"stats":{"Line":10088063165309917692}},{"line":422,"address":[],"length":0,"stats":{"Line":5692549928996309590}},{"line":423,"address":[],"length":0,"stats":{"Line":5692549928996309590}},{"line":429,"address":[],"length":0,"stats":{"Line":6557241057451444206}},{"line":430,"address":[],"length":0,"stats":{"Line":6557241057451444206}},{"line":436,"address":[],"length":0,"stats":{"Line":3170534137668829289}},{"line":437,"address":[],"length":0,"stats":{"Line":3170534137668829289}},{"line":443,"address":[],"length":0,"stats":{"Line":216172782113793259}},{"line":444,"address":[],"length":0,"stats":{"Line":216172782113793259}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":3746994889972260919}},{"line":461,"address":[],"length":0,"stats":{"Line":6052837899185963200}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":6496}},{"line":485,"address":[],"length":0,"stats":{"Line":6496}},{"line":489,"address":[],"length":0,"stats":{"Line":432345564227567929}},{"line":490,"address":[],"length":0,"stats":{"Line":432345564227567929}},{"line":493,"address":[],"length":0,"stats":{"Line":432345564227567929}},{"line":494,"address":[],"length":0,"stats":{"Line":432345564227567929}},{"line":500,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":504,"address":[],"length":0,"stats":{"Line":1297036692682702848}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":511,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":514,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":515,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":520,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":523,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":524,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":534,"address":[],"length":0,"stats":{"Line":15708555500268290048}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":7205759403792839858}},{"line":565,"address":[],"length":0,"stats":{"Line":7205759403792839858}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":579,"address":[],"length":0,"stats":{"Line":0}},{"line":580,"address":[],"length":0,"stats":{"Line":0}},{"line":586,"address":[],"length":0,"stats":{"Line":0}},{"line":587,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":680,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":681,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":687,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":688,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":695,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":711,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":717,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":718,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":725,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":741,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":747,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":748,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":759,"address":[],"length":0,"stats":{"Line":576460752303423998}},{"line":760,"address":[],"length":0,"stats":{"Line":576460752303423998}},{"line":765,"address":[],"length":0,"stats":{"Line":576460752303423494}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":12465963768561533419}},{"line":782,"address":[],"length":0,"stats":{"Line":12465963768561533419}},{"line":783,"address":[],"length":0,"stats":{"Line":12465963768561533419}},{"line":787,"address":[],"length":0,"stats":{"Line":9295429630892706693}},{"line":788,"address":[],"length":0,"stats":{"Line":9295429630892706693}},{"line":791,"address":[],"length":0,"stats":{"Line":4611686018427388395}},{"line":792,"address":[],"length":0,"stats":{"Line":4611686018427388395}},{"line":802,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":803,"address":[],"length":0,"stats":{"Line":14411518807585587200}},{"line":804,"address":[],"length":0,"stats":{"Line":10376293541461622784}},{"line":805,"address":[],"length":0,"stats":{"Line":4755801206503243544}},{"line":806,"address":[],"length":0,"stats":{"Line":4755801206503243916}},{"line":807,"address":[],"length":0,"stats":{"Line":4755801206503243822}},{"line":808,"address":[],"length":0,"stats":{"Line":144115188075855918}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}}],"covered":148,"coverable":191},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx2","poseidon2.rs"],"content":"//! Vectorized AVX2 implementation of Poseidon2 for MontyField31\r\n\r\nuse alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m256i};\r\nuse core::marker::PhantomData;\r\nuse core::mem::transmute;\r\n\r\nuse p3_poseidon2::{\r\n    external_initial_permute_state, external_terminal_permute_state, sum_15, sum_23, ExternalLayer,\r\n    ExternalLayerConstants, ExternalLayerConstructor, InternalLayer, InternalLayerConstructor,\r\n    MDSMat4,\r\n};\r\n\r\nuse crate::{\r\n    add, apply_func_to_even_odd, halve_avx2, packed_exp_3, packed_exp_5, packed_exp_7,\r\n    signed_add_avx2, sub, FieldParameters, InternalLayerBaseParameters, MontyField31,\r\n    MontyParameters, PackedMontyField31AVX2, PackedMontyParameters, RelativelyPrimePower,\r\n};\r\n\r\n// In the internal layers, it is valuable to treat the first entry of the state differently\r\n// as it is the only entry to which we apply s-box.\r\n// It seems to help the compiler if we introduce a different data structure for these layers.\r\n// Note that we use this structure instead of a tuple so we can force the memory layout to align for transmutes.\r\n#[derive(Clone, Copy)]\r\n#[repr(C)] // This is needed to make `transmute`s safe.\r\npub struct InternalLayer16\u003cPMP: PackedMontyParameters\u003e {\r\n    s0: PackedMontyField31AVX2\u003cPMP\u003e,\r\n    s_hi: [__m256i; 15],\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e InternalLayer16\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `InternalLayer16\u003cPMP\u003e` to `[PackedMontyField31AVX2\u003cPMP\u003e; 16]`\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `s_hi` represents a valid `MontyField31\u003cPMP\u003e`.\r\n    /// In particular, each element of each vector must be in `[0, P)` (canonical form).\r\n    unsafe fn to_packed_field_array(self) -\u003e [PackedMontyField31AVX2\u003cPMP\u003e; 16] {\r\n        // Safety: It is up to the user to ensure that elements of `s_hi` represent valid\r\n        // `MontyField31\u003cPMP\u003e` values. We must only reason about memory representations.\r\n        // As described in packing.rs, PackedMontyField31AVX2\u003cPMP\u003e can be transmuted to and from `__m256i`.\r\n\r\n        // `InternalLayer16` is `repr(C)` so its memory layout looks like:\r\n        // `[PackedMontyField31AVX2\u003cPMP\u003e, __m256i, ..., __m256i]`\r\n        // Thus as `__m256i` can be can be transmuted to `PackedMontyField31AVX2\u003cFP\u003e`,\r\n        // `InternalLayer16` can be transmuted to `[PackedMontyField31AVX2\u003cFP\u003e; 16]`.\r\n        transmute(self)\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `[PackedMontyField31AVX2\u003cPMP\u003e; 16]` to `InternalLayer16\u003cPMP\u003e`\r\n    fn from_packed_field_array(vector: [PackedMontyField31AVX2\u003cPMP\u003e; 16]) -\u003e Self {\r\n        unsafe {\r\n            // Safety: As described in packing.rs, PackedMontyField31AVX2\u003cPMP\u003e can be transmuted to and from `__m256i`.\r\n\r\n            // `InternalLayer16` is `repr(C)` so its memory layout looks like:\r\n            // `[PackedMontyField31AVX2\u003cPMP\u003e, __m256i, ..., __m256i]`\r\n            // Thus as `PackedMontyField31AVX2\u003cFP\u003e` can be can be transmuted to `__m256i`,\r\n            // `[PackedMontyField31AVX2\u003cFP\u003e; 16]` can be transmuted to `InternalLayer16`.\r\n            transmute(vector)\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone, Copy)]\r\n#[repr(C)] // This is needed to make `transmute`s safe.\r\npub struct InternalLayer24\u003cPMP: PackedMontyParameters\u003e {\r\n    s0: PackedMontyField31AVX2\u003cPMP\u003e,\r\n    s_hi: [__m256i; 23],\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e InternalLayer24\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `InternalLayer24\u003cPMP\u003e` to `[PackedMontyField31AVX2\u003cPMP\u003e; 24]`\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `s_hi` represents a valid `MontyField31\u003cPMP\u003e`.\r\n    /// In particular, each element of each vector must be in `[0, P)` (canonical form).\r\n    unsafe fn to_packed_field_array(self) -\u003e [PackedMontyField31AVX2\u003cPMP\u003e; 24] {\r\n        // Safety: As described in packing.rs, PackedMontyField31AVX2\u003cPMP\u003e can be transmuted to and from `__m256i`.\r\n\r\n        // `InternalLayer24` is `repr(C)` so its memory layout looks like:\r\n        // `[PackedMontyField31AVX2\u003cPMP\u003e, __m256i, ..., __m256i]`\r\n        // Thus as `__m256i` can be can be transmuted to `PackedMontyField31AVX2\u003cFP\u003e`,\r\n        // `InternalLayer24` can be transmuted to `[PackedMontyField31AVX2\u003cFP\u003e; 24]`.\r\n        transmute(self)\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `[PackedMontyField31AVX2\u003cPMP\u003e; 24]` to `InternalLayer24\u003cPMP\u003e`\r\n    fn from_packed_field_array(vector: [PackedMontyField31AVX2\u003cPMP\u003e; 24]) -\u003e Self {\r\n        unsafe {\r\n            // Safety: As described in packing.rs, PackedMontyField31AVX2\u003cPMP\u003e can be transmuted to and from `__m256i`.\r\n\r\n            // `InternalLayer24` is `repr(C)` so its memory layout looks like:\r\n            // `[PackedMontyField31AVX2\u003cPMP\u003e, __m256i, ..., __m256i]`\r\n            // Thus as `PackedMontyField31AVX2\u003cFP\u003e` can be can be transmuted to `__m256i`,\r\n            // `[PackedMontyField31AVX2\u003cFP\u003e; 24]` can be transmuted to `InternalLayer24`.\r\n            transmute(vector)\r\n        }\r\n    }\r\n}\r\n\r\n/// The internal layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 8 copies of `x - P` into the corresponding `__m256i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMonty31\u003c\r\n    PMP: PackedMontyParameters,\r\n    const WIDTH: usize,\r\n    ILP: InternalLayerParametersAVX2\u003cPMP, WIDTH\u003e,\r\n\u003e {\r\n    pub(crate) internal_constants: Vec\u003cMontyField31\u003cPMP\u003e\u003e,\r\n    packed_internal_constants: Vec\u003c__m256i\u003e,\r\n    _phantom: PhantomData\u003cILP\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize, ILP: InternalLayerParametersAVX2\u003cFP, WIDTH\u003e\u003e\r\n    InternalLayerConstructor\u003cMontyField31\u003cFP\u003e\u003e for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, ILP\u003e\r\n{\r\n    /// Construct an instance of Poseidon2InternalLayerMersenne31AVX2 from a vector containing\r\n    /// the constants for each round. Internally, the constants are transformed into the\r\n    /// {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(internal_constants: Vec\u003cMontyField31\u003cFP\u003e\u003e) -\u003e Self {\r\n        let packed_internal_constants = internal_constants\r\n            .iter()\r\n            .map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32))\r\n            .collect();\r\n        Self {\r\n            internal_constants,\r\n            packed_internal_constants,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 8 copies of `x - P` into the corresponding `__m256i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2ExternalLayerMonty31\u003cPMP: PackedMontyParameters, const WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMontyField31\u003cPMP\u003e, WIDTH\u003e,\r\n    packed_initial_external_constants: Vec\u003c[__m256i; WIDTH]\u003e,\r\n    packed_terminal_external_constants: Vec\u003c[__m256i; WIDTH]\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize\u003e ExternalLayerConstructor\u003cMontyField31\u003cFP\u003e, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\n{\r\n    /// Construct an instance of Poseidon2ExternalLayerMersenne31AVX2 from a array of\r\n    /// vectors containing the constants for each round. Internally, the constants\r\n    ///  are transformed into the {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(\r\n        external_constants: ExternalLayerConstants\u003cMontyField31\u003cFP\u003e, WIDTH\u003e,\r\n    ) -\u003e Self {\r\n        let packed_initial_external_constants = external_constants\r\n            .get_initial_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32)))\r\n            .collect();\r\n        let packed_terminal_external_constants = external_constants\r\n            .get_terminal_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32)))\r\n            .collect();\r\n        Self {\r\n            external_constants,\r\n            packed_initial_external_constants,\r\n            packed_terminal_external_constants,\r\n        }\r\n    }\r\n}\r\n\r\n/// Use hard coded methods to compute x -\u003e x^d for the even index entries and small d.\r\n/// Inputs should be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will also be signed integers in (-P, ..., P) stored in the odd indices.\r\n#[inline(always)]\r\n#[must_use]\r\nfn exp_small\u003cPMP: PackedMontyParameters, const D: u64\u003e(val: __m256i) -\u003e __m256i {\r\n    match D {\r\n        3 =\u003e packed_exp_3::\u003cPMP\u003e(val),\r\n        5 =\u003e packed_exp_5::\u003cPMP\u003e(val),\r\n        7 =\u003e packed_exp_7::\u003cPMP\u003e(val),\r\n        _ =\u003e panic!(\"No exp function for given D\"),\r\n    }\r\n}\r\n\r\n/// Compute val -\u003e (val + rc)^D. Each entry of val should be represented in canonical form.\r\n/// Each entry of rc should be represented by an element in in [-P, 0].\r\n/// Each entry of the output will be represented by an element in canonical form.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline(always)]\r\nfn add_rc_and_sbox\u003cPMP: PackedMontyParameters, const D: u64\u003e(\r\n    val: \u0026mut PackedMontyField31AVX2\u003cPMP\u003e,\r\n    rc: __m256i,\r\n) {\r\n    unsafe {\r\n        // As our exponential functions simply assume that\r\n        // the input lies in [-P, P] we do not need to perform a reduction provided\r\n        // rc is represented by an element in [-P, 0]\r\n        let vec_val = val.to_vector();\r\n        let val_plus_rc = x86_64::_mm256_add_epi32(vec_val, rc);\r\n        let output = apply_func_to_even_odd::\u003cPMP\u003e(val_plus_rc, exp_small::\u003cPMP, D\u003e);\r\n\r\n        *val = PackedMontyField31AVX2::\u003cPMP\u003e::from_vector(output)\r\n    }\r\n}\r\n\r\n/// A trait containing the specific information needed to\r\n/// implement the Poseidon2 Permutation for Monty31 Fields.\r\npub trait InternalLayerParametersAVX2\u003cPMP: PackedMontyParameters, const WIDTH: usize\u003e:\r\n    Clone + Sync\r\n{\r\n    type ArrayLike: AsMut\u003c[__m256i]\u003e;\r\n\r\n    // diagonal_mul and add_sum morally should be one function but are split because diagonal_mul can happen simultaneously to\r\n    // the sbox being applied to the first element of the state which is advantageous as this s-box has very high latency.\r\n    // However these functions should only ever be used together and we only make safety guarantees about the output\r\n    // of the combined function add_sum(diagonal_mul(state), sum) which will output field elements\r\n    // in canonical form provided inputs are in canonical form.\r\n\r\n    // For these reason we mark both functions as unsafe.\r\n\r\n    // All 4 implementation of this trait (Field = BabyBear/KoalaBear, WIDTH = 16/24) have a similarly structured\r\n    // diagonal matrix. The first 9 elements of this matrix are always: [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4] and the remainder\r\n    // are all positive or negative inverse powers of two. This common structure lets us write some default implementations.\r\n\r\n    /// # Safety\r\n    ///\r\n    /// This function assumes its output is piped directly into `add_sum`.\r\n    ///\r\n    /// It might not output field elements in canonical form and indeed may even\r\n    /// output incorrect values in places where it is efficient to correct for\r\n    /// the computation in `add_sum`. For example it might output `3*x` instead of `-3*x`\r\n    /// and have `add_sum` compute `sum - x` instead of `x + sum`.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul(input: \u0026mut Self::ArrayLike) {\r\n        Self::diagonal_mul_first_eight(input); // This only affects the first 8 elements.\r\n\r\n        Self::diagonal_mul_remainder(input); // This leaves the first 8 elements unchanged.\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    /// Multiply the first 8 elements of input by the vector `[1, 2, 1/2, 3, 4, 1/2, 3, 4]`.\r\n    ///\r\n    /// In all implementations of this trait, the first 9 elements of the diagonal matrix are\r\n    /// `[-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4]`. The -2 is handled separately and this function handles\r\n    /// the remainder. Note that for the last three elements we multiply by `1/2, 3, 4` and not\r\n    /// `-1/2, -3, -4`. Hence the value in this location will be the negative of what is desired.\r\n    /// This will be handled by `add_sum` and so it is important these elements are not touched\r\n    /// before input is passed into `add_sum`.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_first_eight(input: \u0026mut Self::ArrayLike) {\r\n        let input = input.as_mut();\r\n        // The first 5 elements should be multiplied by: 1, 2, 1/2, 3, 4\r\n\r\n        // input[0] is being multiplied by 1 so we ignore it.\r\n\r\n        input[1] = add::\u003cPMP\u003e(input[1], input[1]);\r\n        input[2] = halve_avx2::\u003cPMP\u003e(input[2]);\r\n\r\n        let acc3 = add::\u003cPMP\u003e(input[3], input[3]);\r\n        input[3] = add::\u003cPMP\u003e(acc3, input[3]);\r\n\r\n        let acc4 = add::\u003cPMP\u003e(input[4], input[4]);\r\n        input[4] = add::\u003cPMP\u003e(acc4, acc4);\r\n\r\n        // For the final 3 elements we multiply by 1/2, 3, 4.\r\n        // This gives the negative of the correct answer which\r\n        // will be handled by add_sum().\r\n\r\n        input[5] = halve_avx2::\u003cPMP\u003e(input[5]);\r\n\r\n        let acc6 = add::\u003cPMP\u003e(input[6], input[6]);\r\n        input[6] = add::\u003cPMP\u003e(acc6, input[6]);\r\n\r\n        let acc7 = add::\u003cPMP\u003e(input[7], input[7]);\r\n        input[7] = add::\u003cPMP\u003e(acc7, acc7);\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    /// This function must not touch the first 8 elements of input.\r\n    /// It may output values which might not be in canonical form or\r\n    /// will be the negative of the expected value. This will be\r\n    /// handled by `add_sum` so it is important these elements are\r\n    /// not touched before input is passed into `add_sum`.\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut Self::ArrayLike);\r\n\r\n    /// # Safety\r\n    ///\r\n    /// Sum must be in canonical form and input must be exactly the output of `diagonal_mul`.\r\n    /// If either of these does not hold, the result is undefined.\r\n    ///\r\n    /// Morally this function is computing `x -\u003e x + sum` however there are some places where\r\n    /// the output of `diagonal_mul` is the negative of the expected value or not canonical.\r\n    /// It is the job of add_sum to correct for these irregularities. Where the output is negative\r\n    /// we compute `x -\u003e sum - x` instead and when not in canonical form we use `signed_add_avx2`\r\n    /// where acts as add where one input is allowed to lie in `(-P, P)`.\r\n    #[inline(always)]\r\n    unsafe fn add_sum(input: \u0026mut Self::ArrayLike, sum: __m256i) {\r\n        // Diagonal mul multiplied these by 1, 2, 1/2, 3, 4 so we simply need to add the sum.\r\n        input.as_mut()[..5]\r\n            .iter_mut()\r\n            .for_each(|x| *x = add::\u003cPMP\u003e(sum, *x));\r\n\r\n        // Diagonal mul multiplied these by 1/2, 3, 4 instead of -1/2, -3, -4 so we need to subtract instead of adding.\r\n        input.as_mut()[5..8]\r\n            .iter_mut()\r\n            .for_each(|x| *x = sub::\u003cPMP\u003e(sum, *x));\r\n\r\n        // Diagonal mul output a signed value in (-P, P) so we need to do a signed add.\r\n        // Note that signed add's parameters are not interchangeable. The first parameter must be positive.\r\n        input.as_mut()[8..]\r\n            .iter_mut()\r\n            .for_each(|x| *x = signed_add_avx2::\u003cPMP\u003e(sum, *x));\r\n    }\r\n}\r\n\r\n/// Convert elements from canonical form [0, P) to a negative form in [-P, ..., 0) and copy into a vector.\r\n#[inline(always)]\r\nfn convert_to_vec_neg_form\u003cMP: MontyParameters\u003e(input: i32) -\u003e __m256i {\r\n    let input_sub_p = input - (MP::PRIME as i32);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        x86_64::_mm256_set1_epi32(input_sub_p)\r\n    }\r\n}\r\n\r\nimpl\u003cFP, ILP, const D: u64\u003e InternalLayer\u003cPackedMontyField31AVX2\u003cFP\u003e, 16, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, 16, ILP\u003e\r\nwhere\r\n    FP: FieldParameters,\r\n    ILP: InternalLayerParametersAVX2\u003cFP, 16, ArrayLike = [__m256i; 15]\u003e\r\n        + InternalLayerBaseParameters\u003cFP, 16\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMontyField31AVX2\u003cFP\u003e; 16]) {\r\n        unsafe {\r\n            // Safety: This return values in canonical form when given values in canonical form.\r\n\r\n            /*\r\n                Fix a vector v and let Diag(v) denote the diagonal matrix with diagonal given by v.\r\n                Additionally, let 1 denote the matrix with all elements equal to 1.\r\n                The internal layer consists of an sbox operation then a matrix multiplication by 1 + Diag(v).\r\n                Explicitly the internal layer consists of the following 2 operations:\r\n\r\n                s0 -\u003e (s0 + rc)^d\r\n                s -\u003e (1 + Diag(v))s\r\n\r\n                Note that this matrix multiplication is implemented as:\r\n                sum = sum_i s_i\r\n                s_i -\u003e sum + s_iv_i.\r\n            */\r\n\r\n            let mut internal_state = InternalLayer16::from_packed_field_array(*state);\r\n\r\n            self.packed_internal_constants.iter().for_each(|\u0026rc| {\r\n                add_rc_and_sbox::\u003cFP, D\u003e(\u0026mut internal_state.s0, rc); // s0 -\u003e (s0 + rc)^D\r\n                let sum_non_0 = sum_15(\r\n                    \u0026transmute::\u003c[__m256i; 15], [PackedMontyField31AVX2\u003cFP\u003e; 15]\u003e(\r\n                        internal_state.s_hi,\r\n                    ),\r\n                ); // Get the sum of all elements other than s0.\r\n                ILP::diagonal_mul(\u0026mut internal_state.s_hi); // si -\u003e vi * si for all i \u003e 0.\r\n                let sum = sum_non_0 + internal_state.s0; // Get the full sum.\r\n                internal_state.s0 = sum_non_0 - internal_state.s0; // s0 -\u003e sum - 2*s0 = sum_non_0 - s0.\r\n                ILP::add_sum(\r\n                    \u0026mut internal_state.s_hi,\r\n                    transmute::\u003cPackedMontyField31AVX2\u003cFP\u003e, __m256i\u003e(sum),\r\n                ); // si -\u003e si + sum for all i \u003e 0.\r\n            });\r\n\r\n            // This transformation is safe as the above function returns elements\r\n            // in canonical form when given elements in canonical form.\r\n            *state = InternalLayer16::to_packed_field_array(internal_state);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP, ILP, const D: u64\u003e InternalLayer\u003cPackedMontyField31AVX2\u003cFP\u003e, 24, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, 24, ILP\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n    ILP: InternalLayerParametersAVX2\u003cFP, 24, ArrayLike = [__m256i; 23]\u003e\r\n        + InternalLayerBaseParameters\u003cFP, 24\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMontyField31AVX2\u003cFP\u003e; 24]) {\r\n        unsafe {\r\n            // Safety: This return values in canonical form when given values in canonical form.\r\n\r\n            /*\r\n                Fix a vector v and let Diag(v) denote the diagonal matrix with diagonal given by v.\r\n                Additionally, let 1 denote the matrix with all elements equal to 1.\r\n                The internal layer consists of an sbox operation then a matrix multiplication by 1 + Diag(v).\r\n                Explicitly the internal layer consists of the following 2 operations:\r\n\r\n                s0 -\u003e (s0 + rc)^d\r\n                s -\u003e (1 + Diag(v))s\r\n\r\n                Note that this matrix multiplication is implemented as:\r\n                sum = sum_i s_i\r\n                s_i -\u003e sum + s_iv_i.\r\n            */\r\n\r\n            let mut internal_state = InternalLayer24::from_packed_field_array(*state);\r\n\r\n            self.packed_internal_constants.iter().for_each(|\u0026rc| {\r\n                add_rc_and_sbox::\u003cFP, D\u003e(\u0026mut internal_state.s0, rc); // s0 -\u003e (s0 + rc)^D\r\n                let sum_non_0 = sum_23(\r\n                    \u0026transmute::\u003c[__m256i; 23], [PackedMontyField31AVX2\u003cFP\u003e; 23]\u003e(\r\n                        internal_state.s_hi,\r\n                    ),\r\n                ); // Get the sum of all elements other than s0.\r\n                ILP::diagonal_mul(\u0026mut internal_state.s_hi); // si -\u003e vi * si for all i \u003e 0.\r\n                let sum = sum_non_0 + internal_state.s0; // Get the full sum.\r\n                internal_state.s0 = sum_non_0 - internal_state.s0; // s0 -\u003e sum - 2*s0 = sum_non_0 - s0.\r\n                ILP::add_sum(\r\n                    \u0026mut internal_state.s_hi,\r\n                    transmute::\u003cPackedMontyField31AVX2\u003cFP\u003e, __m256i\u003e(sum),\r\n                ); // si -\u003e si + sum for all i \u003e 0.\r\n            });\r\n\r\n            // This transformation is safe as the above function returns elements\r\n            // in canonical form when given elements in canonical form.\r\n            *state = InternalLayer24::to_packed_field_array(internal_state);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP, const D: u64, const WIDTH: usize\u003e ExternalLayer\u003cPackedMontyField31AVX2\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMontyField31AVX2\u003cFP\u003e; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            \u0026self.packed_initial_external_constants,\r\n            add_rc_and_sbox::\u003cFP, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMontyField31AVX2\u003cFP\u003e; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            \u0026self.packed_terminal_external_constants,\r\n            add_rc_and_sbox::\u003cFP, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":2522015791327480181}},{"line":47,"address":[],"length":0,"stats":{"Line":2522015791327480181}},{"line":53,"address":[],"length":0,"stats":{"Line":2522015791327477819}},{"line":61,"address":[],"length":0,"stats":{"Line":2522015791327477819}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":93,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":3242591731706757925}},{"line":129,"address":[],"length":0,"stats":{"Line":3242591731706757925}},{"line":131,"address":[],"length":0,"stats":{"Line":15348267530078651985}},{"line":159,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":162,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":165,"address":[],"length":0,"stats":{"Line":144115188075855870}},{"line":167,"address":[],"length":0,"stats":{"Line":3242591731706757120}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855877}},{"line":185,"address":[],"length":0,"stats":{"Line":17582052945254416405}},{"line":186,"address":[],"length":0,"stats":{"Line":17582052945254416405}},{"line":187,"address":[],"length":0,"stats":{"Line":15420325124116578306}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":2161727821137838080}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":207,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":208,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":209,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":211,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":243,"address":[],"length":0,"stats":{"Line":18014398509481984242}},{"line":244,"address":[],"length":0,"stats":{"Line":18014398509481984242}},{"line":246,"address":[],"length":0,"stats":{"Line":18014398509481984242}},{"line":260,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":261,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":266,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":267,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":269,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":270,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":272,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":273,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":279,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":281,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":282,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":284,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":285,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":308,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":310,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":312,"address":[],"length":0,"stats":{"Line":15420325124116580719}},{"line":315,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":317,"address":[],"length":0,"stats":{"Line":16285016252571720800}},{"line":321,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":323,"address":[],"length":0,"stats":{"Line":3026418949592978957}},{"line":329,"address":[],"length":0,"stats":{"Line":18086456103519920695}},{"line":330,"address":[],"length":0,"stats":{"Line":18086456103519920695}},{"line":333,"address":[],"length":0,"stats":{"Line":18086456103519920695}},{"line":345,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":349,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":350,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":351,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":352,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":353,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":355,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":356,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":358,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":359,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":360,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":361,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":363,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":365,"address":[],"length":0,"stats":{"Line":17365880163140632576}},{"line":366,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":367,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":368,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":369,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":371,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":372,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":373,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":374,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":375,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":376,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":377,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":378,"address":[],"length":0,"stats":{"Line":14843864371813154816}},{"line":383,"address":[],"length":0,"stats":{"Line":2522015791327477760}},{"line":396,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":400,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":401,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":402,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":403,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":404,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":407,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":409,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":410,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":411,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":412,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":414,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":416,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":417,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":418,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":419,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":420,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":422,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":423,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":424,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":425,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":426,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":427,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":428,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":429,"address":[],"length":0,"stats":{"Line":3170534137668829184}},{"line":434,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":445,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":447,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":448,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":449,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":450,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":455,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":457,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":458,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":459,"address":[],"length":0,"stats":{"Line":2666130979403333691}},{"line":460,"address":[],"length":0,"stats":{"Line":2666130979403333691}}],"covered":115,"coverable":117},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx2","utils.rs"],"content":"use core::arch::x86_64::{self, __m256i};\r\nuse core::mem::transmute;\r\n\r\nuse crate::{MontyParameters, PackedMontyParameters, TwoAdicData};\r\n\r\n// Godbolt file showing that these all compile to the expected instructions. (Potentially plus a few memory ops):\r\n// https://godbolt.org/z/9P71nYrqh\r\n\r\n/// Halve a vector of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline(always)]\r\npub(crate) fn halve_avx2\u003cMP: MontyParameters\u003e(input: __m256i) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpand    least_bit, val, ONE\r\n            vpsrld   t, val, 1\r\n            vpsignd  maybe_half, HALF, least_bit\r\n            vpaddd   res, t, maybe_half\r\n        throughput: 1.33 cyc/vec\r\n        latency: 3 cyc\r\n\r\n        Given an element val in [0, P), we want to compute val/2 mod P.\r\n        If val is even: val/2 mod P = val/2 = val \u003e\u003e 1.\r\n        If val is odd: val/2 mod P = (val + P)/2 = (val \u003e\u003e 1) + (P + 1)/2\r\n    */\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        const ONE: __m256i = unsafe { transmute([1u32; 8]) };\r\n        let half = x86_64::_mm256_set1_epi32((MP::PRIME as i32 + 1) / 2); // Compiler realises this is constant.\r\n\r\n        let least_bit = x86_64::_mm256_and_si256(input, ONE); // Determine the parity of val.\r\n        let t = x86_64::_mm256_srli_epi32::\u003c1\u003e(input);\r\n        // This does nothing when least_bit = 1 and sets the corresponding entry to 0 when least_bit = 0\r\n        let maybe_half = x86_64::_mm256_sign_epi32(half, least_bit);\r\n        x86_64::_mm256_add_epi32(t, maybe_half)\r\n    }\r\n}\r\n\r\n/// Add two vectors of Monty31 field elements with lhs in canonical form and rhs in (-P, P).\r\n///\r\n/// # Safety\r\n///\r\n/// This function is not symmetric in the inputs. The caller must ensure that inputs\r\n/// conform to the expected representation. Each element of lhs must lie in [0, P) and\r\n/// each element of rhs in (-P, P).\r\n#[inline(always)]\r\npub(crate) unsafe fn signed_add_avx2\u003cPMP: PackedMontyParameters\u003e(\r\n    lhs: __m256i,\r\n    rhs: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsignd  pos_neg_P,  P,     rhs\r\n            vpaddd   sum,        lhs,   rhs\r\n            vpsubd   sum_corr,   sum,   pos_neg_P\r\n            vpminud  res,        sum,   sum_corr\r\n        throughput: 1.33 cyc/vec\r\n        latency: 3 cyc\r\n\r\n        While this is more expensive than an add, it is cheaper than reducing the rhs to a canonical value and then adding.\r\n\r\n        We give a short proof that the output is correct:\r\n\r\n        Let t = lhs + rhs mod 2^32, we want to return t mod P while correcting for any possible wraparound.\r\n        We make use of the fact wrapping addition acts identically on signed and unsigned inputs.\r\n\r\n        If rhs is positive, lhs + rhs \u003c 2P \u003c 2^32 and so we interpret t as a unsigned 32 bit integer.\r\n            In this case, t mod P = min_{u32}(t, t - P) where min_{u32} takes the min treating both inputs as unsigned 32 bit integers.\r\n            This works as if t \u003e= P then t - P \u003c t and if t \u003c P then, due to wraparound, t - P outputs t - P + 2^32 \u003e t.\r\n        If rhs is negative, -2^31 \u003c -P \u003c lhs + rhs \u003c P \u003c 2^31 so we interpret t as a signed 32 bit integer.\r\n            In this case t mod P = min_{u32}(t, t + P)\r\n            This works as if t \u003e 0 then t \u003c t + P and if t \u003c 0 then due to wraparound when we interpret t as an unsigned integer it becomes\r\n            2^32 + t \u003e t + P.\r\n        if rhs = 0 then we can just return t = lhs as it is already in the desired range.\r\n    */\r\n    unsafe {\r\n        // If rhs \u003e 0 set the value to P, if rhs \u003c 0 set it to -P and if rhs = 0 set it to 0.\r\n        let pos_neg_p = x86_64::_mm256_sign_epi32(PMP::PACKED_P, rhs);\r\n\r\n        // Compute t = lhs + rhs\r\n        let sum = x86_64::_mm256_add_epi32(lhs, rhs);\r\n\r\n        // sum_corr = (t - P) if rhs \u003e 0, t + P if rhs \u003c 0 and t if rhs = 0 as desired.\r\n        let sum_corr = x86_64::_mm256_sub_epi32(sum, pos_neg_p);\r\n\r\n        x86_64::_mm256_min_epu32(sum, sum_corr)\r\n    }\r\n}\r\n\r\n/*\r\n    Write our prime P as r * 2^j + 1 for odd r.\r\n    The following functions implement x -\u003e +/- 2^{-N} x for varying N and output a value in (-P, P).\r\n    There is one approach which works provided N \u003c 15 and r \u003c 2^15.\r\n    Similarly, there is another approach which works when N = j and when r = 2^i - 1.\r\n\r\n    Both approaches rely on the same basic observation about multiplication by +/- 2^{-N} which we present here.\r\n    We will focus on the -2^{-N} case but note that the case of 2^{-N} is essentially identical.\r\n    The strategy for these products is to observe that -2^{-N} = r2^{j - N} mod P.\r\n    Hence given a field element x write it as x = x_lo + 2^N x_hi where x_lo \u003c 2^N.\r\n    Then -2^{-N} x = -x_hi + r2^{j - N} x_lo.\r\n    Clearly x_hi \u003c P and, as x_lo \u003c 2^N, r2^{j - N} x_lo \u003c r2^j \u003c P so\r\n    -P \u003c r2^{j - N} x_lo - x_hi \u003c P\r\n\r\n    It remains to understand how to efficiently compute r2^{j - N} x_lo. This splits into several cases:\r\n\r\n    When r \u003c 2^16, N \u003c 15, r2^{j - N} x_lo can be computed efficiently using _mm256_madd_epi16.\r\n    This avoids having to split the input in two and doing multiple multiplications and/or monty reductions.\r\n\r\n    There is a further improvement possible when if r \u003c 2^7 and N = 8 using _mm256_maddubs_epi16.\r\n    This lets us avoid a mask and an and so we implement a specialised version for this.\r\n\r\n    When n = j and r = 2^i - 1, rx_lo can also be computed efficiently using a shift and subtraction.\r\n*/\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by 2**{-N}.\r\n///\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^15.\r\n/// N must be between 0 and 15.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_2exp_neg_n_avx2\u003cTAD: TwoAdicData, const N: i32, const N_PRIME: i32\u003e(\r\n    input: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld      hi,       val,      N\r\n            vpand       lo,       val,      2^{N} - 1\r\n            vpmaddwd    lo_x_r,   lo,       [r; 8]\r\n            vpslld      lo_shft,  lo_x_r,   j - N\r\n            vpsubd      res,      hi,       lo_shft\r\n        throughput: 1.67\r\n        latency: 8\r\n    */\r\n    unsafe {\r\n        assert_eq!(N + N_PRIME, TAD::TWO_ADICITY as i32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm256_set1_epi32(TAD::ODD_FACTOR); // This is [r; 8]. Compiler realises this is a constant.\r\n        let mask = x86_64::_mm256_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n\r\n        let hi = x86_64::_mm256_srli_epi32::\u003cN\u003e(input);\r\n        let val_lo = x86_64::_mm256_and_si256(input, mask);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of val_lo, odd_factor are \u003c 2^15, _mm256_madd_epi16\r\n        // performs an element wise multiplication.\r\n        // Thus lo_x_r contains r*x_lo.\r\n        let lo_x_r = x86_64::_mm256_madd_epi16(val_lo, odd_factor);\r\n        let lo = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo_x_r);\r\n        x86_64::_mm256_sub_epi32(hi, lo)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-N}.\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^15.\r\n/// N must be between 0 and 15.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_n_avx2\u003cTAD: TwoAdicData, const N: i32, const N_PRIME: i32\u003e(\r\n    input: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld      hi,       val,      N\r\n            vpand       lo,       val,      2^N - 1\r\n            vpmaddwd    lo_x_r,   lo,       [r; 8]\r\n            vpslld      lo_shft,  lo_x_r,   j - N\r\n            vpsubd      res,      lo_shft,  hi\r\n        throughput: 1.67\r\n        latency: 8\r\n    */\r\n    unsafe {\r\n        assert_eq!(N + N_PRIME, TAD::TWO_ADICITY as i32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm256_set1_epi32(TAD::ODD_FACTOR); // This is [r; 8]. Compiler realises this is a constant.\r\n        let mask = x86_64::_mm256_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n\r\n        let hi = x86_64::_mm256_srli_epi32::\u003cN\u003e(input);\r\n        let lo = x86_64::_mm256_and_si256(input, mask);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of lo, odd_factor are \u003c 2^15, _mm256_madd_epi16\r\n        // performs an element wise multiplication.\r\n        // Thus lo_x_r contains lo * r.\r\n        let lo_x_r = x86_64::_mm256_madd_epi16(lo, odd_factor);\r\n        let lo_shft = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo_x_r);\r\n        x86_64::_mm256_sub_epi32(lo_shft, hi)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by 2**{-8}.\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^7.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_2exp_neg_8_avx2\u003cTAD: TwoAdicData, const N_PRIME: i32\u003e(input: __m256i) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld      hi,      val,    8\r\n            vpmaddubsw  lo_x_r,  val,    [r; 8]\r\n            vpslldq     lo_shft, lo_x_r, j - 8\r\n            vpsubd      t,       hi,     lo_shft\r\n        throughput: 1.33\r\n        latency: 7\r\n    */\r\n    unsafe {\r\n        assert_eq!(8 + N_PRIME, TAD::TWO_ADICITY as i32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm256_set1_epi32(TAD::ODD_FACTOR); // This is [r; 8]. Compiler realises this is a constant.\r\n\r\n        // Get the hi 16 bits shifted down.\r\n        let hi = x86_64::_mm256_srli_epi32::\u003c8\u003e(input);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of odd_factor is \u003c 2^7, _mm256_maddubs_epi16\r\n        // performs an element wise multiplication of odd_factor with\r\n        // the bottom 8 bits of input interpreted as an unsigned integer\r\n        // Thus lo_x_r contains lo * r.\r\n        let lo_x_r = x86_64::_mm256_maddubs_epi16(input, odd_factor);\r\n\r\n        let lo_shft = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo_x_r);\r\n        x86_64::_mm256_sub_epi32(hi, lo_shft)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-8}.\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^7.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_8_avx2\u003cTAD: TwoAdicData, const N_PRIME: i32\u003e(\r\n    input: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld      hi,      val,     8\r\n            vpmaddubsw  lo_x_r,  val,     [r; 8]\r\n            vpslldq     lo_shft, lo_x_r,  j - 8\r\n            vpsubd      t,       lo_shft, hi\r\n        throughput: 1.33\r\n        latency: 7\r\n    */\r\n    unsafe {\r\n        assert_eq!(8 + N_PRIME, TAD::TWO_ADICITY as i32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm256_set1_epi32(TAD::ODD_FACTOR); // This is [r; 8]. Compiler realises this is a constant.\r\n\r\n        // Get the hi 16 bits shifted down.\r\n        let hi = x86_64::_mm256_srli_epi32::\u003c8\u003e(input);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of odd_factor is \u003c 2^7, _mm256_maddubs_epi16\r\n        // performs an element wise multiplication of odd_factor with\r\n        // the bottom 8 bits of input interpreted as an unsigned integer\r\n        // Thus lo_x_r contains lo * r.\r\n        let lo_x_r = x86_64::_mm256_maddubs_epi16(input, odd_factor);\r\n\r\n        let lo_shft = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo_x_r);\r\n        x86_64::_mm256_sub_epi32(lo_shft, hi)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by 2**{-N} where P = 2^31 - 2^N + 1.\r\n/// # Safety\r\n///\r\n/// The prime P must have the form P = 2^31 - 2^N + 1.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_2exp_neg_two_adicity_avx2\u003cTAD: TwoAdicData, const N: i32, const N_PRIME: i32\u003e(\r\n    input: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld  hi,         val,        N\r\n            vpand   lo,         val,        2^{N} - 1\r\n            vpslld  lo_shft,    lo,         31 - N\r\n            vpaddd  lo_plus_hi, lo,         hi\r\n            vpsubd  res         lo_plus_hi, lo_shft,\r\n        throughput: 1.67\r\n        latency: 3\r\n    */\r\n    unsafe {\r\n        assert_eq!(N, (TAD::TWO_ADICITY as i32)); // Compiler removes this provided it is satisfied.\r\n        assert_eq!(N + N_PRIME, 31); // Compiler removes this provided it is satisfied.\r\n\r\n        let mask = x86_64::_mm256_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n        let hi = x86_64::_mm256_srli_epi32::\u003cN\u003e(input);\r\n\r\n        // Provided overflow does not occur, (2^{31 - N} - 1)*x = (x \u003c\u003c {31 - N}) - 1.\r\n        // lo \u003c 2^N =\u003e (lo \u003c\u003c {31 - N}) \u003c 2^31 and (lo \u003c\u003c {31 - N}) - lo \u003c P.\r\n        let lo = x86_64::_mm256_and_si256(input, mask);\r\n        let lo_shft = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo);\r\n        let lo_plus_hi = x86_64::_mm256_add_epi32(lo, hi);\r\n        x86_64::_mm256_sub_epi32(lo_plus_hi, lo_shft)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-N} where P = 2^31 - 2^N + 1.\r\n/// # Safety\r\n///\r\n/// The prime P must have the form P = 2^31 - 2^N + 1.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_two_adicity_avx2\u003c\r\n    TAD: TwoAdicData,\r\n    const N: i32,\r\n    const N_PRIME: i32,\r\n\u003e(\r\n    input: __m256i,\r\n) -\u003e __m256i {\r\n    /*\r\n        We want this to compile to:\r\n            vpsrld  hi,         val,      N\r\n            vpand   lo,         val,      2^{N} - 1\r\n            vpslld  lo_shft,    lo,       31 - N\r\n            vpaddd  lo_plus_hi, lo,       hi\r\n            vpsubd  res         lo_shft,  lo_plus_hi\r\n        throughput: 1.67\r\n        latency: 3\r\n    */\r\n    unsafe {\r\n        assert_eq!(N, (TAD::TWO_ADICITY as i32)); // Compiler removes this provided it is satisfied.\r\n        assert_eq!(N + N_PRIME, 31); // Compiler removes this provided it is satisfied.\r\n\r\n        let mask = x86_64::_mm256_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n        let hi = x86_64::_mm256_srli_epi32::\u003cN\u003e(input);\r\n\r\n        // Provided overflow does not occur, (2^{31 - N} - 1)*x = (x \u003c\u003c {31 - N}) - 1.\r\n        // lo \u003c 2^N =\u003e (lo \u003c\u003c {31 - N}) \u003c 2^31 and (lo \u003c\u003c {31 - N}) - lo \u003c P.\r\n        let lo = x86_64::_mm256_and_si256(input, mask);\r\n        let lo_shft = x86_64::_mm256_slli_epi32::\u003cN_PRIME\u003e(lo);\r\n        let lo_plus_hi = x86_64::_mm256_add_epi32(lo, hi);\r\n        x86_64::_mm256_sub_epi32(lo_shft, lo_plus_hi)\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":29,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":31,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":32,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":34,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":35,"address":[],"length":0,"stats":{"Line":17582052945254417189}},{"line":47,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":51,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":52,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":53,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":54,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":55,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":56,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":57,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":58,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":60,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":62,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":64,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":65,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":67,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":68,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":69,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":70,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":71,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":72,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":73,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":74,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":75,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":78,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":81,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":84,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":86,"address":[],"length":0,"stats":{"Line":3891110078048110156}},{"line":124,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":127,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":128,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":129,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":130,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":131,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":132,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":133,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":134,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":135,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":136,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":138,"address":[],"length":0,"stats":{"Line":13979173243358019823}},{"line":140,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":141,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":143,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":144,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":150,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":151,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":152,"address":[],"length":0,"stats":{"Line":13979173243358019822}},{"line":164,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":167,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":168,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":169,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":170,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":171,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":172,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":173,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":174,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":175,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":176,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":178,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":180,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":181,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":183,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":184,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":190,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":191,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":192,"address":[],"length":0,"stats":{"Line":16861477004875137829}},{"line":203,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":204,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":205,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":206,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":207,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":208,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":209,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":210,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":211,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":212,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":214,"address":[],"length":0,"stats":{"Line":14915921965851088405}},{"line":216,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":219,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":226,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":228,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":229,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":240,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":243,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":244,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":245,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":246,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":247,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":248,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":249,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":250,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":251,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":253,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":255,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":258,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":265,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":267,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":268,"address":[],"length":0,"stats":{"Line":14915921965851083557}},{"line":279,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":282,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":283,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":284,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":285,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":286,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":287,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":288,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":289,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":290,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":291,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":293,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":294,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":296,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":297,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":301,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":302,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":303,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":304,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":315,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":322,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":323,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":324,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":325,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":326,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":327,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":328,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":329,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":330,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":331,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":333,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":334,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":336,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":337,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":341,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":342,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":343,"address":[],"length":0,"stats":{"Line":18014398509481984805}},{"line":344,"address":[],"length":0,"stats":{"Line":18014398509481984805}}],"covered":140,"coverable":140},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx512","mod.rs"],"content":"mod packing;\r\nmod poseidon2;\r\nmod utils;\r\n\r\npub use packing::*;\r\npub use poseidon2::*;\r\npub use utils::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx512","packing.rs"],"content":"use alloc::vec::Vec;\r\nuse core::arch::asm;\r\nuse core::arch::x86_64::{self, __m512i, __mmask16, __mmask8};\r\nuse core::hint::unreachable_unchecked;\r\nuse core::iter::{Product, Sum};\r\nuse core::mem::transmute;\r\nuse core::ops::{Add, AddAssign, Div, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::{\r\n    Algebra, Field, InjectiveMonomial, PackedField, PackedFieldPow2, PackedValue,\r\n    PermutationMonomial, PrimeCharacteristicRing,\r\n};\r\nuse p3_util::convert_vec;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\nuse crate::{FieldParameters, MontyField31, PackedMontyParameters, RelativelyPrimePower};\r\n\r\nconst WIDTH: usize = 16;\r\n\r\npub trait MontyParametersAVX512 {\r\n    const PACKED_P: __m512i;\r\n    const PACKED_MU: __m512i;\r\n}\r\n\r\nconst EVENS: __mmask16 = 0b0101010101010101;\r\nconst EVENS4: __mmask16 = 0x0f0f;\r\n\r\n/// Vectorized AVX-512F implementation of `MontyField31` arithmetic.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\r\n#[repr(transparent)] // This needed to make `transmute`s safe.\r\npub struct PackedMontyField31AVX512\u003cPMP: PackedMontyParameters\u003e(pub [MontyField31\u003cPMP\u003e; WIDTH]);\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Get an arch-specific vector representing the packed values.\r\n    pub(crate) fn to_vector(self) -\u003e __m512i {\r\n        unsafe {\r\n            // Safety: `MontyField31` is `repr(transparent)` so it can be transmuted to `u32`. It\r\n            // follows that `[MontyField31; WIDTH]` can be transmuted to `[u32; WIDTH]`, which can be\r\n            // transmuted to `__m512i`, since arrays are guaranteed to be contiguous in memory.\r\n            // Finally `PackedMontyField31AVX512` is `repr(transparent)` so it can be transmuted to\r\n            // `[MontyField31; WIDTH]`.\r\n            transmute(self)\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Make a packed field vector from an arch-specific vector.\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `vector` represents a valid\r\n    /// `MontyField31`. In particular, each element of vector must be in `0..=P`.\r\n    pub(crate) unsafe fn from_vector(vector: __m512i) -\u003e Self {\r\n        // Safety: It is up to the user to ensure that elements of `vector` represent valid\r\n        // `MontyField31` values. We must only reason about memory representations. `__m512i` can be\r\n        // transmuted to `[u32; WIDTH]` (since arrays elements are contiguous in memory), which can\r\n        // be transmuted to `[MontyField31; WIDTH]` (since `MontyField31` is `repr(transparent)`), which\r\n        // in turn can be transmuted to `PackedMontyField31AVX512` (since `PackedMontyField31AVX512` is also\r\n        // `repr(transparent)`).\r\n        transmute(vector)\r\n    }\r\n\r\n    /// Copy `value` to all positions in a packed vector. This is the same as\r\n    /// `From\u003cMontyField31\u003e::from`, but `const`.\r\n    #[inline]\r\n    #[must_use]\r\n    const fn broadcast(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self([value; WIDTH])\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = add::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `add` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = mul::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `mul` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Neg for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn neg(self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        let res = neg::\u003cPMP\u003e(val);\r\n        unsafe {\r\n            // Safety: `neg` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: Self) -\u003e Self {\r\n        let lhs = self.to_vector();\r\n        let rhs = rhs.to_vector();\r\n        let res = sub::\u003cPMP\u003e(lhs, rhs);\r\n        unsafe {\r\n            // Safety: `sub` returns values in canonical form when given values in canonical form.\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n}\r\n\r\n// See https://godbolt.org/z/489aaPhz3 showing that this mostly compiles to what we want (Atleast on the AMD Zen 4 architecture).\r\n\r\n/// Add two vectors of MontyField31 elements in canonical form.\r\n///\r\n/// We allow a slight loosening of the canonical form requirement. One of this inputs\r\n/// must be in canonical form [0, P) but the other is also allowed to equal P.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn add\u003cMPAVX512: MontyParametersAVX512\u003e(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vpaddd   t, lhs, rhs\r\n    //      vpsubd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1.5 cyc/vec (10.67 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    // Let t := lhs + rhs. We want to return t mod P. Recall that lhs and rhs are in [0, P]\r\n    //   with at most one of them equal to P. Hence t is in [0, 2P - 1] and so it suffices\r\n    //   to return t if t \u003c P and t - P otherwise.\r\n    // Let u := (t - P) mod 2^32 and r := unsigned_min(t, u).\r\n    // If t is in [0, P - 1], then u is in (P - 1 \u003c) 2^32 - P, ..., 2^32 - 1 and r = t.\r\n    // Otherwise, t is in [P, 2P - 1], and u is in [0, P - 1] (\u003c P) and r = u. Hence, r is t if\r\n    //   t \u003c P and t - P otherwise, as desired.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let t = x86_64::_mm512_add_epi32(lhs, rhs);\r\n        let u = x86_64::_mm512_sub_epi32(t, MPAVX512::PACKED_P);\r\n        x86_64::_mm512_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n/// Subtract vectors of MontyField31 elements in canonical form.\r\n///\r\n/// We allow a slight loosening of the canonical form requirement. The\r\n/// rhs input is additionally allowed to be P.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn sub\u003cMPAVX512: MontyParametersAVX512\u003e(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vpsubd   t, lhs, rhs\r\n    //      vpaddd   u, t, P\r\n    //      vpminud  res, t, u\r\n    // throughput: 1.5 cyc/vec (10.67 els/cyc)\r\n    // latency: 3 cyc\r\n\r\n    // Let t := lhs - rhs. We want to return t mod P. Recall that lhs is in [0, P - 1]\r\n    //   and rhs is in [0, P] so t is in (-2^31 \u003c) -P, ..., P - 1 (\u003c 2^31). It suffices to return t if\r\n    //   t \u003e= 0 and t + P otherwise.\r\n    // Let u := (t + P) mod 2^32 and r := unsigned_min(t, u).\r\n    // If t is in [0, P - 1], then u is in P, ..., 2 P - 1 and r = t.\r\n    // Otherwise, t is in [-P, -1], u is in [0, P - 1] (\u003c P) and r = u. Hence, r is t if\r\n    //   t \u003c P and t - P otherwise, as desired.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let t = x86_64::_mm512_sub_epi32(lhs, rhs);\r\n        let u = x86_64::_mm512_add_epi32(t, MPAVX512::PACKED_P);\r\n        x86_64::_mm512_min_epu32(t, u)\r\n    }\r\n}\r\n\r\n/// No-op. Prevents the compiler from deducing the value of the vector.\r\n///\r\n/// Similar to `std::hint::black_box`, it can be used to stop the compiler applying undesirable\r\n/// \"optimizations\". Unlike the built-in `black_box`, it does not force the value to be written to\r\n/// and then read from the stack.\r\n#[inline]\r\n#[must_use]\r\nfn confuse_compiler(x: __m512i) -\u003e __m512i {\r\n    let y;\r\n    unsafe {\r\n        asm!(\r\n            \"/*{0}*/\",\r\n            inlateout(zmm_reg) x =\u003e y,\r\n            options(nomem, nostack, preserves_flags, pure),\r\n        );\r\n        // Below tells the compiler the semantics of this so it can still do constant folding, etc.\r\n        // You may ask, doesn't it defeat the point of the inline asm block to tell the compiler\r\n        // what it does? The answer is that we still inhibit the transform we want to avoid, so\r\n        // apparently not. Idk, LLVM works in mysterious ways.\r\n        if transmute::\u003c__m512i, [u32; 16]\u003e(x) != transmute::\u003c__m512i, [u32; 16]\u003e(y) {\r\n            unreachable_unchecked();\r\n        }\r\n    }\r\n    y\r\n}\r\n\r\n// MONTGOMERY MULTIPLICATION\r\n//   This implementation is based on [1] but with minor changes. The reduction is as follows:\r\n//\r\n// Constants: P \u003c 2^31\r\n//            B = 2^32\r\n//             = P^-1 mod B\r\n// Input: 0 \u003c= C \u003c P B\r\n// Output: 0 \u003c= R \u003c P such that R = C B^-1 (mod P)\r\n//   1. Q :=  C mod B\r\n//   2. D := (C - Q P) / B\r\n//   3. R := if D \u003c 0 then D + P else D\r\n//\r\n// We first show that the division in step 2. is exact. It suffices to show that C = Q P (mod B). By\r\n// definition of Q and , we have Q P =  C P = P^-1 C P = C (mod B). We also have\r\n// C - Q P = C (mod P), so thus D = C B^-1 (mod P).\r\n//\r\n// It remains to show that R is in the correct range. It suffices to show that -P \u003c= D \u003c P. We know\r\n// that 0 \u003c= C \u003c P B and 0 \u003c= Q P \u003c P B. Then -P B \u003c C - QP \u003c P B and -P \u003c D \u003c P, as desired.\r\n//\r\n// [1] Modern Computer Arithmetic, Richard Brent and Paul Zimmermann, Cambridge University Press,\r\n//     2010, algorithm 2.7.\r\n\r\n/// Perform a partial Montgomery reduction on each 64 bit element.\r\n/// Input must lie in {0, ..., 2^32P}.\r\n/// The output will lie in {-P, ..., P} and be stored in the upper 32 bits.\r\n#[inline]\r\n#[must_use]\r\nfn partial_monty_red_unsigned_to_signed\u003cMPAVX512: MontyParametersAVX512\u003e(\r\n    input: __m512i,\r\n) -\u003e __m512i {\r\n    unsafe {\r\n        // We throw a confuse compiler here to prevent the compiler from\r\n        // using vpmullq instead of vpmuludq in the computations for q_p.\r\n        // vpmullq has both higher latency and lower throughput.\r\n        let q = confuse_compiler(x86_64::_mm512_mul_epu32(input, MPAVX512::PACKED_MU));\r\n        let q_p = x86_64::_mm512_mul_epu32(q, MPAVX512::PACKED_P);\r\n\r\n        // This could equivalently be _mm512_sub_epi64\r\n        x86_64::_mm512_sub_epi32(input, q_p)\r\n    }\r\n}\r\n\r\n/// Perform a partial Montgomery reduction on each 64 bit element.\r\n/// Input must lie in {-2^{31}P, ..., 2^31P}.\r\n/// The output will lie in {-P, ..., P} and be stored in the upper 32 bits.\r\n#[inline]\r\n#[must_use]\r\nfn partial_monty_red_signed_to_signed\u003cMPAVX512: MontyParametersAVX512\u003e(input: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // We throw a confuse compiler here to prevent the compiler from\r\n        // using vpmullq instead of vpmuludq in the computations for q_p.\r\n        // vpmullq has both higher latency and lower throughput.\r\n        let q = confuse_compiler(x86_64::_mm512_mul_epi32(input, MPAVX512::PACKED_MU));\r\n        let q_p = x86_64::_mm512_mul_epi32(q, MPAVX512::PACKED_P);\r\n\r\n        // This could equivalently be _mm512_sub_epi64\r\n        x86_64::_mm512_sub_epi32(input, q_p)\r\n    }\r\n}\r\n\r\n/// Viewing the input as a vector of 16 `u32`s, copy the odd elements into the even elements below\r\n/// them. In other words, for all `0 \u003c= i \u003c 8`, set the even elements according to\r\n/// `res[2 * i] := a[2 * i + 1]`, and the odd elements according to\r\n/// `res[2 * i + 1] := a[2 * i + 1]`.\r\n#[inline]\r\n#[must_use]\r\nfn movehdup_epi32(a: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        x86_64::_mm512_castps_si512(x86_64::_mm512_movehdup_ps(x86_64::_mm512_castsi512_ps(a)))\r\n    }\r\n}\r\n\r\n/// Viewing `a` as a vector of 16 `u32`s, copy the odd elements into the even elements below them,\r\n/// then merge with `src` according to the mask provided. In other words, for all `0 \u003c= i \u003c 8`, set\r\n/// the even elements according to `res[2 * i] := if k[2 * i] { a[2 * i + 1] } else { src[2 * i] }`,\r\n/// and the odd elements according to\r\n/// `res[2 * i + 1] := if k[2 * i + 1] { a[2 * i + 1] } else { src[2 * i + 1] }`.\r\n#[inline]\r\n#[must_use]\r\nfn mask_movehdup_epi32(src: __m512i, k: __mmask16, a: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters.\r\n\r\n    // Annoyingly, when inlined into the mul function, an intrinsic seems to compile\r\n    // to a vpermt2ps which has worse latency, see https://godbolt.org/z/489aaPhz3. We use inline\r\n    // assembly to force the compiler to do the right thing.\r\n    unsafe {\r\n        let dst: __m512i;\r\n        asm!(\r\n            \"vmovshdup {src_dst}{{{k}}}, {a}\",\r\n            src_dst = inlateout(zmm_reg) src =\u003e dst,\r\n            k = in(kreg) k,\r\n            a = in(zmm_reg) a,\r\n            options(nomem, nostack, preserves_flags, pure),\r\n        );\r\n        dst\r\n    }\r\n}\r\n\r\n/// Multiply vectors of MontyField31 elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn mul\u003cMPAVX512: MontyParametersAVX512\u003e(lhs: __m512i, rhs: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vmovshdup  lhs_odd, lhs\r\n    //      vmovshdup  rhs_odd, rhs\r\n    //      vpmuludq   prod_evn, lhs, rhs\r\n    //      vpmuludq   prod_hi, lhs_odd, rhs_odd\r\n    //      vpmuludq   q_evn, prod_evn, MU\r\n    //      vpmuludq   q_odd, prod_hi, MU\r\n    //      vmovshdup  prod_hi{EVENS}, prod_evn\r\n    //      vpmuludq   q_p_evn, q_evn, P\r\n    //      vpmuludq   q_p_hi, q_odd, P\r\n    //      vmovshdup  q_p_hi{EVENS}, q_p_evn\r\n    //      vpcmpltud  underflow, prod_hi, q_p_hi\r\n    //      vpsubd     res, prod_hi, q_p_hi\r\n    //      vpaddd     res{underflow}, res, P\r\n    // throughput: 6.5 cyc/vec (2.46 els/cyc)\r\n    // latency: 21 cyc\r\n    unsafe {\r\n        // `vpmuludq` only reads the even doublewords, so when we pass `lhs` and `rhs` directly we\r\n        // get the eight products at even positions.\r\n        let lhs_evn = lhs;\r\n        let rhs_evn = rhs;\r\n\r\n        // Copy the odd doublewords into even positions to compute the eight products at odd\r\n        // positions.\r\n        // NB: The odd doublewords are ignored by `vpmuludq`, so we have a lot of choices for how to\r\n        // do this; `vmovshdup` is nice because it runs on a memory port if the operand is in\r\n        // memory, thus improving our throughput.\r\n        let lhs_odd = movehdup_epi32(lhs);\r\n        let rhs_odd = movehdup_epi32(rhs);\r\n\r\n        let prod_evn = x86_64::_mm512_mul_epu32(lhs_evn, rhs_evn);\r\n        let prod_odd = x86_64::_mm512_mul_epu32(lhs_odd, rhs_odd);\r\n\r\n        // We throw a confuse compiler here to prevent the compiler from\r\n        // using vpmullq instead of vpmuludq in the computations for q_p.\r\n        // vpmullq has both higher latency and lower throughput.\r\n        let q_evn = confuse_compiler(x86_64::_mm512_mul_epu32(prod_evn, MPAVX512::PACKED_MU));\r\n        let q_odd = confuse_compiler(x86_64::_mm512_mul_epu32(prod_odd, MPAVX512::PACKED_MU));\r\n\r\n        // Get all the high halves as one vector: this is `(lhs * rhs) \u003e\u003e 32`.\r\n        // NB: `vpermt2d` may feel like a more intuitive choice here, but it has much higher\r\n        // latency.\r\n        //\r\n        // Annoyingly, this (and the line for computing q_p_hi) seem to compile\r\n        // to a vpermt2ps, see https://godbolt.org/z/489aaPhz3.\r\n        //\r\n        // Hopefully this should be only a negligible difference to throughput and so we don't\r\n        // fix it right now. Maybe the compiler works it out when mul is inlined?\r\n        let prod_hi = mask_movehdup_epi32(prod_odd, EVENS, prod_evn);\r\n\r\n        // Normally we'd want to mask to perform % 2**32, but the instruction below only reads the\r\n        // low 32 bits anyway.\r\n        let q_p_evn = x86_64::_mm512_mul_epu32(q_evn, MPAVX512::PACKED_P);\r\n        let q_p_odd = x86_64::_mm512_mul_epu32(q_odd, MPAVX512::PACKED_P);\r\n\r\n        // We can ignore all the low halves of `q_p` as they cancel out. Get all the high halves as\r\n        // one vector.\r\n        let q_p_hi = mask_movehdup_epi32(q_p_odd, EVENS, q_p_evn);\r\n\r\n        // Subtraction `prod_hi - q_p_hi` modulo `P`.\r\n        // NB: Normally we'd `vpaddd P` and take the `vpminud`, but `vpminud` runs on port 0, which\r\n        // is already under a lot of pressure performing multiplications. To relieve this pressure,\r\n        // we check for underflow to generate a mask, and then conditionally add `P`. The underflow\r\n        // check runs on port 5, increasing our throughput, although it does cost us an additional\r\n        // cycle of latency.\r\n        let underflow = x86_64::_mm512_cmplt_epu32_mask(prod_hi, q_p_hi);\r\n        let t = x86_64::_mm512_sub_epi32(prod_hi, q_p_hi);\r\n        x86_64::_mm512_mask_add_epi32(t, underflow, t, MPAVX512::PACKED_P)\r\n    }\r\n}\r\n\r\n/// Square the MontyField31 elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will be a signed integer in (-P, ..., P) copied into both the even and odd indices.\r\n#[inline]\r\n#[must_use]\r\nfn shifted_square\u003cMPAVX512: MontyParametersAVX512\u003e(input: __m512i) -\u003e __m512i {\r\n    // Note that we do not need a restriction on the size of input[i]^2 as\r\n    // 2^30 \u003c P and |i32| \u003c= 2^31 and so =\u003e input[i]^2 \u003c= 2^62 \u003c 2^32P.\r\n    unsafe {\r\n        let square = x86_64::_mm512_mul_epi32(input, input);\r\n        let square_red = partial_monty_red_unsigned_to_signed::\u003cMPAVX512\u003e(square);\r\n        movehdup_epi32(square_red)\r\n    }\r\n}\r\n\r\n/// Cube the MontyField31 elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will be signed integers in (-P^2, ..., P^2).\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_3\u003cMPAVX512: MontyParametersAVX512\u003e(input: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        let square = shifted_square::\u003cMPAVX512\u003e(input);\r\n        x86_64::_mm512_mul_epi32(square, input)\r\n    }\r\n}\r\n\r\n/// Take the fifth power of the MontyField31 elements in the even index entries.\r\n/// Inputs must be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will be signed integers in (-P^2, ..., P^2).\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_5\u003cMPAVX512: MontyParametersAVX512\u003e(input: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        let square = shifted_square::\u003cMPAVX512\u003e(input);\r\n        let quad = shifted_square::\u003cMPAVX512\u003e(square);\r\n        x86_64::_mm512_mul_epi32(quad, input)\r\n    }\r\n}\r\n\r\n/// Take the seventh power of the MontyField31 elements in the even index entries.\r\n/// Inputs must lie in [-P, ..., P].\r\n/// Outputs will be signed integers in (-P^2, ..., P^2).\r\n#[inline]\r\n#[must_use]\r\npub(crate) fn packed_exp_7\u003cMPAVX512: MontyParametersAVX512\u003e(input: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        let square = shifted_square::\u003cMPAVX512\u003e(input);\r\n        let cube_raw = x86_64::_mm512_mul_epi32(square, input);\r\n        let cube_red = partial_monty_red_signed_to_signed::\u003cMPAVX512\u003e(cube_raw);\r\n        let cube = movehdup_epi32(cube_red);\r\n        let quad = shifted_square::\u003cMPAVX512\u003e(square);\r\n        x86_64::_mm512_mul_epi32(quad, cube)\r\n    }\r\n}\r\n\r\n/// Apply func to the even and odd indices of the input vector.\r\n///\r\n/// func should only depend in the 32 bit entries in the even indices.\r\n/// The input should conform to the requirements of `func`.\r\n/// The output of func must lie in (-P^2, ..., P^2) after which\r\n/// apply_func_to_even_odd will reduce the outputs to lie in [0, P)\r\n/// and recombine the odd and even parts.\r\n#[inline]\r\n#[must_use]\r\npub(crate) unsafe fn apply_func_to_even_odd\u003cMPAVX512: MontyParametersAVX512\u003e(\r\n    input: __m512i,\r\n    func: fn(__m512i) -\u003e __m512i,\r\n) -\u003e __m512i {\r\n    let input_evn = input;\r\n    let input_odd = movehdup_epi32(input);\r\n\r\n    // Unlike the mul function, we need to receive back values the reduced\r\n    let output_even = func(input_evn);\r\n    let output_odd = func(input_odd);\r\n\r\n    // We need to recombine these even and odd parts and, at the same time reduce back to\r\n    // and output in [0, P).\r\n\r\n    // We throw a confuse compiler here to prevent the compiler from\r\n    // using vpmullq instead of vpmuludq in the computations for q_p.\r\n    // vpmullq has both higher latency and lower throughput.\r\n    let q_evn = confuse_compiler(x86_64::_mm512_mul_epi32(output_even, MPAVX512::PACKED_MU));\r\n    let q_odd = confuse_compiler(x86_64::_mm512_mul_epi32(output_odd, MPAVX512::PACKED_MU));\r\n\r\n    // Get all the high halves as one vector: this is `(lhs * rhs) \u003e\u003e 32`.\r\n    // NB: `vpermt2d` may feel like a more intuitive choice here, but it has much higher\r\n    // latency.\r\n    //\r\n    // Annoyingly, this (and the line for computing q_p_hi) seem to compile\r\n    // to a vpermt2ps, see https://godbolt.org/z/489aaPhz3.\r\n    //\r\n    // Hopefully this should be only a negligible difference to throughput and so we don't\r\n    // fix it right now. Maybe the compiler works it out when apply_func_to_even_odd is inlined?\r\n    let output_hi = mask_movehdup_epi32(output_odd, EVENS, output_even);\r\n\r\n    // Normally we'd want to mask to perform % 2**32, but the instruction below only reads the\r\n    // low 32 bits anyway.\r\n    let q_p_evn = x86_64::_mm512_mul_epi32(q_evn, MPAVX512::PACKED_P);\r\n    let q_p_odd = x86_64::_mm512_mul_epi32(q_odd, MPAVX512::PACKED_P);\r\n\r\n    // We can ignore all the low halves of `q_p` as they cancel out. Get all the high halves as\r\n    // one vector.\r\n    let q_p_hi = mask_movehdup_epi32(q_p_odd, EVENS, q_p_evn);\r\n\r\n    // Subtraction `output_hi - q_p_hi` modulo `P`.\r\n    // NB: Normally we'd `vpaddd P` and take the `vpminud`, but `vpminud` runs on port 0, which\r\n    // is already under a lot of pressure performing multiplications. To relieve this pressure,\r\n    // we check for underflow to generate a mask, and then conditionally add `P`. The underflow\r\n    // check runs on port 5, increasing our throughput, although it does cost us an additional\r\n    // cycle of latency.\r\n    let underflow = x86_64::_mm512_cmplt_epi32_mask(output_hi, q_p_hi);\r\n    let t = x86_64::_mm512_sub_epi32(output_hi, q_p_hi);\r\n    x86_64::_mm512_mask_add_epi32(t, underflow, t, MPAVX512::PACKED_P)\r\n}\r\n\r\n/// Negate a vector of MontyField31 elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline]\r\n#[must_use]\r\nfn neg\u003cMPAVX512: MontyParametersAVX512\u003e(val: __m512i) -\u003e __m512i {\r\n    // We want this to compile to:\r\n    //      vptestmd  nonzero, val, val\r\n    //      vpsubd    res{nonzero}{z}, P, val\r\n    // throughput: 1 cyc/vec (16 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    // NB: This routine prioritizes throughput over latency. An alternative method would be to do\r\n    // sub(0, val), which would result in shorter latency, but also lower throughput.\r\n\r\n    //   If val is nonzero, then val is in {1, ..., P - 1} and P - val is in the same range. If val\r\n    // is zero, then the result is zeroed by masking.\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        let nonzero = x86_64::_mm512_test_epi32_mask(val, val);\r\n        x86_64::_mm512_maskz_sub_epi32(nonzero, MPAVX512::PACKED_P, val)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e From\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn from(value: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        Self::broadcast(value)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Default for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn default() -\u003e Self {\r\n        MontyField31::default().into()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self + rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self * rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: Self) {\r\n        *self = *self - rhs;\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum for PackedMontyField31AVX512\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs + rhs).unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product for PackedMontyField31AVX512\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = Self\u003e,\r\n    {\r\n        iter.reduce(|lhs, rhs| lhs * rhs).unwrap_or(Self::ONE)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e PrimeCharacteristicRing for PackedMontyField31AVX512\u003cFP\u003e {\r\n    type PrimeSubfield = MontyField31\u003cFP\u003e;\r\n\r\n    const ZERO: Self = Self::broadcast(MontyField31::ZERO);\r\n    const ONE: Self = Self::broadcast(MontyField31::ONE);\r\n    const TWO: Self = Self::broadcast(MontyField31::TWO);\r\n    const NEG_ONE: Self = Self::broadcast(MontyField31::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        f.into()\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn zero_vec(len: usize) -\u003e Vec\u003cSelf\u003e {\r\n        // SAFETY: this is a repr(transparent) wrapper around an array.\r\n        unsafe { convert_vec(MontyField31::\u003cFP\u003e::zero_vec(len * WIDTH)) }\r\n    }\r\n\r\n    #[inline]\r\n    fn cube(\u0026self) -\u003e Self {\r\n        let val = self.to_vector();\r\n        unsafe {\r\n            // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n            let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_3::\u003cFP\u003e);\r\n            Self::from_vector(res)\r\n        }\r\n    }\r\n\r\n    #[must_use]\r\n    #[inline(always)]\r\n    fn exp_const_u64\u003cconst POWER: u64\u003e(\u0026self) -\u003e Self {\r\n        // We provide specialised code for the powers 3, 5, 7 as these turn up regularly.\r\n        // The other powers could be specialised similarly but we ignore this for now.\r\n        // These ideas could also be used to speed up the more generic exp_u64.\r\n        match POWER {\r\n            0 =\u003e Self::ONE,\r\n            1 =\u003e *self,\r\n            2 =\u003e self.square(),\r\n            3 =\u003e self.cube(),\r\n            4 =\u003e self.square().square(),\r\n            5 =\u003e {\r\n                let val = self.to_vector();\r\n                unsafe {\r\n                    // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n                    let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_5::\u003cFP\u003e);\r\n                    Self::from_vector(res)\r\n                }\r\n            }\r\n            6 =\u003e self.square().cube(),\r\n            7 =\u003e {\r\n                let val = self.to_vector();\r\n                unsafe {\r\n                    // Safety: `apply_func_to_even_odd` returns values in canonical form when given values in canonical form.\r\n                    let res = apply_func_to_even_odd::\u003cFP\u003e(val, packed_exp_7::\u003cFP\u003e);\r\n                    Self::from_vector(res)\r\n                }\r\n            }\r\n            _ =\u003e self.exp_u64(POWER),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Algebra\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX512\u003cFP\u003e {}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e InjectiveMonomial\u003cD\u003e\r\n    for PackedMontyField31AVX512\u003cFP\u003e\r\n{\r\n}\r\n\r\nimpl\u003cFP: FieldParameters + RelativelyPrimePower\u003cD\u003e, const D: u64\u003e PermutationMonomial\u003cD\u003e\r\n    for PackedMontyField31AVX512\u003cFP\u003e\r\n{\r\n    fn injective_exp_root_n(\u0026self) -\u003e Self {\r\n        FP::exp_root_d(*self)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn add(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self + Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn mul(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self * Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    type Output = Self;\r\n    #[inline]\r\n    fn sub(self, rhs: MontyField31\u003cPMP\u003e) -\u003e Self {\r\n        self - Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e AddAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn add_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self += Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e MulAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn mul_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self *= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e SubAssign\u003cMontyField31\u003cPMP\u003e\u003e for PackedMontyField31AVX512\u003cPMP\u003e {\r\n    #[inline]\r\n    fn sub_assign(\u0026mut self, rhs: MontyField31\u003cPMP\u003e) {\r\n        *self -= Self::from(rhs)\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Sum\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX512\u003cFP\u003e {\r\n    #[inline]\r\n    fn sum\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.sum::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Product\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX512\u003cFP\u003e {\r\n    #[inline]\r\n    fn product\u003cI\u003e(iter: I) -\u003e Self\r\n    where\r\n        I: Iterator\u003cItem = MontyField31\u003cFP\u003e\u003e,\r\n    {\r\n        iter.product::\u003cMontyField31\u003cFP\u003e\u003e().into()\r\n    }\r\n}\r\n\r\nimpl\u003cFP: FieldParameters\u003e Div\u003cMontyField31\u003cFP\u003e\u003e for PackedMontyField31AVX512\u003cFP\u003e {\r\n    type Output = Self;\r\n    #[allow(clippy::suspicious_arithmetic_impl)]\r\n    #[inline]\r\n    fn div(self, rhs: MontyField31\u003cFP\u003e) -\u003e Self {\r\n        self * rhs.inverse()\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Add\u003cPackedMontyField31AVX512\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX512\u003cPMP\u003e;\r\n    #[inline]\r\n    fn add(self, rhs: PackedMontyField31AVX512\u003cPMP\u003e) -\u003e PackedMontyField31AVX512\u003cPMP\u003e {\r\n        PackedMontyField31AVX512::\u003cPMP\u003e::from(self) + rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Mul\u003cPackedMontyField31AVX512\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX512\u003cPMP\u003e;\r\n    #[inline]\r\n    fn mul(self, rhs: PackedMontyField31AVX512\u003cPMP\u003e) -\u003e PackedMontyField31AVX512\u003cPMP\u003e {\r\n        PackedMontyField31AVX512::\u003cPMP\u003e::from(self) * rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Sub\u003cPackedMontyField31AVX512\u003cPMP\u003e\u003e for MontyField31\u003cPMP\u003e {\r\n    type Output = PackedMontyField31AVX512\u003cPMP\u003e;\r\n    #[inline]\r\n    fn sub(self, rhs: PackedMontyField31AVX512\u003cPMP\u003e) -\u003e PackedMontyField31AVX512\u003cPMP\u003e {\r\n        PackedMontyField31AVX512::\u003cPMP\u003e::from(self) - rhs\r\n    }\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e Distribution\u003cPackedMontyField31AVX512\u003cPMP\u003e\u003e for Standard {\r\n    #[inline]\r\n    fn sample\u003cR: Rng + ?Sized\u003e(\u0026self, rng: \u0026mut R) -\u003e PackedMontyField31AVX512\u003cPMP\u003e {\r\n        PackedMontyField31AVX512::\u003cPMP\u003e(rng.gen())\r\n    }\r\n}\r\n\r\n// vpshrdq requires AVX-512VBMI2.\r\n#[cfg(target_feature = \"avx512vbmi2\")]\r\n#[inline]\r\n#[must_use]\r\nfn interleave1_antidiagonal(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512VBMI2 intrinsics are available.\r\n        x86_64::_mm512_shrdi_epi64::\u003c32\u003e(y, x)\r\n    }\r\n}\r\n\r\n// If we can't use vpshrdq, then do a vpermi2d, but we waste a register and double the latency.\r\n#[cfg(not(target_feature = \"avx512vbmi2\"))]\r\n#[inline]\r\n#[must_use]\r\nfn interleave1_antidiagonal(x: __m512i, y: __m512i) -\u003e __m512i {\r\n    const INTERLEAVE1_INDICES: __m512i = unsafe {\r\n        // Safety: `[u32; 16]` is trivially transmutable to `__m512i`.\r\n        transmute::\u003c[u32; WIDTH], _\u003e([\r\n            0x01, 0x10, 0x03, 0x12, 0x05, 0x14, 0x07, 0x16, 0x09, 0x18, 0x0b, 0x1a, 0x0d, 0x1c,\r\n            0x0f, 0x1e,\r\n        ])\r\n    };\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n        x86_64::_mm512_permutex2var_epi32(x, INTERLEAVE1_INDICES, y)\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave1(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // If we have AVX-512VBMI2, we want this to compile to:\r\n    //      vpshrdq    t, x, y, 32\r\n    //      vpblendmd  res0 {EVENS}, t, x\r\n    //      vpblendmd  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 2 cyc\r\n    //\r\n    // Otherwise, we want it to compile to:\r\n    //      vmovdqa32  t, INTERLEAVE1_INDICES\r\n    //      vpermi2d   t, x, y\r\n    //      vpblendmd  res0 {EVENS}, t, x\r\n    //      vpblendmd  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    // We currently have:\r\n    //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n    //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n    // First form\r\n    //   t = [ x1  y0  x3  y2  x5  y4  x7  y6  x9  y8  xb  ya  xd  yc  xf  ye ].\r\n    let t = interleave1_antidiagonal(x, y);\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // Then\r\n        //   res0 = [ x0  y0  x2  y2  x4  y4  x6  y6  x8  y8  xa  ya  xc  yc  xe  ye ],\r\n        //   res1 = [ x1  y1  x3  y3  x5  y5  x7  y7  x9  y9  xb  yb  xd  yd  xf  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi32(EVENS, t, x),\r\n            x86_64::_mm512_mask_blend_epi32(EVENS, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn shuffle_epi64\u003cconst MASK: i32\u003e(a: __m512i, b: __m512i) -\u003e __m512i {\r\n    // The instruction is only available in the floating-point flavor; this distinction is only for\r\n    // historical reasons and no longer matters. We cast to floats, do the thing, and cast back.\r\n    unsafe {\r\n        let a = x86_64::_mm512_castsi512_pd(a);\r\n        let b = x86_64::_mm512_castsi512_pd(b);\r\n        x86_64::_mm512_castpd_si512(x86_64::_mm512_shuffle_pd::\u003cMASK\u003e(a, b))\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave2(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vshufpd    t, x, y, 55h\r\n    //      vpblendmq  res0 {EVENS}, t, x\r\n    //      vpblendmq  res1 {EVENS}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 2 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x2  x3  y0  y1  x6  x7  y4  y5  xa  xb  y8  y9  xe  xf  yc  yd ].\r\n        let t = shuffle_epi64::\u003c0b01010101\u003e(x, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  y0  y1  x4  x5  y4  y5  x8  x9  y8  y9  xc  xd  yc  yd ],\r\n        //   res1 = [ x2  x3  y2  y3  x6  x7  y6  y7  xa  xb  ya  yb  xe  xf  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi64(EVENS as __mmask8, t, x),\r\n            x86_64::_mm512_mask_blend_epi64(EVENS as __mmask8, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave4(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vmovdqa64   t, INTERLEAVE4_INDICES\r\n    //      vpermi2q    t, x, y\r\n    //      vpblendmd   res0 {EVENS4}, t, x\r\n    //      vpblendmd   res1 {EVENS4}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    const INTERLEAVE4_INDICES: __m512i = unsafe {\r\n        // Safety: `[u64; 8]` is trivially transmutable to `__m512i`.\r\n        transmute::\u003c[u64; WIDTH / 2], _\u003e([0o02, 0o03, 0o10, 0o11, 0o06, 0o07, 0o14, 0o15])\r\n    };\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x4  x5  x6  x7  y0  y1  y2  y3  xc  xd  xe  xf  y8  y9  ya  yb ].\r\n        let t = x86_64::_mm512_permutex2var_epi64(x, INTERLEAVE4_INDICES, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  x2  x3  y0  y1  y2  y3  x8  x9  xa  xb  y8  y9  ya  yb ],\r\n        //   res1 = [ x4  x5  x6  x7  y4  y5  y6  y7  xc  xd  xe  xf  yc  yd  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi32(EVENS4, t, x),\r\n            x86_64::_mm512_mask_blend_epi32(EVENS4, y, t),\r\n        )\r\n    }\r\n}\r\n\r\n#[inline]\r\n#[must_use]\r\nfn interleave8(x: __m512i, y: __m512i) -\u003e (__m512i, __m512i) {\r\n    // We want this to compile to:\r\n    //      vshufi64x2  t, x, b, 4eh\r\n    //      vpblendmq   res0 {EVENS4}, t, x\r\n    //      vpblendmq   res1 {EVENS4}, y, t\r\n    // throughput: 1.5 cyc/2 vec (21.33 els/cyc)\r\n    // latency: 4 cyc\r\n\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX-512F intrinsics are available.\r\n\r\n        // We currently have:\r\n        //   x = [ x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf ],\r\n        //   y = [ y0  y1  y2  y3  y4  y5  y6  y7  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        // First form\r\n        //   t = [ x8  x9  xa  xb  xc  xd  xe  xf  y0  y1  y2  y3  y4  y5  y6  y7 ].\r\n        let t = x86_64::_mm512_shuffle_i64x2::\u003c0b01_00_11_10\u003e(x, y);\r\n\r\n        // Then\r\n        //   res0 = [ x0  x1  x2  x3  x4  x5  x6  x7  y0  y1  y2  y3  y4  y5  y6  y7 ],\r\n        //   res1 = [ x8  x9  xa  xb  xc  xd  xe  xf  y8  y9  ya  yb  yc  yd  ye  yf ].\r\n        (\r\n            x86_64::_mm512_mask_blend_epi64(EVENS4 as __mmask8, t, x),\r\n            x86_64::_mm512_mask_blend_epi64(EVENS4 as __mmask8, y, t),\r\n        )\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedValue for PackedMontyField31AVX512\u003cFP\u003e {\r\n    type Value = MontyField31\u003cFP\u003e;\r\n\r\n    const WIDTH: usize = WIDTH;\r\n\r\n    #[inline]\r\n    fn from_slice(slice: \u0026[MontyField31\u003cFP\u003e]) -\u003e \u0026Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31\u003cFP\u003e; WIDTH]` can be transmuted to `PackedMontyField31AVX512` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026*slice.as_ptr().cast()\r\n        }\r\n    }\r\n    #[inline]\r\n    fn from_slice_mut(slice: \u0026mut [MontyField31\u003cFP\u003e]) -\u003e \u0026mut Self {\r\n        assert_eq!(slice.len(), Self::WIDTH);\r\n        unsafe {\r\n            // Safety: `[MontyField31\u003cFP\u003e; WIDTH]` can be transmuted to `PackedMontyField31AVX512` since the\r\n            // latter is `repr(transparent)`. They have the same alignment, so the reference cast is\r\n            // safe too.\r\n            \u0026mut *slice.as_mut_ptr().cast()\r\n        }\r\n    }\r\n\r\n    /// Similar to `core:array::from_fn`.\r\n    #[inline]\r\n    fn from_fn\u003cF: FnMut(usize) -\u003e MontyField31\u003cFP\u003e\u003e(f: F) -\u003e Self {\r\n        let vals_arr: [_; WIDTH] = core::array::from_fn(f);\r\n        Self(vals_arr)\r\n    }\r\n\r\n    #[inline]\r\n    fn as_slice(\u0026self) -\u003e \u0026[MontyField31\u003cFP\u003e] {\r\n        \u0026self.0[..]\r\n    }\r\n    #[inline]\r\n    fn as_slice_mut(\u0026mut self) -\u003e \u0026mut [MontyField31\u003cFP\u003e] {\r\n        \u0026mut self.0[..]\r\n    }\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedField for PackedMontyField31AVX512\u003cFP\u003e {\r\n    type Scalar = MontyField31\u003cFP\u003e;\r\n}\r\n\r\nunsafe impl\u003cFP: FieldParameters\u003e PackedFieldPow2 for PackedMontyField31AVX512\u003cFP\u003e {\r\n    #[inline]\r\n    fn interleave(\u0026self, other: Self, block_len: usize) -\u003e (Self, Self) {\r\n        let (v0, v1) = (self.to_vector(), other.to_vector());\r\n        let (res0, res1) = match block_len {\r\n            1 =\u003e interleave1(v0, v1),\r\n            2 =\u003e interleave2(v0, v1),\r\n            4 =\u003e interleave4(v0, v1),\r\n            8 =\u003e interleave8(v0, v1),\r\n            16 =\u003e (v0, v1),\r\n            _ =\u003e panic!(\"unsupported block_len\"),\r\n        };\r\n        unsafe {\r\n            // Safety: all values are in canonical form (we haven't changed them).\r\n            (Self::from_vector(res0), Self::from_vector(res1))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":376,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":388,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":506,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":514,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":556,"address":[],"length":0,"stats":{"Line":0}},{"line":557,"address":[],"length":0,"stats":{"Line":0}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":564,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":597,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":602,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":608,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":778,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":846,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":0}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":0}},{"line":980,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":996,"address":[],"length":0,"stats":{"Line":0}},{"line":997,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":0}},{"line":1001,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1003,"address":[],"length":0,"stats":{"Line":0}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":218},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx512","poseidon2.rs"],"content":"//! Vectorized AVX512 implementation of Poseidon2 for MontyField31\r\n\r\nuse alloc::vec::Vec;\r\nuse core::arch::x86_64::{self, __m512i};\r\nuse core::marker::PhantomData;\r\nuse core::mem::transmute;\r\n\r\nuse p3_poseidon2::{\r\n    external_initial_permute_state, external_terminal_permute_state, sum_15, sum_23, ExternalLayer,\r\n    ExternalLayerConstants, ExternalLayerConstructor, InternalLayer, InternalLayerConstructor,\r\n    MDSMat4,\r\n};\r\n\r\nuse super::{add, halve_avx512, sub};\r\nuse crate::{\r\n    apply_func_to_even_odd, packed_exp_3, packed_exp_5, packed_exp_7, FieldParameters,\r\n    MontyField31, MontyParameters, PackedMontyField31AVX512, PackedMontyParameters,\r\n    RelativelyPrimePower,\r\n};\r\n\r\n// In the internal layers, it is valuable to treat the first entry of the state differently\r\n// as it is the only entry to which we apply s-box.\r\n// It seems to help the compiler if we introduce a different data structure for these layers.\r\n// Note that we use this structure instead of a tuple so we can force the memory layout to align for transmutes.\r\n#[derive(Clone, Copy)]\r\n#[repr(C)] // This is needed to make `transmute`s safe.\r\npub struct InternalLayer16\u003cPMP: PackedMontyParameters\u003e {\r\n    s0: PackedMontyField31AVX512\u003cPMP\u003e,\r\n    s_hi: [__m512i; 15],\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e InternalLayer16\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `InternalLayer16\u003cPMP\u003e` to `[PackedMontyField31AVX512\u003cPMP\u003e; 16]`\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `s_hi` represents a valid `MontyField31\u003cPMP\u003e`.\r\n    /// In particular, each element of each vector must be in `[0, P)` (canonical form).\r\n    unsafe fn to_packed_field_array(self) -\u003e [PackedMontyField31AVX512\u003cPMP\u003e; 16] {\r\n        // Safety: It is up to the user to ensure that elements of `s_hi` represent valid\r\n        // `MontyField31\u003cPMP\u003e` values. We must only reason about memory representations.\r\n        // As described in packing.rs, PackedMontyField31AVX512\u003cPMP\u003e can be transmuted to and from `__m512i`.\r\n\r\n        // `InternalLayer16` is `repr(C)` so its memory layout looks like:\r\n        // `[PackedMontyField31AVX512\u003cPMP\u003e, __m512i, ..., __m512i]`\r\n        // Thus as `__m512i` can be can be transmuted to `PackedMontyField31AVX512\u003cFP\u003e`,\r\n        // `InternalLayer16` can be transmuted to `[PackedMontyField31AVX512\u003cFP\u003e; 16]`.\r\n        transmute(self)\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `[PackedMontyField31AVX512\u003cPMP\u003e; 16]` to `InternalLayer16\u003cPMP\u003e`\r\n    fn from_packed_field_array(vector: [PackedMontyField31AVX512\u003cPMP\u003e; 16]) -\u003e Self {\r\n        unsafe {\r\n            // Safety: As described in packing.rs, PackedMontyField31AVX512\u003cPMP\u003e can be transmuted to and from `__m512i`.\r\n\r\n            // `InternalLayer16` is `repr(C)` so its memory layout looks like:\r\n            // `[PackedMontyField31AVX512\u003cPMP\u003e, __m512i, ..., __m512i]`\r\n            // Thus as `PackedMontyField31AVX512\u003cFP\u003e` can be can be transmuted to `__m512i`,\r\n            // `[PackedMontyField31AVX512\u003cFP\u003e; 16]` can be transmuted to `InternalLayer16`.\r\n            transmute(vector)\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone, Copy)]\r\n#[repr(C)] // This is needed to make `transmute`s safe.\r\npub struct InternalLayer24\u003cPMP: PackedMontyParameters\u003e {\r\n    s0: PackedMontyField31AVX512\u003cPMP\u003e,\r\n    s_hi: [__m512i; 23],\r\n}\r\n\r\nimpl\u003cPMP: PackedMontyParameters\u003e InternalLayer24\u003cPMP\u003e {\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `InternalLayer24\u003cPMP\u003e` to `[PackedMontyField31AVX512\u003cPMP\u003e; 24]`\r\n    ///\r\n    /// SAFETY: The caller must ensure that each element of `s_hi` represents a valid `MontyField31\u003cPMP\u003e`.\r\n    /// In particular, each element of each vector must be in `[0, P)` (canonical form).\r\n    unsafe fn to_packed_field_array(self) -\u003e [PackedMontyField31AVX512\u003cPMP\u003e; 24] {\r\n        // Safety: As described in packing.rs, PackedMontyField31AVX512\u003cPMP\u003e can be transmuted to and from `__m512i`.\r\n\r\n        // `InternalLayer24` is `repr(C)` so its memory layout looks like:\r\n        // `[PackedMontyField31AVX512\u003cPMP\u003e, __m512i, ..., __m512i]`\r\n        // Thus as `__m512i` can be can be transmuted to `PackedMontyField31AVX512\u003cFP\u003e`,\r\n        // `InternalLayer24` can be transmuted to `[PackedMontyField31AVX512\u003cFP\u003e; 24]`.\r\n        transmute(self)\r\n    }\r\n\r\n    #[inline]\r\n    #[must_use]\r\n    /// Convert from `[PackedMontyField31AVX512\u003cPMP\u003e; 24]` to `InternalLayer24\u003cPMP\u003e`\r\n    fn from_packed_field_array(vector: [PackedMontyField31AVX512\u003cPMP\u003e; 24]) -\u003e Self {\r\n        unsafe {\r\n            // Safety: As described in packing.rs, PackedMontyField31AVX512\u003cPMP\u003e can be transmuted to and from `__m512i`.\r\n\r\n            // `InternalLayer24` is `repr(C)` so its memory layout looks like:\r\n            // `[PackedMontyField31AVX512\u003cPMP\u003e, __m512i, ..., __m512i]`\r\n            // Thus as `PackedMontyField31AVX512\u003cFP\u003e` can be can be transmuted to `__m512i`,\r\n            // `[PackedMontyField31AVX512\u003cFP\u003e; 24]` can be transmuted to `InternalLayer24`.\r\n            transmute(vector)\r\n        }\r\n    }\r\n}\r\n\r\n/// The internal layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 16 copies of `x - P` into the corresponding `__m512i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2InternalLayerMonty31\u003c\r\n    PMP: PackedMontyParameters,\r\n    const WIDTH: usize,\r\n    ILP: InternalLayerParametersAVX512\u003cPMP, WIDTH\u003e,\r\n\u003e {\r\n    pub(crate) internal_constants: Vec\u003cMontyField31\u003cPMP\u003e\u003e,\r\n    packed_internal_constants: Vec\u003c__m512i\u003e,\r\n    _phantom: PhantomData\u003cILP\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize, ILP: InternalLayerParametersAVX512\u003cFP, WIDTH\u003e\u003e\r\n    InternalLayerConstructor\u003cMontyField31\u003cFP\u003e\u003e for Poseidon2InternalLayerMonty31\u003cFP, WIDTH, ILP\u003e\r\n{\r\n    /// Construct an instance of Poseidon2InternalLayerMersenne31AVX2 from a vector containing\r\n    /// the constants for each round. Internally, the constants are transformed into the\r\n    /// {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(internal_constants: Vec\u003cMontyField31\u003cFP\u003e\u003e) -\u003e Self {\r\n        let packed_internal_constants = internal_constants\r\n            .iter()\r\n            .map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32))\r\n            .collect();\r\n        Self {\r\n            internal_constants,\r\n            packed_internal_constants,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\n/// The external layers of the Poseidon2 permutation for Monty31 fields.\r\n///\r\n/// The packed constants are stored in negative form as this allows some optimizations.\r\n/// This means given a constant `x`, we treat it as an `i32` and\r\n/// pack 16 copies of `x - P` into the corresponding `__m512i` packed constant.\r\n#[derive(Debug, Clone)]\r\npub struct Poseidon2ExternalLayerMonty31\u003cPMP: PackedMontyParameters, const WIDTH: usize\u003e {\r\n    pub(crate) external_constants: ExternalLayerConstants\u003cMontyField31\u003cPMP\u003e, WIDTH\u003e,\r\n    packed_initial_external_constants: Vec\u003c[__m512i; WIDTH]\u003e,\r\n    packed_terminal_external_constants: Vec\u003c[__m512i; WIDTH]\u003e,\r\n}\r\n\r\nimpl\u003cFP: FieldParameters, const WIDTH: usize\u003e ExternalLayerConstructor\u003cMontyField31\u003cFP\u003e, WIDTH\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\n{\r\n    /// Construct an instance of Poseidon2ExternalLayerMersenne31AVX2 from a array of\r\n    /// vectors containing the constants for each round. Internally, the constants\r\n    ///  are transformed into the {-P, ..., 0} representation instead of the standard {0, ..., P} one.\r\n    fn new_from_constants(\r\n        external_constants: ExternalLayerConstants\u003cMontyField31\u003cFP\u003e, WIDTH\u003e,\r\n    ) -\u003e Self {\r\n        let packed_initial_external_constants = external_constants\r\n            .get_initial_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32)))\r\n            .collect();\r\n        let packed_terminal_external_constants = external_constants\r\n            .get_terminal_constants()\r\n            .iter()\r\n            .map(|array| array.map(|constant| convert_to_vec_neg_form::\u003cFP\u003e(constant.value as i32)))\r\n            .collect();\r\n        Self {\r\n            external_constants,\r\n            packed_initial_external_constants,\r\n            packed_terminal_external_constants,\r\n        }\r\n    }\r\n}\r\n\r\n/// Use hard coded methods to compute x -\u003e x^d for the even index entries and small d.\r\n/// Inputs should be signed 32-bit integers in [-P, ..., P].\r\n/// Outputs will also be signed integers in (-P, ..., P) stored in the odd indices.\r\n#[inline(always)]\r\n#[must_use]\r\nfn exp_small\u003cPMP: PackedMontyParameters, const D: u64\u003e(val: __m512i) -\u003e __m512i {\r\n    match D {\r\n        3 =\u003e packed_exp_3::\u003cPMP\u003e(val),\r\n        5 =\u003e packed_exp_5::\u003cPMP\u003e(val),\r\n        7 =\u003e packed_exp_7::\u003cPMP\u003e(val),\r\n        _ =\u003e panic!(\"No exp function for given D\"),\r\n    }\r\n}\r\n\r\n/// Compute val -\u003e (val + rc)^D. Each entry of val should be represented in canonical form.\r\n/// Each entry of rc should be represented by an element in in [-P, 0].\r\n/// Each entry of the output will be represented by an element in canonical form.\r\n/// If the inputs do not conform to this representation, the result is undefined.\r\n#[inline(always)]\r\nfn add_rc_and_sbox\u003cPMP: PackedMontyParameters, const D: u64\u003e(\r\n    val: \u0026mut PackedMontyField31AVX512\u003cPMP\u003e,\r\n    rc: __m512i,\r\n) {\r\n    unsafe {\r\n        // As our exponential functions simply assume that\r\n        // the input lies in [-P, P] we do not need to perform a reduction provided\r\n        // rc is represented by an element in [-P, 0]\r\n        let vec_val = val.to_vector();\r\n        let val_plus_rc = x86_64::_mm512_add_epi32(vec_val, rc);\r\n        let output = apply_func_to_even_odd::\u003cPMP\u003e(val_plus_rc, exp_small::\u003cPMP, D\u003e);\r\n\r\n        *val = PackedMontyField31AVX512::\u003cPMP\u003e::from_vector(output);\r\n    }\r\n}\r\n\r\n/// A trait containing the specific information needed to\r\n/// implement the Poseidon2 Permutation for Monty31 Fields.\r\npub trait InternalLayerParametersAVX512\u003cPMP: PackedMontyParameters, const WIDTH: usize\u003e:\r\n    Clone + Sync\r\n{\r\n    type ArrayLike: AsMut\u003c[__m512i]\u003e;\r\n\r\n    // diagonal_mul and add_sum morally should be one function but are split because diagonal_mul can happen simultaneously to\r\n    // the sbox being applied to the first element of the state which is advantageous as this s-box has very high latency.\r\n    // However these functions should only ever be used together and we only make safety guarantees about the output\r\n    // of the combined function add_sum(diagonal_mul(state), sum) which will output field elements\r\n    // in canonical form provided inputs are in canonical form.\r\n\r\n    // For these reason we mark both functions as unsafe.\r\n\r\n    // All 4 implementation of this trait (Field = BabyBear/KoalaBear, WIDTH = 16/24) have a similarly structured\r\n    // diagonal matrix. The first 9 elements of this matrix are: [-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4] and the remainder\r\n    // are all positive or negative inverse powers of two. This common structure lets us write some default implementations.\r\n\r\n    /// # Safety\r\n    ///\r\n    /// This function assumes its output is piped directly into `add_sum`.\r\n    ///\r\n    /// It might not output field elements in canonical form and indeed may even\r\n    /// output incorrect values in places where it is efficient to correct for\r\n    /// the computation in `add_sum`. For example it might output `3*x` instead of `-3*x`\r\n    /// and have `add_sum` compute `sum - x` instead of `x + sum`.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul(input: \u0026mut Self::ArrayLike) {\r\n        Self::diagonal_mul_first_eight(input);\r\n        Self::diagonal_mul_remainder(input);\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    /// Multiply the first 8 elements of input by the vector `[1, 2, 1/2, 3, 4, 1/2, 3, 4]`.\r\n    ///\r\n    /// In all implementations of this trait, the first 9 elements of the diagonal matrix are\r\n    /// `[-2, 1, 2, 1/2, 3, 4, -1/2, -3, -4]`. The -2 is handled separately and this function handles\r\n    /// the remainder. Note that for the last three elements we multiply by `1/2, 3, 4` and not\r\n    /// `-1/2, -3, -4`. Hence the value in this location will be the negative of what is desired.\r\n    /// This will be handled by `add_sum` and so it is important these elements are not touched\r\n    /// before input is passed into `add_sum`.\r\n    #[inline(always)]\r\n    unsafe fn diagonal_mul_first_eight(input: \u0026mut Self::ArrayLike) {\r\n        let input = input.as_mut();\r\n        // The first 5 elements should be multiplied by: 1, 2, 1/2, 3, 4\r\n\r\n        // input[0] is being multiplied by 1 so we ignore it.\r\n\r\n        input[1] = add::\u003cPMP\u003e(input[1], input[1]);\r\n        input[2] = halve_avx512::\u003cPMP\u003e(input[2]);\r\n\r\n        let acc3 = add::\u003cPMP\u003e(input[3], input[3]);\r\n        input[3] = add::\u003cPMP\u003e(acc3, input[3]);\r\n\r\n        let acc4 = add::\u003cPMP\u003e(input[4], input[4]);\r\n        input[4] = add::\u003cPMP\u003e(acc4, acc4);\r\n\r\n        // For the final 3 elements we multiply by 1/2, 3, 4.\r\n        // This gives the negative of the correct answer which\r\n        // will be handled by add_sum().\r\n\r\n        input[5] = halve_avx512::\u003cPMP\u003e(input[5]);\r\n\r\n        let acc6 = add::\u003cPMP\u003e(input[6], input[6]);\r\n        input[6] = add::\u003cPMP\u003e(acc6, input[6]);\r\n\r\n        let acc7 = add::\u003cPMP\u003e(input[7], input[7]);\r\n        input[7] = add::\u003cPMP\u003e(acc7, acc7);\r\n    }\r\n\r\n    /// # Safety\r\n    ///\r\n    /// This function must not touch the first 8 elements of input.\r\n    /// It may output values which are the negative of the expected\r\n    /// value in some places. This will be handled by `add_sum` so\r\n    /// it is important these elements are not touched\r\n    /// before input is passed into `add_sum`.\r\n    unsafe fn diagonal_mul_remainder(input: \u0026mut Self::ArrayLike);\r\n\r\n    /// The number of positive inverse powers of two in the diagonal matrix after the 4.\r\n    const NUM_POS: usize;\r\n\r\n    /// # Safety\r\n    ///\r\n    /// Sum must be in canonical form and input must be exactly the output of `diagonal_mul`.\r\n    /// If either of these does not hold, the result is undefined.\r\n    ///\r\n    /// Morally this function is computing `x -\u003e x + sum` however there are some places where\r\n    /// the output of `diagonal_mul` is the negative of the expected value.\r\n    /// It is the job of add_sum to correct for these irregularities. Where the output is negative\r\n    /// we compute `x -\u003e sum - x` instead.\r\n    #[inline(always)]\r\n    unsafe fn add_sum(input: \u0026mut Self::ArrayLike, sum: __m512i) {\r\n        // Diagonal mul multiplied these by 1, 2, 1/2, 3, 4 so we simply need to add the sum.\r\n        input.as_mut()[..5]\r\n            .iter_mut()\r\n            .for_each(|x| *x = add::\u003cPMP\u003e(sum, *x));\r\n\r\n        // Diagonal mul multiplied these by 1/2, 3, 4 instead of -1/2, -3, -4 so we need to subtract instead of adding.\r\n        // Similarly we can only cheaply multiply by negative inverse powers of two so we also need to subtract for all\r\n        // the positive powers of two.\r\n        input.as_mut()[5..(8 + Self::NUM_POS)]\r\n            .iter_mut()\r\n            .for_each(|x| *x = sub::\u003cPMP\u003e(sum, *x));\r\n\r\n        // Diagonal mul output a signed value in (-P, P) so we need to do a signed add.\r\n        // Note that signed add's parameters are not interchangeable. The first parameter must be positive.\r\n        input.as_mut()[8 + Self::NUM_POS..]\r\n            .iter_mut()\r\n            .for_each(|x| *x = add::\u003cPMP\u003e(sum, *x));\r\n    }\r\n}\r\n\r\n/// Convert elements from canonical form [0, P) to a negative form in [-P, ..., 0) and copy into a vector.\r\n#[inline(always)]\r\nfn convert_to_vec_neg_form\u003cMP: MontyParameters\u003e(input: i32) -\u003e __m512i {\r\n    let input_sub_p = input - (MP::PRIME as i32);\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX512-F intrinsics are available.\r\n        x86_64::_mm512_set1_epi32(input_sub_p)\r\n    }\r\n}\r\n\r\nimpl\u003cFP, ILP, const D: u64\u003e InternalLayer\u003cPackedMontyField31AVX512\u003cFP\u003e, 16, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, 16, ILP\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n    ILP: InternalLayerParametersAVX512\u003cFP, 16, ArrayLike = [__m512i; 15]\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMontyField31AVX512\u003cFP\u003e; 16]) {\r\n        unsafe {\r\n            // Safety: This return values in canonical form when given values in canonical form.\r\n            /*\r\n                Fix a vector v and let Diag(v) denote the diagonal matrix with diagonal given by v.\r\n                Additionally, let 1 denote the matrix with all elements equal to 1.\r\n                The internal layer consists of an sbox operation then a matrix multiplication by 1 + Diag(v).\r\n                Explicitly the internal layer consists of the following 2 operations:\r\n\r\n                s0 -\u003e (s0 + rc)^d\r\n                s -\u003e (1 + Diag(v))s\r\n\r\n                Note that this matrix multiplication can be implemented as:\r\n                sum = sum_i s_i\r\n                s_i -\u003e sum + s_iv_i\r\n\r\n                which is essentially how we implement it.\r\n            */\r\n\r\n            let mut internal_state = InternalLayer16::from_packed_field_array(*state);\r\n\r\n            self.packed_internal_constants.iter().for_each(|\u0026rc| {\r\n                add_rc_and_sbox::\u003cFP, D\u003e(\u0026mut internal_state.s0, rc); // s0 -\u003e (s0 + rc)^D\r\n                let sum_non_0 = sum_15(\u0026transmute::\u003c\r\n                    [__m512i; 15],\r\n                    [PackedMontyField31AVX512\u003cFP\u003e; 15],\r\n                \u003e(internal_state.s_hi)); // Get the sum of all elements other than s0.\r\n                ILP::diagonal_mul(\u0026mut internal_state.s_hi); // si -\u003e vi * si for all i \u003e 0.\r\n                let sum = sum_non_0 + internal_state.s0; // Get the full sum.\r\n                internal_state.s0 = sum_non_0 - internal_state.s0; // s0 -\u003e sum - 2*s0 = sum_non_0 - s0.\r\n                ILP::add_sum(\r\n                    \u0026mut internal_state.s_hi,\r\n                    transmute::\u003cPackedMontyField31AVX512\u003cFP\u003e, __m512i\u003e(sum),\r\n                ); // si -\u003e si + sum for all i \u003e 0.\r\n            });\r\n\r\n            // This transformation is safe as the above function returns elements\r\n            // in canonical form when given elements in canonical form.\r\n            *state = InternalLayer16::to_packed_field_array(internal_state);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP, ILP, const D: u64\u003e InternalLayer\u003cPackedMontyField31AVX512\u003cFP\u003e, 24, D\u003e\r\n    for Poseidon2InternalLayerMonty31\u003cFP, 24, ILP\u003e\r\nwhere\r\n    FP: FieldParameters,\r\n    ILP: InternalLayerParametersAVX512\u003cFP, 24, ArrayLike = [__m512i; 23]\u003e,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [PackedMontyField31AVX512\u003cFP\u003e; 24]) {\r\n        unsafe {\r\n            // Safety: This return values in canonical form when given values in canonical form.\r\n\r\n            /*\r\n                Fix a vector v and let Diag(v) denote the diagonal matrix with diagonal given by v.\r\n                Additionally, let 1 denote the matrix with all elements equal to 1.\r\n                The internal layer consists of an sbox operation then a matrix multiplication by 1 + Diag(v).\r\n                Explicitly the internal layer consists of the following 2 operations:\r\n\r\n                s0 -\u003e (s0 + rc)^d\r\n                s -\u003e (1 + Diag(v))s\r\n\r\n                Note that this matrix multiplication is implemented as:\r\n                sum = sum_i s_i\r\n                s_i -\u003e sum + s_iv_i.\r\n            */\r\n\r\n            let mut internal_state = InternalLayer24::from_packed_field_array(*state);\r\n\r\n            self.packed_internal_constants.iter().for_each(|\u0026rc| {\r\n                add_rc_and_sbox::\u003cFP, D\u003e(\u0026mut internal_state.s0, rc); // s0 -\u003e (s0 + rc)^D\r\n                let sum_non_0 = sum_23(\u0026transmute::\u003c\r\n                    [__m512i; 23],\r\n                    [PackedMontyField31AVX512\u003cFP\u003e; 23],\r\n                \u003e(internal_state.s_hi)); // Get the sum of all elements other than s0.\r\n                ILP::diagonal_mul(\u0026mut internal_state.s_hi); // si -\u003e vi * si for all i \u003e 0.\r\n                let sum = sum_non_0 + internal_state.s0; // Get the full sum.\r\n                internal_state.s0 = sum_non_0 - internal_state.s0; // s0 -\u003e sum - 2*s0 = sum_non_0 - s0.\r\n                ILP::add_sum(\r\n                    \u0026mut internal_state.s_hi,\r\n                    transmute::\u003cPackedMontyField31AVX512\u003cFP\u003e, __m512i\u003e(sum),\r\n                ); // si -\u003e si + sum for all i \u003e 0.\r\n            });\r\n\r\n            // This transformation is safe as the above function returns elements\r\n            // in canonical form when given elements in canonical form.\r\n            *state = InternalLayer24::to_packed_field_array(internal_state);\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cFP, const D: u64, const WIDTH: usize\u003e ExternalLayer\u003cPackedMontyField31AVX512\u003cFP\u003e, WIDTH, D\u003e\r\n    for Poseidon2ExternalLayerMonty31\u003cFP, WIDTH\u003e\r\nwhere\r\n    FP: FieldParameters + RelativelyPrimePower\u003cD\u003e,\r\n{\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [PackedMontyField31AVX512\u003cFP\u003e; WIDTH]) {\r\n        external_initial_permute_state(\r\n            state,\r\n            \u0026self.packed_initial_external_constants,\r\n            add_rc_and_sbox::\u003cFP, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [PackedMontyField31AVX512\u003cFP\u003e; WIDTH]) {\r\n        external_terminal_permute_state(\r\n            state,\r\n            \u0026self.packed_terminal_external_constants,\r\n            add_rc_and_sbox::\u003cFP, D\u003e,\r\n            \u0026MDSMat4,\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":321,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":448,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":81},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","monty-31","src","x86_64_avx512","utils.rs"],"content":"use core::arch::x86_64::{self, __m512i};\r\nuse core::mem::transmute;\r\n\r\nuse crate::{MontyParameters, PackedMontyParameters, TwoAdicData};\r\n\r\n// Godbolt file showing that these all compile to the expected instructions. (Potentially plus a few memory ops):\r\n// https://godbolt.org/z/dvW7r1zjj\r\n\r\n/// Halve a vector of Monty31 field elements in canonical form.\r\n/// If the inputs are not in canonical form, the result is undefined.\r\n#[inline(always)]\r\npub(crate) fn halve_avx512\u003cMP: MontyParameters\u003e(input: __m512i) -\u003e __m512i {\r\n    /*\r\n        We want this to compile to:\r\n            vptestmd  least_bit, val, ONE\r\n            vpsrld    res, val, 1\r\n            vpaddd    res{least_bit}, res, maybe_half\r\n        throughput: 2 cyc/vec\r\n        latency: 4 cyc\r\n\r\n        Given an element val in [0, P), we want to compute val/2 mod P.\r\n        If val is even: val/2 mod P = val/2 = val \u003e\u003e 1.\r\n        If val is odd: val/2 mod P = (val + P)/2 = (val \u003e\u003e 1) + (P + 1)/2\r\n    */\r\n    unsafe {\r\n        // Safety: If this code got compiled then AVX2 intrinsics are available.\r\n        const ONE: __m512i = unsafe { transmute([1u32; 16]) };\r\n        let half = x86_64::_mm512_set1_epi32((MP::PRIME as i32 + 1) / 2); // Compiler realises this is constant.\r\n\r\n        let least_bit = x86_64::_mm512_test_epi32_mask(input, ONE); // Determine the parity of val.\r\n        let t = x86_64::_mm512_srli_epi32::\u003c1\u003e(input);\r\n        // This does nothing when least_bit = 1 and sets the corresponding entry to 0 when least_bit = 0\r\n        x86_64::_mm512_mask_add_epi32(t, least_bit, t, half)\r\n    }\r\n}\r\n\r\n/*\r\n    Write our prime P as r * 2^j + 1 for odd r.\r\n    The following functions implement x -\u003e -2^{-N} x for varying N and output a value in (-P, P).\r\n    There is one approach which works provided N \u003c 15 and r \u003c 2^15.\r\n    Similarly, there is another approach which works when N = j and when r = 2^i - 1.\r\n\r\n    These approaches rely on the same basic observation about multiplication by -2^{-N} which we present here.\r\n    The strategy for these products is to observe that -2^{-N} = r2^{j - N} mod P.\r\n    Hence given a field element x write it as x = x_lo + 2^N x_hi where x_lo \u003c 2^N and x_hi \u003c= r2^{j - N}.\r\n    Then -2^{-N} x = -x_hi + r2^{j - N} x_lo.\r\n\r\n    Observe that if x_lo \u003e 0, then x_hi \u003c r2^{j - N}x_lo \u003c P and so r2^{j - N} x_lo - x_hi is canonical.\r\n    On the other hand, if x_lo = 0 then the canonical result should be P - x_hi if x_hi \u003e 0 and 0 otherwise.\r\n\r\n    Using intrinsics we can efficiently output r2^{j - N} x_lo - x_hi if x_lo \u003e 0 and P - x_hi if x_lo = 0.\r\n    Whilst this means the output will not be canonical and instead will lie in [0, P] this will be handled by\r\n    a separate function.\r\n\r\n    It remains to understand how to efficiently compute r2^{j - N} x_lo. This splits into several cases:\r\n\r\n    When r \u003c 2^16, N \u003c 15, r2^{j - N} x_lo can be computed efficiently using _mm512_madd_epi16.\r\n    This avoids having to split the input in two and doing multiple multiplications and/or monty reductions.\r\n\r\n    There is a further improvement possible when if r \u003c 2^7 and N = 8 using _mm512_maddubs_epi16.\r\n    This lets us avoid a mask and an and so we implement a specialised version for this.\r\n\r\n    When n = j and r = 2^i - 1, rx_lo can also be computed efficiently using a shift and subtraction.\r\n*/\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-N}.\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^15.\r\n/// N must be between 0 and 15.\r\n/// Input must be given in canonical form.\r\n/// Output may not be in canonical form but will lie in [0, P].\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_n_avx512\u003c\r\n    TAD: TwoAdicData + PackedMontyParameters,\r\n    const N: u32,\r\n    const N_PRIME: u32,\r\n\u003e(\r\n    input: __m512i,\r\n) -\u003e __m512i {\r\n    /*\r\n        We want this to compile to:\r\n            mov         lo_shft,            P           This can be a mov or a load. It will not affect throughput/latency.\r\n            vpsrld      hi,                 val,        N\r\n            vpandd      lo,                 val,        2^N - 1\r\n            vptestmd    lo_MASK,            val,        2^N - 1\r\n            vpmaddwd    lo_x_r,             lo,         [r; 16]\r\n            vpslld      lo_shft{lo_MASK},   lo_x_r,     j - N\r\n            vpsubd      res,                lo_shft,    hi\r\n        throughput: 3\r\n        latency: 9\r\n    */\r\n    unsafe {\r\n        assert_eq!(N + N_PRIME, TAD::TWO_ADICITY as u32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm512_set1_epi32(TAD::ODD_FACTOR); // This is [r; 16]. Compiler realises this is a constant.\r\n        let mask = x86_64::_mm512_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n\r\n        let hi = x86_64::_mm512_srli_epi32::\u003cN\u003e(input);\r\n        let lo = x86_64::_mm512_and_si512(input, mask);\r\n\r\n        // Determine the non 0 values of lo.\r\n        let lo_mask = x86_64::_mm512_test_epi32_mask(input, mask);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of val_lo, odd_factor are \u003c 2^15, _mm512_madd_epi16\r\n        // performs an element wise multiplication.\r\n        // Thus lo_x_r contains lo * r.\r\n        let lo_x_r = x86_64::_mm512_madd_epi16(lo, odd_factor);\r\n\r\n        // When lo = 0, lo_shft = P\r\n        // When lo \u003e 0, lo_shft = r2^{j - N} x_lo\r\n        let lo_shft = x86_64::_mm512_mask_slli_epi32::\u003cN_PRIME\u003e(TAD::PACKED_P, lo_mask, lo_x_r);\r\n\r\n        // As hi \u003c r2^{j - N} \u003c P, the output is always in [0, P]. It is equal to P only when input x = 0.\r\n        x86_64::_mm512_sub_epi32(lo_shft, hi)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-8}.\r\n/// # Safety\r\n///\r\n/// The prime P must be of the form P = r * 2^j + 1 with r odd and r \u003c 2^7.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_8_avx512\u003c\r\n    TAD: TwoAdicData + PackedMontyParameters,\r\n    const N_PRIME: u32,\r\n\u003e(\r\n    input: __m512i,\r\n) -\u003e __m512i {\r\n    /*\r\n        We want this to compile to:\r\n            mov         lo_shft,            P           This can be a mov or a load. It will not affect throughput/latency.\r\n            vpsrld      hi,                 val,        8\r\n            vptestmd    lo_MASK,            val,        2^8 - 1\r\n            vpmaddubsw  lo_x_r,             val,        [r; 16]\r\n            vpslld      lo_shft{lo_MASK},   lo_x_r,     j - 8\r\n            vpsubd      res,                lo_shft,    hi\r\n        throughput: 3\r\n        latency: 7\r\n    */\r\n    unsafe {\r\n        assert_eq!(8 + N_PRIME, TAD::TWO_ADICITY as u32); // Compiler removes this provided it is satisfied.\r\n\r\n        let odd_factor = x86_64::_mm512_set1_epi32(TAD::ODD_FACTOR); // This is [r; 16]. Compiler realises this is a constant.\r\n        let hi = x86_64::_mm512_srli_epi32::\u003c8\u003e(input);\r\n\r\n        let mask = x86_64::_mm512_set1_epi32((1_i32 \u003c\u003c 8) - 1_i32); // Compiler realises this is a constant.\r\n\r\n        // Determine the non 0 values of lo.\r\n        let lo_mask = x86_64::_mm512_test_epi32_mask(input, mask);\r\n\r\n        // Whilst it generically does something else, provided\r\n        // each entry of odd_factor is \u003c 2^7, _mm512_maddubs_epi16\r\n        // performs an element wise multiplication of odd_factor with\r\n        // the bottom 8 bits of input interpreted as an unsigned integer\r\n        // Thus lo_x_r contains lo * r.\r\n        let lo_x_r = x86_64::_mm512_maddubs_epi16(input, odd_factor);\r\n\r\n        // When lo = 0, lo_shft = P\r\n        // When lo \u003e 0, lo_shft = r2^{j - N} x_lo\r\n        let lo_shft = x86_64::_mm512_mask_slli_epi32::\u003cN_PRIME\u003e(TAD::PACKED_P, lo_mask, lo_x_r);\r\n\r\n        // As hi \u003c r2^{j - N} \u003c P, the output is always in [0, P]. It is equal to P only when input x = 0.\r\n        x86_64::_mm512_sub_epi32(lo_shft, hi)\r\n    }\r\n}\r\n\r\n/// Multiply a vector of Monty31 field elements in canonical form by -2**{-N} where P = 2^31 - 2^N + 1.\r\n/// # Safety\r\n///\r\n/// The prime P must have the form P = 2^31 - 2^N + 1.\r\n/// Input must be given in canonical form.\r\n/// Output is not in canonical form, outputs are only guaranteed to lie in (-P, P).\r\n#[inline(always)]\r\npub unsafe fn mul_neg_2exp_neg_two_adicity_avx512\u003c\r\n    TAD: TwoAdicData + PackedMontyParameters,\r\n    const N: u32,\r\n    const N_PRIME: u32,\r\n\u003e(\r\n    input: __m512i,\r\n) -\u003e __m512i {\r\n    /*\r\n        We want this to compile to:\r\n            vmovdqu32   lo_shft,            P           // This can be a mov or a load. It will not affect throughput/latency.\r\n            vpsrld      hi,                 val,        N\r\n            vpandd      lo,                 val,        2^N - 1\r\n            vptestmd    lo_MASK,            val,        2^N - 1\r\n            vpslld      lo_shft{lo_MASK},   lo,         31 - N\r\n            vpaddd      lo_plus_hi,         lo,         hi\r\n            vpsubd      res,                lo_shft,    lo_plus_hi\r\n        throughput: 3\r\n        latency: 5\r\n    */\r\n    unsafe {\r\n        assert_eq!(N, (TAD::TWO_ADICITY as u32)); // Compiler removes this provided it is satisfied.\r\n        assert_eq!(N + N_PRIME, 31); // Compiler removes this provided it is satisfied.\r\n\r\n        let mask = x86_64::_mm512_set1_epi32((1_i32 \u003c\u003c N) - 1_i32); // Compiler realises this is a constant.\r\n        let hi = x86_64::_mm512_srli_epi32::\u003cN\u003e(input);\r\n\r\n        // Provided overflow does not occur, (2^{31 - N} - 1)*x = (x \u003c\u003c {31 - N}) - 1.\r\n        // lo \u003c 2^N =\u003e (lo \u003c\u003c {31 - N}) \u003c 2^31 and (lo \u003c\u003c {31 - N}) - lo \u003c P.\r\n        let lo = x86_64::_mm512_and_si512(input, mask);\r\n\r\n        // Determine the non 0 values of lo.\r\n        let lo_mask = x86_64::_mm512_test_epi32_mask(input, mask);\r\n\r\n        // When lo = 0, lo_shft = P\r\n        // When lo \u003e 0, lo_shft = r x_lo\r\n        let lo_shft = x86_64::_mm512_mask_slli_epi32::\u003cN_PRIME\u003e(TAD::PACKED_P, lo_mask, lo);\r\n\r\n        let lo_plus_hi = x86_64::_mm512_add_epi32(lo, hi);\r\n\r\n        // When lo = 0, return P - hi\r\n        // When lo \u003e 0 return r*lo - hi\r\n        x86_64::_mm512_sub_epi32(lo_shft, lo_plus_hi)\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":20},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon","benches","poseidon.rs"],"content":"use std::any::type_name;\r\nuse std::array;\r\n\r\nuse criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::{BabyBear, MdsMatrixBabyBear};\r\nuse p3_field::{Algebra, Field, InjectiveMonomial, PrimeField};\r\nuse p3_goldilocks::{Goldilocks, MdsMatrixGoldilocks};\r\nuse p3_mds::coset_mds::CosetMds;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::{MdsMatrixMersenne31, Mersenne31};\r\nuse p3_poseidon::Poseidon;\r\nuse p3_symmetric::Permutation;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::thread_rng;\r\n\r\nfn bench_poseidon(c: \u0026mut Criterion) {\r\n    poseidon::\u003cBabyBear, BabyBear, MdsMatrixBabyBear, 16, 7\u003e(c);\r\n    poseidon::\u003cBabyBear, BabyBear, MdsMatrixBabyBear, 24, 7\u003e(c);\r\n    poseidon::\u003cBabyBear, BabyBear, CosetMds\u003c_, 32\u003e, 32, 7\u003e(c);\r\n    poseidon::\u003cBabyBear, \u003cBabyBear as Field\u003e::Packing, CosetMds\u003cBabyBear, 32\u003e, 32, 7\u003e(c);\r\n\r\n    poseidon::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 8, 7\u003e(c);\r\n    poseidon::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 12, 7\u003e(c);\r\n    poseidon::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 16, 7\u003e(c);\r\n\r\n    poseidon::\u003cMersenne31, Mersenne31, MdsMatrixMersenne31, 16, 5\u003e(c);\r\n    poseidon::\u003cMersenne31, Mersenne31, MdsMatrixMersenne31, 32, 5\u003e(c);\r\n}\r\n\r\nfn poseidon\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e(c: \u0026mut Criterion)\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e + Default,\r\n{\r\n    let mut rng = thread_rng();\r\n    let mds = Mds::default();\r\n\r\n    // TODO: Should be calculated for the particular field, width and ALPHA.\r\n    let half_num_full_rounds = 4;\r\n    let num_partial_rounds = 22;\r\n\r\n    let poseidon = Poseidon::\u003cF, Mds, WIDTH, ALPHA\u003e::new_from_rng(\r\n        half_num_full_rounds,\r\n        num_partial_rounds,\r\n        mds,\r\n        \u0026mut rng,\r\n    );\r\n    let input: [A; WIDTH] = array::from_fn(|_| A::ZERO);\r\n    let name = format!(\"poseidon::\u003c{}, {}\u003e\", type_name::\u003cA\u003e(), ALPHA);\r\n    let id = BenchmarkId::new(name, WIDTH);\r\n    c.bench_with_input(id, \u0026input, |b, input| {\r\n        b.iter(|| poseidon.permute(input.clone()))\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_poseidon);\r\ncriterion_main!(benches);\r\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":13},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon","src","lib.rs"],"content":"//! The Poseidon permutation.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{Algebra, InjectiveMonomial, PrimeField};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\nuse rand::Rng;\r\n\r\n/// The Poseidon permutation.\r\n#[derive(Clone, Debug)]\r\npub struct Poseidon\u003cF, Mds, const WIDTH: usize, const ALPHA: u64\u003e {\r\n    half_num_full_rounds: usize,\r\n    num_partial_rounds: usize,\r\n    constants: Vec\u003cF\u003e,\r\n    mds: Mds,\r\n}\r\n\r\nimpl\u003cF, Mds, const WIDTH: usize, const ALPHA: u64\u003e Poseidon\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cALPHA\u003e,\r\n{\r\n    /// Create a new Poseidon configuration.\r\n    ///\r\n    /// # Panics\r\n    /// Number of constants must match WIDTH times `num_rounds`; panics otherwise.\r\n    pub fn new(\r\n        half_num_full_rounds: usize,\r\n        num_partial_rounds: usize,\r\n        constants: Vec\u003cF\u003e,\r\n        mds: Mds,\r\n    ) -\u003e Self {\r\n        let num_rounds = 2 * half_num_full_rounds + num_partial_rounds;\r\n        assert_eq!(constants.len(), WIDTH * num_rounds);\r\n        Self {\r\n            half_num_full_rounds,\r\n            num_partial_rounds,\r\n            constants,\r\n            mds,\r\n        }\r\n    }\r\n\r\n    pub fn new_from_rng\u003cR: Rng\u003e(\r\n        half_num_full_rounds: usize,\r\n        num_partial_rounds: usize,\r\n        mds: Mds,\r\n        rng: \u0026mut R,\r\n    ) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003cF\u003e,\r\n    {\r\n        let num_rounds = 2 * half_num_full_rounds + num_partial_rounds;\r\n        let num_constants = WIDTH * num_rounds;\r\n        let constants = rng\r\n            .sample_iter(Standard)\r\n            .take(num_constants)\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        Self {\r\n            half_num_full_rounds,\r\n            num_partial_rounds,\r\n            constants,\r\n            mds,\r\n        }\r\n    }\r\n\r\n    fn half_full_rounds\u003cA\u003e(\u0026self, state: \u0026mut [A; WIDTH], round_ctr: \u0026mut usize)\r\n    where\r\n        A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n        Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n    {\r\n        for _ in 0..self.half_num_full_rounds {\r\n            self.constant_layer(state, *round_ctr);\r\n            Self::full_sbox_layer(state);\r\n            self.mds.permute_mut(state);\r\n            *round_ctr += 1;\r\n        }\r\n    }\r\n\r\n    fn partial_rounds\u003cA\u003e(\u0026self, state: \u0026mut [A; WIDTH], round_ctr: \u0026mut usize)\r\n    where\r\n        A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n        Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n    {\r\n        for _ in 0..self.num_partial_rounds {\r\n            self.constant_layer(state, *round_ctr);\r\n            Self::partial_sbox_layer(state);\r\n            self.mds.permute_mut(state);\r\n            *round_ctr += 1;\r\n        }\r\n    }\r\n\r\n    fn full_sbox_layer\u003cA\u003e(state: \u0026mut [A; WIDTH])\r\n    where\r\n        A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n    {\r\n        for x in state.iter_mut() {\r\n            *x = x.injective_exp_n();\r\n        }\r\n    }\r\n\r\n    fn partial_sbox_layer\u003cA\u003e(state: \u0026mut [A; WIDTH])\r\n    where\r\n        A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n    {\r\n        state[0] = state[0].injective_exp_n();\r\n    }\r\n\r\n    fn constant_layer\u003cA\u003e(\u0026self, state: \u0026mut [A; WIDTH], round: usize)\r\n    where\r\n        A: Algebra\u003cF\u003e,\r\n    {\r\n        for (i, x) in state.iter_mut().enumerate() {\r\n            *x += self.constants[round * WIDTH + i];\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e Permutation\u003c[A; WIDTH]\u003e\r\n    for Poseidon\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n{\r\n    fn permute_mut(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        let mut round_ctr = 0;\r\n        self.half_full_rounds(state, \u0026mut round_ctr);\r\n        self.partial_rounds(state, \u0026mut round_ctr);\r\n        self.half_full_rounds(state, \u0026mut round_ctr);\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e CryptographicPermutation\u003c[A; WIDTH]\u003e\r\n    for Poseidon\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + InjectiveMonomial\u003cALPHA\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n{\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":60,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":61,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151843071}},{"line":72,"address":[],"length":0,"stats":{"Line":1152921504606846976}},{"line":77,"address":[],"length":0,"stats":{"Line":5764607523034234880}},{"line":78,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":79,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":80,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":81,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":85,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":90,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":91,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":92,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":93,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":94,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":98,"address":[],"length":0,"stats":{"Line":4611686018427387904}},{"line":102,"address":[],"length":0,"stats":{"Line":4611686018427387902}},{"line":103,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":107,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":111,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":114,"address":[],"length":0,"stats":{"Line":17293822569102704640}},{"line":118,"address":[],"length":0,"stats":{"Line":17293822569102704638}},{"line":119,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":131,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":132,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":133,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":134,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":135,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":31,"coverable":33},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","benches","poseidon2.rs"],"content":"use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_bn254_fr::{Bn254Fr, Poseidon2Bn254};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_goldilocks::{Goldilocks, Poseidon2Goldilocks};\r\nuse p3_koala_bear::{KoalaBear, Poseidon2KoalaBear};\r\nuse p3_mersenne_31::{Mersenne31, Poseidon2Mersenne31};\r\nuse p3_symmetric::Permutation;\r\nuse p3_util::pretty_name;\r\nuse rand::thread_rng;\r\n\r\nfn bench_poseidon2(c: \u0026mut Criterion) {\r\n    let mut rng = thread_rng();\r\n\r\n    let poseidon2_bb_16 = Poseidon2BabyBear::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cBabyBear, Poseidon2BabyBear\u003c16\u003e, 16\u003e(c, poseidon2_bb_16);\r\n    let poseidon2_bb_24 = Poseidon2BabyBear::\u003c24\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cBabyBear, Poseidon2BabyBear\u003c24\u003e, 24\u003e(c, poseidon2_bb_24);\r\n\r\n    let poseidon2_kb_16 = Poseidon2KoalaBear::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cKoalaBear, Poseidon2KoalaBear\u003c16\u003e, 16\u003e(c, poseidon2_kb_16);\r\n    let poseidon2_kb_24 = Poseidon2KoalaBear::\u003c24\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cKoalaBear, Poseidon2KoalaBear\u003c24\u003e, 24\u003e(c, poseidon2_kb_24);\r\n\r\n    let poseidon2_m31_16 = Poseidon2Mersenne31::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cMersenne31, Poseidon2Mersenne31\u003c16\u003e, 16\u003e(c, poseidon2_m31_16);\r\n    let poseidon2_m31_24 = Poseidon2Mersenne31::\u003c24\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cMersenne31, Poseidon2Mersenne31\u003c24\u003e, 24\u003e(c, poseidon2_m31_24);\r\n\r\n    let poseidon2_gold_8 = Poseidon2Goldilocks::\u003c8\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cGoldilocks, Poseidon2Goldilocks\u003c8\u003e, 8\u003e(c, poseidon2_gold_8);\r\n    let poseidon2_gold_12 = Poseidon2Goldilocks::\u003c12\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cGoldilocks, Poseidon2Goldilocks\u003c12\u003e, 12\u003e(c, poseidon2_gold_12);\r\n    let poseidon2_gold_16 = Poseidon2Goldilocks::\u003c16\u003e::new_from_rng_128(\u0026mut rng);\r\n    poseidon2::\u003cGoldilocks, Poseidon2Goldilocks\u003c16\u003e, 16\u003e(c, poseidon2_gold_16);\r\n\r\n    // We hard code the round numbers for Bn254Fr.\r\n    let poseidon2_bn254 = Poseidon2Bn254::\u003c3\u003e::new_from_rng(8, 22, \u0026mut rng);\r\n    poseidon2::\u003cBn254Fr, Poseidon2Bn254\u003c3\u003e, 3\u003e(c, poseidon2_bn254);\r\n}\r\n\r\nfn poseidon2\u003cF, Perm, const WIDTH: usize\u003e(c: \u0026mut Criterion, poseidon2: Perm)\r\nwhere\r\n    F: Field,\r\n    Perm: Permutation\u003c[F::Packing; WIDTH]\u003e,\r\n{\r\n    let input = [F::Packing::ZERO; WIDTH];\r\n    let name = format!(\"poseidon2::\u003c{}, {}\u003e\", pretty_name::\u003cF::Packing\u003e(), WIDTH);\r\n    let id = BenchmarkId::new(name, WIDTH);\r\n    c.bench_with_input(id, \u0026input, |b, \u0026input| b.iter(|| poseidon2.permute(input)));\r\n}\r\n\r\ncriterion_group!(benches, bench_poseidon2);\r\ncriterion_main!(benches);\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","src","external.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::Permutation;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\n/// Multiply a 4-element vector x by\r\n/// [ 5 7 1 3 ]\r\n/// [ 4 6 1 1 ]\r\n/// [ 1 3 5 7 ]\r\n/// [ 1 1 4 6 ].\r\n/// This uses the formula from the start of Appendix B in the Poseidon2 paper, with multiplications unrolled into additions.\r\n/// It is also the matrix used by the Horizon Labs implementation.\r\n#[inline(always)]\r\nfn apply_hl_mat4\u003cR\u003e(x: \u0026mut [R; 4])\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n{\r\n    let t0 = x[0].clone() + x[1].clone();\r\n    let t1 = x[2].clone() + x[3].clone();\r\n    let t2 = x[1].clone() + x[1].clone() + t1.clone();\r\n    let t3 = x[3].clone() + x[3].clone() + t0.clone();\r\n    let t4 = t1.double().double() + t3.clone();\r\n    let t5 = t0.double().double() + t2.clone();\r\n    let t6 = t3 + t5.clone();\r\n    let t7 = t2 + t4.clone();\r\n    x[0] = t6;\r\n    x[1] = t5;\r\n    x[2] = t7;\r\n    x[3] = t4;\r\n}\r\n\r\n// It turns out we can find a 4x4 matrix which is more efficient than the above.\r\n\r\n/// Multiply a 4-element vector x by:\r\n/// [ 2 3 1 1 ]\r\n/// [ 1 2 3 1 ]\r\n/// [ 1 1 2 3 ]\r\n/// [ 3 1 1 2 ].\r\n#[inline(always)]\r\nfn apply_mat4\u003cR\u003e(x: \u0026mut [R; 4])\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n{\r\n    let t01 = x[0].clone() + x[1].clone();\r\n    let t23 = x[2].clone() + x[3].clone();\r\n    let t0123 = t01.clone() + t23.clone();\r\n    let t01123 = t0123.clone() + x[1].clone();\r\n    let t01233 = t0123.clone() + x[3].clone();\r\n    // The order here is important. Need to overwrite x[0] and x[2] after x[1] and x[3].\r\n    x[3] = t01233.clone() + x[0].double(); // 3*x[0] + x[1] + x[2] + 2*x[3]\r\n    x[1] = t01123.clone() + x[2].double(); // x[0] + 2*x[1] + 3*x[2] + x[3]\r\n    x[0] = t01123 + t01; // 2*x[0] + 3*x[1] + x[2] + x[3]\r\n    x[2] = t01233 + t23; // x[0] + x[1] + 2*x[2] + 3*x[3]\r\n}\r\n\r\n/// The 4x4 MDS matrix used by the Horizon Labs implementation of Poseidon2.\r\n///\r\n/// This requires 10 additions and 4 doubles to compute.\r\n#[derive(Clone, Default)]\r\npub struct HLMDSMat4;\r\n\r\nimpl\u003cR: PrimeCharacteristicRing\u003e Permutation\u003c[R; 4]\u003e for HLMDSMat4 {\r\n    #[inline(always)]\r\n    fn permute(\u0026self, input: [R; 4]) -\u003e [R; 4] {\r\n        let mut output = input;\r\n        self.permute_mut(\u0026mut output);\r\n        output\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn permute_mut(\u0026self, input: \u0026mut [R; 4]) {\r\n        apply_hl_mat4(input)\r\n    }\r\n}\r\nimpl\u003cR: PrimeCharacteristicRing\u003e MdsPermutation\u003cR, 4\u003e for HLMDSMat4 {}\r\n\r\n/// The fastest 4x4 MDS matrix.\r\n///\r\n/// This requires 7 additions and 2 doubles to compute.\r\n#[derive(Clone, Default)]\r\npub struct MDSMat4;\r\n\r\nimpl\u003cR: PrimeCharacteristicRing\u003e Permutation\u003c[R; 4]\u003e for MDSMat4 {\r\n    #[inline(always)]\r\n    fn permute(\u0026self, input: [R; 4]) -\u003e [R; 4] {\r\n        let mut output = input;\r\n        self.permute_mut(\u0026mut output);\r\n        output\r\n    }\r\n\r\n    #[inline(always)]\r\n    fn permute_mut(\u0026self, input: \u0026mut [R; 4]) {\r\n        apply_mat4(input)\r\n    }\r\n}\r\nimpl\u003cR: PrimeCharacteristicRing\u003e MdsPermutation\u003cR, 4\u003e for MDSMat4 {}\r\n\r\n/// Implement the matrix multiplication used by the external layer.\r\n///\r\n/// Given a 4x4 MDS matrix M, we multiply by the `4N x 4N` matrix\r\n/// `[[2M M  ... M], [M  2M ... M], ..., [M  M ... 2M]]`.\r\n#[inline(always)]\r\npub fn mds_light_permutation\u003c\r\n    R: PrimeCharacteristicRing,\r\n    MdsPerm4: MdsPermutation\u003cR, 4\u003e,\r\n    const WIDTH: usize,\r\n\u003e(\r\n    state: \u0026mut [R; WIDTH],\r\n    mdsmat: \u0026MdsPerm4,\r\n) {\r\n    match WIDTH {\r\n        2 =\u003e {\r\n            let sum = state[0].clone() + state[1].clone();\r\n            state[0] += sum.clone();\r\n            state[1] += sum;\r\n        }\r\n\r\n        3 =\u003e {\r\n            let sum = state[0].clone() + state[1].clone() + state[2].clone();\r\n            state[0] += sum.clone();\r\n            state[1] += sum.clone();\r\n            state[2] += sum;\r\n        }\r\n\r\n        4 | 8 | 12 | 16 | 20 | 24 =\u003e {\r\n            // First, we apply M_4 to each consecutive four elements of the state.\r\n            // In Appendix B's terminology, this replaces each x_i with x_i'.\r\n            for chunk in state.chunks_exact_mut(4) {\r\n                mdsmat.permute_mut(chunk.try_into().unwrap());\r\n            }\r\n            // Now, we apply the outer circulant matrix (to compute the y_i values).\r\n\r\n            // We first precompute the four sums of every four elements.\r\n            let sums: [R; 4] = core::array::from_fn(|k| {\r\n                (0..WIDTH)\r\n                    .step_by(4)\r\n                    .map(|j| state[j + k].clone())\r\n                    .sum::\u003cR\u003e()\r\n            });\r\n\r\n            // The formula for each y_i involves 2x_i' term and x_j' terms for each j that equals i mod 4.\r\n            // In other words, we can add a single copy of x_i' to the appropriate one of our precomputed sums\r\n            state\r\n                .iter_mut()\r\n                .enumerate()\r\n                .for_each(|(i, elem)| *elem += sums[i % 4].clone());\r\n        }\r\n\r\n        _ =\u003e {\r\n            panic!(\"Unsupported width\");\r\n        }\r\n    }\r\n}\r\n\r\n/// A struct which holds the constants for the external layer.\r\n#[derive(Debug, Clone)]\r\npub struct ExternalLayerConstants\u003cT, const WIDTH: usize\u003e {\r\n    // Once initialised, these constants should be immutable.\r\n    initial: Vec\u003c[T; WIDTH]\u003e,\r\n    terminal: Vec\u003c[T; WIDTH]\u003e, // We use terminal instead of final as final is a reserved keyword.\r\n}\r\n\r\nimpl\u003cT, const WIDTH: usize\u003e ExternalLayerConstants\u003cT, WIDTH\u003e {\r\n    pub fn new(initial: Vec\u003c[T; WIDTH]\u003e, terminal: Vec\u003c[T; WIDTH]\u003e) -\u003e Self {\r\n        assert_eq!(\r\n            initial.len(),\r\n            terminal.len(),\r\n            \"The number of initial and terminal external rounds should be equal.\"\r\n        );\r\n        Self { initial, terminal }\r\n    }\r\n\r\n    pub fn new_from_rng\u003cR: Rng\u003e(external_round_number: usize, rng: \u0026mut R) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003c[T; WIDTH]\u003e,\r\n    {\r\n        let half_f = external_round_number / 2;\r\n        assert_eq!(\r\n            2 * half_f,\r\n            external_round_number,\r\n            \"The total number of external rounds should be even\"\r\n        );\r\n        let initial_constants = rng.sample_iter(Standard).take(half_f).collect();\r\n        let terminal_constants = rng.sample_iter(Standard).take(half_f).collect();\r\n\r\n        Self::new(initial_constants, terminal_constants)\r\n    }\r\n\r\n    pub fn new_from_saved_array\u003cU, const N: usize\u003e(\r\n        [initial, terminal]: [[[U; WIDTH]; N]; 2],\r\n        conversion_fn: fn([U; WIDTH]) -\u003e [T; WIDTH],\r\n    ) -\u003e Self\r\n    where\r\n        T: Clone,\r\n    {\r\n        let initial_consts = initial.map(conversion_fn).to_vec();\r\n        let terminal_consts = terminal.map(conversion_fn).to_vec();\r\n        Self::new(initial_consts, terminal_consts)\r\n    }\r\n\r\n    pub fn get_initial_constants(\u0026self) -\u003e \u0026Vec\u003c[T; WIDTH]\u003e {\r\n        \u0026self.initial\r\n    }\r\n\r\n    pub fn get_terminal_constants(\u0026self) -\u003e \u0026Vec\u003c[T; WIDTH]\u003e {\r\n        \u0026self.terminal\r\n    }\r\n}\r\n\r\n/// Initialize an external layer from a set of constants.\r\npub trait ExternalLayerConstructor\u003cF, const WIDTH: usize\u003e\r\nwhere\r\n    F: Field,\r\n{\r\n    /// A constructor which internally will convert the supplied\r\n    /// constants into the appropriate form for the implementation.\r\n    fn new_from_constants(external_constants: ExternalLayerConstants\u003cF, WIDTH\u003e) -\u003e Self;\r\n}\r\n\r\n/// A trait containing all data needed to implement the external layers of Poseidon2.\r\npub trait ExternalLayer\u003cR, const WIDTH: usize, const D: u64\u003e: Sync + Clone\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n{\r\n    // permute_state_initial, permute_state_terminal are split as the Poseidon2 specifications are slightly different\r\n    // with the initial rounds involving an extra matrix multiplication.\r\n\r\n    /// Perform the initial external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_initial(\u0026self, state: \u0026mut [R; WIDTH]);\r\n\r\n    /// Perform the terminal external layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state_terminal(\u0026self, state: \u0026mut [R; WIDTH]);\r\n}\r\n\r\n/// A helper method which allow any field to easily implement the terminal External Layer.\r\n#[inline]\r\npub fn external_terminal_permute_state\u003c\r\n    R: PrimeCharacteristicRing,\r\n    CT: Copy, // Whatever type the constants are stored as.\r\n    MdsPerm4: MdsPermutation\u003cR, 4\u003e,\r\n    const WIDTH: usize,\r\n\u003e(\r\n    state: \u0026mut [R; WIDTH],\r\n    terminal_external_constants: \u0026[[CT; WIDTH]],\r\n    add_rc_and_sbox: fn(\u0026mut R, CT),\r\n    mat4: \u0026MdsPerm4,\r\n) {\r\n    for elem in terminal_external_constants.iter() {\r\n        state\r\n            .iter_mut()\r\n            .zip(elem.iter())\r\n            .for_each(|(s, \u0026rc)| add_rc_and_sbox(s, rc));\r\n        mds_light_permutation(state, mat4);\r\n    }\r\n}\r\n\r\n/// A helper method which allow any field to easily implement the initial External Layer.\r\n#[inline]\r\npub fn external_initial_permute_state\u003c\r\n    R: PrimeCharacteristicRing,\r\n    CT: Copy, // Whatever type the constants are stored as.\r\n    MdsPerm4: MdsPermutation\u003cR, 4\u003e,\r\n    const WIDTH: usize,\r\n\u003e(\r\n    state: \u0026mut [R; WIDTH],\r\n    initial_external_constants: \u0026[[CT; WIDTH]],\r\n    add_rc_and_sbox: fn(\u0026mut R, CT),\r\n    mat4: \u0026MdsPerm4,\r\n) {\r\n    mds_light_permutation(state, mat4);\r\n    // After the initial mds_light_permutation, the remaining layers are identical\r\n    // to the terminal permutation simply with different constants.\r\n    external_terminal_permute_state(state, initial_external_constants, add_rc_and_sbox, mat4)\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":21,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":22,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":23,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":24,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":25,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":26,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":27,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":28,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":29,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":30,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":31,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":32,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":43,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":47,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":48,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":49,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":50,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":51,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":53,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":54,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":55,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":56,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":75,"address":[],"length":0,"stats":{"Line":3891110078048108544}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":96,"address":[],"length":0,"stats":{"Line":5764607523034240238}},{"line":106,"address":[],"length":0,"stats":{"Line":12177733392409821198}},{"line":114,"address":[],"length":0,"stats":{"Line":12177733392409821198}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":122,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":123,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":124,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":125,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":12393906174523608588}},{"line":132,"address":[],"length":0,"stats":{"Line":9655717601082345224}},{"line":137,"address":[],"length":0,"stats":{"Line":16429131440647590966}},{"line":138,"address":[],"length":0,"stats":{"Line":4899916394579121210}},{"line":139,"address":[],"length":0,"stats":{"Line":4899916394579121210}},{"line":140,"address":[],"length":0,"stats":{"Line":9223372036854832548}},{"line":141,"address":[],"length":0,"stats":{"Line":4899916394579121210}},{"line":146,"address":[],"length":0,"stats":{"Line":11529215046068469756}},{"line":149,"address":[],"length":0,"stats":{"Line":4035225266123967843}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":3819052484010180850}},{"line":168,"address":[],"length":0,"stats":{"Line":3819052484010180850}},{"line":169,"address":[],"length":0,"stats":{"Line":3819052484010180850}},{"line":170,"address":[],"length":0,"stats":{"Line":3819052484010180850}},{"line":171,"address":[],"length":0,"stats":{"Line":242}},{"line":176,"address":[],"length":0,"stats":{"Line":3530822107858468898}},{"line":180,"address":[],"length":0,"stats":{"Line":3530822107858468898}},{"line":181,"address":[],"length":0,"stats":{"Line":3530822107858468898}},{"line":182,"address":[],"length":0,"stats":{"Line":3530822107858468898}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":34}},{"line":186,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":187,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":189,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":192,"address":[],"length":0,"stats":{"Line":216172782113784251}},{"line":199,"address":[],"length":0,"stats":{"Line":216172782113784251}},{"line":200,"address":[],"length":0,"stats":{"Line":216172782113784251}},{"line":201,"address":[],"length":0,"stats":{"Line":216172782113784251}},{"line":204,"address":[],"length":0,"stats":{"Line":10664523917613343471}},{"line":205,"address":[],"length":0,"stats":{"Line":10664523917613343471}},{"line":208,"address":[],"length":0,"stats":{"Line":10664523917613334770}},{"line":209,"address":[],"length":0,"stats":{"Line":10664523917613334770}},{"line":240,"address":[],"length":0,"stats":{"Line":3026418949592973659}},{"line":251,"address":[],"length":0,"stats":{"Line":8791026472627209337}},{"line":252,"address":[],"length":0,"stats":{"Line":12105675798371893647}},{"line":254,"address":[],"length":0,"stats":{"Line":12105675798371893647}},{"line":255,"address":[],"length":0,"stats":{"Line":2882303761517156625}},{"line":256,"address":[],"length":0,"stats":{"Line":12105675798371893647}},{"line":262,"address":[],"length":0,"stats":{"Line":11601272640106397692}},{"line":273,"address":[],"length":0,"stats":{"Line":11601272640106397692}},{"line":276,"address":[],"length":0,"stats":{"Line":11601272640106397692}}],"covered":73,"coverable":89},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","src","generic.rs"],"content":"//! Whilst high speed implementations of Poseidon2 rely on a detailed understanding of the underlying field structure\r\n//! it is also useful to have a generic constructor which works for a much larger range of rings.\r\n//!\r\n//! Indeed, for a fixed field F, the Poseidon2 permutation consists of three basic operations:\r\n//! - Addition by elements in F.\r\n//! - A power map x -\u003e x^n.\r\n//! - Multiplication by an F valued matrix.\r\n//!\r\n//! This means that it is possible to define a Poseidon2 over any ring implementing `Algebra\u003cF\u003e`.\r\n//!\r\n//! This file implements the generic methods from which Poseidon2 can be built.\r\n\r\nuse p3_field::{Algebra, Field, InjectiveMonomial, PrimeCharacteristicRing};\r\n\r\nuse crate::{mds_light_permutation, MDSMat4};\r\n\r\n/// A generic method performing the transformation:\r\n///\r\n/// `s -\u003e (s + rc)^D`\r\n///\r\n/// This is a little slower than field specific implementations (particularly for packed fields) so should\r\n/// only be used in non performance critical places.\r\n#[inline(always)]\r\npub fn add_rc_and_sbox_generic\u003cF: Field, A: Algebra\u003cF\u003e + InjectiveMonomial\u003cD\u003e, const D: u64\u003e(\r\n    val: \u0026mut A,\r\n    rc: F,\r\n) {\r\n    *val += rc;\r\n    *val = val.injective_exp_n();\r\n}\r\n\r\npub trait GenericPoseidon2LinearLayers\u003cR: PrimeCharacteristicRing, const WIDTH: usize\u003e:\r\n    Sync\r\n{\r\n    /// A generic implementation of the internal linear layer.\r\n    fn internal_linear_layer(state: \u0026mut [R; WIDTH]);\r\n\r\n    /// A generic implementation of the external linear layer.\r\n    fn external_linear_layer(state: \u0026mut [R; WIDTH]) {\r\n        mds_light_permutation(state, \u0026MDSMat4);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":28,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":29,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","src","internal.rs"],"content":"//! Inside the Poseidon2 paper, they describe that the internal layers of the hash\r\n//! function do not require the full properties of MDS matrices.\r\n//!\r\n//! \u003e For the partial rounds, the MDS property is not required anymore, and\r\n//! \u003e we can set up the matrix MI focusing only on providing full diffusion, breaking\r\n//! \u003e arbitrarily long subspace trails, and ensuring that the polynomial representation\r\n//! \u003e of the scheme is dense. (Section 5.2)\r\n//!\r\n//! This file implements a trait for linear layers that satisfy these three properties.\r\n\r\n// The requirements translate to the following 3 properties:\r\n// 1: All entries are non 0.\r\n// 2: No Subspace Trails.\r\n// 3: For a matrix of the form 1 + D, the diagonal D should also be non 0.\r\n//\r\n// Properties 1 and 3 are essentially immediate to check and a sufficient condition for property 2\r\n// is that the minimal polynomial of the matrix M and all its powers M^2, ..., M^{2WIDTH} are maximal and irreducible.\r\n// This is equivalent to all the characteristic polynomials being irreducible.\r\n//\r\n// These can be verified by the following sage code (Changing field/vector/length as desired):\r\n//\r\n// field = GF(2^31 - 1);\r\n// length = 16;\r\n// vector = [-2,  1,   2,   4,   8,  16,  32,  64, 128, 256, 1024, 4096, 8192, 16384, 32768, 65536];\r\n// const_mat = matrix.ones(field, length);\r\n// diag_mat  = diagonal_matrix(field, vector);\r\n// for i in range(1, 2 * length + 1)\r\n//      assert ((const_mat + diag_mat)^i).characteristic_polynomial().is_irreducible()\r\n\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_field::{Algebra, Field, InjectiveMonomial, PrimeCharacteristicRing};\r\n\r\nuse crate::add_rc_and_sbox_generic;\r\n\r\n/// Initialize an internal layer from a set of constants.\r\npub trait InternalLayerConstructor\u003cF\u003e\r\nwhere\r\n    F: Field,\r\n{\r\n    /// A constructor which internally will convert the supplied\r\n    /// constants into the appropriate form for the implementation.\r\n    fn new_from_constants(internal_constants: Vec\u003cF\u003e) -\u003e Self;\r\n}\r\n\r\n/// Given a vector v compute the matrix vector product (1 + diag(v))state with 1 denoting the constant matrix of ones.\r\npub fn matmul_internal\u003cF: Field, A: Algebra\u003cF\u003e, const WIDTH: usize\u003e(\r\n    state: \u0026mut [A; WIDTH],\r\n    mat_internal_diag_m_1: [F; WIDTH],\r\n) {\r\n    let sum: A = state.iter().cloned().sum();\r\n    for i in 0..WIDTH {\r\n        state[i] *= mat_internal_diag_m_1[i];\r\n        state[i] += sum.clone();\r\n    }\r\n}\r\n\r\n/// A trait containing all data needed to implement the internal layers of Poseidon2.\r\npub trait InternalLayer\u003cR, const WIDTH: usize, const D: u64\u003e: Sync + Clone\r\nwhere\r\n    R: PrimeCharacteristicRing,\r\n{\r\n    /// Perform the internal layers of the Poseidon2 permutation on the given state.\r\n    fn permute_state(\u0026self, state: \u0026mut [R; WIDTH]);\r\n}\r\n\r\n/// A helper method which allows any field to easily implement Internal Layer.\r\n/// This should only be used in places where performance is not critical.\r\n#[inline]\r\npub fn internal_permute_state\u003c\r\n    F: Field,\r\n    A: Algebra\u003cF\u003e + InjectiveMonomial\u003cD\u003e,\r\n    const WIDTH: usize,\r\n    const D: u64,\r\n\u003e(\r\n    state: \u0026mut [A; WIDTH],\r\n    diffusion_mat: fn(\u0026mut [A; WIDTH]),\r\n    internal_constants: \u0026[F],\r\n) {\r\n    for elem in internal_constants.iter() {\r\n        add_rc_and_sbox_generic(\u0026mut state[0], *elem);\r\n        diffusion_mat(state);\r\n    }\r\n}\r\n\r\n/// The compiler doesn't realize that add is associative\r\n/// so we help it out and minimize the dependency chains by hand.\r\n#[inline(always)]\r\nfn sum_7\u003cR: PrimeCharacteristicRing + Copy\u003e(state: \u0026[R]) -\u003e R {\r\n    assert_eq!(state.len(), 7);\r\n\r\n    let s01 = state[0] + state[1];\r\n    let s23 = state[2] + state[3];\r\n    let s45 = state[4] + state[5];\r\n\r\n    let s0123 = s01 + s23;\r\n    let s456 = s45 + state[6];\r\n    s0123 + s456\r\n}\r\n\r\n/// The compiler doesn't realize that add is associative\r\n/// so we help it out and minimize the dependency chains by hand.\r\n#[inline(always)]\r\nfn sum_8\u003cR: PrimeCharacteristicRing + Copy\u003e(state: \u0026[R]) -\u003e R {\r\n    assert_eq!(state.len(), 8);\r\n\r\n    let s01 = state[0] + state[1];\r\n    let s23 = state[2] + state[3];\r\n    let s45 = state[4] + state[5];\r\n    let s67 = state[6] + state[7];\r\n\r\n    let s0123 = s01 + s23;\r\n    let s4567 = s45 + s67;\r\n    s0123 + s4567\r\n}\r\n\r\n/// The compiler doesn't realize that add is associative\r\n/// so we help it out and minimize the dependency chains by hand.\r\n#[inline(always)]\r\npub fn sum_15\u003cR: PrimeCharacteristicRing + Copy\u003e(state: \u0026[R]) -\u003e R {\r\n    assert_eq!(state.len(), 15);\r\n\r\n    let bot_sum = sum_8(\u0026state[..8]);\r\n    let top_sum = sum_7(\u0026state[8..]);\r\n\r\n    bot_sum + top_sum\r\n}\r\n\r\n/// The compiler doesn't realize that add is associative\r\n/// so we help it out and minimize the dependency chains by hand.\r\n#[inline(always)]\r\npub fn sum_23\u003cR: PrimeCharacteristicRing + Copy\u003e(state: \u0026[R]) -\u003e R {\r\n    assert_eq!(state.len(), 23);\r\n\r\n    let bot_sum = sum_8(\u0026state[..8]);\r\n    let mid_sum = sum_8(\u0026state[8..16]);\r\n    let top_sum = sum_7(\u0026state[16..]);\r\n\r\n    bot_sum + mid_sum + top_sum\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":51,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":52,"address":[],"length":0,"stats":{"Line":11673330234144325632}},{"line":53,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":54,"address":[],"length":0,"stats":{"Line":13258597302978740224}},{"line":70,"address":[],"length":0,"stats":{"Line":576460752303423490}},{"line":80,"address":[],"length":0,"stats":{"Line":10088063165309911042}},{"line":81,"address":[],"length":0,"stats":{"Line":13979173243358019584}},{"line":82,"address":[],"length":0,"stats":{"Line":13979173243358019584}},{"line":89,"address":[],"length":0,"stats":{"Line":2161727821137869486}},{"line":90,"address":[],"length":0,"stats":{"Line":2161727821137869486}},{"line":92,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":93,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":94,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":96,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":97,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":98,"address":[],"length":0,"stats":{"Line":2161727821137838885}},{"line":104,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":105,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":107,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":108,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":109,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":110,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":112,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":113,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":114,"address":[],"length":0,"stats":{"Line":6917529027641082661}},{"line":120,"address":[],"length":0,"stats":{"Line":15852670688344146725}},{"line":121,"address":[],"length":0,"stats":{"Line":15852670688344146725}},{"line":123,"address":[],"length":0,"stats":{"Line":15852670688344146725}},{"line":124,"address":[],"length":0,"stats":{"Line":15852670688344146725}},{"line":126,"address":[],"length":0,"stats":{"Line":15852670688344146725}},{"line":132,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":133,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":135,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":136,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":137,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":139,"address":[],"length":0,"stats":{"Line":4755801206503243776}}],"covered":37,"coverable":37},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","src","lib.rs"],"content":"//! The Poseidon2 permutation.\r\n//!\r\n//! This implementation was based upon the following resources:\r\n//! - `\u003chttps://github.com/HorizenLabs/poseidon2/blob/main/plain_implementations/src/poseidon2/poseidon2.rs\u003e`\r\n//! - `\u003chttps://eprint.iacr.org/2023/323.pdf\u003e`\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod external;\r\nmod generic;\r\nmod internal;\r\nmod round_numbers;\r\nuse alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\npub use external::*;\r\npub use generic::*;\r\npub use internal::*;\r\nuse p3_field::{Algebra, InjectiveMonomial, PrimeField, PrimeField64};\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\npub use round_numbers::poseidon2_round_numbers_128;\r\n\r\nconst SUPPORTED_WIDTHS: [usize; 8] = [2, 3, 4, 8, 12, 16, 20, 24];\r\n\r\n/// The Poseidon2 permutation.\r\n#[derive(Clone, Debug)]\r\npub struct Poseidon2\u003cF, ExternalPerm, InternalPerm, const WIDTH: usize, const D: u64\u003e {\r\n    /// The permutations used in External Rounds.\r\n    external_layer: ExternalPerm,\r\n\r\n    /// The permutation used in Internal Rounds.\r\n    internal_layer: InternalPerm,\r\n\r\n    _phantom: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF, ExternalPerm, InternalPerm, const WIDTH: usize, const D: u64\u003e\r\n    Poseidon2\u003cF, ExternalPerm, InternalPerm, WIDTH, D\u003e\r\nwhere\r\n    F: PrimeField,\r\n    ExternalPerm: ExternalLayerConstructor\u003cF, WIDTH\u003e,\r\n    InternalPerm: InternalLayerConstructor\u003cF\u003e,\r\n{\r\n    /// Create a new Poseidon2 configuration.\r\n    /// This internally converts the given constants to the relevant packed versions.\r\n    pub fn new(\r\n        external_constants: ExternalLayerConstants\u003cF, WIDTH\u003e,\r\n        internal_constants: Vec\u003cF\u003e,\r\n    ) -\u003e Self {\r\n        assert!(SUPPORTED_WIDTHS.contains(\u0026WIDTH));\r\n        let external_layer = ExternalPerm::new_from_constants(external_constants);\r\n        let internal_layer = InternalPerm::new_from_constants(internal_constants);\r\n\r\n        Self {\r\n            external_layer,\r\n            internal_layer,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    /// Create a new Poseidon2 configuration with random parameters.\r\n    pub fn new_from_rng\u003cR: Rng\u003e(rounds_f: usize, rounds_p: usize, rng: \u0026mut R) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003cF\u003e + Distribution\u003c[F; WIDTH]\u003e,\r\n    {\r\n        let external_constants = ExternalLayerConstants::new_from_rng(rounds_f, rng);\r\n        let internal_constants = rng.sample_iter(Standard).take(rounds_p).collect();\r\n\r\n        Self::new(external_constants, internal_constants)\r\n    }\r\n}\r\n\r\nimpl\u003cF, ExternalPerm, InternalPerm, const WIDTH: usize, const D: u64\u003e\r\n    Poseidon2\u003cF, ExternalPerm, InternalPerm, WIDTH, D\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    ExternalPerm: ExternalLayerConstructor\u003cF, WIDTH\u003e,\r\n    InternalPerm: InternalLayerConstructor\u003cF\u003e,\r\n{\r\n    /// Create a new Poseidon2 configuration with 128 bit security and random rounds constants.\r\n    pub fn new_from_rng_128\u003cR: Rng\u003e(rng: \u0026mut R) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003cF\u003e + Distribution\u003c[F; WIDTH]\u003e,\r\n    {\r\n        let (rounds_f, rounds_p) = poseidon2_round_numbers_128::\u003cF\u003e(WIDTH, D);\r\n        Self::new_from_rng(rounds_f, rounds_p, rng)\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, ExternalPerm, InternalPerm, const WIDTH: usize, const D: u64\u003e Permutation\u003c[A; WIDTH]\u003e\r\n    for Poseidon2\u003cF, ExternalPerm, InternalPerm, WIDTH, D\u003e\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e + Sync + InjectiveMonomial\u003cD\u003e,\r\n    ExternalPerm: ExternalLayer\u003cA, WIDTH, D\u003e,\r\n    InternalPerm: InternalLayer\u003cA, WIDTH, D\u003e,\r\n{\r\n    fn permute_mut(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        self.external_layer.permute_state_initial(state);\r\n        self.internal_layer.permute_state(state);\r\n        self.external_layer.permute_state_terminal(state);\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, ExternalPerm, InternalPerm, const WIDTH: usize, const D: u64\u003e\r\n    CryptographicPermutation\u003c[A; WIDTH]\u003e for Poseidon2\u003cF, ExternalPerm, InternalPerm, WIDTH, D\u003e\r\nwhere\r\n    F: PrimeField + InjectiveMonomial\u003cD\u003e,\r\n    A: Algebra\u003cF\u003e + Sync + InjectiveMonomial\u003cD\u003e,\r\n    ExternalPerm: ExternalLayer\u003cA, WIDTH, D\u003e,\r\n    InternalPerm: InternalLayer\u003cA, WIDTH, D\u003e,\r\n{\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":54,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":55,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":56,"address":[],"length":0,"stats":{"Line":3819052484010180608}},{"line":66,"address":[],"length":0,"stats":{"Line":3530822107858468868}},{"line":70,"address":[],"length":0,"stats":{"Line":3530822107858468868}},{"line":71,"address":[],"length":0,"stats":{"Line":3530822107858468868}},{"line":73,"address":[],"length":0,"stats":{"Line":3530822107858468868}},{"line":85,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":89,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":90,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":102,"address":[],"length":0,"stats":{"Line":11601272640106397692}},{"line":103,"address":[],"length":0,"stats":{"Line":11601272640106397692}},{"line":104,"address":[],"length":0,"stats":{"Line":11601272640106397692}},{"line":105,"address":[],"length":0,"stats":{"Line":11601272640106397692}}],"covered":15,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2","src","round_numbers.rs"],"content":"//! As the security analysis of Poseidon2 is identical to that of Poseidon,\r\n//! the relevant constraints regarding the number of full/partial rounds required can be found in\r\n//! the original paper: `\u003chttps://eprint.iacr.org/2019/458.pdf\u003e` and the associated codebase:\r\n//! `\u003chttps://extgit.iaik.tugraz.at/krypto/hadeshash\u003e` (See generate_params_poseidon.sage)\r\n//!\r\n//! These constraints are broken down into 6 equations:\r\n//! statistical, interpolation, groebner 1, 2, 3 and\r\n//! an extra constraint coming from the paper `\u003chttps://eprint.iacr.org/2023/537.pdf\u003e`.\r\n//!\r\n//! For our parameters (M = 128, p \u003e 2^30, WIDTH = t \u003e= 8, D = alpha \u003c 12),\r\n//! the statistical constraint always simplifies to requiring RF \u003e= 6.\r\n//! Additionally p does not appear in Groebner 3 or the constraint coming from `\u003chttps://eprint.iacr.org/2023/537.pdf\u003e`.\r\n//! The remaining 3 constraints all can be rearranged into the form:\r\n//! F(RF, RP) \u003e= G(p) where G is a function which is non-decreasing with respect to p.\r\n//!\r\n//! Thus, if some tuple (M, p, WIDTH, D, RF, RP) satisfies all constraints, then so will\r\n//! the tuple (M, q, WIDTH, D, RF, RP) for any 2^30 \u003c q \u003c p.\r\n//! Moreover if RF, RP are the \"optimal\" round numbers (Optimal meaning minimising the number of S-box operations we need to perform)\r\n//! for two tuples (M, p, WIDTH, D) and (M, q, WIDTH, D), then\r\n//! they will also be optimal for (M, r, WIDTH, D) for any q \u003c r \u003c p.\r\n//!\r\n//! We compute the optimal required number of external (full) and internal (partial) rounds using:\r\n//! `\u003chttps://github.com/0xPolygonZero/hash-constants/blob/master/calc_round_numbers.py\u003e`\r\n//! Using the above analysis we can conclude that the round numbers are equal\r\n//! for all 31 bit primes and 64 bit primes respectively.\r\n\r\nuse gcd::Gcd;\r\nuse p3_field::PrimeField64;\r\n\r\n/// Given a field, a width and an D return the number of full and partial rounds needed to achieve 128 bit security.\r\npub fn poseidon2_round_numbers_128\u003cF: PrimeField64\u003e(width: usize, d: u64) -\u003e (usize, usize) {\r\n    // Start by checking that d is a valid permutation.\r\n    assert_eq!(d.gcd(F::ORDER_U64 - 1), 1);\r\n\r\n    // Next compute the number of bits in p.\r\n    let prime_bit_number = F::ORDER_U64.ilog2() + 1;\r\n\r\n    match prime_bit_number {\r\n        31 =\u003e match (width, d) {\r\n            (16, 3) =\u003e (8, 20),\r\n            (16, 5) =\u003e (8, 14),\r\n            (16, 7) =\u003e (8, 13),\r\n            (16, 9) =\u003e (8, 13),\r\n            (16, 11) =\u003e (8, 13),\r\n            (24, 3) =\u003e (8, 23),\r\n            (24, 5) =\u003e (8, 22),\r\n            (24, 7) =\u003e (8, 21),\r\n            (24, 9) =\u003e (8, 21),\r\n            (24, 11) =\u003e (8, 21),\r\n            _ =\u003e panic!(\"The given pair of width and D has not been checked for these fields\"),\r\n        },\r\n        64 =\u003e match (width, d) {\r\n            (8, 3) =\u003e (8, 41),\r\n            (8, 5) =\u003e (8, 27),\r\n            (8, 7) =\u003e (8, 22),\r\n            (8, 9) =\u003e (8, 19),\r\n            (8, 11) =\u003e (8, 17),\r\n            (12, 3) =\u003e (8, 42),\r\n            (12, 5) =\u003e (8, 27),\r\n            (12, 7) =\u003e (8, 22),\r\n            (12, 9) =\u003e (8, 20),\r\n            (12, 11) =\u003e (8, 18),\r\n            (16, 3) =\u003e (8, 42),\r\n            (16, 5) =\u003e (8, 27),\r\n            (16, 7) =\u003e (8, 22),\r\n            (16, 9) =\u003e (8, 20),\r\n            (16, 11) =\u003e (8, 18),\r\n            _ =\u003e panic!(\"The given pair of width and D has not been checked for these fields\"),\r\n        },\r\n        _ =\u003e panic!(\"The optimal parameters for that size of prime have not been computed.\"),\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":3530822107858469133}},{"line":33,"address":[],"length":0,"stats":{"Line":3530822107858469133}},{"line":36,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":38,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":39,"address":[],"length":0,"stats":{"Line":3530822107858468864}},{"line":40,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":42,"address":[],"length":0,"stats":{"Line":2810246167479189504}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}}],"covered":11,"coverable":34},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","examples","prove_poseidon2_baby_bear_keccak_zk.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_baby_bear::{BabyBear, GenericPoseidon2LinearLayersBabyBear};\r\nuse p3_challenger::{HashChallenger, SerializingChallenger32};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, HidingFriPcs};\r\nuse p3_keccak::{Keccak256Hash, KeccakF};\r\nuse p3_merkle_tree::MerkleTreeHidingMmcs;\r\nuse p3_poseidon2_air::{RoundConstants, VectorizedPoseidon2Air};\r\nuse p3_symmetric::{CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher32To64};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::rngs::{StdRng, ThreadRng};\r\nuse rand::{thread_rng, SeedableRng};\r\n#[cfg(not(target_env = \"msvc\"))]\r\nuse tikv_jemallocator::Jemalloc;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\n#[cfg(not(target_env = \"msvc\"))]\r\n#[global_allocator]\r\nstatic GLOBAL: Jemalloc = Jemalloc;\r\n\r\nconst WIDTH: usize = 16;\r\nconst SBOX_DEGREE: u64 = 7;\r\nconst SBOX_REGISTERS: usize = 1;\r\nconst HALF_FULL_ROUNDS: usize = 4;\r\nconst PARTIAL_ROUNDS: usize = 20;\r\n\r\nconst NUM_ROWS: usize = 1 \u003c\u003c 16;\r\nconst VECTOR_LEN: usize = 1 \u003c\u003c 3;\r\nconst NUM_PERMUTATIONS: usize = NUM_ROWS * VECTOR_LEN;\r\n\r\ntype Dft = p3_dft::Radix2DitParallel\u003cBabyBear\u003e;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type ByteHash = Keccak256Hash;\r\n    let byte_hash = ByteHash {};\r\n\r\n    type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\r\n    let u64_hash = U64Hash::new(KeccakF {});\r\n\r\n    type FieldHash = SerializingHasher32To64\u003cU64Hash\u003e;\r\n    let field_hash = FieldHash::new(u64_hash);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cU64Hash, 2, 4\u003e;\r\n    let compress = MyCompress::new(u64_hash);\r\n\r\n    type ValMmcs = MerkleTreeHidingMmcs\u003c\r\n        [Val; p3_keccak::VECTOR_LEN],\r\n        [u64; p3_keccak::VECTOR_LEN],\r\n        FieldHash,\r\n        MyCompress,\r\n        ThreadRng,\r\n        4,\r\n        4,\r\n    \u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress, thread_rng());\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let constants = RoundConstants::from_rng(\u0026mut thread_rng());\r\n    let air: VectorizedPoseidon2Air\u003c\r\n        Val,\r\n        GenericPoseidon2LinearLayersBabyBear,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e = VectorizedPoseidon2Air::new(constants);\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = air.generate_vectorized_trace_rows(NUM_PERMUTATIONS, fri_config.log_blowup);\r\n\r\n    let dft = Dft::default();\r\n\r\n    type Pcs = HidingFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs, StdRng\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config, 4, StdRng::from_entropy());\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026air, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026air, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","examples","prove_poseidon2_koala_bear_keccak.rs"],"content":"use std::fmt::Debug;\r\n\r\nuse p3_challenger::{HashChallenger, SerializingChallenger32};\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_fri::{create_benchmark_fri_config, TwoAdicFriPcs};\r\nuse p3_keccak::{Keccak256Hash, KeccakF};\r\nuse p3_koala_bear::{GenericPoseidon2LinearLayersKoalaBear, KoalaBear};\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_poseidon2_air::{RoundConstants, VectorizedPoseidon2Air};\r\nuse p3_symmetric::{CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher32To64};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::thread_rng;\r\n#[cfg(not(target_env = \"msvc\"))]\r\nuse tikv_jemallocator::Jemalloc;\r\nuse tracing_forest::util::LevelFilter;\r\nuse tracing_forest::ForestLayer;\r\nuse tracing_subscriber::layer::SubscriberExt;\r\nuse tracing_subscriber::util::SubscriberInitExt;\r\nuse tracing_subscriber::{EnvFilter, Registry};\r\n\r\n#[cfg(not(target_env = \"msvc\"))]\r\n#[global_allocator]\r\nstatic GLOBAL: Jemalloc = Jemalloc;\r\n\r\nconst WIDTH: usize = 16;\r\nconst SBOX_DEGREE: u64 = 3;\r\nconst SBOX_REGISTERS: usize = 0;\r\nconst HALF_FULL_ROUNDS: usize = 4;\r\nconst PARTIAL_ROUNDS: usize = 20;\r\n\r\nconst NUM_ROWS: usize = 1 \u003c\u003c 16;\r\nconst VECTOR_LEN: usize = 1 \u003c\u003c 3;\r\nconst NUM_PERMUTATIONS: usize = NUM_ROWS * VECTOR_LEN;\r\n\r\n#[cfg(feature = \"parallel\")]\r\ntype Dft = p3_dft::Radix2DitParallel\u003cKoalaBear\u003e;\r\n#[cfg(not(feature = \"parallel\"))]\r\ntype Dft = p3_dft::Radix2Bowers;\r\n\r\nfn main() -\u003e Result\u003c(), impl Debug\u003e {\r\n    let env_filter = EnvFilter::builder()\r\n        .with_default_directive(LevelFilter::INFO.into())\r\n        .from_env_lossy();\r\n\r\n    Registry::default()\r\n        .with(env_filter)\r\n        .with(ForestLayer::default())\r\n        .init();\r\n\r\n    const PROOFS: usize = 2;\r\n    for _ in 1..PROOFS {\r\n        prove_and_verify()?;\r\n    }\r\n    prove_and_verify()\r\n}\r\n\r\nfn prove_and_verify() -\u003e Result\u003c(), impl Debug\u003e {\r\n    type Val = KoalaBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type ByteHash = Keccak256Hash;\r\n    let byte_hash = ByteHash {};\r\n\r\n    type U64Hash = PaddingFreeSponge\u003cKeccakF, 25, 17, 4\u003e;\r\n    let u64_hash = U64Hash::new(KeccakF {});\r\n\r\n    type FieldHash = SerializingHasher32To64\u003cU64Hash\u003e;\r\n    let field_hash = FieldHash::new(u64_hash);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cU64Hash, 2, 4\u003e;\r\n    let compress = MyCompress::new(u64_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003c\r\n        [Val; p3_keccak::VECTOR_LEN],\r\n        [u64; p3_keccak::VECTOR_LEN],\r\n        FieldHash,\r\n        MyCompress,\r\n        4,\r\n    \u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let constants = RoundConstants::from_rng(\u0026mut thread_rng());\r\n    let air: VectorizedPoseidon2Air\u003c\r\n        Val,\r\n        GenericPoseidon2LinearLayersKoalaBear,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e = VectorizedPoseidon2Air::new(constants);\r\n\r\n    let fri_config = create_benchmark_fri_config(challenge_mmcs);\r\n\r\n    let trace = air.generate_vectorized_trace_rows(NUM_PERMUTATIONS, fri_config.log_blowup);\r\n\r\n    let dft = Dft::default();\r\n\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    let proof = prove(\u0026config, \u0026air, \u0026mut challenger, trace, \u0026vec![]);\r\n\r\n    let mut challenger = Challenger::from_hasher(vec![], byte_hash);\r\n    verify(\u0026config, \u0026air, \u0026mut challenger, \u0026proof, \u0026vec![])\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","air.rs"],"content":"use core::borrow::Borrow;\r\nuse core::marker::PhantomData;\r\n\r\nuse p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_matrix::Matrix;\r\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\r\n\r\nuse crate::columns::{num_cols, Poseidon2Cols};\r\nuse crate::constants::RoundConstants;\r\nuse crate::{FullRound, PartialRound, SBox};\r\n\r\n/// Assumes the field size is at least 16 bits.\r\n#[derive(Debug)]\r\npub struct Poseidon2Air\u003c\r\n    F: Field,\r\n    LinearLayers,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e {\r\n    pub(crate) constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\r\n    _phantom: PhantomData\u003cLinearLayers\u003e,\r\n}\r\n\r\nimpl\u003c\r\n        F: Field,\r\n        LinearLayers,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n    \u003e\r\n    Poseidon2Air\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e\r\n{\r\n    pub fn new(constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e) -\u003e Self {\r\n        Self {\r\n            constants,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        F: Field,\r\n        LinearLayers: Sync,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n    \u003e BaseAir\u003cF\u003e\r\n    for Poseidon2Air\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        num_cols::\u003cWIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e()\r\n    }\r\n}\r\n\r\npub(crate) fn eval\u003c\r\n    AB: AirBuilder,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e(\r\n    air: \u0026Poseidon2Air\u003c\r\n        AB::F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e,\r\n    builder: \u0026mut AB,\r\n    local: \u0026Poseidon2Cols\u003c\r\n        AB::Var,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e,\r\n) {\r\n    let mut state: [AB::Expr; WIDTH] = local.inputs.map(|x| x.into());\r\n\r\n    LinearLayers::external_linear_layer(\u0026mut state);\r\n\r\n    for round in 0..HALF_FULL_ROUNDS {\r\n        eval_full_round::\u003cAB, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state,\r\n            \u0026local.beginning_full_rounds[round],\r\n            \u0026air.constants.beginning_full_round_constants[round],\r\n            builder,\r\n        );\r\n    }\r\n\r\n    for round in 0..PARTIAL_ROUNDS {\r\n        eval_partial_round::\u003cAB, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state,\r\n            \u0026local.partial_rounds[round],\r\n            \u0026air.constants.partial_round_constants[round],\r\n            builder,\r\n        );\r\n    }\r\n\r\n    for round in 0..HALF_FULL_ROUNDS {\r\n        eval_full_round::\u003cAB, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state,\r\n            \u0026local.ending_full_rounds[round],\r\n            \u0026air.constants.ending_full_round_constants[round],\r\n            builder,\r\n        );\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        AB: AirBuilder,\r\n        LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n    \u003e Air\u003cAB\u003e\r\n    for Poseidon2Air\u003c\r\n        AB::F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e\r\n{\r\n    #[inline]\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        let main = builder.main();\r\n        let local = main.row_slice(0);\r\n        let local: \u0026Poseidon2Cols\u003c\r\n            AB::Var,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e = (*local).borrow();\r\n\r\n        eval::\u003c\r\n            AB,\r\n            LinearLayers,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e(self, builder, local);\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn eval_full_round\u003c\r\n    AB: AirBuilder,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n\u003e(\r\n    state: \u0026mut [AB::Expr; WIDTH],\r\n    full_round: \u0026FullRound\u003cAB::Var, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e,\r\n    round_constants: \u0026[AB::F; WIDTH],\r\n    builder: \u0026mut AB,\r\n) {\r\n    for (i, (s, r)) in state.iter_mut().zip(round_constants.iter()).enumerate() {\r\n        *s = s.clone() + *r;\r\n        eval_sbox(\u0026full_round.sbox[i], s, builder);\r\n    }\r\n    LinearLayers::external_linear_layer(state);\r\n    for (state_i, post_i) in state.iter_mut().zip(full_round.post) {\r\n        builder.assert_eq(state_i.clone(), post_i);\r\n        *state_i = post_i.into();\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn eval_partial_round\u003c\r\n    AB: AirBuilder,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n\u003e(\r\n    state: \u0026mut [AB::Expr; WIDTH],\r\n    partial_round: \u0026PartialRound\u003cAB::Var, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e,\r\n    round_constant: \u0026AB::F,\r\n    builder: \u0026mut AB,\r\n) {\r\n    state[0] = state[0].clone() + *round_constant;\r\n    eval_sbox(\u0026partial_round.sbox, \u0026mut state[0], builder);\r\n\r\n    builder.assert_eq(state[0].clone(), partial_round.post_sbox);\r\n    state[0] = partial_round.post_sbox.into();\r\n\r\n    LinearLayers::internal_linear_layer(state);\r\n}\r\n\r\n/// Evaluates the S-box over a degree-1 expression `x`.\r\n///\r\n/// # Panics\r\n///\r\n/// This method panics if the number of `REGISTERS` is not chosen optimally for the given\r\n/// `DEGREE` or if the `DEGREE` is not supported by the S-box. The supported degrees are\r\n/// `3`, `5`, `7`, and `11`.\r\n#[inline]\r\nfn eval_sbox\u003cAB, const DEGREE: u64, const REGISTERS: usize\u003e(\r\n    sbox: \u0026SBox\u003cAB::Var, DEGREE, REGISTERS\u003e,\r\n    x: \u0026mut AB::Expr,\r\n    builder: \u0026mut AB,\r\n) where\r\n    AB: AirBuilder,\r\n{\r\n    *x = match (DEGREE, REGISTERS) {\r\n        (3, 0) =\u003e x.cube(),\r\n        (5, 0) =\u003e x.exp_const_u64::\u003c5\u003e(),\r\n        (7, 0) =\u003e x.exp_const_u64::\u003c7\u003e(),\r\n        (5, 1) =\u003e {\r\n            let committed_x3 = sbox.0[0].into();\r\n            let x2 = x.square();\r\n            builder.assert_eq(committed_x3.clone(), x2.clone() * x.clone());\r\n            committed_x3 * x2\r\n        }\r\n        (7, 1) =\u003e {\r\n            let committed_x3 = sbox.0[0].into();\r\n            builder.assert_eq(committed_x3.clone(), x.cube());\r\n            committed_x3.square() * x.clone()\r\n        }\r\n        (11, 2) =\u003e {\r\n            let committed_x3 = sbox.0[0].into();\r\n            let committed_x9 = sbox.0[1].into();\r\n            let x2 = x.square();\r\n            builder.assert_eq(committed_x3.clone(), x2.clone() * x.clone());\r\n            builder.assert_eq(committed_x9.clone(), committed_x3.cube());\r\n            committed_x9 * x2\r\n        }\r\n        _ =\u003e panic!(\r\n            \"Unexpected (DEGREE, REGISTERS) of ({}, {})\",\r\n            DEGREE, REGISTERS\r\n        ),\r\n    }\r\n}\r\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":71},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","columns.rs"],"content":"use core::borrow::{Borrow, BorrowMut};\r\nuse core::mem::size_of;\r\n\r\n/// Columns for a Poseidon2 AIR which computes one permutation per row.\r\n///\r\n/// The columns of the STARK are divided into the three different round sections of the Poseidon2\r\n/// Permutation: beginning full rounds, partial rounds, and ending full rounds. For the full\r\n/// rounds we store an [`SBox`] columnset for each state variable, and for the partial rounds we\r\n/// store only for the first state variable. Because the matrix multiplications are linear\r\n/// functions, we need only keep auxiliary columns for the S-box computations.\r\n#[repr(C)]\r\npub struct Poseidon2Cols\u003c\r\n    T,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e {\r\n    pub export: T,\r\n\r\n    pub inputs: [T; WIDTH],\r\n\r\n    /// Beginning Full Rounds\r\n    pub beginning_full_rounds: [FullRound\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e; HALF_FULL_ROUNDS],\r\n\r\n    /// Partial Rounds\r\n    pub partial_rounds: [PartialRound\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e; PARTIAL_ROUNDS],\r\n\r\n    /// Ending Full Rounds\r\n    pub ending_full_rounds: [FullRound\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e; HALF_FULL_ROUNDS],\r\n}\r\n\r\n/// Full round columns.\r\n#[repr(C)]\r\npub struct FullRound\u003cT, const WIDTH: usize, const SBOX_DEGREE: u64, const SBOX_REGISTERS: usize\u003e {\r\n    /// Possible intermediate results within each S-box.\r\n    pub sbox: [SBox\u003cT, SBOX_DEGREE, SBOX_REGISTERS\u003e; WIDTH],\r\n    /// The post-state, i.e. the entire layer after this full round.\r\n    pub post: [T; WIDTH],\r\n}\r\n\r\n/// Partial round columns.\r\n#[repr(C)]\r\npub struct PartialRound\u003cT, const WIDTH: usize, const SBOX_DEGREE: u64, const SBOX_REGISTERS: usize\u003e\r\n{\r\n    /// Possible intermediate results within the S-box.\r\n    pub sbox: SBox\u003cT, SBOX_DEGREE, SBOX_REGISTERS\u003e,\r\n    /// The output of the S-box.\r\n    pub post_sbox: T,\r\n}\r\n\r\n/// Possible intermediate results within an S-box.\r\n///\r\n/// Use this column-set for an S-box that can be computed with `REGISTERS`-many intermediate results\r\n/// (not counting the final output). The S-box is checked to ensure that `REGISTERS` is the optimal\r\n/// number of registers for the given `DEGREE` for the degrees given in the Poseidon2 paper:\r\n/// `3`, `5`, `7`, and `11`. See `eval_sbox` for more information.\r\n#[repr(C)]\r\npub struct SBox\u003cT, const DEGREE: u64, const REGISTERS: usize\u003e(pub [T; REGISTERS]);\r\n\r\npub const fn num_cols\u003c\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e() -\u003e usize {\r\n    size_of::\u003cPoseidon2Cols\u003cu8, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\u003e(\r\n    )\r\n}\r\n\r\npub const fn make_col_map\u003c\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e() -\u003e Poseidon2Cols\u003cusize, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e {\r\n    todo!()\r\n    // let indices_arr = indices_arr::\u003c\r\n    //     { num_cols::\u003cWIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e() },\r\n    // \u003e();\r\n    // unsafe {\r\n    //     transmute::\u003c\r\n    //         [usize;\r\n    //             num_cols::\u003cWIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e()],\r\n    //         Poseidon2Cols\u003c\r\n    //             usize,\r\n    //             WIDTH,\r\n    //             SBOX_DEGREE,\r\n    //             SBOX_REGISTERS,\r\n    //             HALF_FULL_ROUNDS,\r\n    //             PARTIAL_ROUNDS,\r\n    //         \u003e,\r\n    //     \u003e(indices_arr)\r\n    // }\r\n}\r\n\r\nimpl\u003c\r\n        T,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n    \u003e Borrow\u003cPoseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\u003e\r\n    for [T]\r\n{\r\n    fn borrow(\r\n        \u0026self,\r\n    ) -\u003e \u0026Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\r\n    {\r\n        // debug_assert_eq!(self.len(), NUM_COLS);\r\n        let (prefix, shorts, suffix) = unsafe {\r\n            self.align_to::\u003cPoseidon2Cols\u003c\r\n                T,\r\n                WIDTH,\r\n                SBOX_DEGREE,\r\n                SBOX_REGISTERS,\r\n                HALF_FULL_ROUNDS,\r\n                PARTIAL_ROUNDS,\r\n            \u003e\u003e()\r\n        };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026shorts[0]\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        T,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n    \u003e\r\n    BorrowMut\u003c\r\n        Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\r\n    \u003e for [T]\r\n{\r\n    fn borrow_mut(\r\n        \u0026mut self,\r\n    ) -\u003e \u0026mut Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\r\n    {\r\n        // debug_assert_eq!(self.len(), NUM_COLS);\r\n        let (prefix, shorts, suffix) = unsafe {\r\n            self.align_to_mut::\u003cPoseidon2Cols\u003c\r\n                T,\r\n                WIDTH,\r\n                SBOX_DEGREE,\r\n                SBOX_REGISTERS,\r\n                HALF_FULL_ROUNDS,\r\n                PARTIAL_ROUNDS,\r\n            \u003e\u003e()\r\n        };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026mut shorts[0]\r\n    }\r\n}\r\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":15},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","constants.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_field::Field;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::Rng;\r\n\r\n/// Round constants for Poseidon2, in a format that's convenient for the AIR.\r\n#[derive(Debug, Clone)]\r\npub struct RoundConstants\u003c\r\n    F: Field,\r\n    const WIDTH: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e {\r\n    pub(crate) beginning_full_round_constants: [[F; WIDTH]; HALF_FULL_ROUNDS],\r\n    pub(crate) partial_round_constants: [F; PARTIAL_ROUNDS],\r\n    pub(crate) ending_full_round_constants: [[F; WIDTH]; HALF_FULL_ROUNDS],\r\n}\r\n\r\nimpl\u003cF: Field, const WIDTH: usize, const HALF_FULL_ROUNDS: usize, const PARTIAL_ROUNDS: usize\u003e\r\n    RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e\r\n{\r\n    pub fn new(\r\n        beginning_full_round_constants: [[F; WIDTH]; HALF_FULL_ROUNDS],\r\n        partial_round_constants: [F; PARTIAL_ROUNDS],\r\n        ending_full_round_constants: [[F; WIDTH]; HALF_FULL_ROUNDS],\r\n    ) -\u003e Self {\r\n        Self {\r\n            beginning_full_round_constants,\r\n            partial_round_constants,\r\n            ending_full_round_constants,\r\n        }\r\n    }\r\n\r\n    pub fn from_rng\u003cR: Rng\u003e(rng: \u0026mut R) -\u003e Self\r\n    where\r\n        Standard: Distribution\u003cF\u003e + Distribution\u003c[F; WIDTH]\u003e,\r\n    {\r\n        let beginning_full_round_constants = rng\r\n            .sample_iter(Standard)\r\n            .take(HALF_FULL_ROUNDS)\r\n            .collect::\u003cVec\u003c[F; WIDTH]\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n        let partial_round_constants = rng\r\n            .sample_iter(Standard)\r\n            .take(PARTIAL_ROUNDS)\r\n            .collect::\u003cVec\u003cF\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n        let ending_full_round_constants = rng\r\n            .sample_iter(Standard)\r\n            .take(HALF_FULL_ROUNDS)\r\n            .collect::\u003cVec\u003c[F; WIDTH]\u003e\u003e()\r\n            .try_into()\r\n            .unwrap();\r\n        Self {\r\n            beginning_full_round_constants,\r\n            partial_round_constants,\r\n            ending_full_round_constants,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","generation.rs"],"content":"use alloc::vec::Vec;\r\nuse core::mem::MaybeUninit;\r\n\r\nuse p3_field::PrimeField;\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixViewMut};\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\r\nuse tracing::instrument;\r\n\r\nuse crate::columns::{num_cols, Poseidon2Cols};\r\nuse crate::{FullRound, PartialRound, RoundConstants, SBox};\r\n\r\n#[instrument(name = \"generate vectorized Poseidon2 trace\", skip_all)]\r\npub fn generate_vectorized_trace_rows\u003c\r\n    F: PrimeField,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n    const VECTOR_LEN: usize,\r\n\u003e(\r\n    inputs: Vec\u003c[F; WIDTH]\u003e,\r\n    round_constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\r\n    extra_capacity_bits: usize,\r\n) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    let n = inputs.len();\r\n    assert!(\r\n        n % VECTOR_LEN == 0 \u0026\u0026 (n / VECTOR_LEN).is_power_of_two(),\r\n        \"Callers expected to pad inputs to VECTOR_LEN times a power of two\"\r\n    );\r\n\r\n    let nrows = n.div_ceil(VECTOR_LEN);\r\n    let ncols = num_cols::\u003cWIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e()\r\n        * VECTOR_LEN;\r\n    let mut vec = Vec::with_capacity((nrows * ncols) \u003c\u003c extra_capacity_bits);\r\n    let trace: \u0026mut [MaybeUninit\u003cF\u003e] = \u0026mut vec.spare_capacity_mut()[..nrows * ncols];\r\n    let trace: RowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e = RowMajorMatrixViewMut::new(trace, ncols);\r\n\r\n    let (prefix, perms, suffix) = unsafe {\r\n        trace.values.align_to_mut::\u003cPoseidon2Cols\u003c\r\n            MaybeUninit\u003cF\u003e,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e\u003e()\r\n    };\r\n    assert!(prefix.is_empty(), \"Alignment should match\");\r\n    assert!(suffix.is_empty(), \"Alignment should match\");\r\n    assert_eq!(perms.len(), n);\r\n\r\n    perms.par_iter_mut().zip(inputs).for_each(|(perm, input)| {\r\n        generate_trace_rows_for_perm::\u003c\r\n            F,\r\n            LinearLayers,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e(perm, input, round_constants);\r\n    });\r\n\r\n    unsafe {\r\n        vec.set_len(nrows * ncols);\r\n    }\r\n\r\n    RowMajorMatrix::new(vec, ncols)\r\n}\r\n\r\n// TODO: Take generic iterable\r\n#[instrument(name = \"generate Poseidon2 trace\", skip_all)]\r\npub fn generate_trace_rows\u003c\r\n    F: PrimeField,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e(\r\n    inputs: Vec\u003c[F; WIDTH]\u003e,\r\n    constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\r\n) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    let n = inputs.len();\r\n    assert!(\r\n        n.is_power_of_two(),\r\n        \"Callers expected to pad inputs to a power of two\"\r\n    );\r\n\r\n    let ncols = num_cols::\u003cWIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e();\r\n    let mut vec = Vec::with_capacity(n * ncols * 2);\r\n    let trace: \u0026mut [MaybeUninit\u003cF\u003e] = \u0026mut vec.spare_capacity_mut()[..n * ncols];\r\n    let trace: RowMajorMatrixViewMut\u003cMaybeUninit\u003cF\u003e\u003e = RowMajorMatrixViewMut::new(trace, ncols);\r\n\r\n    let (prefix, perms, suffix) = unsafe {\r\n        trace.values.align_to_mut::\u003cPoseidon2Cols\u003c\r\n            MaybeUninit\u003cF\u003e,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e\u003e()\r\n    };\r\n    assert!(prefix.is_empty(), \"Alignment should match\");\r\n    assert!(suffix.is_empty(), \"Alignment should match\");\r\n    assert_eq!(perms.len(), n);\r\n\r\n    perms.par_iter_mut().zip(inputs).for_each(|(perm, input)| {\r\n        generate_trace_rows_for_perm::\u003c\r\n            F,\r\n            LinearLayers,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n        \u003e(perm, input, constants);\r\n    });\r\n\r\n    unsafe {\r\n        vec.set_len(n * ncols);\r\n    }\r\n\r\n    RowMajorMatrix::new(vec, ncols)\r\n}\r\n\r\n/// `rows` will normally consist of 24 rows, with an exception for the final row.\r\nfn generate_trace_rows_for_perm\u003c\r\n    F: PrimeField,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n\u003e(\r\n    perm: \u0026mut Poseidon2Cols\u003c\r\n        MaybeUninit\u003cF\u003e,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e,\r\n    mut state: [F; WIDTH],\r\n    constants: \u0026RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e,\r\n) {\r\n    perm.export.write(F::ONE);\r\n    perm.inputs\r\n        .iter_mut()\r\n        .zip(state.iter())\r\n        .for_each(|(input, \u0026x)| {\r\n            input.write(x);\r\n        });\r\n\r\n    LinearLayers::external_linear_layer(\u0026mut state);\r\n\r\n    for (full_round, constants) in perm\r\n        .beginning_full_rounds\r\n        .iter_mut()\r\n        .zip(\u0026constants.beginning_full_round_constants)\r\n    {\r\n        generate_full_round::\u003cF, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state, full_round, constants,\r\n        );\r\n    }\r\n\r\n    for (partial_round, constant) in perm\r\n        .partial_rounds\r\n        .iter_mut()\r\n        .zip(\u0026constants.partial_round_constants)\r\n    {\r\n        generate_partial_round::\u003cF, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state,\r\n            partial_round,\r\n            *constant,\r\n        );\r\n    }\r\n\r\n    for (full_round, constants) in perm\r\n        .ending_full_rounds\r\n        .iter_mut()\r\n        .zip(\u0026constants.ending_full_round_constants)\r\n    {\r\n        generate_full_round::\u003cF, LinearLayers, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e(\r\n            \u0026mut state, full_round, constants,\r\n        );\r\n    }\r\n}\r\n\r\n#[inline]\r\nfn generate_full_round\u003c\r\n    F: PrimeField,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n\u003e(\r\n    state: \u0026mut [F; WIDTH],\r\n    full_round: \u0026mut FullRound\u003cMaybeUninit\u003cF\u003e, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e,\r\n    round_constants: \u0026[F; WIDTH],\r\n) {\r\n    for (state_i, const_i) in state.iter_mut().zip(round_constants) {\r\n        *state_i += *const_i;\r\n    }\r\n    for (state_i, sbox_i) in state.iter_mut().zip(full_round.sbox.iter_mut()) {\r\n        generate_sbox(sbox_i, state_i);\r\n    }\r\n    LinearLayers::external_linear_layer(state);\r\n    full_round\r\n        .post\r\n        .iter_mut()\r\n        .zip(*state)\r\n        .for_each(|(post, x)| {\r\n            post.write(x);\r\n        });\r\n}\r\n\r\n#[inline]\r\nfn generate_partial_round\u003c\r\n    F: PrimeField,\r\n    LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n\u003e(\r\n    state: \u0026mut [F; WIDTH],\r\n    partial_round: \u0026mut PartialRound\u003cMaybeUninit\u003cF\u003e, WIDTH, SBOX_DEGREE, SBOX_REGISTERS\u003e,\r\n    round_constant: F,\r\n) {\r\n    state[0] += round_constant;\r\n    generate_sbox(\u0026mut partial_round.sbox, \u0026mut state[0]);\r\n    partial_round.post_sbox.write(state[0]);\r\n    LinearLayers::internal_linear_layer(state);\r\n}\r\n\r\n#[inline]\r\nfn generate_sbox\u003cF: PrimeField, const DEGREE: u64, const REGISTERS: usize\u003e(\r\n    sbox: \u0026mut SBox\u003cMaybeUninit\u003cF\u003e, DEGREE, REGISTERS\u003e,\r\n    x: \u0026mut F,\r\n) {\r\n    *x = match (DEGREE, REGISTERS) {\r\n        (3, 0) =\u003e x.cube(),\r\n        (5, 0) =\u003e x.exp_const_u64::\u003c5\u003e(),\r\n        (7, 0) =\u003e x.exp_const_u64::\u003c7\u003e(),\r\n        (5, 1) =\u003e {\r\n            let x2 = x.square();\r\n            let x3 = x2 * *x;\r\n            sbox.0[0].write(x3);\r\n            x3 * x2\r\n        }\r\n        (7, 1) =\u003e {\r\n            let x3 = x.cube();\r\n            sbox.0[0].write(x3);\r\n            x3 * x3 * *x\r\n        }\r\n        (11, 2) =\u003e {\r\n            let x2 = x.square();\r\n            let x3 = x2 * *x;\r\n            let x9 = x3.cube();\r\n            sbox.0[0].write(x3);\r\n            sbox.0[1].write(x9);\r\n            x9 * x2\r\n        }\r\n        _ =\u003e panic!(\r\n            \"Unexpected (DEGREE, REGISTERS) of ({}, {})\",\r\n            DEGREE, REGISTERS\r\n        ),\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":253,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":114},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","lib.rs"],"content":"//! And AIR for the Poseidon2 permutation.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod air;\r\nmod columns;\r\nmod constants;\r\nmod generation;\r\nmod vectorized;\r\n\r\npub use air::*;\r\npub use columns::*;\r\npub use constants::*;\r\npub use generation::*;\r\npub use vectorized::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","poseidon2-air","src","vectorized.rs"],"content":"use alloc::vec::Vec;\r\nuse core::borrow::{Borrow, BorrowMut};\r\n\r\nuse p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_field::{Field, PrimeField};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_poseidon2::GenericPoseidon2LinearLayers;\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\nuse rand::random;\r\n\r\nuse crate::air::eval;\r\nuse crate::constants::RoundConstants;\r\nuse crate::{generate_vectorized_trace_rows, Poseidon2Air, Poseidon2Cols};\r\n\r\n/// A \"vectorized\" version of Poseidon2Cols, for computing multiple Poseidon2 permutations per row.\r\n#[repr(C)]\r\npub struct VectorizedPoseidon2Cols\u003c\r\n    T,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n    const VECTOR_LEN: usize,\r\n\u003e {\r\n    pub(crate) cols:\r\n        [Poseidon2Cols\u003cT, WIDTH, SBOX_DEGREE, SBOX_REGISTERS, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e;\r\n            VECTOR_LEN],\r\n}\r\n\r\nimpl\u003c\r\n        T,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e\r\n    Borrow\u003c\r\n        VectorizedPoseidon2Cols\u003c\r\n            T,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n            VECTOR_LEN,\r\n        \u003e,\r\n    \u003e for [T]\r\n{\r\n    fn borrow(\r\n        \u0026self,\r\n    ) -\u003e \u0026VectorizedPoseidon2Cols\u003c\r\n        T,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e {\r\n        // debug_assert_eq!(self.len(), NUM_COLS);\r\n        let (prefix, shorts, suffix) = unsafe {\r\n            self.align_to::\u003cVectorizedPoseidon2Cols\u003c\r\n                T,\r\n                WIDTH,\r\n                SBOX_DEGREE,\r\n                SBOX_REGISTERS,\r\n                HALF_FULL_ROUNDS,\r\n                PARTIAL_ROUNDS,\r\n                VECTOR_LEN,\r\n            \u003e\u003e()\r\n        };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026shorts[0]\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        T,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e\r\n    BorrowMut\u003c\r\n        VectorizedPoseidon2Cols\u003c\r\n            T,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n            VECTOR_LEN,\r\n        \u003e,\r\n    \u003e for [T]\r\n{\r\n    fn borrow_mut(\r\n        \u0026mut self,\r\n    ) -\u003e \u0026mut VectorizedPoseidon2Cols\u003c\r\n        T,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e {\r\n        // debug_assert_eq!(self.len(), NUM_COLS);\r\n        let (prefix, shorts, suffix) = unsafe {\r\n            self.align_to_mut::\u003cVectorizedPoseidon2Cols\u003c\r\n                T,\r\n                WIDTH,\r\n                SBOX_DEGREE,\r\n                SBOX_REGISTERS,\r\n                HALF_FULL_ROUNDS,\r\n                PARTIAL_ROUNDS,\r\n                VECTOR_LEN,\r\n            \u003e\u003e()\r\n        };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026mut shorts[0]\r\n    }\r\n}\r\n\r\n/// A \"vectorized\" version of Poseidon2Air, for computing multiple Poseidon2 permutations per row.\r\npub struct VectorizedPoseidon2Air\u003c\r\n    F: Field,\r\n    LinearLayers,\r\n    const WIDTH: usize,\r\n    const SBOX_DEGREE: u64,\r\n    const SBOX_REGISTERS: usize,\r\n    const HALF_FULL_ROUNDS: usize,\r\n    const PARTIAL_ROUNDS: usize,\r\n    const VECTOR_LEN: usize,\r\n\u003e {\r\n    pub(crate) air: Poseidon2Air\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n    \u003e,\r\n}\r\n\r\nimpl\u003c\r\n        F: Field,\r\n        LinearLayers,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e\r\n    VectorizedPoseidon2Air\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    pub fn new(constants: RoundConstants\u003cF, WIDTH, HALF_FULL_ROUNDS, PARTIAL_ROUNDS\u003e) -\u003e Self {\r\n        Self {\r\n            air: Poseidon2Air::new(constants),\r\n        }\r\n    }\r\n\r\n    pub fn generate_vectorized_trace_rows(\r\n        \u0026self,\r\n        num_hashes: usize,\r\n        extra_capacity_bits: usize,\r\n    ) -\u003e RowMajorMatrix\u003cF\u003e\r\n    where\r\n        F: PrimeField,\r\n        LinearLayers: GenericPoseidon2LinearLayers\u003cF, WIDTH\u003e,\r\n        Standard: Distribution\u003c[F; WIDTH]\u003e,\r\n    {\r\n        let inputs = (0..num_hashes).map(|_| random()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        generate_vectorized_trace_rows::\u003c\r\n            F,\r\n            LinearLayers,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n            VECTOR_LEN,\r\n        \u003e(inputs, \u0026self.air.constants, extra_capacity_bits)\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        F: Field,\r\n        LinearLayers: Sync,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e BaseAir\u003cF\u003e\r\n    for VectorizedPoseidon2Air\u003c\r\n        F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    fn width(\u0026self) -\u003e usize {\r\n        self.air.width() * VECTOR_LEN\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        AB: AirBuilder,\r\n        LinearLayers: GenericPoseidon2LinearLayers\u003cAB::Expr, WIDTH\u003e,\r\n        const WIDTH: usize,\r\n        const SBOX_DEGREE: u64,\r\n        const SBOX_REGISTERS: usize,\r\n        const HALF_FULL_ROUNDS: usize,\r\n        const PARTIAL_ROUNDS: usize,\r\n        const VECTOR_LEN: usize,\r\n    \u003e Air\u003cAB\u003e\r\n    for VectorizedPoseidon2Air\u003c\r\n        AB::F,\r\n        LinearLayers,\r\n        WIDTH,\r\n        SBOX_DEGREE,\r\n        SBOX_REGISTERS,\r\n        HALF_FULL_ROUNDS,\r\n        PARTIAL_ROUNDS,\r\n        VECTOR_LEN,\r\n    \u003e\r\n{\r\n    #[inline]\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        let main = builder.main();\r\n        let local = main.row_slice(0);\r\n        let local: \u0026VectorizedPoseidon2Cols\u003c\r\n            AB::Var,\r\n            WIDTH,\r\n            SBOX_DEGREE,\r\n            SBOX_REGISTERS,\r\n            HALF_FULL_ROUNDS,\r\n            PARTIAL_ROUNDS,\r\n            VECTOR_LEN,\r\n        \u003e = (*local).borrow();\r\n        for perm in \u0026local.cols {\r\n            eval(\u0026self.air, builder, perm);\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":33},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","rescue","benches","rescue.rs"],"content":"use std::any::type_name;\r\nuse std::array;\r\n\r\nuse criterion::{criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_baby_bear::{BabyBear, MdsMatrixBabyBear};\r\nuse p3_field::{Algebra, Field, PermutationMonomial, PrimeField64};\r\nuse p3_goldilocks::{Goldilocks, MdsMatrixGoldilocks};\r\nuse p3_mds::integrated_coset_mds::IntegratedCosetMds;\r\nuse p3_mds::MdsPermutation;\r\nuse p3_mersenne_31::{MdsMatrixMersenne31, Mersenne31};\r\nuse p3_rescue::Rescue;\r\nuse p3_symmetric::Permutation;\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{thread_rng, Rng};\r\n\r\nfn bench_rescue(c: \u0026mut Criterion) {\r\n    rescue::\u003cBabyBear, BabyBear, IntegratedCosetMds\u003c_, 16\u003e, 16, 7\u003e(c);\r\n    rescue::\u003cBabyBear, \u003cBabyBear as Field\u003e::Packing, IntegratedCosetMds\u003cBabyBear, 16\u003e, 16, 7\u003e(c);\r\n    rescue::\u003cBabyBear, BabyBear, MdsMatrixBabyBear, 24, 7\u003e(c);\r\n    rescue::\u003cBabyBear, BabyBear, MdsMatrixBabyBear, 32, 7\u003e(c);\r\n\r\n    rescue::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 8, 7\u003e(c);\r\n    rescue::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 12, 7\u003e(c);\r\n    rescue::\u003cGoldilocks, Goldilocks, MdsMatrixGoldilocks, 16, 7\u003e(c);\r\n\r\n    rescue::\u003cMersenne31, Mersenne31, MdsMatrixMersenne31, 16, 5\u003e(c);\r\n    rescue::\u003cMersenne31, Mersenne31, MdsMatrixMersenne31, 32, 5\u003e(c);\r\n}\r\n\r\nfn rescue\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e(c: \u0026mut Criterion)\r\nwhere\r\n    F: PrimeField64 + PermutationMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + PermutationMonomial\u003cALPHA\u003e,\r\n    Standard: Distribution\u003cF\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e + Default,\r\n{\r\n    // 8 rounds seems to work for the configs we use in practice. For benchmarking purposes we will\r\n    // assume it suffices; for real usage the Sage calculation in the paper should be used.\r\n    const NUM_ROUNDS: usize = 8;\r\n\r\n    let rng = thread_rng();\r\n    let num_constants = 2 * WIDTH * NUM_ROUNDS;\r\n    let round_constants = rng.sample_iter(Standard).take(num_constants).collect();\r\n    let mds = Mds::default();\r\n    let rescue = Rescue::\u003cF, Mds, WIDTH, ALPHA\u003e::new(NUM_ROUNDS, round_constants, mds);\r\n    let input: [A; WIDTH] = array::from_fn(|_| A::ZERO);\r\n    let name = format!(\"rescue::\u003c{}, {}\u003e\", type_name::\u003cA\u003e(), ALPHA);\r\n    let id = BenchmarkId::new(name, WIDTH);\r\n    c.bench_with_input(id, \u0026input, |b, input| {\r\n        b.iter(|| rescue.permute(input.clone()))\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, bench_rescue);\r\ncriterion_main!(benches);\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":10},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","rescue","src","lib.rs"],"content":"#![allow(dead_code)] // TODO: remove when we settle on implementation details and publicly export\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod rescue;\r\nmod util;\r\n\r\npub use rescue::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","rescue","src","rescue.rs"],"content":"use alloc::format;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::Itertools;\r\nuse num::{BigUint, One};\r\nuse num_integer::binomial;\r\nuse p3_field::{Algebra, PermutationMonomial, PrimeField, PrimeField64};\r\nuse p3_mds::MdsPermutation;\r\nuse p3_symmetric::{CryptographicPermutation, Permutation};\r\nuse rand::distributions::Standard;\r\nuse rand::prelude::Distribution;\r\nuse rand::Rng;\r\n\r\nuse crate::util::shake256_hash;\r\n\r\n/// The Rescue-XLIX permutation.\r\n#[derive(Clone, Debug)]\r\npub struct Rescue\u003cF, Mds, const WIDTH: usize, const ALPHA: u64\u003e {\r\n    num_rounds: usize,\r\n    mds: Mds,\r\n    round_constants: Vec\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF, Mds, const WIDTH: usize, const ALPHA: u64\u003e Rescue\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + PermutationMonomial\u003cALPHA\u003e,\r\n{\r\n    pub fn new(num_rounds: usize, round_constants: Vec\u003cF\u003e, mds: Mds) -\u003e Self {\r\n        Self {\r\n            num_rounds,\r\n            mds,\r\n            round_constants,\r\n        }\r\n    }\r\n\r\n    fn num_rounds(capacity: usize, sec_level: usize, alpha: u64) -\u003e usize {\r\n        let rate = WIDTH - capacity;\r\n        let dcon = |n: usize| {\r\n            (0.5 * ((alpha - 1) * WIDTH as u64 * (n as u64 - 1)) as f64 + 2.0).floor() as usize\r\n        };\r\n        let v = |n: usize| WIDTH * (n - 1) + rate;\r\n        let target = BigUint::one() \u003c\u003c sec_level;\r\n\r\n        let is_sufficient = |l1: \u0026usize| {\r\n            let n = BigUint::from(v(*l1) + dcon(*l1));\r\n            let k = BigUint::from(v(*l1));\r\n            let bin = binomial(n, k);\r\n            \u0026bin * \u0026bin \u003e target\r\n        };\r\n        let l1 = (1..25).find(is_sufficient).unwrap();\r\n        (l1.max(5) as f32 * 1.5).ceil() as usize\r\n    }\r\n\r\n    // For a general field, we provide a generic constructor for the round constants.\r\n    pub fn get_round_constants_from_rng\u003cR: Rng\u003e(num_rounds: usize, rng: \u0026mut R) -\u003e Vec\u003cF\u003e\r\n    where\r\n        Standard: Distribution\u003cF\u003e,\r\n    {\r\n        let num_constants = 2 * WIDTH * num_rounds;\r\n        rng.sample_iter(Standard).take(num_constants).collect()\r\n    }\r\n\r\n    fn get_round_constants_rescue_prime(\r\n        num_rounds: usize,\r\n        capacity: usize,\r\n        sec_level: usize,\r\n    ) -\u003e Vec\u003cF\u003e\r\n    where\r\n        F: PrimeField64,\r\n    {\r\n        let num_constants = 2 * WIDTH * num_rounds;\r\n        let bytes_per_constant = F::bits().div_ceil(8) + 1;\r\n        let num_bytes = bytes_per_constant * num_constants;\r\n\r\n        let seed_string = format!(\r\n            \"Rescue-XLIX({},{},{},{})\",\r\n            F::ORDER_U64,\r\n            WIDTH,\r\n            capacity,\r\n            sec_level,\r\n        );\r\n        let byte_string = shake256_hash(seed_string.as_bytes(), num_bytes);\r\n\r\n        byte_string\r\n            .iter()\r\n            .chunks(bytes_per_constant)\r\n            .into_iter()\r\n            .map(|chunk| {\r\n                let integer = chunk\r\n                    .collect_vec()\r\n                    .iter()\r\n                    .rev()\r\n                    .fold(0, |acc, \u0026byte| (acc \u003c\u003c 8) + *byte as u64);\r\n                F::from_u64(integer)\r\n            })\r\n            .collect()\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e Permutation\u003c[A; WIDTH]\u003e\r\n    for Rescue\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + PermutationMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + PermutationMonomial\u003cALPHA\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n{\r\n    fn permute_mut(\u0026self, state: \u0026mut [A; WIDTH]) {\r\n        for round in 0..self.num_rounds {\r\n            // S-box\r\n            state.iter_mut().for_each(|x| *x = x.injective_exp_n());\r\n\r\n            // MDS\r\n            self.mds.permute_mut(state);\r\n\r\n            // Constants\r\n            for (state_item, \u0026round_constant) in state\r\n                .iter_mut()\r\n                .zip(\u0026self.round_constants[round * WIDTH * 2..])\r\n            {\r\n                *state_item += round_constant;\r\n            }\r\n\r\n            // Inverse S-box\r\n            state.iter_mut().for_each(|x| *x = x.injective_exp_root_n());\r\n\r\n            // MDS\r\n            self.mds.permute_mut(state);\r\n\r\n            // Constants\r\n            for (state_item, \u0026round_constant) in state\r\n                .iter_mut()\r\n                .zip(\u0026self.round_constants[round * WIDTH * 2 + WIDTH..])\r\n            {\r\n                *state_item += round_constant;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, A, Mds, const WIDTH: usize, const ALPHA: u64\u003e CryptographicPermutation\u003c[A; WIDTH]\u003e\r\n    for Rescue\u003cF, Mds, WIDTH, ALPHA\u003e\r\nwhere\r\n    F: PrimeField + PermutationMonomial\u003cALPHA\u003e,\r\n    A: Algebra\u003cF\u003e + PermutationMonomial\u003cALPHA\u003e,\r\n    Mds: MdsPermutation\u003cA, WIDTH\u003e,\r\n{\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use p3_field::PrimeCharacteristicRing;\r\n    use p3_mersenne_31::{MdsMatrixMersenne31, Mersenne31};\r\n    use p3_symmetric::{CryptographicHasher, PaddingFreeSponge, Permutation};\r\n\r\n    use crate::rescue::Rescue;\r\n\r\n    const WIDTH: usize = 12;\r\n    const ALPHA: u64 = 5;\r\n    type RescuePrimeM31Default = Rescue\u003cMersenne31, MdsMatrixMersenne31, WIDTH, ALPHA\u003e;\r\n\r\n    fn new_rescue_prime_m31_default() -\u003e RescuePrimeM31Default {\r\n        let num_rounds = RescuePrimeM31Default::num_rounds(6, 128, ALPHA);\r\n        let round_constants =\r\n            RescuePrimeM31Default::get_round_constants_rescue_prime(num_rounds, 6, 128);\r\n        let mds = MdsMatrixMersenne31 {};\r\n\r\n        RescuePrimeM31Default::new(num_rounds, round_constants, mds)\r\n    }\r\n\r\n    const NUM_TESTS: usize = 3;\r\n\r\n    const PERMUTATION_INPUTS: [[u64; WIDTH]; NUM_TESTS] = [\r\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\r\n        [\r\n            144096679, 1638468327, 1550998769, 1713522258, 730676443, 955614588, 1970746889,\r\n            1473251100, 1575313887, 1867935938, 364960233, 91318724,\r\n        ],\r\n        [\r\n            1946786350, 648783024, 470775457, 573110744, 2049365630, 710763043, 1694076126,\r\n            1852085316, 1518834534, 249604062, 45487116, 1543494419,\r\n        ],\r\n    ];\r\n\r\n    // Generated using the rescue_XLIX_permutation function of\r\n    // https://github.com/KULeuven-COSIC/Marvellous/blob/master/rescue_prime.sage\r\n    const PERMUTATION_OUTPUTS: [[u64; WIDTH]; NUM_TESTS] = [\r\n        [\r\n            1415867641, 1662872101, 1070605392, 450708029, 1752877321, 144003686, 623713963,\r\n            13124252, 1719755748, 1164265443, 1031746503, 656034061,\r\n        ],\r\n        [\r\n            745601819, 399135364, 1705560828, 1125372012, 2039222953, 1144119753, 1606567447,\r\n            1152559313, 1762793605, 424623198, 651056006, 1227670410,\r\n        ],\r\n        [\r\n            277798368, 1055656487, 366843969, 917136738, 1286790161, 1840518903, 161567750,\r\n            974017246, 1102241644, 633393178, 896102012, 1791619348,\r\n        ],\r\n    ];\r\n\r\n    #[test]\r\n    fn test_rescue_xlix_permutation() {\r\n        let rescue_prime = new_rescue_prime_m31_default();\r\n\r\n        for test_run in 0..NUM_TESTS {\r\n            let state: [Mersenne31; WIDTH] = PERMUTATION_INPUTS[test_run].map(Mersenne31::from_u64);\r\n\r\n            let expected: [Mersenne31; WIDTH] =\r\n                PERMUTATION_OUTPUTS[test_run].map(Mersenne31::from_u64);\r\n\r\n            let actual = rescue_prime.permute(state);\r\n            assert_eq!(actual, expected);\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_rescue_sponge() {\r\n        let rescue_prime = new_rescue_prime_m31_default();\r\n        let rescue_sponge = PaddingFreeSponge::\u003c_, WIDTH, 8, 6\u003e::new(rescue_prime);\r\n\r\n        let input: [Mersenne31; 6] = [1, 2, 3, 4, 5, 6].map(Mersenne31::from_u8);\r\n\r\n        let expected: [Mersenne31; 6] = [\r\n            2055426095, 968531194, 1592692524, 136824376, 175318858, 1160805485,\r\n        ]\r\n        .map(Mersenne31::from_u64);\r\n\r\n        let actual = rescue_sponge.hash_iter(input);\r\n        assert_eq!(actual, expected);\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":38,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":41,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":44,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":45,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":46,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":72,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":75,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":80,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":84,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":9367487224930631680}},{"line":89,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":90,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":91,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":92,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":93,"address":[],"length":0,"stats":{"Line":9223372036854775809}},{"line":94,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":107,"address":[],"length":0,"stats":{"Line":288230376151711751}},{"line":108,"address":[],"length":0,"stats":{"Line":2594073385365405703}},{"line":110,"address":[],"length":0,"stats":{"Line":13835058055282163713}},{"line":113,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":116,"address":[],"length":0,"stats":{"Line":11529215046068469760}},{"line":117,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":118,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":120,"address":[],"length":0,"stats":{"Line":9223372036854775808}},{"line":124,"address":[],"length":0,"stats":{"Line":13835058055282163715}},{"line":127,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":130,"address":[],"length":0,"stats":{"Line":11529215046068469761}},{"line":131,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":132,"address":[],"length":0,"stats":{"Line":2305843009213693953}},{"line":134,"address":[],"length":0,"stats":{"Line":9223372036854775808}}],"covered":47,"coverable":50},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","rescue","src","util.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse gcd::Gcd;\r\nuse modinverse::modinverse;\r\nuse p3_field::PrimeField64;\r\nuse sha3::digest::{ExtendableOutput, Update, XofReader};\r\nuse sha3::Shake256;\r\n\r\n/// Generate alpha, the smallest integer relatively prime to `p  1`.\r\npub(crate) fn get_alpha\u003cF: PrimeField64\u003e() -\u003e u64 {\r\n    let p = F::ORDER_U64;\r\n\r\n    (3..p).find(|\u0026a| a.gcd(p - 1) == 1).unwrap()\r\n}\r\n\r\n/// Given alpha, find its multiplicative inverse in `Z/p  1`.\r\npub(crate) fn get_inverse\u003cF: PrimeField64\u003e(alpha: u64) -\u003e u64 {\r\n    let p = F::ORDER_U64 as i128;\r\n    modinverse(alpha as i128, p - 1)\r\n        .expect(\"x^alpha not a permutation\")\r\n        .unsigned_abs()\r\n        .try_into()\r\n        .unwrap()\r\n}\r\n\r\n/// Compute the SHAKE256 variant of SHA-3.\r\n/// This is used to generate the round constants from a seed string.\r\npub(crate) fn shake256_hash(seed_bytes: \u0026[u8], num_bytes: usize) -\u003e Vec\u003cu8\u003e {\r\n    let mut hasher = Shake256::default();\r\n    hasher.update(seed_bytes);\r\n    let mut reader = hasher.finalize_xof();\r\n    let mut result = vec![0u8; num_bytes];\r\n    reader.read(\u0026mut result);\r\n    result\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0}},{"line":12,"address":[],"length":0,"stats":{"Line":0}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":30,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":34,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":7,"coverable":13},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","sha256","src","lib.rs"],"content":"//! The SHA2-256 hash function.\r\n\r\n#![no_std]\r\n\r\nuse p3_symmetric::{CompressionFunction, CryptographicHasher, PseudoCompressionFunction};\r\nuse sha2::digest::generic_array::GenericArray;\r\nuse sha2::digest::typenum::U64;\r\nuse sha2::Digest;\r\n\r\npub const H256_256: [u32; 8] = [\r\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\r\n];\r\n\r\n/// The SHA2-256 hash function.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct Sha256;\r\n\r\nimpl CryptographicHasher\u003cu8, [u8; 32]\u003e for Sha256 {\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = u8\u003e,\r\n    {\r\n        const BUFLEN: usize = 512; // Tweakable parameter; determined by experiment\r\n        let mut hasher = sha2::Sha256::new();\r\n        p3_util::apply_to_chunks::\u003cBUFLEN, _, _\u003e(input, |buf| hasher.update(buf));\r\n        hasher.finalize().into()\r\n    }\r\n\r\n    fn hash_iter_slices\u003c'a, I\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = \u0026'a [u8]\u003e,\r\n    {\r\n        let mut hasher = sha2::Sha256::new();\r\n        for chunk in input.into_iter() {\r\n            hasher.update(chunk);\r\n        }\r\n        hasher.finalize().into()\r\n    }\r\n}\r\n\r\n/// SHA2-256 without the padding (pre-processing), intended to be used\r\n/// as a 2-to-1 [PseudoCompressionFunction].\r\n#[derive(Copy, Clone, Debug)]\r\npub struct Sha256Compress;\r\n\r\nimpl PseudoCompressionFunction\u003c[u8; 32], 2\u003e for Sha256Compress {\r\n    fn compress(\u0026self, input: [[u8; 32]; 2]) -\u003e [u8; 32] {\r\n        let mut state = H256_256;\r\n        // GenericArray\u003cu8, U64\u003e has same memory layout as [u8; 64]\r\n        let block: GenericArray\u003cu8, U64\u003e = unsafe { core::mem::transmute(input) };\r\n        sha2::compress256(\u0026mut state, \u0026[block]);\r\n\r\n        let mut output = [0u8; 32];\r\n        for (chunk, word) in output.chunks_exact_mut(4).zip(state) {\r\n            chunk.copy_from_slice(\u0026word.to_be_bytes());\r\n        }\r\n        output\r\n    }\r\n}\r\n\r\nimpl CompressionFunction\u003c[u8; 32], 2\u003e for Sha256Compress {}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use hex_literal::hex;\r\n    use p3_symmetric::{CryptographicHasher, PseudoCompressionFunction};\r\n\r\n    use crate::{Sha256, Sha256Compress};\r\n\r\n    #[test]\r\n    fn test_hello_world() {\r\n        let input = b\"hello world\";\r\n        let expected = hex!(\r\n            \"\r\n            b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9\r\n        \"\r\n        );\r\n\r\n        let sha256 = Sha256;\r\n        assert_eq!(sha256.hash_iter(input.to_vec())[..], expected[..]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_compress() {\r\n        let left = [0u8; 32];\r\n        // `right` will simulate the SHA256 padding\r\n        let mut right = [0u8; 32];\r\n        right[0] = 1 \u003c\u003c 7;\r\n        right[30] = 1; // left has length 256 in bits, L = 0x100\r\n\r\n        let expected = Sha256.hash_iter(left);\r\n        let sha256_compress = Sha256Compress;\r\n        assert_eq!(sha256_compress.compress([left, right]), expected);\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":24,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":25,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":50,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":51,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936}},{"line":54,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":55,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":57,"address":[],"length":0,"stats":{"Line":72057594037927936}}],"covered":12,"coverable":17},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","compression.rs"],"content":"use crate::hasher::CryptographicHasher;\r\nuse crate::permutation::CryptographicPermutation;\r\n\r\n/// An `N`-to-1 compression function collision-resistant in a hash tree setting.\r\n///\r\n/// Unlike `CompressionFunction`, it may not be collision-resistant in general.\r\n/// Instead it is only collision-resistant in hash-tree like settings where\r\n/// the preimage of a non-leaf node must consist of compression outputs.\r\npub trait PseudoCompressionFunction\u003cT, const N: usize\u003e: Clone {\r\n    fn compress(\u0026self, input: [T; N]) -\u003e T;\r\n}\r\n\r\n/// An `N`-to-1 compression function.\r\npub trait CompressionFunction\u003cT, const N: usize\u003e: PseudoCompressionFunction\u003cT, N\u003e {}\r\n\r\n#[derive(Clone, Debug)]\r\npub struct TruncatedPermutation\u003cInnerP, const N: usize, const CHUNK: usize, const WIDTH: usize\u003e {\r\n    inner_permutation: InnerP,\r\n}\r\n\r\nimpl\u003cInnerP, const N: usize, const CHUNK: usize, const WIDTH: usize\u003e\r\n    TruncatedPermutation\u003cInnerP, N, CHUNK, WIDTH\u003e\r\n{\r\n    pub const fn new(inner_permutation: InnerP) -\u003e Self {\r\n        Self { inner_permutation }\r\n    }\r\n}\r\n\r\nimpl\u003cT, InnerP, const N: usize, const CHUNK: usize, const WIDTH: usize\u003e\r\n    PseudoCompressionFunction\u003c[T; CHUNK], N\u003e for TruncatedPermutation\u003cInnerP, N, CHUNK, WIDTH\u003e\r\nwhere\r\n    T: Copy + Default,\r\n    InnerP: CryptographicPermutation\u003c[T; WIDTH]\u003e,\r\n{\r\n    fn compress(\u0026self, input: [[T; CHUNK]; N]) -\u003e [T; CHUNK] {\r\n        debug_assert!(CHUNK * N \u003c= WIDTH);\r\n        let mut pre = [T::default(); WIDTH];\r\n        for i in 0..N {\r\n            pre[i * CHUNK..(i + 1) * CHUNK].copy_from_slice(\u0026input[i]);\r\n        }\r\n        let post = self.inner_permutation.permute(pre);\r\n        post[..CHUNK].try_into().unwrap()\r\n    }\r\n}\r\n\r\n#[derive(Clone, Debug)]\r\npub struct CompressionFunctionFromHasher\u003cH, const N: usize, const CHUNK: usize\u003e {\r\n    hasher: H,\r\n}\r\n\r\nimpl\u003cH, const N: usize, const CHUNK: usize\u003e CompressionFunctionFromHasher\u003cH, N, CHUNK\u003e {\r\n    pub const fn new(hasher: H) -\u003e Self {\r\n        Self { hasher }\r\n    }\r\n}\r\n\r\nimpl\u003cT, H, const N: usize, const CHUNK: usize\u003e PseudoCompressionFunction\u003c[T; CHUNK], N\u003e\r\n    for CompressionFunctionFromHasher\u003cH, N, CHUNK\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; CHUNK]\u003e,\r\n{\r\n    fn compress(\u0026self, input: [[T; CHUNK]; N]) -\u003e [T; CHUNK] {\r\n        self.hasher.hash_iter(input.into_iter().flatten())\r\n    }\r\n}\r\n\r\nimpl\u003cT, H, const N: usize, const CHUNK: usize\u003e CompressionFunction\u003c[T; CHUNK], N\u003e\r\n    for CompressionFunctionFromHasher\u003cH, N, CHUNK\u003e\r\nwhere\r\n    T: Clone,\r\n    H: CryptographicHasher\u003cT, [T; CHUNK]\u003e,\r\n{\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":2449958197289550156}},{"line":35,"address":[],"length":0,"stats":{"Line":792633534417207735}},{"line":36,"address":[],"length":0,"stats":{"Line":1585267068834415130}},{"line":37,"address":[],"length":0,"stats":{"Line":792633534417207735}},{"line":38,"address":[],"length":0,"stats":{"Line":16212958658533786083}},{"line":39,"address":[],"length":0,"stats":{"Line":3891110078048108559}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":936748722493063168}},{"line":63,"address":[],"length":0,"stats":{"Line":5476377146882523136}},{"line":64,"address":[],"length":0,"stats":{"Line":5476377146882523136}}],"covered":9,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","hash.rs"],"content":"use core::borrow::Borrow;\r\nuse core::marker::PhantomData;\r\n\r\nuse serde::{Deserialize, Serialize};\r\n\r\n/// A wrapper around an array digest, with a phantom type parameter to ensure that the digest is\r\n/// associated with a particular field.\r\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize)]\r\n#[serde(bound(serialize = \"[W; DIGEST_ELEMS]: Serialize\"))]\r\n#[serde(bound(deserialize = \"[W; DIGEST_ELEMS]: Deserialize\u003c'de\u003e\"))]\r\npub struct Hash\u003cF, W, const DIGEST_ELEMS: usize\u003e {\r\n    value: [W; DIGEST_ELEMS],\r\n    _marker: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF, W, const DIGEST_ELEMS: usize\u003e From\u003c[W; DIGEST_ELEMS]\u003e for Hash\u003cF, W, DIGEST_ELEMS\u003e {\r\n    fn from(value: [W; DIGEST_ELEMS]) -\u003e Self {\r\n        Self {\r\n            value,\r\n            _marker: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF, W, const DIGEST_ELEMS: usize\u003e From\u003cHash\u003cF, W, DIGEST_ELEMS\u003e\u003e for [W; DIGEST_ELEMS] {\r\n    fn from(value: Hash\u003cF, W, DIGEST_ELEMS\u003e) -\u003e [W; DIGEST_ELEMS] {\r\n        value.value\r\n    }\r\n}\r\n\r\nimpl\u003cF, W: PartialEq, const DIGEST_ELEMS: usize\u003e PartialEq\u003c[W; DIGEST_ELEMS]\u003e\r\n    for Hash\u003cF, W, DIGEST_ELEMS\u003e\r\n{\r\n    fn eq(\u0026self, other: \u0026[W; DIGEST_ELEMS]) -\u003e bool {\r\n        self.value == *other\r\n    }\r\n}\r\n\r\nimpl\u003cF, W, const DIGEST_ELEMS: usize\u003e IntoIterator for Hash\u003cF, W, DIGEST_ELEMS\u003e {\r\n    type Item = W;\r\n    type IntoIter = core::array::IntoIter\u003cW, DIGEST_ELEMS\u003e;\r\n\r\n    fn into_iter(self) -\u003e Self::IntoIter {\r\n        self.value.into_iter()\r\n    }\r\n}\r\n\r\nimpl\u003cF, W, const DIGEST_ELEMS: usize\u003e Borrow\u003c[W; DIGEST_ELEMS]\u003e for Hash\u003cF, W, DIGEST_ELEMS\u003e {\r\n    fn borrow(\u0026self) -\u003e \u0026[W; DIGEST_ELEMS] {\r\n        \u0026self.value\r\n    }\r\n}\r\n\r\nimpl\u003cF, W, const DIGEST_ELEMS: usize\u003e AsRef\u003c[W; DIGEST_ELEMS]\u003e for Hash\u003cF, W, DIGEST_ELEMS\u003e {\r\n    fn as_ref(\u0026self) -\u003e \u0026[W; DIGEST_ELEMS] {\r\n        \u0026self.value\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":16285016252571713545}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":12177733392409821185}},{"line":35,"address":[],"length":0,"stats":{"Line":12177733392409821185}},{"line":43,"address":[],"length":0,"stats":{"Line":11240984669916758019}},{"line":44,"address":[],"length":0,"stats":{"Line":11240984669916758019}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}}],"covered":5,"coverable":11},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","hasher.rs"],"content":"pub trait CryptographicHasher\u003cItem: Clone, Out\u003e: Clone {\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e Out\r\n    where\r\n        I: IntoIterator\u003cItem = Item\u003e;\r\n\r\n    fn hash_iter_slices\u003c'a, I\u003e(\u0026self, input: I) -\u003e Out\r\n    where\r\n        I: IntoIterator\u003cItem = \u0026'a [Item]\u003e,\r\n        Item: 'a,\r\n    {\r\n        self.hash_iter(input.into_iter().flatten().cloned())\r\n    }\r\n\r\n    fn hash_slice(\u0026self, input: \u0026[Item]) -\u003e Out {\r\n        self.hash_iter_slices(core::iter::once(input))\r\n    }\r\n\r\n    fn hash_item(\u0026self, input: Item) -\u003e Out {\r\n        self.hash_slice(\u0026[input])\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":13546827679130451973}},{"line":11,"address":[],"length":0,"stats":{"Line":13546827679130451973}},{"line":14,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":15,"address":[],"length":0,"stats":{"Line":1513209474796486656}},{"line":18,"address":[],"length":0,"stats":{"Line":576460752303423488}},{"line":19,"address":[],"length":0,"stats":{"Line":576460752303423488}}],"covered":6,"coverable":6},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","lib.rs"],"content":"//! A framework for symmetric cryptography primitives.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod compression;\r\nmod hash;\r\nmod hasher;\r\nmod permutation;\r\nmod serializing_hasher;\r\nmod sponge;\r\n\r\npub use compression::*;\r\npub use hash::*;\r\npub use hasher::*;\r\npub use permutation::*;\r\npub use serializing_hasher::*;\r\npub use sponge::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","permutation.rs"],"content":"/// A permutation in the mathematical sense.\r\npub trait Permutation\u003cT: Clone\u003e: Clone + Sync {\r\n    fn permute(\u0026self, mut input: T) -\u003e T {\r\n        self.permute_mut(\u0026mut input);\r\n        input\r\n    }\r\n\r\n    fn permute_mut(\u0026self, input: \u0026mut T);\r\n}\r\n\r\n/// A permutation thought to be cryptographically secure, in the sense that it is thought to be\r\n/// difficult to distinguish (in a nontrivial way) from a random permutation.\r\npub trait CryptographicPermutation\u003cT: Clone\u003e: Permutation\u003cT\u003e {}\r\n","traces":[{"line":3,"address":[],"length":0,"stats":{"Line":1008806316530991238}},{"line":4,"address":[],"length":0,"stats":{"Line":1008806316530991238}},{"line":5,"address":[],"length":0,"stats":{"Line":1008806316530991238}}],"covered":3,"coverable":3},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","serializing_hasher.rs"],"content":"use core::iter;\r\n\r\nuse p3_field::{PackedValue, PrimeField32, PrimeField64};\r\n\r\nuse crate::CryptographicHasher;\r\n\r\n/// Serializes 32-bit field elements to bytes (i.e. the little-endian encoding of their canonical\r\n/// values), then hashes those bytes using some inner hasher, and outputs a `[u8; 32]`.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct SerializingHasher32\u003cInner\u003e {\r\n    inner: Inner,\r\n}\r\n\r\n/// Serializes 32-bit field elements to u64s (packing two canonical values together), then hashes\r\n/// those u64s using some inner hasher, and outputs a `[u64; 4]`.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct SerializingHasher32To64\u003cInner\u003e {\r\n    inner: Inner,\r\n}\r\n\r\n/// Serializes 64-bit field elements to bytes (i.e. the little-endian encoding of their canonical\r\n/// values), then hashes those bytes using some inner hasher, and outputs a `[u8; 32]`.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct SerializingHasher64\u003cInner\u003e {\r\n    inner: Inner,\r\n}\r\n\r\nimpl\u003cInner\u003e SerializingHasher32\u003cInner\u003e {\r\n    pub const fn new(inner: Inner) -\u003e Self {\r\n        Self { inner }\r\n    }\r\n}\r\n\r\nimpl\u003cInner\u003e SerializingHasher32To64\u003cInner\u003e {\r\n    pub const fn new(inner: Inner) -\u003e Self {\r\n        Self { inner }\r\n    }\r\n}\r\n\r\nimpl\u003cInner\u003e SerializingHasher64\u003cInner\u003e {\r\n    pub const fn new(inner: Inner) -\u003e Self {\r\n        Self { inner }\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e CryptographicHasher\u003cF, [u8; 32]\u003e for SerializingHasher32\u003cInner\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    Inner: CryptographicHasher\u003cu8, [u8; 32]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = F\u003e,\r\n    {\r\n        self.inner.hash_iter(\r\n            input\r\n                .into_iter()\r\n                .flat_map(|x| x.to_unique_u32().to_le_bytes()),\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cP, PW, Inner\u003e CryptographicHasher\u003cP, [PW; 8]\u003e for SerializingHasher32\u003cInner\u003e\r\nwhere\r\n    P: PackedValue,\r\n    P::Value: PrimeField32,\r\n    PW: PackedValue\u003cValue = u32\u003e,\r\n    Inner: CryptographicHasher\u003cPW, [PW; 8]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [PW; 8]\r\n    where\r\n        I: IntoIterator\u003cItem = P\u003e,\r\n    {\r\n        self.inner.hash_iter(\r\n            input\r\n                .into_iter()\r\n                .map(|x| PW::from_fn(|i| x.as_slice()[i].to_unique_u32())),\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cP, PW, Inner\u003e CryptographicHasher\u003cP, [PW; 4]\u003e for SerializingHasher32To64\u003cInner\u003e\r\nwhere\r\n    P: PackedValue,\r\n    P::Value: PrimeField32,\r\n    PW: PackedValue\u003cValue = u64\u003e,\r\n    Inner: CryptographicHasher\u003cPW, [PW; 4]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [PW; 4]\r\n    where\r\n        I: IntoIterator\u003cItem = P\u003e,\r\n    {\r\n        assert_eq!(P::WIDTH, PW::WIDTH);\r\n        let mut input = input.into_iter();\r\n        self.inner.hash_iter(iter::from_fn(\r\n            #[inline]\r\n            || {\r\n                let a = input.next();\r\n                let b = input.next();\r\n                if let (Some(a), Some(b)) = (a, b) {\r\n                    let ab = PW::from_fn(|i| {\r\n                        let a_i = a.as_slice()[i].to_unique_u64();\r\n                        let b_i = b.as_slice()[i].to_unique_u64();\r\n                        a_i | (b_i \u003c\u003c 32)\r\n                    });\r\n                    Some(ab)\r\n                } else {\r\n                    a.map(|a| PW::from_fn(|i| a.as_slice()[i].to_unique_u64()))\r\n                }\r\n            },\r\n        ))\r\n    }\r\n}\r\n\r\nimpl\u003cF, Inner\u003e CryptographicHasher\u003cF, [u8; 32]\u003e for SerializingHasher64\u003cInner\u003e\r\nwhere\r\n    F: PrimeField64,\r\n    Inner: CryptographicHasher\u003cu8, [u8; 32]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [u8; 32]\r\n    where\r\n        I: IntoIterator\u003cItem = F\u003e,\r\n    {\r\n        self.inner.hash_iter(\r\n            input\r\n                .into_iter()\r\n                .flat_map(|x| x.to_unique_u64().to_le_bytes()),\r\n        )\r\n    }\r\n}\r\n\r\nimpl\u003cP, PW, Inner\u003e CryptographicHasher\u003cP, [PW; 4]\u003e for SerializingHasher64\u003cInner\u003e\r\nwhere\r\n    P: PackedValue,\r\n    P::Value: PrimeField64,\r\n    PW: PackedValue\u003cValue = u64\u003e,\r\n    Inner: CryptographicHasher\u003cPW, [PW; 4]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [PW; 4]\r\n    where\r\n        I: IntoIterator\u003cItem = P\u003e,\r\n    {\r\n        self.inner.hash_iter(\r\n            input\r\n                .into_iter()\r\n                .map(|x| PW::from_fn(|i| x.as_slice()[i].to_unique_u64())),\r\n        )\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":936748722493063304}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":55,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":56,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":57,"address":[],"length":0,"stats":{"Line":18446744073709551613}},{"line":58,"address":[],"length":0,"stats":{"Line":18446744073709551607}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":6,"coverable":34},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","symmetric","src","sponge.rs"],"content":"use alloc::string::String;\r\nuse core::marker::PhantomData;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::{reduce_32, Field, PrimeField, PrimeField32};\r\n\r\nuse crate::hasher::CryptographicHasher;\r\nuse crate::permutation::CryptographicPermutation;\r\n\r\n/// A padding-free, overwrite-mode sponge function.\r\n///\r\n/// `WIDTH` is the sponge's rate plus the sponge's capacity.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct PaddingFreeSponge\u003cP, const WIDTH: usize, const RATE: usize, const OUT: usize\u003e {\r\n    permutation: P,\r\n}\r\n\r\nimpl\u003cP, const WIDTH: usize, const RATE: usize, const OUT: usize\u003e\r\n    PaddingFreeSponge\u003cP, WIDTH, RATE, OUT\u003e\r\n{\r\n    pub const fn new(permutation: P) -\u003e Self {\r\n        Self { permutation }\r\n    }\r\n}\r\n\r\nimpl\u003cT, P, const WIDTH: usize, const RATE: usize, const OUT: usize\u003e CryptographicHasher\u003cT, [T; OUT]\u003e\r\n    for PaddingFreeSponge\u003cP, WIDTH, RATE, OUT\u003e\r\nwhere\r\n    T: Default + Copy,\r\n    P: CryptographicPermutation\u003c[T; WIDTH]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [T; OUT]\r\n    where\r\n        I: IntoIterator\u003cItem = T\u003e,\r\n    {\r\n        // static_assert(RATE \u003c WIDTH)\r\n        let mut state = [T::default(); WIDTH];\r\n        let mut input = input.into_iter();\r\n\r\n        // Itertools' chunks() is more convenient, but seems to add more overhead,\r\n        // hence the more manual loop.\r\n        'outer: loop {\r\n            for i in 0..RATE {\r\n                if let Some(x) = input.next() {\r\n                    state[i] = x;\r\n                } else {\r\n                    if i != 0 {\r\n                        self.permutation.permute_mut(\u0026mut state);\r\n                    }\r\n                    break 'outer;\r\n                }\r\n            }\r\n            self.permutation.permute_mut(\u0026mut state);\r\n        }\r\n\r\n        state[..OUT].try_into().unwrap()\r\n    }\r\n}\r\n\r\n/// A padding-free, overwrite-mode sponge function that operates natively over PF but accepts elements\r\n/// of F: PrimeField32.\r\n///\r\n/// `WIDTH` is the sponge's rate plus the sponge's capacity.\r\n#[derive(Clone, Debug)]\r\npub struct MultiField32PaddingFreeSponge\u003c\r\n    F,\r\n    PF,\r\n    P,\r\n    const WIDTH: usize,\r\n    const RATE: usize,\r\n    const OUT: usize,\r\n\u003e {\r\n    permutation: P,\r\n    num_f_elms: usize,\r\n    _phantom: PhantomData\u003c(F, PF)\u003e,\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize, const OUT: usize\u003e\r\n    MultiField32PaddingFreeSponge\u003cF, PF, P, WIDTH, RATE, OUT\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: Field,\r\n{\r\n    pub fn new(permutation: P) -\u003e Result\u003cSelf, String\u003e {\r\n        if F::order() \u003e= PF::order() {\r\n            return Err(String::from(\"F::order() must be less than PF::order()\"));\r\n        }\r\n\r\n        let num_f_elms = PF::bits() / F::bits();\r\n        Ok(Self {\r\n            permutation,\r\n            num_f_elms,\r\n            _phantom: PhantomData,\r\n        })\r\n    }\r\n}\r\n\r\nimpl\u003cF, PF, P, const WIDTH: usize, const RATE: usize, const OUT: usize\u003e\r\n    CryptographicHasher\u003cF, [PF; OUT]\u003e for MultiField32PaddingFreeSponge\u003cF, PF, P, WIDTH, RATE, OUT\u003e\r\nwhere\r\n    F: PrimeField32,\r\n    PF: PrimeField + Default + Copy,\r\n    P: CryptographicPermutation\u003c[PF; WIDTH]\u003e,\r\n{\r\n    fn hash_iter\u003cI\u003e(\u0026self, input: I) -\u003e [PF; OUT]\r\n    where\r\n        I: IntoIterator\u003cItem = F\u003e,\r\n    {\r\n        let mut state = [PF::default(); WIDTH];\r\n        for block_chunk in \u0026input.into_iter().chunks(RATE) {\r\n            for (chunk_id, chunk) in (\u0026block_chunk.chunks(self.num_f_elms))\r\n                .into_iter()\r\n                .enumerate()\r\n            {\r\n                state[chunk_id] = reduce_32(\u0026chunk.collect_vec());\r\n            }\r\n            state = self.permutation.permute(state);\r\n        }\r\n\r\n        state[..OUT].try_into().unwrap()\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2522015791327477763}},{"line":32,"address":[],"length":0,"stats":{"Line":8070450532247928891}},{"line":37,"address":[],"length":0,"stats":{"Line":8070450532247928891}},{"line":38,"address":[],"length":0,"stats":{"Line":8070450532247928891}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":9583660007044415480}},{"line":44,"address":[],"length":0,"stats":{"Line":4323455642275676152}},{"line":45,"address":[],"length":0,"stats":{"Line":11385099857992613884}},{"line":47,"address":[],"length":0,"stats":{"Line":12682136550675316835}},{"line":48,"address":[],"length":0,"stats":{"Line":4611686018427387944}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":12177733392409821185}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}}],"covered":10,"coverable":29},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","check_constraints.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues};\r\nuse p3_field::Field;\r\nuse p3_matrix::dense::{RowMajorMatrix, RowMajorMatrixView};\r\nuse p3_matrix::stack::VerticalPair;\r\nuse p3_matrix::Matrix;\r\nuse tracing::instrument;\r\n\r\n#[instrument(name = \"check constraints\", skip_all)]\r\npub(crate) fn check_constraints\u003cF, A\u003e(air: \u0026A, main: \u0026RowMajorMatrix\u003cF\u003e, public_values: \u0026Vec\u003cF\u003e)\r\nwhere\r\n    F: Field,\r\n    A: for\u003c'a\u003e Air\u003cDebugConstraintBuilder\u003c'a, F\u003e\u003e,\r\n{\r\n    let height = main.height();\r\n\r\n    (0..height).for_each(|i| {\r\n        let i_next = (i + 1) % height;\r\n\r\n        let local = main.row_slice(i);\r\n        let next = main.row_slice(i_next);\r\n        let main = VerticalPair::new(\r\n            RowMajorMatrixView::new_row(\u0026*local),\r\n            RowMajorMatrixView::new_row(\u0026*next),\r\n        );\r\n\r\n        let mut builder = DebugConstraintBuilder {\r\n            row_index: i,\r\n            main,\r\n            public_values,\r\n            is_first_row: F::from_bool(i == 0),\r\n            is_last_row: F::from_bool(i == height - 1),\r\n            is_transition: F::from_bool(i != height - 1),\r\n        };\r\n\r\n        air.eval(\u0026mut builder);\r\n    });\r\n}\r\n\r\n/// An `AirBuilder` which asserts that each constraint is zero, allowing any failed constraints to\r\n/// be detected early.\r\n#[derive(Debug)]\r\npub struct DebugConstraintBuilder\u003c'a, F: Field\u003e {\r\n    row_index: usize,\r\n    main: VerticalPair\u003cRowMajorMatrixView\u003c'a, F\u003e, RowMajorMatrixView\u003c'a, F\u003e\u003e,\r\n    public_values: \u0026'a [F],\r\n    is_first_row: F,\r\n    is_last_row: F,\r\n    is_transition: F,\r\n}\r\n\r\nimpl\u003c'a, F\u003e AirBuilder for DebugConstraintBuilder\u003c'a, F\u003e\r\nwhere\r\n    F: Field,\r\n{\r\n    type F = F;\r\n    type Expr = F;\r\n    type Var = F;\r\n    type M = VerticalPair\u003cRowMajorMatrixView\u003c'a, F\u003e, RowMajorMatrixView\u003c'a, F\u003e\u003e;\r\n\r\n    fn main(\u0026self) -\u003e Self::M {\r\n        self.main\r\n    }\r\n\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_first_row\r\n    }\r\n\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_last_row\r\n    }\r\n\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr {\r\n        if size == 2 {\r\n            self.is_transition\r\n        } else {\r\n            panic!(\"only supports a window size of 2\")\r\n        }\r\n    }\r\n\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        assert_eq!(\r\n            x.into(),\r\n            F::ZERO,\r\n            \"constraints had nonzero value on row {}\",\r\n            self.row_index\r\n        );\r\n    }\r\n\r\n    fn assert_eq\u003cI1: Into\u003cSelf::Expr\u003e, I2: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I1, y: I2) {\r\n        let x = x.into();\r\n        let y = y.into();\r\n        assert_eq!(\r\n            x, y,\r\n            \"values didn't match on row {}: {} != {}\",\r\n            self.row_index, x, y\r\n        );\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e AirBuilderWithPublicValues for DebugConstraintBuilder\u003c'_, F\u003e {\r\n    type PublicVar = Self::F;\r\n\r\n    fn public_values(\u0026self) -\u003e \u0026[Self::F] {\r\n        self.public_values\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":19,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":21,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":22,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":23,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":24,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":25,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":28,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":29,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":30,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":31,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":32,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":33,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":34,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":37,"address":[],"length":0,"stats":{"Line":10448351135499550844}},{"line":62,"address":[],"length":0,"stats":{"Line":10448351135499550870}},{"line":63,"address":[],"length":0,"stats":{"Line":10448351135499550870}},{"line":66,"address":[],"length":0,"stats":{"Line":1224979098644774916}},{"line":67,"address":[],"length":0,"stats":{"Line":1224979098644774916}},{"line":70,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":71,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":74,"address":[],"length":0,"stats":{"Line":1224979098644775062}},{"line":75,"address":[],"length":0,"stats":{"Line":1224979098644775062}},{"line":76,"address":[],"length":0,"stats":{"Line":1224979098644775062}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":6124895493223874830}},{"line":83,"address":[],"length":0,"stats":{"Line":6124895493223874830}},{"line":84,"address":[],"length":0,"stats":{"Line":6124895493223874830}},{"line":85,"address":[],"length":0,"stats":{"Line":6124895493223874830}},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927756}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":1224979098644774912}},{"line":106,"address":[],"length":0,"stats":{"Line":1224979098644774912}}],"covered":31,"coverable":41},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","config.rs"],"content":"use core::marker::PhantomData;\r\n\r\nuse p3_challenger::{CanObserve, CanSample, FieldChallenger};\r\nuse p3_commit::{Pcs, PolynomialSpace};\r\nuse p3_field::{ExtensionField, Field};\r\n\r\npub type PcsError\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\r\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\r\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\r\n\u003e\u003e::Error;\r\n\r\npub type Domain\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\r\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\r\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\r\n\u003e\u003e::Domain;\r\n\r\npub type Val\u003cSC\u003e = \u003cDomain\u003cSC\u003e as PolynomialSpace\u003e::Val;\r\n\r\npub type PackedVal\u003cSC\u003e = \u003cVal\u003cSC\u003e as Field\u003e::Packing;\r\n\r\npub type PackedChallenge\u003cSC\u003e =\r\n    \u003c\u003cSC as StarkGenericConfig\u003e::Challenge as ExtensionField\u003cVal\u003cSC\u003e\u003e\u003e::ExtensionPacking;\r\n\r\npub trait StarkGenericConfig {\r\n    /// The PCS used to commit to trace polynomials.\r\n    type Pcs: Pcs\u003cSelf::Challenge, Self::Challenger\u003e;\r\n\r\n    /// The field from which most random challenges are drawn.\r\n    type Challenge: ExtensionField\u003cVal\u003cSelf\u003e\u003e;\r\n\r\n    /// The challenger (Fiat-Shamir) implementation used.\r\n    type Challenger: FieldChallenger\u003cVal\u003cSelf\u003e\u003e\r\n        + CanObserve\u003c\u003cSelf::Pcs as Pcs\u003cSelf::Challenge, Self::Challenger\u003e\u003e::Commitment\u003e\r\n        + CanSample\u003cSelf::Challenge\u003e;\r\n\r\n    fn pcs(\u0026self) -\u003e \u0026Self::Pcs;\r\n}\r\n\r\n#[derive(Debug)]\r\npub struct StarkConfig\u003cPcs, Challenge, Challenger\u003e {\r\n    pcs: Pcs,\r\n    _phantom: PhantomData\u003c(Challenge, Challenger)\u003e,\r\n}\r\n\r\nimpl\u003cPcs, Challenge, Challenger\u003e StarkConfig\u003cPcs, Challenge, Challenger\u003e {\r\n    pub const fn new(pcs: Pcs) -\u003e Self {\r\n        Self {\r\n            pcs,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cPcs, Challenge, Challenger\u003e StarkGenericConfig for StarkConfig\u003cPcs, Challenge, Challenger\u003e\r\nwhere\r\n    Challenge: ExtensionField\u003c\u003cPcs::Domain as PolynomialSpace\u003e::Val\u003e,\r\n    Pcs: p3_commit::Pcs\u003cChallenge, Challenger\u003e,\r\n    Challenger: FieldChallenger\u003c\u003cPcs::Domain as PolynomialSpace\u003e::Val\u003e\r\n        + CanObserve\u003c\u003cPcs as p3_commit::Pcs\u003cChallenge, Challenger\u003e\u003e::Commitment\u003e\r\n        + CanSample\u003cChallenge\u003e,\r\n{\r\n    type Pcs = Pcs;\r\n    type Challenge = Challenge;\r\n    type Challenger = Challenger;\r\n\r\n    fn pcs(\u0026self) -\u003e \u0026Self::Pcs {\r\n        \u0026self.pcs\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":864691128455135232}},{"line":66,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":67,"address":[],"length":0,"stats":{"Line":1585267068834414592}}],"covered":3,"coverable":3},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","folder.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_air::{AirBuilder, AirBuilderWithPublicValues};\r\nuse p3_matrix::dense::RowMajorMatrixView;\r\nuse p3_matrix::stack::VerticalPair;\r\n\r\nuse crate::{PackedChallenge, PackedVal, StarkGenericConfig, Val};\r\n\r\n#[derive(Debug)]\r\npub struct ProverConstraintFolder\u003c'a, SC: StarkGenericConfig\u003e {\r\n    pub main: RowMajorMatrixView\u003c'a, PackedVal\u003cSC\u003e\u003e,\r\n    pub public_values: \u0026'a Vec\u003cVal\u003cSC\u003e\u003e,\r\n    pub is_first_row: PackedVal\u003cSC\u003e,\r\n    pub is_last_row: PackedVal\u003cSC\u003e,\r\n    pub is_transition: PackedVal\u003cSC\u003e,\r\n    pub alpha_powers: \u0026'a [SC::Challenge],\r\n    pub accumulator: PackedChallenge\u003cSC\u003e,\r\n    pub constraint_index: usize,\r\n}\r\n\r\ntype ViewPair\u003c'a, T\u003e = VerticalPair\u003cRowMajorMatrixView\u003c'a, T\u003e, RowMajorMatrixView\u003c'a, T\u003e\u003e;\r\n\r\n#[derive(Debug)]\r\npub struct VerifierConstraintFolder\u003c'a, SC: StarkGenericConfig\u003e {\r\n    pub main: ViewPair\u003c'a, SC::Challenge\u003e,\r\n    pub public_values: \u0026'a Vec\u003cVal\u003cSC\u003e\u003e,\r\n    pub is_first_row: SC::Challenge,\r\n    pub is_last_row: SC::Challenge,\r\n    pub is_transition: SC::Challenge,\r\n    pub alpha: SC::Challenge,\r\n    pub accumulator: SC::Challenge,\r\n}\r\n\r\nimpl\u003c'a, SC: StarkGenericConfig\u003e AirBuilder for ProverConstraintFolder\u003c'a, SC\u003e {\r\n    type F = Val\u003cSC\u003e;\r\n    type Expr = PackedVal\u003cSC\u003e;\r\n    type Var = PackedVal\u003cSC\u003e;\r\n    type M = RowMajorMatrixView\u003c'a, PackedVal\u003cSC\u003e\u003e;\r\n\r\n    #[inline]\r\n    fn main(\u0026self) -\u003e Self::M {\r\n        self.main\r\n    }\r\n\r\n    #[inline]\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_first_row\r\n    }\r\n\r\n    #[inline]\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_last_row\r\n    }\r\n\r\n    #[inline]\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr {\r\n        if size == 2 {\r\n            self.is_transition\r\n        } else {\r\n            panic!(\"uni-stark only supports a window size of 2\")\r\n        }\r\n    }\r\n\r\n    #[inline]\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        let x: PackedVal\u003cSC\u003e = x.into();\r\n        let alpha_power = self.alpha_powers[self.constraint_index];\r\n        self.accumulator += Into::\u003cPackedChallenge\u003cSC\u003e\u003e::into(alpha_power) * x;\r\n        self.constraint_index += 1;\r\n    }\r\n}\r\n\r\nimpl\u003cSC: StarkGenericConfig\u003e AirBuilderWithPublicValues for ProverConstraintFolder\u003c'_, SC\u003e {\r\n    type PublicVar = Self::F;\r\n\r\n    #[inline]\r\n    fn public_values(\u0026self) -\u003e \u0026[Self::F] {\r\n        self.public_values\r\n    }\r\n}\r\n\r\nimpl\u003c'a, SC: StarkGenericConfig\u003e AirBuilder for VerifierConstraintFolder\u003c'a, SC\u003e {\r\n    type F = Val\u003cSC\u003e;\r\n    type Expr = SC::Challenge;\r\n    type Var = SC::Challenge;\r\n    type M = ViewPair\u003c'a, SC::Challenge\u003e;\r\n\r\n    fn main(\u0026self) -\u003e Self::M {\r\n        self.main\r\n    }\r\n\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_first_row\r\n    }\r\n\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr {\r\n        self.is_last_row\r\n    }\r\n\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr {\r\n        if size == 2 {\r\n            self.is_transition\r\n        } else {\r\n            panic!(\"uni-stark only supports a window size of 2\")\r\n        }\r\n    }\r\n\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        let x: SC::Challenge = x.into();\r\n        self.accumulator *= self.alpha;\r\n        self.accumulator += x;\r\n    }\r\n}\r\n\r\nimpl\u003cSC: StarkGenericConfig\u003e AirBuilderWithPublicValues for VerifierConstraintFolder\u003c'_, SC\u003e {\r\n    type PublicVar = Self::F;\r\n\r\n    fn public_values(\u0026self) -\u003e \u0026[Self::F] {\r\n        self.public_values\r\n    }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":52,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855917}},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855917}},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855917}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":720575940379279435}},{"line":66,"address":[],"length":0,"stats":{"Line":720575940379279435}},{"line":67,"address":[],"length":0,"stats":{"Line":720575940379279435}},{"line":68,"address":[],"length":0,"stats":{"Line":720575940379279435}},{"line":69,"address":[],"length":0,"stats":{"Line":720575940379279435}},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":88,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":89,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":92,"address":[],"length":0,"stats":{"Line":13114482114902884353}},{"line":93,"address":[],"length":0,"stats":{"Line":13114482114902884353}},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":97,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":100,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":101,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":102,"address":[],"length":0,"stats":{"Line":13114482114902884352}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":720575940379279359}},{"line":109,"address":[],"length":0,"stats":{"Line":720575940379279359}},{"line":110,"address":[],"length":0,"stats":{"Line":720575940379279359}},{"line":111,"address":[],"length":0,"stats":{"Line":720575940379279359}},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":31,"coverable":33},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","lib.rs"],"content":"//! A minimal univariate STARK framework.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nmod config;\r\nmod folder;\r\nmod proof;\r\nmod prover;\r\nmod symbolic_builder;\r\nmod symbolic_expression;\r\nmod symbolic_variable;\r\nmod verifier;\r\nmod zerofier_coset;\r\n\r\nmod check_constraints;\r\n\r\npub use check_constraints::*;\r\npub use config::*;\r\npub use folder::*;\r\npub use proof::*;\r\npub use prover::*;\r\npub use symbolic_builder::*;\r\npub use symbolic_expression::*;\r\npub use symbolic_variable::*;\r\npub use verifier::*;\r\npub use zerofier_coset::*;\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","proof.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse p3_commit::Pcs;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::StarkGenericConfig;\r\n\r\ntype Com\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\r\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\r\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\r\n\u003e\u003e::Commitment;\r\ntype PcsProof\u003cSC\u003e = \u003c\u003cSC as StarkGenericConfig\u003e::Pcs as Pcs\u003c\r\n    \u003cSC as StarkGenericConfig\u003e::Challenge,\r\n    \u003cSC as StarkGenericConfig\u003e::Challenger,\r\n\u003e\u003e::Proof;\r\n\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(bound = \"\")]\r\npub struct Proof\u003cSC: StarkGenericConfig\u003e {\r\n    pub(crate) commitments: Commitments\u003cCom\u003cSC\u003e\u003e,\r\n    pub(crate) opened_values: OpenedValues\u003cSC::Challenge\u003e,\r\n    pub(crate) opening_proof: PcsProof\u003cSC\u003e,\r\n    pub(crate) degree_bits: usize,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct Commitments\u003cCom\u003e {\r\n    pub(crate) trace: Com,\r\n    pub(crate) quotient_chunks: Com,\r\n}\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct OpenedValues\u003cChallenge\u003e {\r\n    pub(crate) trace_local: Vec\u003cChallenge\u003e,\r\n    pub(crate) trace_next: Vec\u003cChallenge\u003e,\r\n    pub(crate) quotient_chunks: Vec\u003cVec\u003cChallenge\u003e\u003e,\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","prover.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::{izip, Itertools};\r\nuse p3_air::Air;\r\nuse p3_challenger::{CanObserve, CanSample, FieldChallenger};\r\nuse p3_commit::{Pcs, PolynomialSpace};\r\nuse p3_field::{PackedValue, PrimeCharacteristicRing, Serializable};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_maybe_rayon::prelude::*;\r\nuse p3_util::{log2_ceil_usize, log2_strict_usize};\r\nuse tracing::{info_span, instrument};\r\n\r\nuse crate::{\r\n    get_symbolic_constraints, Commitments, Domain, OpenedValues, PackedChallenge, PackedVal, Proof,\r\n    ProverConstraintFolder, StarkGenericConfig, SymbolicAirBuilder, SymbolicExpression, Val,\r\n};\r\n\r\n#[instrument(skip_all)]\r\n#[allow(clippy::multiple_bound_locations)] // cfg not supported in where clauses?\r\npub fn prove\u003c\r\n    SC,\r\n    #[cfg(debug_assertions)] A: for\u003c'a\u003e Air\u003ccrate::check_constraints::DebugConstraintBuilder\u003c'a, Val\u003cSC\u003e\u003e\u003e,\r\n    #[cfg(not(debug_assertions))] A,\r\n\u003e(\r\n    config: \u0026SC,\r\n    air: \u0026A,\r\n    challenger: \u0026mut SC::Challenger,\r\n    trace: RowMajorMatrix\u003cVal\u003cSC\u003e\u003e,\r\n    public_values: \u0026Vec\u003cVal\u003cSC\u003e\u003e,\r\n) -\u003e Proof\u003cSC\u003e\r\nwhere\r\n    SC: StarkGenericConfig,\r\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e + for\u003c'a\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e,\r\n{\r\n    #[cfg(debug_assertions)]\r\n    crate::check_constraints::check_constraints(air, \u0026trace, public_values);\r\n\r\n    let degree = trace.height();\r\n    let log_degree = log2_strict_usize(degree);\r\n\r\n    let symbolic_constraints = get_symbolic_constraints::\u003cVal\u003cSC\u003e, A\u003e(air, 0, public_values.len());\r\n    let constraint_count = symbolic_constraints.len();\r\n    let constraint_degree = symbolic_constraints\r\n        .iter()\r\n        .map(SymbolicExpression::degree_multiple)\r\n        .max()\r\n        .unwrap_or(0);\r\n    let log_quotient_degree = log2_ceil_usize(constraint_degree - 1);\r\n    let quotient_degree = 1 \u003c\u003c log_quotient_degree;\r\n\r\n    let pcs = config.pcs();\r\n    let trace_domain = pcs.natural_domain_for_degree(degree);\r\n\r\n    let (trace_commit, trace_data) =\r\n        info_span!(\"commit to trace data\").in_scope(|| pcs.commit(vec![(trace_domain, trace)]));\r\n\r\n    // Observe the instance.\r\n    // degree \u003c 2^255 so we can safely cast log_degree to a u8.\r\n    challenger.observe(Val::\u003cSC\u003e::from_u8(log_degree as u8));\r\n    // TODO: Might be best practice to include other instance data here; see verifier comment.\r\n\r\n    challenger.observe(trace_commit.clone());\r\n    challenger.observe_slice(public_values);\r\n    let alpha: SC::Challenge = challenger.sample_algebra_element();\r\n\r\n    let quotient_domain =\r\n        trace_domain.create_disjoint_domain(1 \u003c\u003c (log_degree + log_quotient_degree));\r\n\r\n    let trace_on_quotient_domain = pcs.get_evaluations_on_domain(\u0026trace_data, 0, quotient_domain);\r\n\r\n    let quotient_values = quotient_values(\r\n        air,\r\n        public_values,\r\n        trace_domain,\r\n        quotient_domain,\r\n        trace_on_quotient_domain,\r\n        alpha,\r\n        constraint_count,\r\n    );\r\n    let quotient_flat = RowMajorMatrix::new_col(quotient_values).flatten_to_base();\r\n    let quotient_chunks = quotient_domain.split_evals(quotient_degree, quotient_flat);\r\n    let qc_domains = quotient_domain.split_domains(quotient_degree);\r\n\r\n    let (quotient_commit, quotient_data) = info_span!(\"commit to quotient poly chunks\")\r\n        .in_scope(|| pcs.commit(izip!(qc_domains, quotient_chunks).collect_vec()));\r\n    challenger.observe(quotient_commit.clone());\r\n\r\n    let commitments = Commitments {\r\n        trace: trace_commit,\r\n        quotient_chunks: quotient_commit,\r\n    };\r\n\r\n    let zeta: SC::Challenge = challenger.sample();\r\n    let zeta_next = trace_domain.next_point(zeta).unwrap();\r\n\r\n    let (opened_values, opening_proof) = info_span!(\"open\").in_scope(|| {\r\n        pcs.open(\r\n            vec![\r\n                (\u0026trace_data, vec![vec![zeta, zeta_next]]),\r\n                (\r\n                    \u0026quotient_data,\r\n                    // open every chunk at zeta\r\n                    (0..quotient_degree).map(|_| vec![zeta]).collect_vec(),\r\n                ),\r\n            ],\r\n            challenger,\r\n        )\r\n    });\r\n    let trace_local = opened_values[0][0][0].clone();\r\n    let trace_next = opened_values[0][0][1].clone();\r\n    let quotient_chunks = opened_values[1].iter().map(|v| v[0].clone()).collect_vec();\r\n    let opened_values = OpenedValues {\r\n        trace_local,\r\n        trace_next,\r\n        quotient_chunks,\r\n    };\r\n    Proof {\r\n        commitments,\r\n        opened_values,\r\n        opening_proof,\r\n        degree_bits: log_degree,\r\n    }\r\n}\r\n\r\n#[instrument(name = \"compute quotient polynomial\", skip_all)]\r\nfn quotient_values\u003cSC, A, Mat\u003e(\r\n    air: \u0026A,\r\n    public_values: \u0026Vec\u003cVal\u003cSC\u003e\u003e,\r\n    trace_domain: Domain\u003cSC\u003e,\r\n    quotient_domain: Domain\u003cSC\u003e,\r\n    trace_on_quotient_domain: Mat,\r\n    alpha: SC::Challenge,\r\n    constraint_count: usize,\r\n) -\u003e Vec\u003cSC::Challenge\u003e\r\nwhere\r\n    SC: StarkGenericConfig,\r\n    A: for\u003c'a\u003e Air\u003cProverConstraintFolder\u003c'a, SC\u003e\u003e,\r\n    Mat: Matrix\u003cVal\u003cSC\u003e\u003e + Sync,\r\n{\r\n    let quotient_size = quotient_domain.size();\r\n    let width = trace_on_quotient_domain.width();\r\n    let mut sels = trace_domain.selectors_on_coset(quotient_domain);\r\n\r\n    let qdb = log2_strict_usize(quotient_domain.size()) - log2_strict_usize(trace_domain.size());\r\n    let next_step = 1 \u003c\u003c qdb;\r\n\r\n    // We take PackedVal::\u003cSC\u003e::WIDTH worth of values at a time from a quotient_size slice, so we need to\r\n    // pad with default values in the case where quotient_size is smaller than PackedVal::\u003cSC\u003e::WIDTH.\r\n    for _ in quotient_size..PackedVal::\u003cSC\u003e::WIDTH {\r\n        sels.is_first_row.push(Val::\u003cSC\u003e::default());\r\n        sels.is_last_row.push(Val::\u003cSC\u003e::default());\r\n        sels.is_transition.push(Val::\u003cSC\u003e::default());\r\n        sels.inv_zeroifier.push(Val::\u003cSC\u003e::default());\r\n    }\r\n\r\n    let mut alpha_powers = alpha.powers().take(constraint_count).collect_vec();\r\n    alpha_powers.reverse();\r\n\r\n    (0..quotient_size)\r\n        .into_par_iter()\r\n        .step_by(PackedVal::\u003cSC\u003e::WIDTH)\r\n        .flat_map_iter(|i_start| {\r\n            let i_range = i_start..i_start + PackedVal::\u003cSC\u003e::WIDTH;\r\n\r\n            let is_first_row = *PackedVal::\u003cSC\u003e::from_slice(\u0026sels.is_first_row[i_range.clone()]);\r\n            let is_last_row = *PackedVal::\u003cSC\u003e::from_slice(\u0026sels.is_last_row[i_range.clone()]);\r\n            let is_transition = *PackedVal::\u003cSC\u003e::from_slice(\u0026sels.is_transition[i_range.clone()]);\r\n            let inv_zeroifier = *PackedVal::\u003cSC\u003e::from_slice(\u0026sels.inv_zeroifier[i_range.clone()]);\r\n\r\n            let main = RowMajorMatrix::new(\r\n                trace_on_quotient_domain.vertically_packed_row_pair(i_start, next_step),\r\n                width,\r\n            );\r\n\r\n            let accumulator = PackedChallenge::\u003cSC\u003e::ZERO;\r\n            let mut folder = ProverConstraintFolder {\r\n                main: main.as_view(),\r\n                public_values,\r\n                is_first_row,\r\n                is_last_row,\r\n                is_transition,\r\n                alpha_powers: \u0026alpha_powers,\r\n                accumulator,\r\n                constraint_index: 0,\r\n            };\r\n            air.eval(\u0026mut folder);\r\n\r\n            // quotient(x) = constraints(x) / Z_H(x)\r\n            let quotient = folder.accumulator * inv_zeroifier;\r\n\r\n            // \"Transpose\" D packed base coefficients into WIDTH scalar extension coefficients.\r\n            (0..core::cmp::min(quotient_size, PackedVal::\u003cSC\u003e::WIDTH)).map(move |idx_in_packing| {\r\n                SC::Challenge::deserialize_fn(|coeff_idx| {\r\n                    quotient.serialize_as_slice()[coeff_idx].as_slice()[idx_in_packing]\r\n                })\r\n            })\r\n        })\r\n        .collect()\r\n}\r\n","traces":[{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":792633534417207297}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":99,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":100,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":101,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":103,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":105,"address":[],"length":0,"stats":{"Line":3458764513820540936}},{"line":108,"address":[],"length":0,"stats":{"Line":792633534417207296}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":165,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":168,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":170,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":172,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":173,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":174,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":177,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":179,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":180,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":181,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":182,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":184,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":185,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":186,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":188,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":191,"address":[],"length":0,"stats":{"Line":144115188075855871}},{"line":194,"address":[],"length":0,"stats":{"Line":792633534417207305}},{"line":195,"address":[],"length":0,"stats":{"Line":3242591731706757164}},{"line":196,"address":[],"length":0,"stats":{"Line":2594073385365405730}}],"covered":34,"coverable":83},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","symbolic_builder.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, PairBuilder};\r\nuse p3_field::Field;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_util::log2_ceil_usize;\r\nuse tracing::instrument;\r\n\r\nuse crate::symbolic_expression::SymbolicExpression;\r\nuse crate::symbolic_variable::SymbolicVariable;\r\nuse crate::Entry;\r\n\r\n#[instrument(name = \"infer log of constraint degree\", skip_all)]\r\npub fn get_log_quotient_degree\u003cF, A\u003e(\r\n    air: \u0026A,\r\n    preprocessed_width: usize,\r\n    num_public_values: usize,\r\n) -\u003e usize\r\nwhere\r\n    F: Field,\r\n    A: Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e,\r\n{\r\n    // We pad to at least degree 2, since a quotient argument doesn't make sense with smaller degrees.\r\n    let constraint_degree =\r\n        get_max_constraint_degree(air, preprocessed_width, num_public_values).max(2);\r\n\r\n    // The quotient's actual degree is approximately (max_constraint_degree - 1) n,\r\n    // where subtracting 1 comes from division by the zerofier.\r\n    // But we pad it to a power of two so that we can efficiently decompose the quotient.\r\n    log2_ceil_usize(constraint_degree - 1)\r\n}\r\n\r\n#[instrument(name = \"infer constraint degree\", skip_all, level = \"debug\")]\r\npub fn get_max_constraint_degree\u003cF, A\u003e(\r\n    air: \u0026A,\r\n    preprocessed_width: usize,\r\n    num_public_values: usize,\r\n) -\u003e usize\r\nwhere\r\n    F: Field,\r\n    A: Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e,\r\n{\r\n    get_symbolic_constraints(air, preprocessed_width, num_public_values)\r\n        .iter()\r\n        .map(|c| c.degree_multiple())\r\n        .max()\r\n        .unwrap_or(0)\r\n}\r\n\r\n#[instrument(name = \"evaluate constraints symbolically\", skip_all, level = \"debug\")]\r\npub fn get_symbolic_constraints\u003cF, A\u003e(\r\n    air: \u0026A,\r\n    preprocessed_width: usize,\r\n    num_public_values: usize,\r\n) -\u003e Vec\u003cSymbolicExpression\u003cF\u003e\u003e\r\nwhere\r\n    F: Field,\r\n    A: Air\u003cSymbolicAirBuilder\u003cF\u003e\u003e,\r\n{\r\n    let mut builder = SymbolicAirBuilder::new(preprocessed_width, air.width(), num_public_values);\r\n    air.eval(\u0026mut builder);\r\n    builder.constraints()\r\n}\r\n\r\n/// An `AirBuilder` for evaluating constraints symbolically, and recording them for later use.\r\n#[derive(Debug)]\r\npub struct SymbolicAirBuilder\u003cF: Field\u003e {\r\n    preprocessed: RowMajorMatrix\u003cSymbolicVariable\u003cF\u003e\u003e,\r\n    main: RowMajorMatrix\u003cSymbolicVariable\u003cF\u003e\u003e,\r\n    public_values: Vec\u003cSymbolicVariable\u003cF\u003e\u003e,\r\n    constraints: Vec\u003cSymbolicExpression\u003cF\u003e\u003e,\r\n}\r\n\r\nimpl\u003cF: Field\u003e SymbolicAirBuilder\u003cF\u003e {\r\n    pub(crate) fn new(preprocessed_width: usize, width: usize, num_public_values: usize) -\u003e Self {\r\n        let prep_values = [0, 1]\r\n            .into_iter()\r\n            .flat_map(|offset| {\r\n                (0..preprocessed_width)\r\n                    .map(move |index| SymbolicVariable::new(Entry::Preprocessed { offset }, index))\r\n            })\r\n            .collect();\r\n        let main_values = [0, 1]\r\n            .into_iter()\r\n            .flat_map(|offset| {\r\n                (0..width).map(move |index| SymbolicVariable::new(Entry::Main { offset }, index))\r\n            })\r\n            .collect();\r\n        let public_values = (0..num_public_values)\r\n            .map(move |index| SymbolicVariable::new(Entry::Public, index))\r\n            .collect();\r\n        Self {\r\n            preprocessed: RowMajorMatrix::new(prep_values, preprocessed_width),\r\n            main: RowMajorMatrix::new(main_values, width),\r\n            public_values,\r\n            constraints: vec![],\r\n        }\r\n    }\r\n\r\n    pub(crate) fn constraints(self) -\u003e Vec\u003cSymbolicExpression\u003cF\u003e\u003e {\r\n        self.constraints\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e AirBuilder for SymbolicAirBuilder\u003cF\u003e {\r\n    type F = F;\r\n    type Expr = SymbolicExpression\u003cF\u003e;\r\n    type Var = SymbolicVariable\u003cF\u003e;\r\n    type M = RowMajorMatrix\u003cSelf::Var\u003e;\r\n\r\n    fn main(\u0026self) -\u003e Self::M {\r\n        self.main.clone()\r\n    }\r\n\r\n    fn is_first_row(\u0026self) -\u003e Self::Expr {\r\n        SymbolicExpression::IsFirstRow\r\n    }\r\n\r\n    fn is_last_row(\u0026self) -\u003e Self::Expr {\r\n        SymbolicExpression::IsLastRow\r\n    }\r\n\r\n    fn is_transition_window(\u0026self, size: usize) -\u003e Self::Expr {\r\n        if size == 2 {\r\n            SymbolicExpression::IsTransition\r\n        } else {\r\n            panic!(\"uni-stark only supports a window size of 2\")\r\n        }\r\n    }\r\n\r\n    fn assert_zero\u003cI: Into\u003cSelf::Expr\u003e\u003e(\u0026mut self, x: I) {\r\n        self.constraints.push(x.into());\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e AirBuilderWithPublicValues for SymbolicAirBuilder\u003cF\u003e {\r\n    type PublicVar = SymbolicVariable\u003cF\u003e;\r\n    fn public_values(\u0026self) -\u003e \u0026[Self::PublicVar] {\r\n        \u0026self.public_values\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e PairBuilder for SymbolicAirBuilder\u003cF\u003e {\r\n    fn preprocessed(\u0026self) -\u003e Self::M {\r\n        self.preprocessed.clone()\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":720575940379279359}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":77,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":79,"address":[],"length":0,"stats":{"Line":4755801206503243777}},{"line":80,"address":[],"length":0,"stats":{"Line":3170534137668829185}},{"line":81,"address":[],"length":0,"stats":{"Line":6341068275337658376}},{"line":84,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":86,"address":[],"length":0,"stats":{"Line":4755801206503243776}},{"line":87,"address":[],"length":0,"stats":{"Line":7493989779944505343}},{"line":90,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":91,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":94,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":95,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":97,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":101,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":102,"address":[],"length":0,"stats":{"Line":1585267068834414592}},{"line":112,"address":[],"length":0,"stats":{"Line":1585267068834414593}},{"line":113,"address":[],"length":0,"stats":{"Line":1585267068834414593}},{"line":116,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":117,"address":[],"length":0,"stats":{"Line":7782220156096217088}},{"line":120,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":124,"address":[],"length":0,"stats":{"Line":7782220156096217089}},{"line":125,"address":[],"length":0,"stats":{"Line":7782220156096217089}},{"line":126,"address":[],"length":0,"stats":{"Line":7782220156096217089}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":133,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":139,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":140,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}}],"covered":29,"coverable":39},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","symbolic_expression.rs"],"content":"use alloc::rc::Rc;\r\nuse core::cmp;\r\nuse core::fmt::Debug;\r\nuse core::iter::{Product, Sum};\r\nuse core::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};\r\n\r\nuse p3_field::{Algebra, Field, InjectiveMonomial, PrimeCharacteristicRing};\r\n\r\nuse crate::symbolic_variable::SymbolicVariable;\r\n\r\n/// An expression over `SymbolicVariable`s.\r\n#[derive(Clone, Debug)]\r\npub enum SymbolicExpression\u003cF\u003e {\r\n    Variable(SymbolicVariable\u003cF\u003e),\r\n    IsFirstRow,\r\n    IsLastRow,\r\n    IsTransition,\r\n    Constant(F),\r\n    Add {\r\n        x: Rc\u003cSelf\u003e,\r\n        y: Rc\u003cSelf\u003e,\r\n        degree_multiple: usize,\r\n    },\r\n    Sub {\r\n        x: Rc\u003cSelf\u003e,\r\n        y: Rc\u003cSelf\u003e,\r\n        degree_multiple: usize,\r\n    },\r\n    Neg {\r\n        x: Rc\u003cSelf\u003e,\r\n        degree_multiple: usize,\r\n    },\r\n    Mul {\r\n        x: Rc\u003cSelf\u003e,\r\n        y: Rc\u003cSelf\u003e,\r\n        degree_multiple: usize,\r\n    },\r\n}\r\n\r\nimpl\u003cF\u003e SymbolicExpression\u003cF\u003e {\r\n    /// Returns the multiple of `n` (the trace length) in this expression's degree.\r\n    pub const fn degree_multiple(\u0026self) -\u003e usize {\r\n        match self {\r\n            SymbolicExpression::Variable(v) =\u003e v.degree_multiple(),\r\n            SymbolicExpression::IsFirstRow =\u003e 1,\r\n            SymbolicExpression::IsLastRow =\u003e 1,\r\n            SymbolicExpression::IsTransition =\u003e 0,\r\n            SymbolicExpression::Constant(_) =\u003e 0,\r\n            SymbolicExpression::Add {\r\n                degree_multiple, ..\r\n            } =\u003e *degree_multiple,\r\n            SymbolicExpression::Sub {\r\n                degree_multiple, ..\r\n            } =\u003e *degree_multiple,\r\n            SymbolicExpression::Neg {\r\n                degree_multiple, ..\r\n            } =\u003e *degree_multiple,\r\n            SymbolicExpression::Mul {\r\n                degree_multiple, ..\r\n            } =\u003e *degree_multiple,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e Default for SymbolicExpression\u003cF\u003e {\r\n    fn default() -\u003e Self {\r\n        Self::Constant(F::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e From\u003cF\u003e for SymbolicExpression\u003cF\u003e {\r\n    fn from(value: F) -\u003e Self {\r\n        Self::Constant(value)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e PrimeCharacteristicRing for SymbolicExpression\u003cF\u003e {\r\n    type PrimeSubfield = F::PrimeSubfield;\r\n\r\n    const ZERO: Self = Self::Constant(F::ZERO);\r\n    const ONE: Self = Self::Constant(F::ONE);\r\n    const TWO: Self = Self::Constant(F::TWO);\r\n    const NEG_ONE: Self = Self::Constant(F::NEG_ONE);\r\n\r\n    #[inline]\r\n    fn from_prime_subfield(f: Self::PrimeSubfield) -\u003e Self {\r\n        F::from_prime_subfield(f).into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e Algebra\u003cF\u003e for SymbolicExpression\u003cF\u003e {}\r\n\r\nimpl\u003cF: Field\u003e Algebra\u003cSymbolicVariable\u003cF\u003e\u003e for SymbolicExpression\u003cF\u003e {}\r\n\r\n// Note we cannot implement PermutationMonomial due to the degree_multiple part which makes\r\n// operations non invertible.\r\nimpl\u003cF: Field + InjectiveMonomial\u003cN\u003e, const N: u64\u003e InjectiveMonomial\u003cN\u003e for SymbolicExpression\u003cF\u003e {}\r\n\r\nimpl\u003cF: Field, T\u003e Add\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    fn add(self, rhs: T) -\u003e Self {\r\n        let rhs = rhs.into();\r\n        match (self, rhs) {\r\n            (Self::Constant(lhs), Self::Constant(rhs)) =\u003e Self::Constant(lhs + rhs),\r\n            (lhs, rhs) =\u003e {\r\n                let degree_multiple = cmp::max(lhs.degree_multiple(), rhs.degree_multiple());\r\n                Self::Add {\r\n                    x: Rc::new(lhs),\r\n                    y: Rc::new(rhs),\r\n                    degree_multiple,\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e AddAssign\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    fn add_assign(\u0026mut self, rhs: T) {\r\n        *self = self.clone() + rhs.into();\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Sum\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    fn sum\u003cI: Iterator\u003cItem = T\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.map(Into::into)\r\n            .reduce(|x, y| x + y)\r\n            .unwrap_or(Self::ZERO)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Sub\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    fn sub(self, rhs: T) -\u003e Self {\r\n        let rhs = rhs.into();\r\n        match (self, rhs) {\r\n            (Self::Constant(lhs), Self::Constant(rhs)) =\u003e Self::Constant(lhs - rhs),\r\n            (lhs, rhs) =\u003e {\r\n                let degree_multiple = cmp::max(lhs.degree_multiple(), rhs.degree_multiple());\r\n                Self::Sub {\r\n                    x: Rc::new(lhs),\r\n                    y: Rc::new(rhs),\r\n                    degree_multiple,\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e SubAssign\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    fn sub_assign(\u0026mut self, rhs: T) {\r\n        *self = self.clone() - rhs.into();\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e Neg for SymbolicExpression\u003cF\u003e {\r\n    type Output = Self;\r\n\r\n    fn neg(self) -\u003e Self {\r\n        match self {\r\n            Self::Constant(c) =\u003e Self::Constant(-c),\r\n            expr =\u003e {\r\n                let degree_multiple = expr.degree_multiple();\r\n                Self::Neg {\r\n                    x: Rc::new(expr),\r\n                    degree_multiple,\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Mul\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    type Output = Self;\r\n\r\n    fn mul(self, rhs: T) -\u003e Self {\r\n        let rhs = rhs.into();\r\n        match (self, rhs) {\r\n            (Self::Constant(lhs), Self::Constant(rhs)) =\u003e Self::Constant(lhs * rhs),\r\n            (lhs, rhs) =\u003e {\r\n                #[allow(clippy::suspicious_arithmetic_impl)]\r\n                let degree_multiple = lhs.degree_multiple() + rhs.degree_multiple();\r\n                Self::Mul {\r\n                    x: Rc::new(lhs),\r\n                    y: Rc::new(rhs),\r\n                    degree_multiple,\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e MulAssign\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    fn mul_assign(\u0026mut self, rhs: T) {\r\n        *self = self.clone() * rhs.into();\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Product\u003cT\u003e for SymbolicExpression\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSelf\u003e,\r\n{\r\n    fn product\u003cI: Iterator\u003cItem = T\u003e\u003e(iter: I) -\u003e Self {\r\n        iter.map(Into::into)\r\n            .reduce(|x, y| x * y)\r\n            .unwrap_or(Self::ONE)\r\n    }\r\n}\r\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":43,"address":[],"length":0,"stats":{"Line":7205759403792793608}},{"line":44,"address":[],"length":0,"stats":{"Line":3170534137668829183}},{"line":45,"address":[],"length":0,"stats":{"Line":8070450532247928869}},{"line":46,"address":[],"length":0,"stats":{"Line":288230376151711745}},{"line":47,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":48,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":15276209936040722435}},{"line":51,"address":[],"length":0,"stats":{"Line":15276209936040722435}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":54,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":57,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":60,"address":[],"length":0,"stats":{"Line":10088063165309911040}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":7493989779944505347}},{"line":73,"address":[],"length":0,"stats":{"Line":7493989779944505347}},{"line":86,"address":[],"length":0,"stats":{"Line":7493989779944505345}},{"line":87,"address":[],"length":0,"stats":{"Line":7493989779944505345}},{"line":105,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":106,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":107,"address":[],"length":0,"stats":{"Line":15276209936040722432}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":15276209936040722436}},{"line":110,"address":[],"length":0,"stats":{"Line":15276209936040722436}},{"line":112,"address":[],"length":0,"stats":{"Line":15276209936040722436}},{"line":113,"address":[],"length":0,"stats":{"Line":15276209936040722436}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":148,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":149,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":152,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":154,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":155,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":196,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":197,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":199,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":201,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":203,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":204,"address":[],"length":0,"stats":{"Line":1441151880758558719}},{"line":216,"address":[],"length":0,"stats":{"Line":13258597302978740225}},{"line":217,"address":[],"length":0,"stats":{"Line":13258597302978740225}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}}],"covered":43,"coverable":69},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","symbolic_variable.rs"],"content":"use core::marker::PhantomData;\r\nuse core::ops::{Add, Mul, Sub};\r\n\r\nuse p3_field::Field;\r\n\r\nuse crate::symbolic_expression::SymbolicExpression;\r\n\r\n#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\r\npub enum Entry {\r\n    Preprocessed { offset: usize },\r\n    Main { offset: usize },\r\n    Permutation { offset: usize },\r\n    Public,\r\n    Challenge,\r\n}\r\n\r\n/// A variable within the evaluation window, i.e. a column in either the local or next row.\r\n#[derive(Copy, Clone, Debug)]\r\npub struct SymbolicVariable\u003cF\u003e {\r\n    pub entry: Entry,\r\n    pub index: usize,\r\n    pub(crate) _phantom: PhantomData\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF\u003e SymbolicVariable\u003cF\u003e {\r\n    pub const fn new(entry: Entry, index: usize) -\u003e Self {\r\n        Self {\r\n            entry,\r\n            index,\r\n            _phantom: PhantomData,\r\n        }\r\n    }\r\n\r\n    pub const fn degree_multiple(\u0026self) -\u003e usize {\r\n        match self.entry {\r\n            Entry::Preprocessed { .. } | Entry::Main { .. } | Entry::Permutation { .. } =\u003e 1,\r\n            Entry::Public | Entry::Challenge =\u003e 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field\u003e From\u003cSymbolicVariable\u003cF\u003e\u003e for SymbolicExpression\u003cF\u003e {\r\n    fn from(value: SymbolicVariable\u003cF\u003e) -\u003e Self {\r\n        SymbolicExpression::Variable(value)\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Add\u003cT\u003e for SymbolicVariable\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSymbolicExpression\u003cF\u003e\u003e,\r\n{\r\n    type Output = SymbolicExpression\u003cF\u003e;\r\n\r\n    fn add(self, rhs: T) -\u003e Self::Output {\r\n        SymbolicExpression::from(self) + rhs.into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Sub\u003cT\u003e for SymbolicVariable\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSymbolicExpression\u003cF\u003e\u003e,\r\n{\r\n    type Output = SymbolicExpression\u003cF\u003e;\r\n\r\n    fn sub(self, rhs: T) -\u003e Self::Output {\r\n        SymbolicExpression::from(self) - rhs.into()\r\n    }\r\n}\r\n\r\nimpl\u003cF: Field, T\u003e Mul\u003cT\u003e for SymbolicVariable\u003cF\u003e\r\nwhere\r\n    T: Into\u003cSymbolicExpression\u003cF\u003e\u003e,\r\n{\r\n    type Output = SymbolicExpression\u003cF\u003e;\r\n\r\n    fn mul(self, rhs: T) -\u003e Self::Output {\r\n        SymbolicExpression::from(self) * rhs.into()\r\n    }\r\n}\r\n","traces":[{"line":26,"address":[],"length":0,"stats":{"Line":2017612633061982207}},{"line":34,"address":[],"length":0,"stats":{"Line":3170534137668829183}},{"line":35,"address":[],"length":0,"stats":{"Line":3170534137668829183}},{"line":36,"address":[],"length":0,"stats":{"Line":2305843009213693951}},{"line":37,"address":[],"length":0,"stats":{"Line":864691128455135244}},{"line":43,"address":[],"length":0,"stats":{"Line":3170534137668829183}},{"line":44,"address":[],"length":0,"stats":{"Line":3170534137668829183}},{"line":54,"address":[],"length":0,"stats":{"Line":7782220156096217090}},{"line":55,"address":[],"length":0,"stats":{"Line":7782220156096217090}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":7493989779944505345}},{"line":77,"address":[],"length":0,"stats":{"Line":7493989779944505345}}],"covered":11,"coverable":13},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","verifier.rs"],"content":"use alloc::vec;\r\nuse alloc::vec::Vec;\r\n\r\nuse itertools::Itertools;\r\nuse p3_air::{Air, BaseAir};\r\nuse p3_challenger::{CanObserve, CanSample, FieldChallenger};\r\nuse p3_commit::{Pcs, PolynomialSpace};\r\nuse p3_field::{Field, PrimeCharacteristicRing, Serializable};\r\nuse p3_matrix::dense::RowMajorMatrixView;\r\nuse p3_matrix::stack::VerticalPair;\r\nuse tracing::instrument;\r\n\r\nuse crate::symbolic_builder::{get_log_quotient_degree, SymbolicAirBuilder};\r\nuse crate::{PcsError, Proof, StarkGenericConfig, Val, VerifierConstraintFolder};\r\n\r\n#[instrument(skip_all)]\r\npub fn verify\u003cSC, A\u003e(\r\n    config: \u0026SC,\r\n    air: \u0026A,\r\n    challenger: \u0026mut SC::Challenger,\r\n    proof: \u0026Proof\u003cSC\u003e,\r\n    public_values: \u0026Vec\u003cVal\u003cSC\u003e\u003e,\r\n) -\u003e Result\u003c(), VerificationError\u003cPcsError\u003cSC\u003e\u003e\u003e\r\nwhere\r\n    SC: StarkGenericConfig,\r\n    A: Air\u003cSymbolicAirBuilder\u003cVal\u003cSC\u003e\u003e\u003e + for\u003c'a\u003e Air\u003cVerifierConstraintFolder\u003c'a, SC\u003e\u003e,\r\n{\r\n    let Proof {\r\n        commitments,\r\n        opened_values,\r\n        opening_proof,\r\n        degree_bits,\r\n    } = proof;\r\n\r\n    let degree = 1 \u003c\u003c degree_bits;\r\n    let log_quotient_degree = get_log_quotient_degree::\u003cVal\u003cSC\u003e, A\u003e(air, 0, public_values.len());\r\n    let quotient_degree = 1 \u003c\u003c log_quotient_degree;\r\n\r\n    let pcs = config.pcs();\r\n    let trace_domain = pcs.natural_domain_for_degree(degree);\r\n    let quotient_domain =\r\n        trace_domain.create_disjoint_domain(1 \u003c\u003c (degree_bits + log_quotient_degree));\r\n    let quotient_chunks_domains = quotient_domain.split_domains(quotient_degree);\r\n\r\n    let air_width = \u003cA as BaseAir\u003cVal\u003cSC\u003e\u003e\u003e::width(air);\r\n    let valid_shape = opened_values.trace_local.len() == air_width\r\n        \u0026\u0026 opened_values.trace_next.len() == air_width\r\n        \u0026\u0026 opened_values.quotient_chunks.len() == quotient_degree\r\n        \u0026\u0026 opened_values\r\n            .quotient_chunks\r\n            .iter()\r\n            .all(|qc| qc.len() == \u003cSC::Challenge as Serializable\u003cVal\u003cSC\u003e\u003e\u003e::DIMENSION);\r\n    if !valid_shape {\r\n        return Err(VerificationError::InvalidProofShape);\r\n    }\r\n\r\n    // Observe the instance.\r\n    challenger.observe(Val::\u003cSC\u003e::from_usize(proof.degree_bits));\r\n    // TODO: Might be best practice to include other instance data here in the transcript, like some\r\n    // encoding of the AIR. This protects against transcript collisions between distinct instances.\r\n    // Practically speaking though, the only related known attack is from failing to include public\r\n    // values. It's not clear if failing to include other instance data could enable a transcript\r\n    // collision, since most such changes would completely change the set of satisfying witnesses.\r\n\r\n    challenger.observe(commitments.trace.clone());\r\n    challenger.observe_slice(public_values);\r\n    let alpha: SC::Challenge = challenger.sample_algebra_element();\r\n    challenger.observe(commitments.quotient_chunks.clone());\r\n\r\n    let zeta: SC::Challenge = challenger.sample();\r\n    let zeta_next = trace_domain.next_point(zeta).unwrap();\r\n\r\n    pcs.verify(\r\n        vec![\r\n            (\r\n                commitments.trace.clone(),\r\n                vec![(\r\n                    trace_domain,\r\n                    vec![\r\n                        (zeta, opened_values.trace_local.clone()),\r\n                        (zeta_next, opened_values.trace_next.clone()),\r\n                    ],\r\n                )],\r\n            ),\r\n            (\r\n                commitments.quotient_chunks.clone(),\r\n                quotient_chunks_domains\r\n                    .iter()\r\n                    .zip(\u0026opened_values.quotient_chunks)\r\n                    .map(|(domain, values)| (*domain, vec![(zeta, values.clone())]))\r\n                    .collect_vec(),\r\n            ),\r\n        ],\r\n        opening_proof,\r\n        challenger,\r\n    )\r\n    .map_err(VerificationError::InvalidOpeningArgument)?;\r\n\r\n    let zps = quotient_chunks_domains\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(i, domain)| {\r\n            quotient_chunks_domains\r\n                .iter()\r\n                .enumerate()\r\n                .filter(|(j, _)| *j != i)\r\n                .map(|(_, other_domain)| {\r\n                    other_domain.zp_at_point(zeta)\r\n                        * other_domain.zp_at_point(domain.first_point()).inverse()\r\n                })\r\n                .product::\u003cSC::Challenge\u003e()\r\n        })\r\n        .collect_vec();\r\n\r\n    let quotient = opened_values\r\n        .quotient_chunks\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(ch_i, ch)| {\r\n            zps[ch_i]\r\n                * ch.iter()\r\n                    .enumerate()\r\n                    .map(|(e_i, \u0026c)| SC::Challenge::ith_basis_element(e_i) * c)\r\n                    .sum::\u003cSC::Challenge\u003e()\r\n        })\r\n        .sum::\u003cSC::Challenge\u003e();\r\n\r\n    let sels = trace_domain.selectors_at_point(zeta);\r\n\r\n    let main = VerticalPair::new(\r\n        RowMajorMatrixView::new_row(\u0026opened_values.trace_local),\r\n        RowMajorMatrixView::new_row(\u0026opened_values.trace_next),\r\n    );\r\n\r\n    let mut folder = VerifierConstraintFolder {\r\n        main,\r\n        public_values,\r\n        is_first_row: sels.is_first_row,\r\n        is_last_row: sels.is_last_row,\r\n        is_transition: sels.is_transition,\r\n        alpha,\r\n        accumulator: SC::Challenge::ZERO,\r\n    };\r\n    air.eval(\u0026mut folder);\r\n    let folded_constraints = folder.accumulator;\r\n\r\n    // Finally, check that\r\n    //     folded_constraints(zeta) / Z_H(zeta) = quotient(zeta)\r\n    if folded_constraints * sels.inv_zeroifier != quotient {\r\n        return Err(VerificationError::OodEvaluationMismatch);\r\n    }\r\n\r\n    Ok(())\r\n}\r\n\r\n#[derive(Debug)]\r\npub enum VerificationError\u003cPcsErr\u003e {\r\n    InvalidProofShape,\r\n    /// An error occurred while verifying the claimed openings.\r\n    InvalidOpeningArgument(PcsErr),\r\n    /// Out-of-domain evaluation mismatch, i.e. `constraints(zeta)` did not match\r\n    /// `quotient(zeta) Z_H(zeta)`.\r\n    OodEvaluationMismatch,\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":103,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":104,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":105,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":106,"address":[],"length":0,"stats":{"Line":9079256848778919936}},{"line":107,"address":[],"length":0,"stats":{"Line":5332261958806667264}},{"line":108,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":109,"address":[],"length":0,"stats":{"Line":3458764513820540928}},{"line":111,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":120,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":121,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":122,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":123,"address":[],"length":0,"stats":{"Line":10952754293765046272}},{"line":124,"address":[],"length":0,"stats":{"Line":1873497444986126336}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}}],"covered":17,"coverable":77},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","src","zerofier_coset.rs"],"content":"use alloc::vec::Vec;\r\n\r\nuse itertools::Itertools;\r\nuse p3_field::{\r\n    batch_multiplicative_inverse, cyclic_subgroup_coset_known_order, Field, PackedField,\r\n    TwoAdicField,\r\n};\r\n\r\n/// Precomputations of the evaluation of `Z_H(X) = X^n - 1` on a coset `s K` with `H \u003c= K`.\r\n#[derive(Debug)]\r\npub struct ZerofierOnCoset\u003cF: Field\u003e {\r\n    /// `n = |H|`.\r\n    log_n: usize,\r\n    /// `rate = |K|/|H|`.\r\n    rate_bits: usize,\r\n    coset_shift: F,\r\n    /// Holds `g^n * (w^n)^i - 1 = g^n * v^i - 1` for `i in 0..rate`, with `w` a generator of `K` and `v` a\r\n    /// `rate`-primitive root of unity.\r\n    evals: Vec\u003cF\u003e,\r\n    /// Holds the multiplicative inverses of `evals`.\r\n    inverses: Vec\u003cF\u003e,\r\n}\r\n\r\nimpl\u003cF: TwoAdicField\u003e ZerofierOnCoset\u003cF\u003e {\r\n    pub fn new(log_n: usize, rate_bits: usize, coset_shift: F) -\u003e Self {\r\n        let s_pow_n = coset_shift.exp_power_of_2(log_n);\r\n        let evals = F::two_adic_generator(rate_bits)\r\n            .powers()\r\n            .take(1 \u003c\u003c rate_bits)\r\n            .map(|x| s_pow_n * x - F::ONE)\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        let inverses = batch_multiplicative_inverse(\u0026evals);\r\n        Self {\r\n            log_n,\r\n            rate_bits,\r\n            coset_shift,\r\n            evals,\r\n            inverses,\r\n        }\r\n    }\r\n\r\n    /// Returns `Z_H(g * w^i)`.\r\n    pub fn eval(\u0026self, i: usize) -\u003e F {\r\n        self.evals[i \u0026 ((1 \u003c\u003c self.rate_bits) - 1)]\r\n    }\r\n\r\n    /// Returns `1 / Z_H(g * w^i)`.\r\n    pub fn eval_inverse(\u0026self, i: usize) -\u003e F {\r\n        self.inverses[i \u0026 ((1 \u003c\u003c self.rate_bits) - 1)]\r\n    }\r\n\r\n    /// Like `eval_inverse`, but for a range of indices starting with `i_start`.\r\n    pub fn eval_inverse_packed\u003cP: PackedField\u003cScalar = F\u003e\u003e(\u0026self, i_start: usize) -\u003e P {\r\n        let mut packed = P::ZERO;\r\n        packed\r\n            .as_slice_mut()\r\n            .iter_mut()\r\n            .enumerate()\r\n            .for_each(|(j, packed_j)| *packed_j = self.eval_inverse(i_start + j));\r\n        packed\r\n    }\r\n\r\n    /// Evaluate the Langrange basis polynomial, `L_i(x) = Z_H(x) / (x - g_H^i)`, on our coset `s K`.\r\n    /// Here `L_i(x)` is unnormalized in the sense that it evaluates to some nonzero value at `g_H^i`,\r\n    /// not necessarily 1.\r\n    pub fn lagrange_basis_unnormalized(\u0026self, i: usize) -\u003e Vec\u003cF\u003e {\r\n        let log_coset_size = self.log_n + self.rate_bits;\r\n        let coset_size = 1 \u003c\u003c log_coset_size;\r\n        let g_h = F::two_adic_generator(self.log_n);\r\n        let g_k = F::two_adic_generator(log_coset_size);\r\n\r\n        let target_point = g_h.exp_u64(i as u64);\r\n        let denominators = cyclic_subgroup_coset_known_order(g_k, self.coset_shift, coset_size)\r\n            .map(|x| x - target_point)\r\n            .collect_vec();\r\n        let inverses = batch_multiplicative_inverse(\u0026denominators);\r\n\r\n        self.evals\r\n            .iter()\r\n            .cycle()\r\n            .zip(inverses)\r\n            .map(|(\u0026z_h, inv)| z_h * inv)\r\n            .collect()\r\n    }\r\n}\r\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":27},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","tests","fib_air.rs"],"content":"use std::borrow::Borrow;\r\n\r\nuse p3_air::{Air, AirBuilder, AirBuilderWithPublicValues, BaseAir};\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_challenger::DuplexChallenger;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field::{Field, PrimeCharacteristicRing, PrimeField64};\r\nuse p3_fri::{create_test_fri_config, TwoAdicFriPcs};\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_symmetric::{PaddingFreeSponge, TruncatedPermutation};\r\nuse p3_uni_stark::{prove, verify, StarkConfig};\r\nuse rand::thread_rng;\r\n\r\n/// For testing the public values feature\r\npub struct FibonacciAir {}\r\n\r\nimpl\u003cF\u003e BaseAir\u003cF\u003e for FibonacciAir {\r\n    fn width(\u0026self) -\u003e usize {\r\n        NUM_FIBONACCI_COLS\r\n    }\r\n}\r\n\r\nimpl\u003cAB: AirBuilderWithPublicValues\u003e Air\u003cAB\u003e for FibonacciAir {\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        let main = builder.main();\r\n        let pis = builder.public_values();\r\n\r\n        let a = pis[0];\r\n        let b = pis[1];\r\n        let x = pis[2];\r\n\r\n        let (local, next) = (main.row_slice(0), main.row_slice(1));\r\n        let local: \u0026FibonacciRow\u003cAB::Var\u003e = (*local).borrow();\r\n        let next: \u0026FibonacciRow\u003cAB::Var\u003e = (*next).borrow();\r\n\r\n        let mut when_first_row = builder.when_first_row();\r\n\r\n        when_first_row.assert_eq(local.left, a);\r\n        when_first_row.assert_eq(local.right, b);\r\n\r\n        let mut when_transition = builder.when_transition();\r\n\r\n        // a' \u003c- b\r\n        when_transition.assert_eq(local.right, next.left);\r\n\r\n        // b' \u003c- a + b\r\n        when_transition.assert_eq(local.left + local.right, next.right);\r\n\r\n        builder.when_last_row().assert_eq(local.right, x);\r\n    }\r\n}\r\n\r\npub fn generate_trace_rows\u003cF: PrimeField64\u003e(a: u64, b: u64, n: usize) -\u003e RowMajorMatrix\u003cF\u003e {\r\n    assert!(n.is_power_of_two());\r\n\r\n    let mut trace = RowMajorMatrix::new(F::zero_vec(n * NUM_FIBONACCI_COLS), NUM_FIBONACCI_COLS);\r\n\r\n    let (prefix, rows, suffix) = unsafe { trace.values.align_to_mut::\u003cFibonacciRow\u003cF\u003e\u003e() };\r\n    assert!(prefix.is_empty(), \"Alignment should match\");\r\n    assert!(suffix.is_empty(), \"Alignment should match\");\r\n    assert_eq!(rows.len(), n);\r\n\r\n    rows[0] = FibonacciRow::new(F::from_u64(a), F::from_u64(b));\r\n\r\n    for i in 1..n {\r\n        rows[i].left = rows[i - 1].right;\r\n        rows[i].right = rows[i - 1].left + rows[i - 1].right;\r\n    }\r\n\r\n    trace\r\n}\r\n\r\nconst NUM_FIBONACCI_COLS: usize = 2;\r\n\r\npub struct FibonacciRow\u003cF\u003e {\r\n    pub left: F,\r\n    pub right: F,\r\n}\r\n\r\nimpl\u003cF\u003e FibonacciRow\u003cF\u003e {\r\n    const fn new(left: F, right: F) -\u003e FibonacciRow\u003cF\u003e {\r\n        FibonacciRow { left, right }\r\n    }\r\n}\r\n\r\nimpl\u003cF\u003e Borrow\u003cFibonacciRow\u003cF\u003e\u003e for [F] {\r\n    fn borrow(\u0026self) -\u003e \u0026FibonacciRow\u003cF\u003e {\r\n        debug_assert_eq!(self.len(), NUM_FIBONACCI_COLS);\r\n        let (prefix, shorts, suffix) = unsafe { self.align_to::\u003cFibonacciRow\u003cF\u003e\u003e() };\r\n        debug_assert!(prefix.is_empty(), \"Alignment should match\");\r\n        debug_assert!(suffix.is_empty(), \"Alignment should match\");\r\n        debug_assert_eq!(shorts.len(), 1);\r\n        \u0026shorts[0]\r\n    }\r\n}\r\n\r\ntype Val = BabyBear;\r\ntype Perm = Poseidon2BabyBear\u003c16\u003e;\r\ntype MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\ntype MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\ntype ValMmcs =\r\n    MerkleTreeMmcs\u003c\u003cVal as Field\u003e::Packing, \u003cVal as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\r\ntype Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\ntype ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\ntype Challenger = DuplexChallenger\u003cVal, Perm, 16, 8\u003e;\r\ntype Dft = Radix2DitParallel\u003cVal\u003e;\r\ntype Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\ntype MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n\r\n/// n-th Fibonacci number expected to be x\r\nfn test_public_value_impl(n: usize, x: u64) {\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n    let hash = MyHash::new(perm.clone());\r\n    let compress = MyCompress::new(perm.clone());\r\n    let val_mmcs = ValMmcs::new(hash, compress);\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n    let dft = Dft::default();\r\n    let trace = generate_trace_rows::\u003cVal\u003e(0, 1, n);\r\n    let fri_config = create_test_fri_config(challenge_mmcs);\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n    let config = MyConfig::new(pcs);\r\n    let mut challenger = Challenger::new(perm.clone());\r\n    let pis = vec![BabyBear::ZERO, BabyBear::ONE, BabyBear::from_u64(x)];\r\n    let proof = prove(\u0026config, \u0026FibonacciAir {}, \u0026mut challenger, trace, \u0026pis);\r\n    let mut challenger = Challenger::new(perm);\r\n    verify(\u0026config, \u0026FibonacciAir {}, \u0026mut challenger, \u0026proof, \u0026pis).expect(\"verification failed\");\r\n}\r\n\r\n#[test]\r\nfn test_one_row_trace() {\r\n    test_public_value_impl(1, 1);\r\n}\r\n\r\n#[test]\r\nfn test_public_value() {\r\n    test_public_value_impl(1 \u003c\u003c 3, 21);\r\n}\r\n\r\n#[cfg(debug_assertions)]\r\n#[test]\r\n#[should_panic(expected = \"assertion `left == right` failed: constraints had nonzero value\")]\r\nfn test_incorrect_public_value() {\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n    let hash = MyHash::new(perm.clone());\r\n    let compress = MyCompress::new(perm.clone());\r\n    let val_mmcs = ValMmcs::new(hash, compress);\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n    let dft = Dft::default();\r\n    let fri_config = create_test_fri_config(challenge_mmcs);\r\n    let trace = generate_trace_rows::\u003cVal\u003e(0, 1, 1 \u003c\u003c 3);\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n    let config = MyConfig::new(pcs);\r\n    let mut challenger = Challenger::new(perm.clone());\r\n    let pis = vec![\r\n        BabyBear::ZERO,\r\n        BabyBear::ONE,\r\n        BabyBear::from_u32(123_123), // incorrect result\r\n    ];\r\n    prove(\u0026config, \u0026FibonacciAir {}, \u0026mut challenger, trace, \u0026pis);\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":23,"address":[],"length":0,"stats":{"Line":432345564227567616}},{"line":28,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":29,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":30,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":32,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":33,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":34,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":36,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":37,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":38,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":40,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":42,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":43,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":45,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":48,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":51,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":53,"address":[],"length":0,"stats":{"Line":1801439850948198400}},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":60,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":62,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":63,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":64,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":65,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":67,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":69,"address":[],"length":0,"stats":{"Line":2233785415175766016}},{"line":70,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":71,"address":[],"length":0,"stats":{"Line":1008806316530991104}},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":85,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":91,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":92,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":93,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":94,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":95,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":96,"address":[],"length":0,"stats":{"Line":7205759403792793600}},{"line":97,"address":[],"length":0,"stats":{"Line":3602879701896396800}},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":116,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":121,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":123,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":129,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":54,"coverable":54},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","uni-stark","tests","mul_air.rs"],"content":"use std::fmt::Debug;\r\nuse std::marker::PhantomData;\r\n\r\nuse itertools::Itertools;\r\nuse p3_air::{Air, AirBuilder, BaseAir};\r\nuse p3_baby_bear::{BabyBear, Poseidon2BabyBear};\r\nuse p3_challenger::{DuplexChallenger, HashChallenger, SerializingChallenger32};\r\nuse p3_circle::CirclePcs;\r\nuse p3_commit::testing::TrivialPcs;\r\nuse p3_commit::ExtensionMmcs;\r\nuse p3_dft::Radix2DitParallel;\r\nuse p3_field::extension::BinomialExtensionField;\r\nuse p3_field::{Field, PrimeCharacteristicRing};\r\nuse p3_fri::{FriConfig, TwoAdicFriPcs};\r\nuse p3_keccak::Keccak256Hash;\r\nuse p3_matrix::dense::RowMajorMatrix;\r\nuse p3_matrix::Matrix;\r\nuse p3_merkle_tree::MerkleTreeMmcs;\r\nuse p3_mersenne_31::Mersenne31;\r\nuse p3_symmetric::{\r\n    CompressionFunctionFromHasher, PaddingFreeSponge, SerializingHasher32, TruncatedPermutation,\r\n};\r\nuse p3_uni_stark::{prove, verify, StarkConfig, StarkGenericConfig, Val};\r\nuse rand::distributions::{Distribution, Standard};\r\nuse rand::{thread_rng, Rng};\r\n\r\n/// How many `a * b = c` operations to do per row in the AIR.\r\nconst REPETITIONS: usize = 20; // This should be \u003c 255 so it can fit into a u8.\r\nconst TRACE_WIDTH: usize = REPETITIONS * 3;\r\n\r\n/*\r\nIn its basic form, asserts a^(self.degree-1) * b = c\r\n(so that the total constraint degree is self.degree)\r\n\r\n\r\nIf `uses_transition_constraints`, checks that on transition rows, the first a = row number\r\n*/\r\npub struct MulAir {\r\n    degree: u64,\r\n    uses_boundary_constraints: bool,\r\n    uses_transition_constraints: bool,\r\n}\r\n\r\nimpl Default for MulAir {\r\n    fn default() -\u003e Self {\r\n        MulAir {\r\n            degree: 3,\r\n            uses_boundary_constraints: true,\r\n            uses_transition_constraints: true,\r\n        }\r\n    }\r\n}\r\n\r\nimpl MulAir {\r\n    pub fn random_valid_trace\u003cF: Field\u003e(\u0026self, rows: usize, valid: bool) -\u003e RowMajorMatrix\u003cF\u003e\r\n    where\r\n        Standard: Distribution\u003cF\u003e,\r\n    {\r\n        let mut rng = thread_rng();\r\n        let mut trace_values = F::zero_vec(rows * TRACE_WIDTH);\r\n        for (i, (a, b, c)) in trace_values.iter_mut().tuples().enumerate() {\r\n            let row = i / REPETITIONS;\r\n            *a = if self.uses_transition_constraints {\r\n                F::from_usize(i)\r\n            } else {\r\n                rng.gen()\r\n            };\r\n            *b = if self.uses_boundary_constraints \u0026\u0026 row == 0 {\r\n                a.square() + F::ONE\r\n            } else {\r\n                rng.gen()\r\n            };\r\n            *c = a.exp_u64(self.degree - 1) * *b;\r\n\r\n            if !valid {\r\n                // make it invalid\r\n                *c *= F::TWO;\r\n            }\r\n        }\r\n        RowMajorMatrix::new(trace_values, TRACE_WIDTH)\r\n    }\r\n}\r\n\r\nimpl\u003cF\u003e BaseAir\u003cF\u003e for MulAir {\r\n    fn width(\u0026self) -\u003e usize {\r\n        TRACE_WIDTH\r\n    }\r\n}\r\n\r\nimpl\u003cAB: AirBuilder\u003e Air\u003cAB\u003e for MulAir {\r\n    fn eval(\u0026self, builder: \u0026mut AB) {\r\n        let main = builder.main();\r\n        let main_local = main.row_slice(0);\r\n        let main_next = main.row_slice(1);\r\n\r\n        for i in 0..REPETITIONS {\r\n            let start = i * 3;\r\n            let a = main_local[start];\r\n            let b = main_local[start + 1];\r\n            let c = main_local[start + 2];\r\n            builder.assert_zero(a.into().exp_u64(self.degree - 1) * b - c);\r\n            if self.uses_boundary_constraints {\r\n                builder.when_first_row().assert_eq(a * a + AB::Expr::ONE, b);\r\n            }\r\n            if self.uses_transition_constraints {\r\n                let next_a = main_next[start];\r\n                builder\r\n                    .when_transition()\r\n                    .assert_eq(a + AB::Expr::from_u8(REPETITIONS as u8), next_a);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn do_test\u003cSC: StarkGenericConfig\u003e(\r\n    config: SC,\r\n    air: MulAir,\r\n    log_height: usize,\r\n    challenger: SC::Challenger,\r\n) -\u003e Result\u003c(), impl Debug\u003e\r\nwhere\r\n    SC::Challenger: Clone,\r\n    Standard: Distribution\u003cVal\u003cSC\u003e\u003e,\r\n{\r\n    let trace = air.random_valid_trace(log_height, true);\r\n\r\n    let mut p_challenger = challenger.clone();\r\n    let proof = prove(\u0026config, \u0026air, \u0026mut p_challenger, trace, \u0026vec![]);\r\n\r\n    let serialized_proof = postcard::to_allocvec(\u0026proof).expect(\"unable to serialize proof\");\r\n    tracing::debug!(\"serialized_proof len: {} bytes\", serialized_proof.len());\r\n\r\n    let deserialized_proof =\r\n        postcard::from_bytes(\u0026serialized_proof).expect(\"unable to deserialize proof\");\r\n\r\n    let mut v_challenger = challenger.clone();\r\n    verify(\r\n        \u0026config,\r\n        \u0026air,\r\n        \u0026mut v_challenger,\r\n        \u0026deserialized_proof,\r\n        \u0026vec![],\r\n    )\r\n}\r\n\r\nfn do_test_bb_trivial(degree: u64, log_n: usize) -\u003e Result\u003c(), impl Debug\u003e {\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = DuplexChallenger\u003cVal, Perm, 16, 8\u003e;\r\n\r\n    type Pcs = TrivialPcs\u003cVal, Radix2DitParallel\u003cVal\u003e\u003e;\r\n    let pcs = TrivialPcs {\r\n        dft,\r\n        log_n,\r\n        _phantom: PhantomData,\r\n    };\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let air = MulAir {\r\n        degree,\r\n        ..Default::default()\r\n    };\r\n\r\n    do_test(config, air, 1 \u003c\u003c log_n, Challenger::new(perm))\r\n}\r\n\r\n#[test]\r\nfn prove_bb_trivial_deg2() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_trivial(2, 8)\r\n}\r\n\r\n#[test]\r\nfn prove_bb_trivial_deg3() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_trivial(3, 8)\r\n}\r\n\r\n#[test]\r\nfn prove_bb_trivial_deg4() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_trivial(4, 8)\r\n}\r\n\r\nfn do_test_bb_twoadic(log_blowup: usize, degree: u64, log_n: usize) -\u003e Result\u003c(), impl Debug\u003e {\r\n    type Val = BabyBear;\r\n    type Challenge = BinomialExtensionField\u003cVal, 4\u003e;\r\n\r\n    type Perm = Poseidon2BabyBear\u003c16\u003e;\r\n    let perm = Perm::new_from_rng_128(\u0026mut thread_rng());\r\n\r\n    type MyHash = PaddingFreeSponge\u003cPerm, 16, 8, 8\u003e;\r\n    let hash = MyHash::new(perm.clone());\r\n\r\n    type MyCompress = TruncatedPermutation\u003cPerm, 2, 8, 16\u003e;\r\n    let compress = MyCompress::new(perm.clone());\r\n\r\n    type ValMmcs =\r\n        MerkleTreeMmcs\u003c\u003cVal as Field\u003e::Packing, \u003cVal as Field\u003e::Packing, MyHash, MyCompress, 8\u003e;\r\n    let val_mmcs = ValMmcs::new(hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Dft = Radix2DitParallel\u003cVal\u003e;\r\n    let dft = Dft::default();\r\n\r\n    type Challenger = DuplexChallenger\u003cVal, Perm, 16, 8\u003e;\r\n\r\n    let fri_config = FriConfig {\r\n        log_blowup,\r\n        log_final_poly_len: 5,\r\n        num_queries: 40,\r\n        proof_of_work_bits: 8,\r\n        mmcs: challenge_mmcs,\r\n    };\r\n    type Pcs = TwoAdicFriPcs\u003cVal, Dft, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs::new(dft, val_mmcs, fri_config);\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let air = MulAir {\r\n        degree,\r\n        ..Default::default()\r\n    };\r\n\r\n    do_test(config, air, 1 \u003c\u003c log_n, Challenger::new(perm))\r\n}\r\n\r\n#[test]\r\nfn prove_bb_twoadic_deg2() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_twoadic(1, 2, 7)\r\n}\r\n\r\n#[test]\r\nfn prove_bb_twoadic_deg3() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_twoadic(1, 3, 7)\r\n}\r\n\r\n#[test]\r\nfn prove_bb_twoadic_deg4() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_twoadic(2, 4, 6)\r\n}\r\n\r\n#[test]\r\nfn prove_bb_twoadic_deg5() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_bb_twoadic(2, 5, 6)\r\n}\r\n\r\nfn do_test_m31_circle(log_blowup: usize, degree: u64, log_n: usize) -\u003e Result\u003c(), impl Debug\u003e {\r\n    type Val = Mersenne31;\r\n    type Challenge = BinomialExtensionField\u003cVal, 3\u003e;\r\n\r\n    type ByteHash = Keccak256Hash;\r\n    type FieldHash = SerializingHasher32\u003cByteHash\u003e;\r\n    let byte_hash = ByteHash {};\r\n    let field_hash = FieldHash::new(byte_hash);\r\n\r\n    type MyCompress = CompressionFunctionFromHasher\u003cByteHash, 2, 32\u003e;\r\n    let compress = MyCompress::new(byte_hash);\r\n\r\n    type ValMmcs = MerkleTreeMmcs\u003cVal, u8, FieldHash, MyCompress, 32\u003e;\r\n    let val_mmcs = ValMmcs::new(field_hash, compress);\r\n\r\n    type ChallengeMmcs = ExtensionMmcs\u003cVal, Challenge, ValMmcs\u003e;\r\n    let challenge_mmcs = ChallengeMmcs::new(val_mmcs.clone());\r\n\r\n    type Challenger = SerializingChallenger32\u003cVal, HashChallenger\u003cu8, ByteHash, 32\u003e\u003e;\r\n\r\n    let fri_config = FriConfig {\r\n        log_blowup,\r\n        log_final_poly_len: 0,\r\n        num_queries: 40,\r\n        proof_of_work_bits: 8,\r\n        mmcs: challenge_mmcs,\r\n    };\r\n\r\n    type Pcs = CirclePcs\u003cVal, ValMmcs, ChallengeMmcs\u003e;\r\n    let pcs = Pcs {\r\n        mmcs: val_mmcs,\r\n        fri_config,\r\n        _phantom: PhantomData,\r\n    };\r\n\r\n    type MyConfig = StarkConfig\u003cPcs, Challenge, Challenger\u003e;\r\n    let config = MyConfig::new(pcs);\r\n\r\n    let air = MulAir {\r\n        degree,\r\n        uses_boundary_constraints: true,\r\n        uses_transition_constraints: true,\r\n    };\r\n\r\n    do_test(\r\n        config,\r\n        air,\r\n        1 \u003c\u003c log_n,\r\n        Challenger::from_hasher(vec![], byte_hash),\r\n    )\r\n}\r\n\r\n#[test]\r\nfn prove_m31_circle_deg2() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_m31_circle(1, 2, 8)\r\n}\r\n\r\n#[test]\r\nfn prove_m31_circle_deg3() -\u003e Result\u003c(), impl Debug\u003e {\r\n    do_test_m31_circle(1, 3, 9)\r\n}\r\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":504403158265495552}},{"line":55,"address":[],"length":0,"stats":{"Line":648518346341351514}},{"line":59,"address":[],"length":0,"stats":{"Line":648518346341351514}},{"line":60,"address":[],"length":0,"stats":{"Line":648518346341351514}},{"line":61,"address":[],"length":0,"stats":{"Line":648518346341351514}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":150}},{"line":66,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":68,"address":[],"length":0,"stats":{"Line":150}},{"line":69,"address":[],"length":0,"stats":{"Line":12970366926827028480}},{"line":71,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":77,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":80,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":85,"address":[],"length":0,"stats":{"Line":1945555039024054332}},{"line":86,"address":[],"length":0,"stats":{"Line":1945555039024054332}},{"line":91,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":92,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":93,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":94,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":96,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":103,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":105,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":106,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":107,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":109,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":115,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":125,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":127,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":128,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":130,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":131,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":133,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":134,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":136,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":138,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":139,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":140,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":141,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":142,"address":[],"length":0,"stats":{"Line":648518346341351424}},{"line":146,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":151,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":154,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":166,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":173,"address":[],"length":0,"stats":{"Line":216172782113783808}},{"line":191,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":196,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":199,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":202,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":206,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":209,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":212,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":224,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":227,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":234,"address":[],"length":0,"stats":{"Line":288230376151711744}},{"line":257,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":263,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":264,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":267,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":270,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":273,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":293,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":302,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":303,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":304,"address":[],"length":0,"stats":{"Line":144115188075855872}},{"line":305,"address":[],"length":0,"stats":{"Line":144115188075855872}}],"covered":66,"coverable":74},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","util","benches","bit_reverse.rs"],"content":"use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};\r\nuse p3_util::{reverse_bits, reverse_slice_index_bits};\r\nuse rand::{thread_rng, Rng};\r\n\r\nfn bench_reverse_bits(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"reverse_bits\");\r\n    for log_size in [1, 3, 5, 8, 16, 24] {\r\n        let bits = 1 \u003c\u003c log_size;\r\n        group.bench_with_input(BenchmarkId::from_parameter(bits), \u0026bits, |b, \u0026bits| {\r\n            let n = 1 \u003c\u003c bits;\r\n            let x = thread_rng().gen_range(0..n);\r\n            b.iter(|| {\r\n                black_box(reverse_bits(black_box(x), black_box(n)));\r\n            });\r\n        });\r\n    }\r\n    group.finish();\r\n}\r\n\r\nfn bench_reverse_slice_index_bits(c: \u0026mut Criterion) {\r\n    let mut group = c.benchmark_group(\"reverse_slice_index_bits\");\r\n    for log_size in [1, 3, 5, 8, 16, 24] {\r\n        let size = 1 \u003c\u003c log_size;\r\n        group.bench_with_input(BenchmarkId::from_parameter(size), \u0026size, |b, \u0026size| {\r\n            let mut rng = thread_rng();\r\n            let data: Vec\u003cu64\u003e = (0..size).map(|_| rng.gen()).collect();\r\n            b.iter(|| {\r\n                let mut test_data = data.clone();\r\n                reverse_slice_index_bits(black_box(\u0026mut test_data));\r\n                black_box(test_data)\r\n            });\r\n        });\r\n    }\r\n    group.finish();\r\n}\r\n\r\ncriterion_group!(benches, bench_reverse_bits, bench_reverse_slice_index_bits);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","util","src","array_serialization.rs"],"content":"use alloc::vec::Vec;\r\nuse core::marker::PhantomData;\r\n\r\nuse serde::de::{SeqAccess, Visitor};\r\nuse serde::ser::SerializeTuple;\r\nuse serde::{Deserialize, Deserializer, Serialize, Serializer};\r\n\r\npub fn serialize\u003cS: Serializer, T: Serialize, const N: usize\u003e(\r\n    data: \u0026[T; N],\r\n    ser: S,\r\n) -\u003e Result\u003cS::Ok, S::Error\u003e {\r\n    let mut s = ser.serialize_tuple(N)?;\r\n    for item in data {\r\n        s.serialize_element(item)?;\r\n    }\r\n    s.end()\r\n}\r\n\r\nstruct ArrayVisitor\u003cT, const N: usize\u003e(PhantomData\u003cT\u003e);\r\n\r\nimpl\u003c'de, T, const N: usize\u003e Visitor\u003c'de\u003e for ArrayVisitor\u003cT, N\u003e\r\nwhere\r\n    T: Deserialize\u003c'de\u003e,\r\n{\r\n    type Value = [T; N];\r\n\r\n    fn expecting(\u0026self, formatter: \u0026mut core::fmt::Formatter\u003c'_\u003e) -\u003e core::fmt::Result {\r\n        formatter.write_fmt(format_args!(\"an array of length {}\", N))\r\n    }\r\n\r\n    #[inline]\r\n    fn visit_seq\u003cA\u003e(self, mut seq: A) -\u003e Result\u003cSelf::Value, A::Error\u003e\r\n    where\r\n        A: SeqAccess\u003c'de\u003e,\r\n    {\r\n        let mut data = Vec::with_capacity(N);\r\n        for _ in 0..N {\r\n            match seq.next_element()? {\r\n                Some(val) =\u003e data.push(val),\r\n                None =\u003e return Err(serde::de::Error::invalid_length(N, \u0026self)),\r\n            }\r\n        }\r\n        match data.try_into() {\r\n            Ok(arr) =\u003e Ok(arr),\r\n            Err(_) =\u003e unreachable!(),\r\n        }\r\n    }\r\n}\r\npub fn deserialize\u003c'de, D, T, const N: usize\u003e(deserializer: D) -\u003e Result\u003c[T; N], D::Error\u003e\r\nwhere\r\n    D: Deserializer\u003c'de\u003e,\r\n    T: Deserialize\u003c'de\u003e,\r\n{\r\n    deserializer.deserialize_tuple(N, ArrayVisitor::\u003cT, N\u003e(PhantomData))\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":12682136550675316763}},{"line":12,"address":[],"length":0,"stats":{"Line":6917529027641081910}},{"line":13,"address":[],"length":0,"stats":{"Line":14411518807585587226}},{"line":14,"address":[],"length":0,"stats":{"Line":0}},{"line":16,"address":[],"length":0,"stats":{"Line":12682136550675316736}},{"line":27,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":12682136550675316746}},{"line":36,"address":[],"length":0,"stats":{"Line":12682136550675316746}},{"line":37,"address":[],"length":0,"stats":{"Line":14411518807585587219}},{"line":38,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":39,"address":[],"length":0,"stats":{"Line":18446744073709551615}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":12682136550675316770}},{"line":44,"address":[],"length":0,"stats":{"Line":12682136550675316761}},{"line":49,"address":[],"length":0,"stats":{"Line":12682136550675316742}},{"line":54,"address":[],"length":0,"stats":{"Line":12682136550675316742}}],"covered":13,"coverable":17},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","util","src","lib.rs"],"content":"//! Various simple utilities.\r\n\r\n#![no_std]\r\n\r\nextern crate alloc;\r\n\r\nuse alloc::string::String;\r\nuse alloc::vec::Vec;\r\nuse core::any::type_name;\r\nuse core::hint::unreachable_unchecked;\r\nuse core::mem;\r\nuse core::mem::MaybeUninit;\r\n\r\npub mod array_serialization;\r\npub mod linear_map;\r\npub mod transpose;\r\n\r\n/// Computes `ceil(log_2(n))`.\r\n#[must_use]\r\npub const fn log2_ceil_usize(n: usize) -\u003e usize {\r\n    (usize::BITS - n.saturating_sub(1).leading_zeros()) as usize\r\n}\r\n\r\n#[must_use]\r\npub fn log2_ceil_u64(n: u64) -\u003e u64 {\r\n    (u64::BITS - n.saturating_sub(1).leading_zeros()).into()\r\n}\r\n\r\n/// Computes `log_2(n)`\r\n///\r\n/// # Panics\r\n/// Panics if `n` is not a power of two.\r\n#[must_use]\r\n#[inline]\r\npub fn log2_strict_usize(n: usize) -\u003e usize {\r\n    let res = n.trailing_zeros();\r\n    assert_eq!(n.wrapping_shr(res), 1, \"Not a power of two: {n}\");\r\n    // Tell the optimizer about the semantics of `log2_strict`. i.e. it can replace `n` with\r\n    // `1 \u003c\u003c res` and vice versa.\r\n    assume(n == 1 \u003c\u003c res);\r\n    res as usize\r\n}\r\n\r\n/// Returns `[0, ..., N - 1]`.\r\n#[must_use]\r\npub const fn indices_arr\u003cconst N: usize\u003e() -\u003e [usize; N] {\r\n    let mut indices_arr = [0; N];\r\n    let mut i = 0;\r\n    while i \u003c N {\r\n        indices_arr[i] = i;\r\n        i += 1;\r\n    }\r\n    indices_arr\r\n}\r\n\r\n#[inline]\r\npub const fn reverse_bits(x: usize, n: usize) -\u003e usize {\r\n    // Assert that n is a power of 2\r\n    debug_assert!(n.is_power_of_two());\r\n    reverse_bits_len(x, n.trailing_zeros() as usize)\r\n}\r\n\r\n#[inline]\r\npub const fn reverse_bits_len(x: usize, bit_len: usize) -\u003e usize {\r\n    // NB: The only reason we need overflowing_shr() here as opposed\r\n    // to plain '\u003e\u003e' is to accommodate the case n == num_bits == 0,\r\n    // which would become `0 \u003e\u003e 64`. Rust thinks that any shift of 64\r\n    // bits causes overflow, even when the argument is zero.\r\n    x.reverse_bits()\r\n        .overflowing_shr(usize::BITS - bit_len as u32)\r\n        .0\r\n}\r\n\r\n// Lookup table of 6-bit reverses.\r\n// NB: 2^6=64 bytes is a cacheline. A smaller table wastes cache space.\r\n#[cfg(not(target_arch = \"aarch64\"))]\r\n#[rustfmt::skip]\r\nconst BIT_REVERSE_6BIT: \u0026[u8] = \u0026[\r\n    0o00, 0o40, 0o20, 0o60, 0o10, 0o50, 0o30, 0o70,\r\n    0o04, 0o44, 0o24, 0o64, 0o14, 0o54, 0o34, 0o74,\r\n    0o02, 0o42, 0o22, 0o62, 0o12, 0o52, 0o32, 0o72,\r\n    0o06, 0o46, 0o26, 0o66, 0o16, 0o56, 0o36, 0o76,\r\n    0o01, 0o41, 0o21, 0o61, 0o11, 0o51, 0o31, 0o71,\r\n    0o05, 0o45, 0o25, 0o65, 0o15, 0o55, 0o35, 0o75,\r\n    0o03, 0o43, 0o23, 0o63, 0o13, 0o53, 0o33, 0o73,\r\n    0o07, 0o47, 0o27, 0o67, 0o17, 0o57, 0o37, 0o77,\r\n];\r\n\r\n// Ensure that SMALL_ARR_SIZE \u003e= 4 * BIG_T_SIZE.\r\nconst BIG_T_SIZE: usize = 1 \u003c\u003c 14;\r\nconst SMALL_ARR_SIZE: usize = 1 \u003c\u003c 16;\r\n\r\n/// Permutes `arr` such that each index is mapped to its reverse in binary.\r\n/// If the whole array fits in fast cache, then the trivial algorithm is cache friendly. Also, if\r\n/// `T` is really big, then the trivial algorithm is cache-friendly, no matter the size of the array.\r\npub fn reverse_slice_index_bits\u003cF\u003e(vals: \u0026mut [F]) {\r\n    let n = vals.len();\r\n    if n == 0 {\r\n        return;\r\n    }\r\n    let log_n = log2_strict_usize(n);\r\n\r\n    // If the whole array fits in fast cache, then the trivial algorithm is cache friendly. Also, if\r\n    // `T` is really big, then the trivial algorithm is cache-friendly, no matter the size of the array.\r\n    if core::mem::size_of::\u003cF\u003e() \u003c\u003c log_n \u003c= SMALL_ARR_SIZE\r\n        || core::mem::size_of::\u003cF\u003e() \u003e= BIG_T_SIZE\r\n    {\r\n        reverse_slice_index_bits_small(vals, log_n);\r\n    } else {\r\n        debug_assert!(n \u003e= 4); // By our choice of `BIG_T_SIZE` and `SMALL_ARR_SIZE`.\r\n\r\n        // Algorithm:\r\n        //\r\n        // Treat `arr` as a `sqrt(n)` by `sqrt(n)` row-major matrix. (Assume for now that `lb_n` is\r\n        // even, i.e., `n` is a square number.) To perform bit-order reversal we:\r\n        //  1. Bit-reverse the order of the rows. (They are contiguous in memory, so this is\r\n        //     basically a series of large `memcpy`s.)\r\n        //  2. Transpose the matrix.\r\n        //  3. Bit-reverse the order of the rows.\r\n        //\r\n        // This is equivalent to, for every index `0 \u003c= i \u003c n`:\r\n        //  1. bit-reversing `i[lb_n / 2..lb_n]`,\r\n        //  2. swapping `i[0..lb_n / 2]` and `i[lb_n / 2..lb_n]`,\r\n        //  3. bit-reversing `i[lb_n / 2..lb_n]`.\r\n        //\r\n        // If `lb_n` is odd, i.e., `n` is not a square number, then the above procedure requires\r\n        // slight modification. At steps 1 and 3 we bit-reverse bits `ceil(lb_n / 2)..lb_n`, of the\r\n        // index (shuffling `floor(lb_n / 2)` chunks of length `ceil(lb_n / 2)`). At step 2, we\r\n        // perform _two_ transposes. We treat `arr` as two matrices, one where the middle bit of the\r\n        // index is `0` and another, where the middle bit is `1`; we transpose each individually.\r\n\r\n        let lb_num_chunks = log_n \u003e\u003e 1;\r\n        let lb_chunk_size = log_n - lb_num_chunks;\r\n        unsafe {\r\n            reverse_slice_index_bits_chunks(vals, lb_num_chunks, lb_chunk_size);\r\n            transpose_in_place_square(vals, lb_chunk_size, lb_num_chunks, 0);\r\n            if lb_num_chunks != lb_chunk_size {\r\n                // `arr` cannot be interpreted as a square matrix. We instead interpret it as a\r\n                // `1 \u003c\u003c lb_num_chunks` by `2` by `1 \u003c\u003c lb_num_chunks` tensor, in row-major order.\r\n                // The above transpose acted on `tensor[..., 0, ...]` (all indices with middle bit\r\n                // `0`). We still need to transpose `tensor[..., 1, ...]`. To do so, we advance\r\n                // arr by `1 \u003c\u003c lb_num_chunks` effectively, adding that to every index.\r\n                let vals_with_offset = \u0026mut vals[1 \u003c\u003c lb_num_chunks..];\r\n                transpose_in_place_square(vals_with_offset, lb_chunk_size, lb_num_chunks, 0);\r\n            }\r\n            reverse_slice_index_bits_chunks(vals, lb_num_chunks, lb_chunk_size);\r\n        }\r\n    }\r\n}\r\n\r\n// Both functions below are semantically equivalent to:\r\n//     for i in 0..n {\r\n//         result.push(arr[reverse_bits(i, n_power)]);\r\n//     }\r\n// where reverse_bits(i, n_power) computes the n_power-bit reverse. The complications are there\r\n// to guide the compiler to generate optimal assembly.\r\n\r\n#[cfg(not(target_arch = \"aarch64\"))]\r\nfn reverse_slice_index_bits_small\u003cF\u003e(vals: \u0026mut [F], lb_n: usize) {\r\n    if lb_n \u003c= 6 {\r\n        // BIT_REVERSE_6BIT holds 6-bit reverses. This shift makes them lb_n-bit reverses.\r\n        let dst_shr_amt = 6 - lb_n as u32;\r\n        #[allow(clippy::needless_range_loop)]\r\n        for src in 0..vals.len() {\r\n            let dst = (BIT_REVERSE_6BIT[src] as usize).wrapping_shr(dst_shr_amt);\r\n            if src \u003c dst {\r\n                vals.swap(src, dst);\r\n            }\r\n        }\r\n    } else {\r\n        // LLVM does not know that it does not need to reverse src at each iteration (which is\r\n        // expensive on x86). We take advantage of the fact that the low bits of dst change rarely and the high\r\n        // bits of dst are dependent only on the low bits of src.\r\n        let dst_lo_shr_amt = usize::BITS - (lb_n - 6) as u32;\r\n        let dst_hi_shl_amt = lb_n - 6;\r\n        for src_chunk in 0..(vals.len() \u003e\u003e 6) {\r\n            let src_hi = src_chunk \u003c\u003c 6;\r\n            let dst_lo = src_chunk.reverse_bits().wrapping_shr(dst_lo_shr_amt);\r\n            #[allow(clippy::needless_range_loop)]\r\n            for src_lo in 0..(1 \u003c\u003c 6) {\r\n                let dst_hi = (BIT_REVERSE_6BIT[src_lo] as usize) \u003c\u003c dst_hi_shl_amt;\r\n                let src = src_hi + src_lo;\r\n                let dst = dst_hi + dst_lo;\r\n                if src \u003c dst {\r\n                    vals.swap(src, dst);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(target_arch = \"aarch64\")]\r\nfn reverse_slice_index_bits_small\u003cF\u003e(vals: \u0026mut [F], lb_n: usize) {\r\n    // Aarch64 can reverse bits in one instruction, so the trivial version works best.\r\n    for src in 0..vals.len() {\r\n        let dst = src.reverse_bits().wrapping_shr(usize::BITS - lb_n as u32);\r\n        if src \u003c dst {\r\n            vals.swap(src, dst);\r\n        }\r\n    }\r\n}\r\n\r\n/// Split `arr` chunks and bit-reverse the order of the chunks. There are `1 \u003c\u003c lb_num_chunks`\r\n/// chunks, each of length `1 \u003c\u003c lb_chunk_size`.\r\n/// SAFETY: ensure that `arr.len() == 1 \u003c\u003c lb_num_chunks + lb_chunk_size`.\r\nunsafe fn reverse_slice_index_bits_chunks\u003cF\u003e(\r\n    vals: \u0026mut [F],\r\n    lb_num_chunks: usize,\r\n    lb_chunk_size: usize,\r\n) {\r\n    for i in 0..1usize \u003c\u003c lb_num_chunks {\r\n        // `wrapping_shr` handles the silly case when `lb_num_chunks == 0`.\r\n        let j = i\r\n            .reverse_bits()\r\n            .wrapping_shr(usize::BITS - lb_num_chunks as u32);\r\n        if i \u003c j {\r\n            core::ptr::swap_nonoverlapping(\r\n                vals.get_unchecked_mut(i \u003c\u003c lb_chunk_size),\r\n                vals.get_unchecked_mut(j \u003c\u003c lb_chunk_size),\r\n                1 \u003c\u003c lb_chunk_size,\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/// Transpose a square matrix in place.\r\n/// SAFETY: ensure that `arr.len() == 1 \u003c\u003c lb_chunk_size + lb_num_chunks`.\r\nunsafe fn transpose_in_place_square\u003cT\u003e(\r\n    arr: \u0026mut [T],\r\n    lb_chunk_size: usize,\r\n    lb_num_chunks: usize,\r\n    offset: usize,\r\n) {\r\n    transpose::transpose_in_place_square(arr, lb_chunk_size, lb_num_chunks, offset)\r\n}\r\n\r\n#[inline(always)]\r\npub fn assume(p: bool) {\r\n    debug_assert!(p);\r\n    if !p {\r\n        unsafe {\r\n            unreachable_unchecked();\r\n        }\r\n    }\r\n}\r\n\r\n/// Try to force Rust to emit a branch. Example:\r\n///\r\n/// ```no_run\r\n/// let x = 100;\r\n/// if x \u003e 20 {\r\n///     println!(\"x is big!\");\r\n///     p3_util::branch_hint();\r\n/// } else {\r\n///     println!(\"x is small!\");\r\n/// }\r\n/// ```\r\n///\r\n/// This function has no semantics. It is a hint only.\r\n#[inline(always)]\r\npub fn branch_hint() {\r\n    // NOTE: These are the currently supported assembly architectures. See the\r\n    // [nightly reference](https://doc.rust-lang.org/nightly/reference/inline-assembly.html) for\r\n    // the most up-to-date list.\r\n    #[cfg(any(\r\n        target_arch = \"aarch64\",\r\n        target_arch = \"arm\",\r\n        target_arch = \"riscv32\",\r\n        target_arch = \"riscv64\",\r\n        target_arch = \"x86\",\r\n        target_arch = \"x86_64\",\r\n    ))]\r\n    unsafe {\r\n        core::arch::asm!(\"\", options(nomem, nostack, preserves_flags));\r\n    }\r\n}\r\n\r\n/// Convenience methods for Vec.\r\npub trait VecExt\u003cT\u003e {\r\n    /// Push `elem` and return a reference to it.\r\n    fn pushed_ref(\u0026mut self, elem: T) -\u003e \u0026T;\r\n    /// Push `elem` and return a mutable reference to it.\r\n    fn pushed_mut(\u0026mut self, elem: T) -\u003e \u0026mut T;\r\n}\r\n\r\nimpl\u003cT\u003e VecExt\u003cT\u003e for alloc::vec::Vec\u003cT\u003e {\r\n    fn pushed_ref(\u0026mut self, elem: T) -\u003e \u0026T {\r\n        self.push(elem);\r\n        self.last().unwrap()\r\n    }\r\n    fn pushed_mut(\u0026mut self, elem: T) -\u003e \u0026mut T {\r\n        self.push(elem);\r\n        self.last_mut().unwrap()\r\n    }\r\n}\r\n\r\npub fn transpose_vec\u003cT\u003e(v: Vec\u003cVec\u003cT\u003e\u003e) -\u003e Vec\u003cVec\u003cT\u003e\u003e {\r\n    assert!(!v.is_empty());\r\n    let len = v[0].len();\r\n    let mut iters: Vec\u003c_\u003e = v.into_iter().map(|n| n.into_iter()).collect();\r\n    (0..len)\r\n        .map(|_| {\r\n            iters\r\n                .iter_mut()\r\n                .map(|n| n.next().unwrap())\r\n                .collect::\u003cVec\u003cT\u003e\u003e()\r\n        })\r\n        .collect()\r\n}\r\n\r\n/// Return a String containing the name of T but with all the crate\r\n/// and module prefixes removed.\r\npub fn pretty_name\u003cT\u003e() -\u003e String {\r\n    let name = type_name::\u003cT\u003e();\r\n    let mut result = String::new();\r\n    for qual in name.split_inclusive(\u0026['\u003c', '\u003e', ',']) {\r\n        result.push_str(qual.split(\"::\").last().unwrap());\r\n    }\r\n    result\r\n}\r\n\r\n/// A C-style buffered input reader, similar to\r\n/// `std::iter::Iterator::next_chunk()` from nightly.\r\n///\r\n/// Unsafe because the returned array may contain uninitialised\r\n/// elements.\r\n#[inline]\r\nunsafe fn iter_next_chunk\u003cconst BUFLEN: usize, I: Iterator\u003e(\r\n    iter: \u0026mut I,\r\n) -\u003e ([I::Item; BUFLEN], usize)\r\nwhere\r\n    I::Item: Copy,\r\n{\r\n    let mut buf = unsafe {\r\n        let t = [const { MaybeUninit::\u003cI::Item\u003e::uninit() }; BUFLEN];\r\n        // We are forced to use `transmute_copy` here instead of\r\n        // `transmute` because `BUFLEN` is a const generic parameter.\r\n        // The compiler *should* be smart enough not to emit a copy though.\r\n        core::mem::transmute_copy::\u003c_, [I::Item; BUFLEN]\u003e(\u0026t)\r\n    };\r\n    let mut i = 0;\r\n\r\n    // Read BUFLEN values from `iter` into `buf` at a time.\r\n    for c in iter {\r\n        // Copy the next Item into `buf`.\r\n        unsafe {\r\n            *buf.get_unchecked_mut(i) = c;\r\n            i = i.unchecked_add(1);\r\n        }\r\n        // If `buf` is full\r\n        if i == BUFLEN {\r\n            break;\r\n        }\r\n    }\r\n    (buf, i)\r\n}\r\n\r\n/// Split an iterator into small arrays and apply `func` to each.\r\n///\r\n/// Repeatedly read `BUFLEN` elements from `input` into an array and\r\n/// pass the array to `func` as a slice. If less than `BUFLEN`\r\n/// elements are remaining, that smaller slice is passed to `func` (if\r\n/// it is non-empty) and the function returns.\r\n#[inline]\r\npub fn apply_to_chunks\u003cconst BUFLEN: usize, I, H\u003e(input: I, mut func: H)\r\nwhere\r\n    I: IntoIterator\u003cItem = u8\u003e,\r\n    H: FnMut(\u0026[I::Item]),\r\n{\r\n    let mut iter = input.into_iter();\r\n    loop {\r\n        let (buf, n) = unsafe { iter_next_chunk::\u003cBUFLEN, _\u003e(\u0026mut iter) };\r\n        if n == 0 {\r\n            break;\r\n        }\r\n        func(unsafe { buf.get_unchecked(..n) });\r\n    }\r\n}\r\n\r\n/// Converts a vector of one type to one of another type.\r\n///\r\n/// This is useful to convert between things like `Vec\u003cu32\u003e` and `Vec\u003c[u32; 10]\u003e`, for example.\r\n/// This is roughly like a transmutation, except that we also adjust the vector's length\r\n/// and capacity based on the sizes of the two types.\r\n///\r\n/// # Safety\r\n/// In addition to the usual safety considerations around transmutation, the caller must ensure that\r\n/// the two types have the same alignment, that one of their sizes is a multiple of the other.\r\n#[inline(always)]\r\npub unsafe fn convert_vec\u003cT, U\u003e(mut vec: Vec\u003cT\u003e) -\u003e Vec\u003cU\u003e {\r\n    let ptr = vec.as_mut_ptr() as *mut U;\r\n    let len_bytes = vec.len() * size_of::\u003cT\u003e();\r\n    let cap_bytes = vec.capacity() * size_of::\u003cT\u003e();\r\n\r\n    assert_eq!(align_of::\u003cT\u003e(), align_of::\u003cU\u003e());\r\n    assert_eq!(len_bytes % size_of::\u003cU\u003e(), 0);\r\n    assert_eq!(cap_bytes % size_of::\u003cU\u003e(), 0);\r\n\r\n    let new_len = len_bytes / size_of::\u003cU\u003e();\r\n    let new_cap = cap_bytes / size_of::\u003cU\u003e();\r\n    mem::forget(vec);\r\n    Vec::from_raw_parts(ptr, new_len, new_cap)\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use alloc::vec;\r\n    use alloc::vec::Vec;\r\n\r\n    use rand::rngs::OsRng;\r\n    use rand::Rng;\r\n\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_reverse_bits_len() {\r\n        assert_eq!(reverse_bits_len(0b0000000000, 10), 0b0000000000);\r\n        assert_eq!(reverse_bits_len(0b0000000001, 10), 0b1000000000);\r\n        assert_eq!(reverse_bits_len(0b1000000000, 10), 0b0000000001);\r\n        assert_eq!(reverse_bits_len(0b00000, 5), 0b00000);\r\n        assert_eq!(reverse_bits_len(0b01011, 5), 0b11010);\r\n    }\r\n\r\n    #[test]\r\n    fn test_reverse_index_bits() {\r\n        let mut arg = vec![10, 20, 30, 40];\r\n        reverse_slice_index_bits(\u0026mut arg);\r\n        assert_eq!(arg, vec![10, 30, 20, 40]);\r\n\r\n        let mut input256: Vec\u003cu64\u003e = (0..256).collect();\r\n        #[rustfmt::skip]\r\n        let output256: Vec\u003cu64\u003e = vec![\r\n            0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,\r\n            0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,\r\n            0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,\r\n            0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,\r\n            0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,\r\n            0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,\r\n            0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,\r\n            0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,\r\n            0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,\r\n            0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,\r\n            0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,\r\n            0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,\r\n            0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,\r\n            0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,\r\n            0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,\r\n            0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,\r\n        ];\r\n        reverse_slice_index_bits(\u0026mut input256[..]);\r\n        assert_eq!(input256, output256);\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_exact_fit() {\r\n        const CHUNK_SIZE: usize = 4;\r\n        let input: Vec\u003cu8\u003e = vec![1, 2, 3, 4, 5, 6, 7, 8];\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert_eq!(results, vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8]]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_with_remainder() {\r\n        const CHUNK_SIZE: usize = 3;\r\n        let input: Vec\u003cu8\u003e = vec![1, 2, 3, 4, 5, 6, 7];\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert_eq!(results, vec![vec![1, 2, 3], vec![4, 5, 6], vec![7]]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_empty_input() {\r\n        const CHUNK_SIZE: usize = 4;\r\n        let input: Vec\u003cu8\u003e = vec![];\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert!(results.is_empty());\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_single_chunk() {\r\n        const CHUNK_SIZE: usize = 10;\r\n        let input: Vec\u003cu8\u003e = vec![1, 2, 3, 4, 5];\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert_eq!(results, vec![vec![1, 2, 3, 4, 5]]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_large_chunk_size() {\r\n        const CHUNK_SIZE: usize = 100;\r\n        let input: Vec\u003cu8\u003e = vec![1, 2, 3, 4, 5, 6, 7, 8];\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert_eq!(results, vec![vec![1, 2, 3, 4, 5, 6, 7, 8]]);\r\n    }\r\n\r\n    #[test]\r\n    fn test_apply_to_chunks_large_input() {\r\n        const CHUNK_SIZE: usize = 5;\r\n        let input: Vec\u003cu8\u003e = (1..=20).collect();\r\n        let mut results: Vec\u003cVec\u003cu8\u003e\u003e = Vec::new();\r\n\r\n        apply_to_chunks::\u003cCHUNK_SIZE, _, _\u003e(input, |chunk| {\r\n            results.push(chunk.to_vec());\r\n        });\r\n\r\n        assert_eq!(\r\n            results,\r\n            vec![\r\n                vec![1, 2, 3, 4, 5],\r\n                vec![6, 7, 8, 9, 10],\r\n                vec![11, 12, 13, 14, 15],\r\n                vec![16, 17, 18, 19, 20]\r\n            ]\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_reverse_slice_index_bits_random() {\r\n        let lengths = [32, 128, 1 \u003c\u003c 16];\r\n        let mut rng = OsRng;\r\n        for _ in 0..32 {\r\n            for \u0026length in \u0026lengths {\r\n                let mut rand_list: Vec\u003cu32\u003e = Vec::with_capacity(length);\r\n                rand_list.resize_with(length, || rng.gen());\r\n                let expect = reverse_index_bits_naive(\u0026rand_list);\r\n\r\n                let mut actual = rand_list.clone();\r\n                reverse_slice_index_bits(\u0026mut actual);\r\n\r\n                assert_eq!(actual, expect);\r\n            }\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_log2_strict_usize_edge_cases() {\r\n        assert_eq!(log2_strict_usize(1), 0);\r\n        assert_eq!(log2_strict_usize(2), 1);\r\n        assert_eq!(log2_strict_usize(1 \u003c\u003c 18), 18);\r\n        assert_eq!(log2_strict_usize(1 \u003c\u003c 31), 31);\r\n        assert_eq!(\r\n            log2_strict_usize(1 \u003c\u003c (usize::BITS - 1)),\r\n            usize::BITS as usize - 1\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_log2_strict_usize_zero() {\r\n        let _ = log2_strict_usize(0);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_log2_strict_usize_nonpower_2() {\r\n        let _ = log2_strict_usize(0x78c341c65ae6d262);\r\n    }\r\n\r\n    #[test]\r\n    #[should_panic]\r\n    fn test_log2_strict_usize_max() {\r\n        let _ = log2_strict_usize(usize::MAX);\r\n    }\r\n\r\n    #[test]\r\n    fn test_log2_ceil_usize_comprehensive() {\r\n        // Powers of 2\r\n        assert_eq!(log2_ceil_usize(0), 0);\r\n        assert_eq!(log2_ceil_usize(1), 0);\r\n        assert_eq!(log2_ceil_usize(2), 1);\r\n        assert_eq!(log2_ceil_usize(1 \u003c\u003c 18), 18);\r\n        assert_eq!(log2_ceil_usize(1 \u003c\u003c 31), 31);\r\n        assert_eq!(\r\n            log2_ceil_usize(1 \u003c\u003c (usize::BITS - 1)),\r\n            usize::BITS as usize - 1\r\n        );\r\n\r\n        // Nonpowers; want to round up\r\n        assert_eq!(log2_ceil_usize(3), 2);\r\n        assert_eq!(log2_ceil_usize(0x14fe901b), 29);\r\n        assert_eq!(\r\n            log2_ceil_usize((1 \u003c\u003c (usize::BITS - 1)) + 1),\r\n            usize::BITS as usize\r\n        );\r\n        assert_eq!(log2_ceil_usize(usize::MAX - 1), usize::BITS as usize);\r\n        assert_eq!(log2_ceil_usize(usize::MAX), usize::BITS as usize);\r\n    }\r\n\r\n    fn reverse_index_bits_naive\u003cT: Copy\u003e(arr: \u0026[T]) -\u003e Vec\u003cT\u003e {\r\n        let n = arr.len();\r\n        let n_power = log2_strict_usize(n);\r\n\r\n        let mut out = vec![None; n];\r\n        for (i, v) in arr.iter().enumerate() {\r\n            let dst = i.reverse_bits() \u003e\u003e (usize::BITS - n_power as u32);\r\n            out[dst] = Some(*v);\r\n        }\r\n\r\n        out.into_iter().map(|x| x.unwrap()).collect()\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":21,"address":[],"length":0,"stats":{"Line":3314649325744685056}},{"line":25,"address":[],"length":0,"stats":{"Line":2882303761517117581}},{"line":26,"address":[],"length":0,"stats":{"Line":2882303761517117581}},{"line":35,"address":[],"length":0,"stats":{"Line":7349874591868651604}},{"line":36,"address":[],"length":0,"stats":{"Line":7349874591868651604}},{"line":37,"address":[],"length":0,"stats":{"Line":7566047373982437432}},{"line":40,"address":[],"length":0,"stats":{"Line":7133701809754865776}},{"line":41,"address":[],"length":0,"stats":{"Line":7133701809754865776}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":59,"address":[],"length":0,"stats":{"Line":13402712491054596096}},{"line":60,"address":[],"length":0,"stats":{"Line":6701356245527298048}},{"line":64,"address":[],"length":0,"stats":{"Line":9511602413006495716}},{"line":69,"address":[],"length":0,"stats":{"Line":9511602413006495716}},{"line":70,"address":[],"length":0,"stats":{"Line":9511602413006495716}},{"line":71,"address":[],"length":0,"stats":{"Line":9511602413006495716}},{"line":96,"address":[],"length":0,"stats":{"Line":4827858800541179927}},{"line":97,"address":[],"length":0,"stats":{"Line":4827858800541179927}},{"line":98,"address":[],"length":0,"stats":{"Line":4827858800541179927}},{"line":99,"address":[],"length":0,"stats":{"Line":3314649325744685074}},{"line":101,"address":[],"length":0,"stats":{"Line":1513209474796494868}},{"line":105,"address":[],"length":0,"stats":{"Line":1513209474796494868}},{"line":106,"address":[],"length":0,"stats":{"Line":2305843009213702164}},{"line":108,"address":[],"length":0,"stats":{"Line":17654110539292344322}},{"line":110,"address":[],"length":0,"stats":{"Line":4611686018427396113}},{"line":132,"address":[],"length":0,"stats":{"Line":2305843009213702161}},{"line":133,"address":[],"length":0,"stats":{"Line":2305843009213702161}},{"line":135,"address":[],"length":0,"stats":{"Line":2305843009213702161}},{"line":136,"address":[],"length":0,"stats":{"Line":2305843009213702161}},{"line":137,"address":[],"length":0,"stats":{"Line":2305843009213702161}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":159,"address":[],"length":0,"stats":{"Line":17654110539292344394}},{"line":160,"address":[],"length":0,"stats":{"Line":17654110539292344394}},{"line":162,"address":[],"length":0,"stats":{"Line":18086456103519911936}},{"line":164,"address":[],"length":0,"stats":{"Line":15420325124116578300}},{"line":165,"address":[],"length":0,"stats":{"Line":15780613094306217980}},{"line":166,"address":[],"length":0,"stats":{"Line":5836665117072162814}},{"line":167,"address":[],"length":0,"stats":{"Line":8502796096475496450}},{"line":174,"address":[],"length":0,"stats":{"Line":15276209936040722582}},{"line":175,"address":[],"length":0,"stats":{"Line":15276209936040722582}},{"line":176,"address":[],"length":0,"stats":{"Line":3746994889972252671}},{"line":177,"address":[],"length":0,"stats":{"Line":3746994889972252671}},{"line":178,"address":[],"length":0,"stats":{"Line":3746994889972252671}},{"line":180,"address":[],"length":0,"stats":{"Line":3746994889972252669}},{"line":181,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":182,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":183,"address":[],"length":0,"stats":{"Line":18446744073709551614}},{"line":184,"address":[],"length":0,"stats":{"Line":10952754293765046462}},{"line":185,"address":[],"length":0,"stats":{"Line":10952754293765046464}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":195,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":4611686018427388003}},{"line":211,"address":[],"length":0,"stats":{"Line":4611686018427388003}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":64}},{"line":218,"address":[],"length":0,"stats":{"Line":64}},{"line":219,"address":[],"length":0,"stats":{"Line":64}},{"line":220,"address":[],"length":0,"stats":{"Line":64}},{"line":228,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":234,"address":[],"length":0,"stats":{"Line":2305843009213693952}},{"line":238,"address":[],"length":0,"stats":{"Line":144115188075856980}},{"line":239,"address":[],"length":0,"stats":{"Line":288230376152768475}},{"line":240,"address":[],"length":0,"stats":{"Line":144115188075856980}},{"line":261,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":265,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":266,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":267,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":268,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":269,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":270,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":271,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":274,"address":[],"length":0,"stats":{"Line":12105675798371893248}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":0}},{"line":306,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":317,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":335,"address":[],"length":0,"stats":{"Line":3026418949592973306}},{"line":339,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":341,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":344,"address":[],"length":0,"stats":{"Line":14051230837395947514}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":4323455642275677328}},{"line":355,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":365,"address":[],"length":0,"stats":{"Line":576460752303423485}},{"line":370,"address":[],"length":0,"stats":{"Line":576460752303423485}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":373,"address":[],"length":0,"stats":{"Line":1513209474796486653}},{"line":374,"address":[],"length":0,"stats":{"Line":576460752303423485}},{"line":376,"address":[],"length":0,"stats":{"Line":936748722493063165}},{"line":390,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":391,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":392,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":393,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":395,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":396,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":397,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":399,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":400,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":401,"address":[],"length":0,"stats":{"Line":7205759403792793598}},{"line":402,"address":[],"length":0,"stats":{"Line":7205759403792793598}}],"covered":93,"coverable":135},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","util","src","linear_map.rs"],"content":"use alloc::vec::Vec;\r\nuse core::mem;\r\n\r\nuse crate::VecExt;\r\n\r\n/// O(n) Vec-backed map for keys that only implement Eq.\r\n/// Only use this for a very small number of keys, operations\r\n/// on it can easily become O(n^2).\r\n#[derive(Debug)]\r\npub struct LinearMap\u003cK, V\u003e(Vec\u003c(K, V)\u003e);\r\n\r\nimpl\u003cK, V\u003e Default for LinearMap\u003cK, V\u003e {\r\n    fn default() -\u003e Self {\r\n        Self(Default::default())\r\n    }\r\n}\r\n\r\nimpl\u003cK: Eq, V\u003e LinearMap\u003cK, V\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Default::default()\r\n    }\r\n    pub fn get(\u0026self, k: \u0026K) -\u003e Option\u003c\u0026V\u003e {\r\n        self.0.iter().find(|(kk, _)| kk == k).map(|(_, v)| v)\r\n    }\r\n    pub fn get_mut(\u0026mut self, k: \u0026K) -\u003e Option\u003c\u0026mut V\u003e {\r\n        self.0.iter_mut().find(|(kk, _)| kk == k).map(|(_, v)| v)\r\n    }\r\n    /// This is O(n), because we check for an existing entry.\r\n    pub fn insert(\u0026mut self, k: K, mut v: V) -\u003e Option\u003cV\u003e {\r\n        if let Some(vv) = self.get_mut(\u0026k) {\r\n            mem::swap(\u0026mut v, vv);\r\n            Some(v)\r\n        } else {\r\n            self.0.push((k, v));\r\n            None\r\n        }\r\n    }\r\n    pub fn get_or_insert_with(\u0026mut self, k: K, f: impl FnOnce() -\u003e V) -\u003e \u0026mut V {\r\n        let existing = self.0.iter().position(|(kk, _)| kk == \u0026k);\r\n        if let Some(idx) = existing {\r\n            \u0026mut self.0[idx].1\r\n        } else {\r\n            let slot = self.0.pushed_mut((k, f()));\r\n            \u0026mut slot.1\r\n        }\r\n    }\r\n    pub fn values(\u0026self) -\u003e impl Iterator\u003cItem = \u0026V\u003e {\r\n        self.0.iter().map(|(_, v)| v)\r\n    }\r\n}\r\n\r\nimpl\u003cK: Eq, V\u003e FromIterator\u003c(K, V)\u003e for LinearMap\u003cK, V\u003e {\r\n    /// This calls `insert` in a loop, so is O(n^2)!!\r\n    fn from_iter\u003cT: IntoIterator\u003cItem = (K, V)\u003e\u003e(iter: T) -\u003e Self {\r\n        let mut me = LinearMap::default();\r\n        for (k, v) in iter {\r\n            me.insert(k, v);\r\n        }\r\n        me\r\n    }\r\n}\r\n\r\nimpl\u003cK, V\u003e IntoIterator for LinearMap\u003cK, V\u003e {\r\n    type Item = (K, V);\r\n    type IntoIter = \u003cVec\u003c(K, V)\u003e as IntoIterator\u003e::IntoIter;\r\n    fn into_iter(self) -\u003e Self::IntoIter {\r\n        self.0.into_iter()\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":14,"address":[],"length":0,"stats":{"Line":8070450532247928832}},{"line":19,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":20,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":22,"address":[],"length":0,"stats":{"Line":12393906174523604992}},{"line":23,"address":[],"length":0,"stats":{"Line":7349874591868649473}},{"line":25,"address":[],"length":0,"stats":{"Line":3458764513820540927}},{"line":26,"address":[],"length":0,"stats":{"Line":15060037153926938622}},{"line":29,"address":[],"length":0,"stats":{"Line":8791026472627208193}},{"line":30,"address":[],"length":0,"stats":{"Line":8791026472627208194}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":35,"address":[],"length":0,"stats":{"Line":8791026472627208192}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":48,"address":[],"length":0,"stats":{"Line":12465963768561532928}},{"line":54,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":55,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":56,"address":[],"length":0,"stats":{"Line":17221764975064776704}},{"line":57,"address":[],"length":0,"stats":{"Line":4395513236313604096}},{"line":59,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":66,"address":[],"length":0,"stats":{"Line":4035225266123964416}},{"line":67,"address":[],"length":0,"stats":{"Line":4035225266123964416}}],"covered":21,"coverable":29},{"path":["C:","\\","Users","AngusGruen","Documents","GitHub","Plonky3","util","src","transpose.rs"],"content":"use core::ptr::swap;\r\n\r\nconst LB_BLOCK_SIZE: usize = 3;\r\n\r\n/// Transpose square matrix in-place\r\n/// The matrix is of size `1 \u003c\u003c lb_size` by `1 \u003c\u003c lb_size`. It occupies\r\n/// `M[i, j] == arr[(i + x \u003c\u003c lb_stride) + j + x]` for `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. The transposition\r\n/// swaps `M[i, j]` and `M[j, i]`.\r\n///\r\n/// SAFETY:\r\n/// Make sure that `(i + x \u003c\u003c lb_stride) + j + x` is a valid index in `arr` for all\r\n/// `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. Ensure also that `lb_size \u003c= lb_stride` to prevent overlap.\r\nunsafe fn transpose_in_place_square_small\u003cT\u003e(\r\n    arr: \u0026mut [T],\r\n    lb_stride: usize,\r\n    lb_size: usize,\r\n    x: usize,\r\n) {\r\n    for i in x + 1..x + (1 \u003c\u003c lb_size) {\r\n        for j in x..i {\r\n            swap(\r\n                arr.get_unchecked_mut(i + (j \u003c\u003c lb_stride)),\r\n                arr.get_unchecked_mut((i \u003c\u003c lb_stride) + j),\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/// Transpose square matrices and swap\r\n/// The matrices are of size `1 \u003c\u003c lb_size` by `1 \u003c\u003c lb_size`. They occupy\r\n/// `M0[i, j] == arr[(i + x \u003c\u003c lb_stride) + j + y]`, `M1[i, j] == arr[i + x + (j + y \u003c\u003c lb_stride)]`\r\n/// for `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size. The transposition swaps `M0[i, j]` and `M1[j, i]`.\r\n///\r\n/// SAFETY:\r\n/// Make sure that `(i + x \u003c\u003c lb_stride) + j + y` and `i + x + (j + y \u003c\u003c lb_stride)` are valid\r\n/// indices in `arr` for all `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. Ensure also that `lb_size \u003c= lb_stride` to\r\n/// prevent overlap.\r\nunsafe fn transpose_swap_square_small\u003cT\u003e(\r\n    arr: \u0026mut [T],\r\n    lb_stride: usize,\r\n    lb_size: usize,\r\n    x: usize,\r\n    y: usize,\r\n) {\r\n    for i in x..x + (1 \u003c\u003c lb_size) {\r\n        for j in y..y + (1 \u003c\u003c lb_size) {\r\n            swap(\r\n                arr.get_unchecked_mut(i + (j \u003c\u003c lb_stride)),\r\n                arr.get_unchecked_mut((i \u003c\u003c lb_stride) + j),\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n/// Transpose square matrices and swap\r\n/// The matrices are of size `1 \u003c\u003c lb_size` by `1 \u003c\u003c lb_size`. They occupy\r\n/// `M0[i, j] == arr[(i + x \u003c\u003c lb_stride) + j + y]`, `M1[i, j] == arr[i + x + (j + y \u003c\u003c lb_stride)]`\r\n/// for `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size. The transposition swaps `M0[i, j]` and `M1[j, i]`.\r\n///\r\n/// SAFETY:\r\n/// Make sure that `(i + x \u003c\u003c lb_stride) + j + y` and `i + x + (j + y \u003c\u003c lb_stride)` are valid\r\n/// indices in `arr` for all `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. Ensure also that `lb_size \u003c= lb_stride` to\r\n/// prevent overlap.\r\nunsafe fn transpose_swap_square\u003cT\u003e(\r\n    arr: \u0026mut [T],\r\n    lb_stride: usize,\r\n    lb_size: usize,\r\n    x: usize,\r\n    y: usize,\r\n) {\r\n    if lb_size \u003c= LB_BLOCK_SIZE {\r\n        transpose_swap_square_small(arr, lb_stride, lb_size, x, y);\r\n    } else {\r\n        let lb_block_size = lb_size - 1;\r\n        let block_size = 1 \u003c\u003c lb_block_size;\r\n        transpose_swap_square(arr, lb_stride, lb_block_size, x, y);\r\n        transpose_swap_square(arr, lb_stride, lb_block_size, x + block_size, y);\r\n        transpose_swap_square(arr, lb_stride, lb_block_size, x, y + block_size);\r\n        transpose_swap_square(\r\n            arr,\r\n            lb_stride,\r\n            lb_block_size,\r\n            x + block_size,\r\n            y + block_size,\r\n        );\r\n    }\r\n}\r\n\r\n/// Transpose square matrix in-place\r\n/// The matrix is of size `1 \u003c\u003c lb_size` by `1 \u003c\u003c lb_size`. It occupies\r\n/// `M[i, j] == arr[(i + x \u003c\u003c lb_stride) + j + x]` for `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. The transposition\r\n/// swaps `M[i, j]` and `M[j, i]`.\r\n///\r\n/// SAFETY:\r\n/// Make sure that `(i + x \u003c\u003c lb_stride) + j + x` is a valid index in `arr` for all\r\n/// `0 \u003c= i, j \u003c 1 \u003c\u003c lb_size`. Ensure also that `lb_size \u003c= lb_stride` to prevent overlap.\r\npub(crate) unsafe fn transpose_in_place_square\u003cT\u003e(\r\n    arr: \u0026mut [T],\r\n    lb_stride: usize,\r\n    lb_size: usize,\r\n    x: usize,\r\n) {\r\n    if lb_size \u003c= LB_BLOCK_SIZE {\r\n        transpose_in_place_square_small(arr, lb_stride, lb_size, x);\r\n    } else {\r\n        let lb_block_size = lb_size - 1;\r\n        let block_size = 1 \u003c\u003c lb_block_size;\r\n        transpose_in_place_square(arr, lb_stride, lb_block_size, x);\r\n        transpose_swap_square(arr, lb_stride, lb_block_size, x, x + block_size);\r\n        transpose_in_place_square(arr, lb_stride, lb_block_size, x + block_size);\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":112}},{"line":19,"address":[],"length":0,"stats":{"Line":116}},{"line":20,"address":[],"length":0,"stats":{"Line":12}},{"line":22,"address":[],"length":0,"stats":{"Line":4}},{"line":23,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":3968}},{"line":45,"address":[],"length":0,"stats":{"Line":4030}},{"line":46,"address":[],"length":0,"stats":{"Line":186}},{"line":48,"address":[],"length":0,"stats":{"Line":62}},{"line":49,"address":[],"length":0,"stats":{"Line":62}},{"line":64,"address":[],"length":0,"stats":{"Line":6917529027641081919}},{"line":71,"address":[],"length":0,"stats":{"Line":6917529027641082000}},{"line":72,"address":[],"length":0,"stats":{"Line":81}},{"line":74,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":75,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":76,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":77,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":78,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":80,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":81,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":82,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":83,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":84,"address":[],"length":0,"stats":{"Line":6917529027641081838}},{"line":97,"address":[],"length":0,"stats":{"Line":16140901064495857668}},{"line":103,"address":[],"length":0,"stats":{"Line":16140901064495857675}},{"line":104,"address":[],"length":0,"stats":{"Line":7}},{"line":106,"address":[],"length":0,"stats":{"Line":16140901064495857661}},{"line":107,"address":[],"length":0,"stats":{"Line":16140901064495857661}},{"line":108,"address":[],"length":0,"stats":{"Line":16140901064495857661}},{"line":109,"address":[],"length":0,"stats":{"Line":16140901064495857661}},{"line":110,"address":[],"length":0,"stats":{"Line":16140901064495857661}}],"covered":31,"coverable":31}]};
        var previousData = null;
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>