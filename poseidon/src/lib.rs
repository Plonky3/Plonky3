//! The Poseidon permutation.
//!
//! # Overview
//!
//! Poseidon is a cryptographic hash function designed for efficient verification inside
//! zero-knowledge proof systems (SNARKs, STARKs, etc). It operates natively over
//! prime fields, avoiding the overhead of bit-decomposition required by traditional hashes
//! like SHA-256 or Keccak.
//!
//! This crate provides [`Poseidon`], an optimized implementation that uses the **Appendix B
//! decomposition** from the original paper to factor the dense MDS matrix into sparse
//! components. This reduces the cost of each partial round from O(t^2) to O(t), where
//! t = `WIDTH` is the state width.
//!
//! # The HADES Design Strategy
//!
//! Poseidon follows the HADES construction, which alternates between two types of rounds:
//!
//! ```text
//!   ┌──────────────────┐   ┌───────────────────┐   ┌──────────────────┐
//!   │ RF/2 full rounds │ → │ RP partial rounds │ → │ RF/2 full rounds │
//!   │ (S-box on all)   │   │ (S-box on s[0])   │   │ (S-box on all)   │
//!   └──────────────────┘   └───────────────────┘   └──────────────────┘
//! ```
//!
//! - **Full rounds** (RF total, split equally): apply the S-box x^D to every state element,
//!   then multiply by the dense MDS matrix. These provide resistance against statistical
//!   attacks (differential, linear, rebound).
//!
//! - **Partial rounds** (RP total): apply the S-box only to `state[0]`, then multiply by a
//!   **sparse** matrix derived from the MDS factorization. These efficiently increase the
//!   algebraic degree to resist interpolation and Gröbner basis attacks.
//!
//! Each round follows the sequence: **AddRoundConstants → S-box → MixLayer**.
//!
//! # References
//!
//! - Grassi et al., "Poseidon: A New Hash Function for Zero-Knowledge Proof Systems",
//!   USENIX Security 2021. <https://eprint.iacr.org/2019/458>
//! - HorizenLabs reference implementation: <https://github.com/HorizenLabs/poseidon2>

#![no_std]

extern crate alloc;

pub mod external;
pub mod generic;
pub mod internal;
pub mod utils;

use alloc::vec::Vec;
use core::marker::PhantomData;

pub use external::*;
pub use generic::*;
pub use internal::*;
use p3_field::{Algebra, InjectiveMonomial, PrimeField};
use p3_symmetric::{CryptographicPermutation, Permutation};

/// Raw Poseidon parameters before the Appendix B optimization.
///
/// These are the "textbook" parameters as generated by the Grain LFSR or any other
/// parameter-generation script. The utils module transforms them into
/// the optimized sparse form used at runtime.
///
/// # Layout of round constants
///
/// The round constants are stored in a flat array with the following layout:
///
/// ```text
///   index:  0 .. RF/2-1  |  RF/2 .. RF/2+RP-1  |  RF/2+RP .. RF-1+RP
///           ─────────────   ───────────────────    ─────────────────────
///           initial full     partial rounds         terminal full
/// ```
///
/// Each entry is a `[F; WIDTH]` vector (one constant per state element per round).
#[derive(Clone, Debug)]
pub struct PoseidonConstants<F, const WIDTH: usize> {
    /// Total number of full rounds RF (split equally: RF/2 initial + RF/2 terminal).
    pub rounds_f: usize,

    /// Number of partial rounds RP.
    pub rounds_p: usize,

    /// The t x t MDS (Maximum Distance Separable) matrix used in the linear layer.
    ///
    /// MDS matrices have maximal branch number (t+1), meaning every submatrix is non-singular.
    ///
    /// This guarantees optimal diffusion for:
    /// - the wide-trail argument against differential,
    /// - linear cryptanalysis.
    pub mds: [[F; WIDTH]; WIDTH],

    /// Round constants, one WIDTH-vector per round.
    ///
    /// Total length = RF + RP.
    pub round_constants: Vec<[F; WIDTH]>,
}

impl<F: PrimeField, const WIDTH: usize> PoseidonConstants<F, WIDTH> {
    /// Compute the optimized (Appendix B) constants from these raw parameters.
    ///
    /// This performs two transformations:
    ///
    /// 1. **Sparse matrix decomposition**: factors the dense MDS matrix into one
    ///    transition matrix m_i and RP sparse matrices S_r, each parameterized by
    ///    vectors v_r and ŵ_r of length WIDTH-1.
    ///
    /// 2. **Round constant compression**: via backward substitution through M^{-1},
    ///    reduces each partial round's WIDTH-vector constant to a single scalar,
    ///    except for the first partial round which keeps its full vector.
    pub fn to_optimized(
        &self,
    ) -> (
        FullRoundConstants<F, WIDTH>,
        PartialRoundConstants<F, WIDTH>,
    ) {
        let half_f = self.rounds_f / 2;
        let rounds_p = self.rounds_p;

        // Split the flat round-constant array into three sections.
        //
        // Layout: [initial_full (RF/2) | partial (RP) | terminal_full (RF/2)]
        let initial_rc: Vec<[F; WIDTH]> = self.round_constants[..half_f].to_vec();
        let partial_rc: Vec<[F; WIDTH]> = self.round_constants[half_f..half_f + rounds_p].to_vec();
        let terminal_rc: Vec<[F; WIDTH]> = self.round_constants[half_f + rounds_p..].to_vec();

        // M^{-1} is needed for the round constant backward substitution.
        let mds_inv = utils::matrix_inverse(&self.mds);

        // Transform 1: compress round constants via backward substitution through M^{-1}.
        let (first_round_constants, opt_partial_rc) =
            utils::equivalent_round_constants::<F, WIDTH>(&partial_rc, &mds_inv);

        // Transform 2: factor M into sparse matrices, extracting (v, ŵ) per round.
        let (m_i, sparse_v, sparse_w_hat) =
            utils::compute_equivalent_matrices::<F, WIDTH>(&self.mds, rounds_p);

        let full_constants = FullRoundConstants {
            initial: initial_rc,
            terminal: terminal_rc,
            mds: self.mds,
        };

        let partial_constants = PartialRoundConstants {
            first_round_constants,
            m_i,
            mds_0_0: self.mds[0][0],
            v: sparse_v,
            w_hat: sparse_w_hat,
            round_constants: opt_partial_rc,
        };

        (full_constants, partial_constants)
    }
}

/// The optimized Poseidon permutation.
///
/// This struct:
/// - holds the pre-computed full and partial round layers,
/// - applies them in sequence: initial full rounds → partial rounds → terminal full rounds.
#[derive(Clone, Debug)]
pub struct Poseidon<F, FullRoundPerm, PartialRoundPerm, const WIDTH: usize, const D: u64> {
    /// The RF/2 initial and RF/2 terminal full round layers.
    ///
    /// Each full round:
    /// - applies the S-box to every state element,
    /// - multiplies by the dense MDS matrix.
    full_round_layer: FullRoundPerm,

    /// The RP partial round layer using the Appendix B sparse decomposition.
    ///
    /// Each partial round:
    /// - applies the S-box only to `state[0]`,
    /// - multiplies by a sparse matrix in O(t) operations.
    partial_round_layer: PartialRoundPerm,

    /// Marker for the base field type.
    _phantom: PhantomData<F>,
}

impl<F, FullRoundPerm, PartialRoundPerm, const WIDTH: usize, const D: u64>
    Poseidon<F, FullRoundPerm, PartialRoundPerm, WIDTH, D>
where
    F: PrimeField,
    FullRoundPerm: FullRoundLayerConstructor<F, WIDTH>,
    PartialRoundPerm: PartialRoundLayerConstructor<F, WIDTH>,
{
    /// Create a new optimized Poseidon from raw constants.
    ///
    /// Internally computes the Appendix B sparse matrix decomposition and the
    /// optimized round constants. This is the typical entry point.
    pub fn new(raw: &PoseidonConstants<F, WIDTH>) -> Self {
        let (full_constants, partial_constants) = raw.to_optimized();
        Self::new_from_precomputed(full_constants, partial_constants)
    }

    /// Create a new optimized Poseidon from pre-computed constants.
    ///
    /// Use this when the Appendix B decomposition has already been performed
    /// (e.g., constants loaded from a file or hardcoded).
    pub fn new_from_precomputed(
        full_constants: FullRoundConstants<F, WIDTH>,
        partial_constants: PartialRoundConstants<F, WIDTH>,
    ) -> Self {
        Self {
            full_round_layer: FullRoundPerm::new_from_constants(full_constants),
            partial_round_layer: PartialRoundPerm::new_from_constants(partial_constants),
            _phantom: PhantomData,
        }
    }
}

impl<F, A, FullRoundPerm, PartialRoundPerm, const WIDTH: usize, const D: u64>
    Permutation<[A; WIDTH]> for Poseidon<F, FullRoundPerm, PartialRoundPerm, WIDTH, D>
where
    F: PrimeField + InjectiveMonomial<D>,
    A: Algebra<F> + Sync + InjectiveMonomial<D>,
    FullRoundPerm: FullRoundLayer<A, WIDTH, D>,
    PartialRoundPerm: PartialRoundLayer<A, WIDTH, D>,
{
    fn permute_mut(&self, state: &mut [A; WIDTH]) {
        // RF/2 full rounds (S-box on all elements + dense MDS).
        self.full_round_layer.permute_state_initial(state);
        // RP partial rounds (S-box on state[0] only + sparse matrix).
        self.partial_round_layer.permute_state(state);
        // RF/2 full rounds (S-box on all elements + dense MDS).
        self.full_round_layer.permute_state_terminal(state);
    }
}

impl<F, A, FullRoundPerm, PartialRoundPerm, const WIDTH: usize, const D: u64>
    CryptographicPermutation<[A; WIDTH]> for Poseidon<F, FullRoundPerm, PartialRoundPerm, WIDTH, D>
where
    F: PrimeField + InjectiveMonomial<D>,
    A: Algebra<F> + Sync + InjectiveMonomial<D>,
    FullRoundPerm: FullRoundLayer<A, WIDTH, D>,
    PartialRoundPerm: PartialRoundLayer<A, WIDTH, D>,
{
}
