use p3_field::AbstractField;
use p3_poseidon2::{matmul_internal, DiffusionPermutation};
use p3_symmetric::Permutation;

use crate::{to_babybear_array, BabyBear};

// Diffusion matrices for Babybear16 and Babybear24.
//
// Reference: https://github.com/HorizenLabs/poseidon2/blob/main/plain_implementations/src/poseidon2/poseidon2_instance_babybear.rs
const MATRIX_DIAG_16_BABYBEAR_U32: [u32; 16] = [
    0x0a632d94, 0x6db657b7, 0x56fbdc9e, 0x052b3d8a, 0x33745201, 0x5c03108c, 0x0beba37b, 0x258c2e8b,
    0x12029f39, 0x694909ce, 0x6d231724, 0x21c3b222, 0x3c0904a5, 0x01d6acda, 0x27705c83, 0x5231c802,
];

const MATRIX_DIAG_24_BABYBEAR_U32: [u32; 24] = [
    0x409133f0, 0x1667a8a1, 0x06a6c7b6, 0x6f53160e, 0x273b11d1, 0x03176c5d, 0x72f9bbf9, 0x73ceba91,
    0x5cdef81d, 0x01393285, 0x46daee06, 0x065d7ba6, 0x52d72d6f, 0x05dd05e0, 0x3bab4b63, 0x6ada3842,
    0x2fc5fbec, 0x770d61b0, 0x5715aae9, 0x03ef0e90, 0x75b6c770, 0x242adf5f, 0x00d0ca4c, 0x36c0e388,
];

// Convert the above arrays of u32's into arrays of BabyBear field elements saved in MONTY form.
const MATRIX_DIAG_16_BABYBEAR_MONTY: [BabyBear; 16] =
    to_babybear_array(MATRIX_DIAG_16_BABYBEAR_U32);
const MATRIX_DIAG_24_BABYBEAR_MONTY: [BabyBear; 24] =
    to_babybear_array(MATRIX_DIAG_24_BABYBEAR_U32);

#[derive(Debug, Clone, Default)]
pub struct DiffusionMatrixBabybear;

impl<AF: AbstractField<F = BabyBear>> Permutation<[AF; 16]> for DiffusionMatrixBabybear {
    fn permute_mut(&self, state: &mut [AF; 16]) {
        matmul_internal::<BabyBear, AF, 16>(state, MATRIX_DIAG_16_BABYBEAR_MONTY);
    }
}

impl<AF: AbstractField<F = BabyBear>> DiffusionPermutation<AF, 16> for DiffusionMatrixBabybear {}

impl<AF: AbstractField<F = BabyBear>> Permutation<[AF; 24]> for DiffusionMatrixBabybear {
    fn permute_mut(&self, state: &mut [AF; 24]) {
        matmul_internal::<BabyBear, AF, 24>(state, MATRIX_DIAG_24_BABYBEAR_MONTY);
    }
}

impl<AF: AbstractField<F = BabyBear>> DiffusionPermutation<AF, 24> for DiffusionMatrixBabybear {}

#[cfg(test)]
mod tests {
    use core::array;

    use p3_field::AbstractField;
    use p3_poseidon2::{
        Poseidon2, HL_BABYBEAR_16_EXTERNAL_ROUND_CONSTANTS, HL_BABYBEAR_16_INTERNAL_ROUND_CONSTANTS,
    };

    use super::*;

    type F = BabyBear;

    // These are currently saved as their true values. It will be far more efficient to save them in Monty Form.

    #[test]
    fn test_poseidon2_constants() {
        let monty_constant = MATRIX_DIAG_16_BABYBEAR_U32.map(BabyBear::from_canonical_u32);
        assert_eq!(monty_constant, MATRIX_DIAG_16_BABYBEAR_MONTY);

        let monty_constant = MATRIX_DIAG_24_BABYBEAR_U32.map(BabyBear::from_canonical_u32);
        assert_eq!(monty_constant, MATRIX_DIAG_24_BABYBEAR_MONTY);
    }

    // A function which recreates the poseidon2 implementation in
    // https://github.com/HorizenLabs/poseidon2
    fn hl_poseidon2_babybear_width_16(input: &mut [F; 16]) {
        const WIDTH: usize = 16;
        const D: u64 = 7;
        const ROUNDS_F: usize = 8;
        const ROUNDS_P: usize = 13;

        // Our Poseidon2 implementation.
        let poseidon2: Poseidon2<BabyBear, DiffusionMatrixBabybear, WIDTH, D> = Poseidon2::new(
            ROUNDS_F,
            HL_BABYBEAR_16_EXTERNAL_ROUND_CONSTANTS
                .map(to_babybear_array)
                .to_vec(),
            ROUNDS_P,
            to_babybear_array(HL_BABYBEAR_16_INTERNAL_ROUND_CONSTANTS).to_vec(),
            DiffusionMatrixBabybear,
        );
        poseidon2.permute_mut(input);
    }

    /// Test on the constant 0 input.
    #[test]
    fn test_poseidon2_width_16_zeroes() {
        let mut input: [F; 16] = [0_u32; 16].map(F::from_wrapped_u32);

        let expected: [F; 16] = [
            1337856655, 1843094405, 328115114, 964209316, 1365212758, 1431554563, 210126733,
            1214932203, 1929553766, 1647595522, 1496863878, 324695999, 1569728319, 1634598391,
            597968641, 679989771,
        ]
        .map(F::from_canonical_u32);
        hl_poseidon2_babybear_width_16(&mut input);
        assert_eq!(input, expected);
    }

    /// Test on the input 0..16.
    #[test]
    fn test_poseidon2_width_16_range() {
        let mut input: [F; 16] = array::from_fn(|i| F::from_wrapped_u32(i as u32));

        let expected: [F; 16] = [
            896560466, 771677727, 128113032, 1378976435, 160019712, 1452738514, 682850273,
            223500421, 501450187, 1804685789, 1671399593, 1788755219, 1736880027, 1352180784,
            1928489698, 1128802977,
        ]
        .map(F::from_canonical_u32);
        hl_poseidon2_babybear_width_16(&mut input);
        assert_eq!(input, expected);
    }

    /// Test on a roughly random input.
    /// This random input is generated by the following sage code:
    /// set_random_seed(2468)
    /// vector([ZZ.random_element(2**31) for t in range(16)])
    #[test]
    fn test_poseidon2_width_16_random() {
        let mut input: [F; 16] = [
            1179785652, 1291567559, 66272299, 471640172, 653876821, 478855335, 871063984,
            540251327, 1506944720, 1403776782, 770420443, 126472305, 1535928603, 1017977016,
            818646757, 359411429,
        ]
        .map(F::from_wrapped_u32);

        let expected: [F; 16] = [
            1736862924, 1950079822, 952072292, 1965704005, 236226362, 1113998185, 1624488077,
            391891139, 1194078311, 1040746778, 1898067001, 774167026, 193702242, 859952892,
            732204701, 1744970965,
        ]
        .map(F::from_canonical_u32);

        hl_poseidon2_babybear_width_16(&mut input);
        assert_eq!(input, expected);
    }
}
