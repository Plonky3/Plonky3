//! Trait for gadgets that enforce interaction constraints.

use p3_air::{AirBuilderWithPublicValues, PairBuilder, PermutationAirBuilder};
use p3_field::Field;

use crate::error::LookupError;
use crate::interaction::{Interaction, InteractionKind};

/// A context struct that provides all necessary information for a gadget
/// to evaluate constraints for a single group of interactions.
#[derive(Clone)]
pub struct GadgetConstraintContext<'a, F, K, EF>
where
    F: Field,
    K: InteractionKind,
{
    /// The interactions to be constrained, all belonging to the same `kind`.
    pub interactions: &'a [Interaction<F, K>],
    /// The index of the auxiliary column in the permutation trace that this
    /// interaction group should use for its running sum.
    pub aux_column_index: usize,
    /// The expected final value of the running sum.
    /// - `None`: This is a **local** interaction. The sum is expected to be 0.
    /// - `Some(value)`: This is a **global** interaction. The sum is expected to equal `value`.
    pub expected_cumulative_sum: Option<EF>,
}

/// Trait for gadgets that enforce interaction constraints in STARKs.
pub trait InteractionGadget {
    /// Evaluates the interaction constraints for a given context.
    fn eval_constraints<AB, K>(
        &self,
        builder: &mut AB,
        context: GadgetConstraintContext<'_, AB::F, K, AB::ExprEF>,
    ) where
        AB: PermutationAirBuilder + PairBuilder + AirBuilderWithPublicValues,
        K: InteractionKind;

    /// Returns the constraint degree for the given interactions.
    ///
    /// This is the maximum degree of any constraint polynomial generated by the gadget.
    fn constraint_degree<F: Field, K: InteractionKind>(
        &self,
        interactions: &[Interaction<F, K>],
    ) -> usize;

    /// Verifies that global accumulated values across all AIRs satisfy the protocol.
    ///
    /// For global interactions, each AIR computes an accumulated value. This function
    /// verifies that these values satisfy the protocol's constraints, ensuring that
    /// sends and receives balance globally.
    fn verify_global_final_value<F: Field>(
        &self,
        all_expected_cumulative: &[F],
    ) -> Result<(), LookupError>;
}
